"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@google";
exports.ids = ["vendor-chunks/@google"];
exports.modules = {

/***/ "(rsc)/./node_modules/@google/genai/dist/node/index.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@google/genai/dist/node/index.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ActivityHandling: () => (/* binding */ ActivityHandling),\n/* harmony export */   AdapterSize: () => (/* binding */ AdapterSize),\n/* harmony export */   ApiError: () => (/* binding */ ApiError),\n/* harmony export */   AuthType: () => (/* binding */ AuthType),\n/* harmony export */   Batches: () => (/* binding */ Batches),\n/* harmony export */   Behavior: () => (/* binding */ Behavior),\n/* harmony export */   BlockedReason: () => (/* binding */ BlockedReason),\n/* harmony export */   Caches: () => (/* binding */ Caches),\n/* harmony export */   Chat: () => (/* binding */ Chat),\n/* harmony export */   Chats: () => (/* binding */ Chats),\n/* harmony export */   ComputeTokensResponse: () => (/* binding */ ComputeTokensResponse),\n/* harmony export */   ControlReferenceImage: () => (/* binding */ ControlReferenceImage),\n/* harmony export */   ControlReferenceType: () => (/* binding */ ControlReferenceType),\n/* harmony export */   CountTokensResponse: () => (/* binding */ CountTokensResponse),\n/* harmony export */   CreateFileResponse: () => (/* binding */ CreateFileResponse),\n/* harmony export */   DeleteCachedContentResponse: () => (/* binding */ DeleteCachedContentResponse),\n/* harmony export */   DeleteFileResponse: () => (/* binding */ DeleteFileResponse),\n/* harmony export */   DeleteModelResponse: () => (/* binding */ DeleteModelResponse),\n/* harmony export */   DynamicRetrievalConfigMode: () => (/* binding */ DynamicRetrievalConfigMode),\n/* harmony export */   EditImageResponse: () => (/* binding */ EditImageResponse),\n/* harmony export */   EditMode: () => (/* binding */ EditMode),\n/* harmony export */   EmbedContentResponse: () => (/* binding */ EmbedContentResponse),\n/* harmony export */   EndSensitivity: () => (/* binding */ EndSensitivity),\n/* harmony export */   FeatureSelectionPreference: () => (/* binding */ FeatureSelectionPreference),\n/* harmony export */   FileSource: () => (/* binding */ FileSource),\n/* harmony export */   FileState: () => (/* binding */ FileState),\n/* harmony export */   Files: () => (/* binding */ Files),\n/* harmony export */   FinishReason: () => (/* binding */ FinishReason),\n/* harmony export */   FunctionCallingConfigMode: () => (/* binding */ FunctionCallingConfigMode),\n/* harmony export */   FunctionResponse: () => (/* binding */ FunctionResponse),\n/* harmony export */   FunctionResponseScheduling: () => (/* binding */ FunctionResponseScheduling),\n/* harmony export */   GenerateContentResponse: () => (/* binding */ GenerateContentResponse),\n/* harmony export */   GenerateContentResponsePromptFeedback: () => (/* binding */ GenerateContentResponsePromptFeedback),\n/* harmony export */   GenerateContentResponseUsageMetadata: () => (/* binding */ GenerateContentResponseUsageMetadata),\n/* harmony export */   GenerateImagesResponse: () => (/* binding */ GenerateImagesResponse),\n/* harmony export */   GenerateVideosResponse: () => (/* binding */ GenerateVideosResponse),\n/* harmony export */   GoogleGenAI: () => (/* binding */ GoogleGenAI),\n/* harmony export */   HarmBlockMethod: () => (/* binding */ HarmBlockMethod),\n/* harmony export */   HarmBlockThreshold: () => (/* binding */ HarmBlockThreshold),\n/* harmony export */   HarmCategory: () => (/* binding */ HarmCategory),\n/* harmony export */   HarmProbability: () => (/* binding */ HarmProbability),\n/* harmony export */   HarmSeverity: () => (/* binding */ HarmSeverity),\n/* harmony export */   HttpResponse: () => (/* binding */ HttpResponse),\n/* harmony export */   ImagePromptLanguage: () => (/* binding */ ImagePromptLanguage),\n/* harmony export */   InlinedResponse: () => (/* binding */ InlinedResponse),\n/* harmony export */   JobState: () => (/* binding */ JobState),\n/* harmony export */   Language: () => (/* binding */ Language),\n/* harmony export */   ListBatchJobsResponse: () => (/* binding */ ListBatchJobsResponse),\n/* harmony export */   ListCachedContentsResponse: () => (/* binding */ ListCachedContentsResponse),\n/* harmony export */   ListFilesResponse: () => (/* binding */ ListFilesResponse),\n/* harmony export */   ListModelsResponse: () => (/* binding */ ListModelsResponse),\n/* harmony export */   ListTuningJobsResponse: () => (/* binding */ ListTuningJobsResponse),\n/* harmony export */   Live: () => (/* binding */ Live),\n/* harmony export */   LiveClientToolResponse: () => (/* binding */ LiveClientToolResponse),\n/* harmony export */   LiveMusicPlaybackControl: () => (/* binding */ LiveMusicPlaybackControl),\n/* harmony export */   LiveMusicServerMessage: () => (/* binding */ LiveMusicServerMessage),\n/* harmony export */   LiveSendToolResponseParameters: () => (/* binding */ LiveSendToolResponseParameters),\n/* harmony export */   LiveServerMessage: () => (/* binding */ LiveServerMessage),\n/* harmony export */   MaskReferenceImage: () => (/* binding */ MaskReferenceImage),\n/* harmony export */   MaskReferenceMode: () => (/* binding */ MaskReferenceMode),\n/* harmony export */   MediaModality: () => (/* binding */ MediaModality),\n/* harmony export */   MediaResolution: () => (/* binding */ MediaResolution),\n/* harmony export */   Modality: () => (/* binding */ Modality),\n/* harmony export */   Mode: () => (/* binding */ Mode),\n/* harmony export */   Models: () => (/* binding */ Models),\n/* harmony export */   Operations: () => (/* binding */ Operations),\n/* harmony export */   Outcome: () => (/* binding */ Outcome),\n/* harmony export */   PagedItem: () => (/* binding */ PagedItem),\n/* harmony export */   Pager: () => (/* binding */ Pager),\n/* harmony export */   PersonGeneration: () => (/* binding */ PersonGeneration),\n/* harmony export */   RawReferenceImage: () => (/* binding */ RawReferenceImage),\n/* harmony export */   ReplayResponse: () => (/* binding */ ReplayResponse),\n/* harmony export */   SafetyFilterLevel: () => (/* binding */ SafetyFilterLevel),\n/* harmony export */   Scale: () => (/* binding */ Scale),\n/* harmony export */   Session: () => (/* binding */ Session),\n/* harmony export */   StartSensitivity: () => (/* binding */ StartSensitivity),\n/* harmony export */   StyleReferenceImage: () => (/* binding */ StyleReferenceImage),\n/* harmony export */   SubjectReferenceImage: () => (/* binding */ SubjectReferenceImage),\n/* harmony export */   SubjectReferenceType: () => (/* binding */ SubjectReferenceType),\n/* harmony export */   Tokens: () => (/* binding */ Tokens),\n/* harmony export */   TrafficType: () => (/* binding */ TrafficType),\n/* harmony export */   TurnCoverage: () => (/* binding */ TurnCoverage),\n/* harmony export */   Type: () => (/* binding */ Type),\n/* harmony export */   UpscaleImageResponse: () => (/* binding */ UpscaleImageResponse),\n/* harmony export */   UrlRetrievalStatus: () => (/* binding */ UrlRetrievalStatus),\n/* harmony export */   VideoCompressionQuality: () => (/* binding */ VideoCompressionQuality),\n/* harmony export */   createModelContent: () => (/* binding */ createModelContent),\n/* harmony export */   createPartFromBase64: () => (/* binding */ createPartFromBase64),\n/* harmony export */   createPartFromCodeExecutionResult: () => (/* binding */ createPartFromCodeExecutionResult),\n/* harmony export */   createPartFromExecutableCode: () => (/* binding */ createPartFromExecutableCode),\n/* harmony export */   createPartFromFunctionCall: () => (/* binding */ createPartFromFunctionCall),\n/* harmony export */   createPartFromFunctionResponse: () => (/* binding */ createPartFromFunctionResponse),\n/* harmony export */   createPartFromText: () => (/* binding */ createPartFromText),\n/* harmony export */   createPartFromUri: () => (/* binding */ createPartFromUri),\n/* harmony export */   createUserContent: () => (/* binding */ createUserContent),\n/* harmony export */   mcpToTool: () => (/* binding */ mcpToTool),\n/* harmony export */   setDefaultBaseUrls: () => (/* binding */ setDefaultBaseUrls)\n/* harmony export */ });\n/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/dist/esm/index.js\");\n/* harmony import */ var google_auth_library__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! google-auth-library */ \"(rsc)/./node_modules/google-auth-library/build/src/index.js\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var node_stream__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! node:stream */ \"node:stream\");\n/* harmony import */ var ws__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ws */ \"(rsc)/./node_modules/ws/wrapper.mjs\");\n/* harmony import */ var fs_promises__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! fs/promises */ \"fs/promises\");\n\n\n\n\n\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ let _defaultBaseGeminiUrl = undefined;\nlet _defaultBaseVertexUrl = undefined;\n/**\n * Overrides the base URLs for the Gemini API and Vertex AI API.\n *\n * @remarks This function should be called before initializing the SDK. If the\n * base URLs are set after initializing the SDK, the base URLs will not be\n * updated. Base URLs provided in the HttpOptions will also take precedence over\n * URLs set here.\n *\n * @example\n * ```ts\n * import {GoogleGenAI, setDefaultBaseUrls} from '@google/genai';\n * // Override the base URL for the Gemini API.\n * setDefaultBaseUrls({geminiUrl:'https://gemini.google.com'});\n *\n * // Override the base URL for the Vertex AI API.\n * setDefaultBaseUrls({vertexUrl: 'https://vertexai.googleapis.com'});\n *\n * const ai = new GoogleGenAI({apiKey: 'GEMINI_API_KEY'});\n * ```\n */ function setDefaultBaseUrls(baseUrlParams) {\n    _defaultBaseGeminiUrl = baseUrlParams.geminiUrl;\n    _defaultBaseVertexUrl = baseUrlParams.vertexUrl;\n}\n/**\n * Returns the default base URLs for the Gemini API and Vertex AI API.\n */ function getDefaultBaseUrls() {\n    return {\n        geminiUrl: _defaultBaseGeminiUrl,\n        vertexUrl: _defaultBaseVertexUrl\n    };\n}\n/**\n * Returns the default base URL based on the following priority:\n *   1. Base URLs set via HttpOptions.\n *   2. Base URLs set via the latest call to setDefaultBaseUrls.\n *   3. Base URLs set via environment variables.\n */ function getBaseUrl(options, vertexBaseUrlFromEnv, geminiBaseUrlFromEnv) {\n    var _a, _b, _c;\n    if (!((_a = options.httpOptions) === null || _a === void 0 ? void 0 : _a.baseUrl)) {\n        const defaultBaseUrls = getDefaultBaseUrls();\n        if (options.vertexai) {\n            return (_b = defaultBaseUrls.vertexUrl) !== null && _b !== void 0 ? _b : vertexBaseUrlFromEnv;\n        } else {\n            return (_c = defaultBaseUrls.geminiUrl) !== null && _c !== void 0 ? _c : geminiBaseUrlFromEnv;\n        }\n    }\n    return options.httpOptions.baseUrl;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ class BaseModule {\n}\nfunction formatMap(templateString, valueMap) {\n    // Use a regular expression to find all placeholders in the template string\n    const regex = /\\{([^}]+)\\}/g;\n    // Replace each placeholder with its corresponding value from the valueMap\n    return templateString.replace(regex, (match, key)=>{\n        if (Object.prototype.hasOwnProperty.call(valueMap, key)) {\n            const value = valueMap[key];\n            // Convert the value to a string if it's not a string already\n            return value !== undefined && value !== null ? String(value) : \"\";\n        } else {\n            // Handle missing keys\n            throw new Error(`Key '${key}' not found in valueMap.`);\n        }\n    });\n}\nfunction setValueByPath(data, keys, value) {\n    for(let i = 0; i < keys.length - 1; i++){\n        const key = keys[i];\n        if (key.endsWith(\"[]\")) {\n            const keyName = key.slice(0, -2);\n            if (!(keyName in data)) {\n                if (Array.isArray(value)) {\n                    data[keyName] = Array.from({\n                        length: value.length\n                    }, ()=>({}));\n                } else {\n                    throw new Error(`Value must be a list given an array path ${key}`);\n                }\n            }\n            if (Array.isArray(data[keyName])) {\n                const arrayData = data[keyName];\n                if (Array.isArray(value)) {\n                    for(let j = 0; j < arrayData.length; j++){\n                        const entry = arrayData[j];\n                        setValueByPath(entry, keys.slice(i + 1), value[j]);\n                    }\n                } else {\n                    for (const d of arrayData){\n                        setValueByPath(d, keys.slice(i + 1), value);\n                    }\n                }\n            }\n            return;\n        } else if (key.endsWith(\"[0]\")) {\n            const keyName = key.slice(0, -3);\n            if (!(keyName in data)) {\n                data[keyName] = [\n                    {}\n                ];\n            }\n            const arrayData = data[keyName];\n            setValueByPath(arrayData[0], keys.slice(i + 1), value);\n            return;\n        }\n        if (!data[key] || typeof data[key] !== \"object\") {\n            data[key] = {};\n        }\n        data = data[key];\n    }\n    const keyToSet = keys[keys.length - 1];\n    const existingData = data[keyToSet];\n    if (existingData !== undefined) {\n        if (!value || typeof value === \"object\" && Object.keys(value).length === 0) {\n            return;\n        }\n        if (value === existingData) {\n            return;\n        }\n        if (typeof existingData === \"object\" && typeof value === \"object\" && existingData !== null && value !== null) {\n            Object.assign(existingData, value);\n        } else {\n            throw new Error(`Cannot set value for an existing key. Key: ${keyToSet}`);\n        }\n    } else {\n        data[keyToSet] = value;\n    }\n}\nfunction getValueByPath(data, keys) {\n    try {\n        if (keys.length === 1 && keys[0] === \"_self\") {\n            return data;\n        }\n        for(let i = 0; i < keys.length; i++){\n            if (typeof data !== \"object\" || data === null) {\n                return undefined;\n            }\n            const key = keys[i];\n            if (key.endsWith(\"[]\")) {\n                const keyName = key.slice(0, -2);\n                if (keyName in data) {\n                    const arrayData = data[keyName];\n                    if (!Array.isArray(arrayData)) {\n                        return undefined;\n                    }\n                    return arrayData.map((d)=>getValueByPath(d, keys.slice(i + 1)));\n                } else {\n                    return undefined;\n                }\n            } else {\n                data = data[key];\n            }\n        }\n        return data;\n    } catch (error) {\n        if (error instanceof TypeError) {\n            return undefined;\n        }\n        throw error;\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ /** Required. Outcome of the code execution. */ var Outcome;\n(function(Outcome) {\n    /**\n     * Unspecified status. This value should not be used.\n     */ Outcome[\"OUTCOME_UNSPECIFIED\"] = \"OUTCOME_UNSPECIFIED\";\n    /**\n     * Code execution completed successfully.\n     */ Outcome[\"OUTCOME_OK\"] = \"OUTCOME_OK\";\n    /**\n     * Code execution finished but with a failure. `stderr` should contain the reason.\n     */ Outcome[\"OUTCOME_FAILED\"] = \"OUTCOME_FAILED\";\n    /**\n     * Code execution ran for too long, and was cancelled. There may or may not be a partial output present.\n     */ Outcome[\"OUTCOME_DEADLINE_EXCEEDED\"] = \"OUTCOME_DEADLINE_EXCEEDED\";\n})(Outcome || (Outcome = {}));\n/** Required. Programming language of the `code`. */ var Language;\n(function(Language) {\n    /**\n     * Unspecified language. This value should not be used.\n     */ Language[\"LANGUAGE_UNSPECIFIED\"] = \"LANGUAGE_UNSPECIFIED\";\n    /**\n     * Python >= 3.10, with numpy and simpy available.\n     */ Language[\"PYTHON\"] = \"PYTHON\";\n})(Language || (Language = {}));\n/** Optional. The type of the data. */ var Type;\n(function(Type) {\n    /**\n     * Not specified, should not be used.\n     */ Type[\"TYPE_UNSPECIFIED\"] = \"TYPE_UNSPECIFIED\";\n    /**\n     * OpenAPI string type\n     */ Type[\"STRING\"] = \"STRING\";\n    /**\n     * OpenAPI number type\n     */ Type[\"NUMBER\"] = \"NUMBER\";\n    /**\n     * OpenAPI integer type\n     */ Type[\"INTEGER\"] = \"INTEGER\";\n    /**\n     * OpenAPI boolean type\n     */ Type[\"BOOLEAN\"] = \"BOOLEAN\";\n    /**\n     * OpenAPI array type\n     */ Type[\"ARRAY\"] = \"ARRAY\";\n    /**\n     * OpenAPI object type\n     */ Type[\"OBJECT\"] = \"OBJECT\";\n    /**\n     * Null type\n     */ Type[\"NULL\"] = \"NULL\";\n})(Type || (Type = {}));\n/** Required. Harm category. */ var HarmCategory;\n(function(HarmCategory) {\n    /**\n     * The harm category is unspecified.\n     */ HarmCategory[\"HARM_CATEGORY_UNSPECIFIED\"] = \"HARM_CATEGORY_UNSPECIFIED\";\n    /**\n     * The harm category is hate speech.\n     */ HarmCategory[\"HARM_CATEGORY_HATE_SPEECH\"] = \"HARM_CATEGORY_HATE_SPEECH\";\n    /**\n     * The harm category is dangerous content.\n     */ HarmCategory[\"HARM_CATEGORY_DANGEROUS_CONTENT\"] = \"HARM_CATEGORY_DANGEROUS_CONTENT\";\n    /**\n     * The harm category is harassment.\n     */ HarmCategory[\"HARM_CATEGORY_HARASSMENT\"] = \"HARM_CATEGORY_HARASSMENT\";\n    /**\n     * The harm category is sexually explicit content.\n     */ HarmCategory[\"HARM_CATEGORY_SEXUALLY_EXPLICIT\"] = \"HARM_CATEGORY_SEXUALLY_EXPLICIT\";\n    /**\n     * Deprecated: Election filter is not longer supported. The harm category is civic integrity.\n     */ HarmCategory[\"HARM_CATEGORY_CIVIC_INTEGRITY\"] = \"HARM_CATEGORY_CIVIC_INTEGRITY\";\n})(HarmCategory || (HarmCategory = {}));\n/** Optional. Specify if the threshold is used for probability or severity score. If not specified, the threshold is used for probability score. */ var HarmBlockMethod;\n(function(HarmBlockMethod) {\n    /**\n     * The harm block method is unspecified.\n     */ HarmBlockMethod[\"HARM_BLOCK_METHOD_UNSPECIFIED\"] = \"HARM_BLOCK_METHOD_UNSPECIFIED\";\n    /**\n     * The harm block method uses both probability and severity scores.\n     */ HarmBlockMethod[\"SEVERITY\"] = \"SEVERITY\";\n    /**\n     * The harm block method uses the probability score.\n     */ HarmBlockMethod[\"PROBABILITY\"] = \"PROBABILITY\";\n})(HarmBlockMethod || (HarmBlockMethod = {}));\n/** Required. The harm block threshold. */ var HarmBlockThreshold;\n(function(HarmBlockThreshold) {\n    /**\n     * Unspecified harm block threshold.\n     */ HarmBlockThreshold[\"HARM_BLOCK_THRESHOLD_UNSPECIFIED\"] = \"HARM_BLOCK_THRESHOLD_UNSPECIFIED\";\n    /**\n     * Block low threshold and above (i.e. block more).\n     */ HarmBlockThreshold[\"BLOCK_LOW_AND_ABOVE\"] = \"BLOCK_LOW_AND_ABOVE\";\n    /**\n     * Block medium threshold and above.\n     */ HarmBlockThreshold[\"BLOCK_MEDIUM_AND_ABOVE\"] = \"BLOCK_MEDIUM_AND_ABOVE\";\n    /**\n     * Block only high threshold (i.e. block less).\n     */ HarmBlockThreshold[\"BLOCK_ONLY_HIGH\"] = \"BLOCK_ONLY_HIGH\";\n    /**\n     * Block none.\n     */ HarmBlockThreshold[\"BLOCK_NONE\"] = \"BLOCK_NONE\";\n    /**\n     * Turn off the safety filter.\n     */ HarmBlockThreshold[\"OFF\"] = \"OFF\";\n})(HarmBlockThreshold || (HarmBlockThreshold = {}));\n/** The mode of the predictor to be used in dynamic retrieval. */ var Mode;\n(function(Mode) {\n    /**\n     * Always trigger retrieval.\n     */ Mode[\"MODE_UNSPECIFIED\"] = \"MODE_UNSPECIFIED\";\n    /**\n     * Run retrieval only when system decides it is necessary.\n     */ Mode[\"MODE_DYNAMIC\"] = \"MODE_DYNAMIC\";\n})(Mode || (Mode = {}));\n/** Type of auth scheme. */ var AuthType;\n(function(AuthType) {\n    AuthType[\"AUTH_TYPE_UNSPECIFIED\"] = \"AUTH_TYPE_UNSPECIFIED\";\n    /**\n     * No Auth.\n     */ AuthType[\"NO_AUTH\"] = \"NO_AUTH\";\n    /**\n     * API Key Auth.\n     */ AuthType[\"API_KEY_AUTH\"] = \"API_KEY_AUTH\";\n    /**\n     * HTTP Basic Auth.\n     */ AuthType[\"HTTP_BASIC_AUTH\"] = \"HTTP_BASIC_AUTH\";\n    /**\n     * Google Service Account Auth.\n     */ AuthType[\"GOOGLE_SERVICE_ACCOUNT_AUTH\"] = \"GOOGLE_SERVICE_ACCOUNT_AUTH\";\n    /**\n     * OAuth auth.\n     */ AuthType[\"OAUTH\"] = \"OAUTH\";\n    /**\n     * OpenID Connect (OIDC) Auth.\n     */ AuthType[\"OIDC_AUTH\"] = \"OIDC_AUTH\";\n})(AuthType || (AuthType = {}));\n/** Output only. The reason why the model stopped generating tokens.\n\n  If empty, the model has not stopped generating the tokens.\n   */ var FinishReason;\n(function(FinishReason) {\n    /**\n     * The finish reason is unspecified.\n     */ FinishReason[\"FINISH_REASON_UNSPECIFIED\"] = \"FINISH_REASON_UNSPECIFIED\";\n    /**\n     * Token generation reached a natural stopping point or a configured stop sequence.\n     */ FinishReason[\"STOP\"] = \"STOP\";\n    /**\n     * Token generation reached the configured maximum output tokens.\n     */ FinishReason[\"MAX_TOKENS\"] = \"MAX_TOKENS\";\n    /**\n     * Token generation stopped because the content potentially contains safety violations. NOTE: When streaming, [content][] is empty if content filters blocks the output.\n     */ FinishReason[\"SAFETY\"] = \"SAFETY\";\n    /**\n     * The token generation stopped because of potential recitation.\n     */ FinishReason[\"RECITATION\"] = \"RECITATION\";\n    /**\n     * The token generation stopped because of using an unsupported language.\n     */ FinishReason[\"LANGUAGE\"] = \"LANGUAGE\";\n    /**\n     * All other reasons that stopped the token generation.\n     */ FinishReason[\"OTHER\"] = \"OTHER\";\n    /**\n     * Token generation stopped because the content contains forbidden terms.\n     */ FinishReason[\"BLOCKLIST\"] = \"BLOCKLIST\";\n    /**\n     * Token generation stopped for potentially containing prohibited content.\n     */ FinishReason[\"PROHIBITED_CONTENT\"] = \"PROHIBITED_CONTENT\";\n    /**\n     * Token generation stopped because the content potentially contains Sensitive Personally Identifiable Information (SPII).\n     */ FinishReason[\"SPII\"] = \"SPII\";\n    /**\n     * The function call generated by the model is invalid.\n     */ FinishReason[\"MALFORMED_FUNCTION_CALL\"] = \"MALFORMED_FUNCTION_CALL\";\n    /**\n     * Token generation stopped because generated images have safety violations.\n     */ FinishReason[\"IMAGE_SAFETY\"] = \"IMAGE_SAFETY\";\n    /**\n     * The tool call generated by the model is invalid.\n     */ FinishReason[\"UNEXPECTED_TOOL_CALL\"] = \"UNEXPECTED_TOOL_CALL\";\n})(FinishReason || (FinishReason = {}));\n/** Output only. Harm probability levels in the content. */ var HarmProbability;\n(function(HarmProbability) {\n    /**\n     * Harm probability unspecified.\n     */ HarmProbability[\"HARM_PROBABILITY_UNSPECIFIED\"] = \"HARM_PROBABILITY_UNSPECIFIED\";\n    /**\n     * Negligible level of harm.\n     */ HarmProbability[\"NEGLIGIBLE\"] = \"NEGLIGIBLE\";\n    /**\n     * Low level of harm.\n     */ HarmProbability[\"LOW\"] = \"LOW\";\n    /**\n     * Medium level of harm.\n     */ HarmProbability[\"MEDIUM\"] = \"MEDIUM\";\n    /**\n     * High level of harm.\n     */ HarmProbability[\"HIGH\"] = \"HIGH\";\n})(HarmProbability || (HarmProbability = {}));\n/** Output only. Harm severity levels in the content. */ var HarmSeverity;\n(function(HarmSeverity) {\n    /**\n     * Harm severity unspecified.\n     */ HarmSeverity[\"HARM_SEVERITY_UNSPECIFIED\"] = \"HARM_SEVERITY_UNSPECIFIED\";\n    /**\n     * Negligible level of harm severity.\n     */ HarmSeverity[\"HARM_SEVERITY_NEGLIGIBLE\"] = \"HARM_SEVERITY_NEGLIGIBLE\";\n    /**\n     * Low level of harm severity.\n     */ HarmSeverity[\"HARM_SEVERITY_LOW\"] = \"HARM_SEVERITY_LOW\";\n    /**\n     * Medium level of harm severity.\n     */ HarmSeverity[\"HARM_SEVERITY_MEDIUM\"] = \"HARM_SEVERITY_MEDIUM\";\n    /**\n     * High level of harm severity.\n     */ HarmSeverity[\"HARM_SEVERITY_HIGH\"] = \"HARM_SEVERITY_HIGH\";\n})(HarmSeverity || (HarmSeverity = {}));\n/** Output only. Blocked reason. */ var BlockedReason;\n(function(BlockedReason) {\n    /**\n     * Unspecified blocked reason.\n     */ BlockedReason[\"BLOCKED_REASON_UNSPECIFIED\"] = \"BLOCKED_REASON_UNSPECIFIED\";\n    /**\n     * Candidates blocked due to safety.\n     */ BlockedReason[\"SAFETY\"] = \"SAFETY\";\n    /**\n     * Candidates blocked due to other reason.\n     */ BlockedReason[\"OTHER\"] = \"OTHER\";\n    /**\n     * Candidates blocked due to the terms which are included from the terminology blocklist.\n     */ BlockedReason[\"BLOCKLIST\"] = \"BLOCKLIST\";\n    /**\n     * Candidates blocked due to prohibited content.\n     */ BlockedReason[\"PROHIBITED_CONTENT\"] = \"PROHIBITED_CONTENT\";\n})(BlockedReason || (BlockedReason = {}));\n/** Output only. Traffic type. This shows whether a request consumes Pay-As-You-Go or Provisioned Throughput quota. */ var TrafficType;\n(function(TrafficType) {\n    /**\n     * Unspecified request traffic type.\n     */ TrafficType[\"TRAFFIC_TYPE_UNSPECIFIED\"] = \"TRAFFIC_TYPE_UNSPECIFIED\";\n    /**\n     * Type for Pay-As-You-Go traffic.\n     */ TrafficType[\"ON_DEMAND\"] = \"ON_DEMAND\";\n    /**\n     * Type for Provisioned Throughput traffic.\n     */ TrafficType[\"PROVISIONED_THROUGHPUT\"] = \"PROVISIONED_THROUGHPUT\";\n})(TrafficType || (TrafficType = {}));\n/** Server content modalities. */ var Modality;\n(function(Modality) {\n    /**\n     * The modality is unspecified.\n     */ Modality[\"MODALITY_UNSPECIFIED\"] = \"MODALITY_UNSPECIFIED\";\n    /**\n     * Indicates the model should return text\n     */ Modality[\"TEXT\"] = \"TEXT\";\n    /**\n     * Indicates the model should return images.\n     */ Modality[\"IMAGE\"] = \"IMAGE\";\n    /**\n     * Indicates the model should return audio.\n     */ Modality[\"AUDIO\"] = \"AUDIO\";\n})(Modality || (Modality = {}));\n/** The media resolution to use. */ var MediaResolution;\n(function(MediaResolution) {\n    /**\n     * Media resolution has not been set\n     */ MediaResolution[\"MEDIA_RESOLUTION_UNSPECIFIED\"] = \"MEDIA_RESOLUTION_UNSPECIFIED\";\n    /**\n     * Media resolution set to low (64 tokens).\n     */ MediaResolution[\"MEDIA_RESOLUTION_LOW\"] = \"MEDIA_RESOLUTION_LOW\";\n    /**\n     * Media resolution set to medium (256 tokens).\n     */ MediaResolution[\"MEDIA_RESOLUTION_MEDIUM\"] = \"MEDIA_RESOLUTION_MEDIUM\";\n    /**\n     * Media resolution set to high (zoomed reframing with 256 tokens).\n     */ MediaResolution[\"MEDIA_RESOLUTION_HIGH\"] = \"MEDIA_RESOLUTION_HIGH\";\n})(MediaResolution || (MediaResolution = {}));\n/** Job state. */ var JobState;\n(function(JobState) {\n    /**\n     * The job state is unspecified.\n     */ JobState[\"JOB_STATE_UNSPECIFIED\"] = \"JOB_STATE_UNSPECIFIED\";\n    /**\n     * The job has been just created or resumed and processing has not yet begun.\n     */ JobState[\"JOB_STATE_QUEUED\"] = \"JOB_STATE_QUEUED\";\n    /**\n     * The service is preparing to run the job.\n     */ JobState[\"JOB_STATE_PENDING\"] = \"JOB_STATE_PENDING\";\n    /**\n     * The job is in progress.\n     */ JobState[\"JOB_STATE_RUNNING\"] = \"JOB_STATE_RUNNING\";\n    /**\n     * The job completed successfully.\n     */ JobState[\"JOB_STATE_SUCCEEDED\"] = \"JOB_STATE_SUCCEEDED\";\n    /**\n     * The job failed.\n     */ JobState[\"JOB_STATE_FAILED\"] = \"JOB_STATE_FAILED\";\n    /**\n     * The job is being cancelled. From this state the job may only go to either `JOB_STATE_SUCCEEDED`, `JOB_STATE_FAILED` or `JOB_STATE_CANCELLED`.\n     */ JobState[\"JOB_STATE_CANCELLING\"] = \"JOB_STATE_CANCELLING\";\n    /**\n     * The job has been cancelled.\n     */ JobState[\"JOB_STATE_CANCELLED\"] = \"JOB_STATE_CANCELLED\";\n    /**\n     * The job has been stopped, and can be resumed.\n     */ JobState[\"JOB_STATE_PAUSED\"] = \"JOB_STATE_PAUSED\";\n    /**\n     * The job has expired.\n     */ JobState[\"JOB_STATE_EXPIRED\"] = \"JOB_STATE_EXPIRED\";\n    /**\n     * The job is being updated. Only jobs in the `JOB_STATE_RUNNING` state can be updated. After updating, the job goes back to the `JOB_STATE_RUNNING` state.\n     */ JobState[\"JOB_STATE_UPDATING\"] = \"JOB_STATE_UPDATING\";\n    /**\n     * The job is partially succeeded, some results may be missing due to errors.\n     */ JobState[\"JOB_STATE_PARTIALLY_SUCCEEDED\"] = \"JOB_STATE_PARTIALLY_SUCCEEDED\";\n})(JobState || (JobState = {}));\n/** Optional. Adapter size for tuning. */ var AdapterSize;\n(function(AdapterSize) {\n    /**\n     * Adapter size is unspecified.\n     */ AdapterSize[\"ADAPTER_SIZE_UNSPECIFIED\"] = \"ADAPTER_SIZE_UNSPECIFIED\";\n    /**\n     * Adapter size 1.\n     */ AdapterSize[\"ADAPTER_SIZE_ONE\"] = \"ADAPTER_SIZE_ONE\";\n    /**\n     * Adapter size 2.\n     */ AdapterSize[\"ADAPTER_SIZE_TWO\"] = \"ADAPTER_SIZE_TWO\";\n    /**\n     * Adapter size 4.\n     */ AdapterSize[\"ADAPTER_SIZE_FOUR\"] = \"ADAPTER_SIZE_FOUR\";\n    /**\n     * Adapter size 8.\n     */ AdapterSize[\"ADAPTER_SIZE_EIGHT\"] = \"ADAPTER_SIZE_EIGHT\";\n    /**\n     * Adapter size 16.\n     */ AdapterSize[\"ADAPTER_SIZE_SIXTEEN\"] = \"ADAPTER_SIZE_SIXTEEN\";\n    /**\n     * Adapter size 32.\n     */ AdapterSize[\"ADAPTER_SIZE_THIRTY_TWO\"] = \"ADAPTER_SIZE_THIRTY_TWO\";\n})(AdapterSize || (AdapterSize = {}));\n/** Options for feature selection preference. */ var FeatureSelectionPreference;\n(function(FeatureSelectionPreference) {\n    FeatureSelectionPreference[\"FEATURE_SELECTION_PREFERENCE_UNSPECIFIED\"] = \"FEATURE_SELECTION_PREFERENCE_UNSPECIFIED\";\n    FeatureSelectionPreference[\"PRIORITIZE_QUALITY\"] = \"PRIORITIZE_QUALITY\";\n    FeatureSelectionPreference[\"BALANCED\"] = \"BALANCED\";\n    FeatureSelectionPreference[\"PRIORITIZE_COST\"] = \"PRIORITIZE_COST\";\n})(FeatureSelectionPreference || (FeatureSelectionPreference = {}));\n/** Defines the function behavior. Defaults to `BLOCKING`. */ var Behavior;\n(function(Behavior) {\n    /**\n     * This value is unused.\n     */ Behavior[\"UNSPECIFIED\"] = \"UNSPECIFIED\";\n    /**\n     * If set, the system will wait to receive the function response before continuing the conversation.\n     */ Behavior[\"BLOCKING\"] = \"BLOCKING\";\n    /**\n     * If set, the system will not wait to receive the function response. Instead, it will attempt to handle function responses as they become available while maintaining the conversation between the user and the model.\n     */ Behavior[\"NON_BLOCKING\"] = \"NON_BLOCKING\";\n})(Behavior || (Behavior = {}));\n/** Config for the dynamic retrieval config mode. */ var DynamicRetrievalConfigMode;\n(function(DynamicRetrievalConfigMode) {\n    /**\n     * Always trigger retrieval.\n     */ DynamicRetrievalConfigMode[\"MODE_UNSPECIFIED\"] = \"MODE_UNSPECIFIED\";\n    /**\n     * Run retrieval only when system decides it is necessary.\n     */ DynamicRetrievalConfigMode[\"MODE_DYNAMIC\"] = \"MODE_DYNAMIC\";\n})(DynamicRetrievalConfigMode || (DynamicRetrievalConfigMode = {}));\n/** Config for the function calling config mode. */ var FunctionCallingConfigMode;\n(function(FunctionCallingConfigMode) {\n    /**\n     * The function calling config mode is unspecified. Should not be used.\n     */ FunctionCallingConfigMode[\"MODE_UNSPECIFIED\"] = \"MODE_UNSPECIFIED\";\n    /**\n     * Default model behavior, model decides to predict either function calls or natural language response.\n     */ FunctionCallingConfigMode[\"AUTO\"] = \"AUTO\";\n    /**\n     * Model is constrained to always predicting function calls only. If \"allowed_function_names\" are set, the predicted function calls will be limited to any one of \"allowed_function_names\", else the predicted function calls will be any one of the provided \"function_declarations\".\n     */ FunctionCallingConfigMode[\"ANY\"] = \"ANY\";\n    /**\n     * Model will not predict any function calls. Model behavior is same as when not passing any function declarations.\n     */ FunctionCallingConfigMode[\"NONE\"] = \"NONE\";\n})(FunctionCallingConfigMode || (FunctionCallingConfigMode = {}));\n/** Status of the url retrieval. */ var UrlRetrievalStatus;\n(function(UrlRetrievalStatus) {\n    /**\n     * Default value. This value is unused\n     */ UrlRetrievalStatus[\"URL_RETRIEVAL_STATUS_UNSPECIFIED\"] = \"URL_RETRIEVAL_STATUS_UNSPECIFIED\";\n    /**\n     * Url retrieval is successful.\n     */ UrlRetrievalStatus[\"URL_RETRIEVAL_STATUS_SUCCESS\"] = \"URL_RETRIEVAL_STATUS_SUCCESS\";\n    /**\n     * Url retrieval is failed due to error.\n     */ UrlRetrievalStatus[\"URL_RETRIEVAL_STATUS_ERROR\"] = \"URL_RETRIEVAL_STATUS_ERROR\";\n})(UrlRetrievalStatus || (UrlRetrievalStatus = {}));\n/** Enum that controls the safety filter level for objectionable content. */ var SafetyFilterLevel;\n(function(SafetyFilterLevel) {\n    SafetyFilterLevel[\"BLOCK_LOW_AND_ABOVE\"] = \"BLOCK_LOW_AND_ABOVE\";\n    SafetyFilterLevel[\"BLOCK_MEDIUM_AND_ABOVE\"] = \"BLOCK_MEDIUM_AND_ABOVE\";\n    SafetyFilterLevel[\"BLOCK_ONLY_HIGH\"] = \"BLOCK_ONLY_HIGH\";\n    SafetyFilterLevel[\"BLOCK_NONE\"] = \"BLOCK_NONE\";\n})(SafetyFilterLevel || (SafetyFilterLevel = {}));\n/** Enum that controls the generation of people. */ var PersonGeneration;\n(function(PersonGeneration) {\n    /**\n     * Block generation of images of people.\n     */ PersonGeneration[\"DONT_ALLOW\"] = \"DONT_ALLOW\";\n    /**\n     * Generate images of adults, but not children.\n     */ PersonGeneration[\"ALLOW_ADULT\"] = \"ALLOW_ADULT\";\n    /**\n     * Generate images that include adults and children.\n     */ PersonGeneration[\"ALLOW_ALL\"] = \"ALLOW_ALL\";\n})(PersonGeneration || (PersonGeneration = {}));\n/** Enum that specifies the language of the text in the prompt. */ var ImagePromptLanguage;\n(function(ImagePromptLanguage) {\n    ImagePromptLanguage[\"auto\"] = \"auto\";\n    ImagePromptLanguage[\"en\"] = \"en\";\n    ImagePromptLanguage[\"ja\"] = \"ja\";\n    ImagePromptLanguage[\"ko\"] = \"ko\";\n    ImagePromptLanguage[\"hi\"] = \"hi\";\n})(ImagePromptLanguage || (ImagePromptLanguage = {}));\n/** Enum representing the mask mode of a mask reference image. */ var MaskReferenceMode;\n(function(MaskReferenceMode) {\n    MaskReferenceMode[\"MASK_MODE_DEFAULT\"] = \"MASK_MODE_DEFAULT\";\n    MaskReferenceMode[\"MASK_MODE_USER_PROVIDED\"] = \"MASK_MODE_USER_PROVIDED\";\n    MaskReferenceMode[\"MASK_MODE_BACKGROUND\"] = \"MASK_MODE_BACKGROUND\";\n    MaskReferenceMode[\"MASK_MODE_FOREGROUND\"] = \"MASK_MODE_FOREGROUND\";\n    MaskReferenceMode[\"MASK_MODE_SEMANTIC\"] = \"MASK_MODE_SEMANTIC\";\n})(MaskReferenceMode || (MaskReferenceMode = {}));\n/** Enum representing the control type of a control reference image. */ var ControlReferenceType;\n(function(ControlReferenceType) {\n    ControlReferenceType[\"CONTROL_TYPE_DEFAULT\"] = \"CONTROL_TYPE_DEFAULT\";\n    ControlReferenceType[\"CONTROL_TYPE_CANNY\"] = \"CONTROL_TYPE_CANNY\";\n    ControlReferenceType[\"CONTROL_TYPE_SCRIBBLE\"] = \"CONTROL_TYPE_SCRIBBLE\";\n    ControlReferenceType[\"CONTROL_TYPE_FACE_MESH\"] = \"CONTROL_TYPE_FACE_MESH\";\n})(ControlReferenceType || (ControlReferenceType = {}));\n/** Enum representing the subject type of a subject reference image. */ var SubjectReferenceType;\n(function(SubjectReferenceType) {\n    SubjectReferenceType[\"SUBJECT_TYPE_DEFAULT\"] = \"SUBJECT_TYPE_DEFAULT\";\n    SubjectReferenceType[\"SUBJECT_TYPE_PERSON\"] = \"SUBJECT_TYPE_PERSON\";\n    SubjectReferenceType[\"SUBJECT_TYPE_ANIMAL\"] = \"SUBJECT_TYPE_ANIMAL\";\n    SubjectReferenceType[\"SUBJECT_TYPE_PRODUCT\"] = \"SUBJECT_TYPE_PRODUCT\";\n})(SubjectReferenceType || (SubjectReferenceType = {}));\n/** Enum representing the Imagen 3 Edit mode. */ var EditMode;\n(function(EditMode) {\n    EditMode[\"EDIT_MODE_DEFAULT\"] = \"EDIT_MODE_DEFAULT\";\n    EditMode[\"EDIT_MODE_INPAINT_REMOVAL\"] = \"EDIT_MODE_INPAINT_REMOVAL\";\n    EditMode[\"EDIT_MODE_INPAINT_INSERTION\"] = \"EDIT_MODE_INPAINT_INSERTION\";\n    EditMode[\"EDIT_MODE_OUTPAINT\"] = \"EDIT_MODE_OUTPAINT\";\n    EditMode[\"EDIT_MODE_CONTROLLED_EDITING\"] = \"EDIT_MODE_CONTROLLED_EDITING\";\n    EditMode[\"EDIT_MODE_STYLE\"] = \"EDIT_MODE_STYLE\";\n    EditMode[\"EDIT_MODE_BGSWAP\"] = \"EDIT_MODE_BGSWAP\";\n    EditMode[\"EDIT_MODE_PRODUCT_IMAGE\"] = \"EDIT_MODE_PRODUCT_IMAGE\";\n})(EditMode || (EditMode = {}));\n/** Enum that controls the compression quality of the generated videos. */ var VideoCompressionQuality;\n(function(VideoCompressionQuality) {\n    /**\n     * Optimized video compression quality. This will produce videos\n        with a compressed, smaller file size.\n     */ VideoCompressionQuality[\"OPTIMIZED\"] = \"OPTIMIZED\";\n    /**\n     * Lossless video compression quality. This will produce videos\n        with a larger file size.\n     */ VideoCompressionQuality[\"LOSSLESS\"] = \"LOSSLESS\";\n})(VideoCompressionQuality || (VideoCompressionQuality = {}));\n/** State for the lifecycle of a File. */ var FileState;\n(function(FileState) {\n    FileState[\"STATE_UNSPECIFIED\"] = \"STATE_UNSPECIFIED\";\n    FileState[\"PROCESSING\"] = \"PROCESSING\";\n    FileState[\"ACTIVE\"] = \"ACTIVE\";\n    FileState[\"FAILED\"] = \"FAILED\";\n})(FileState || (FileState = {}));\n/** Source of the File. */ var FileSource;\n(function(FileSource) {\n    FileSource[\"SOURCE_UNSPECIFIED\"] = \"SOURCE_UNSPECIFIED\";\n    FileSource[\"UPLOADED\"] = \"UPLOADED\";\n    FileSource[\"GENERATED\"] = \"GENERATED\";\n})(FileSource || (FileSource = {}));\n/** Server content modalities. */ var MediaModality;\n(function(MediaModality) {\n    /**\n     * The modality is unspecified.\n     */ MediaModality[\"MODALITY_UNSPECIFIED\"] = \"MODALITY_UNSPECIFIED\";\n    /**\n     * Plain text.\n     */ MediaModality[\"TEXT\"] = \"TEXT\";\n    /**\n     * Images.\n     */ MediaModality[\"IMAGE\"] = \"IMAGE\";\n    /**\n     * Video.\n     */ MediaModality[\"VIDEO\"] = \"VIDEO\";\n    /**\n     * Audio.\n     */ MediaModality[\"AUDIO\"] = \"AUDIO\";\n    /**\n     * Document, e.g. PDF.\n     */ MediaModality[\"DOCUMENT\"] = \"DOCUMENT\";\n})(MediaModality || (MediaModality = {}));\n/** Start of speech sensitivity. */ var StartSensitivity;\n(function(StartSensitivity) {\n    /**\n     * The default is START_SENSITIVITY_LOW.\n     */ StartSensitivity[\"START_SENSITIVITY_UNSPECIFIED\"] = \"START_SENSITIVITY_UNSPECIFIED\";\n    /**\n     * Automatic detection will detect the start of speech more often.\n     */ StartSensitivity[\"START_SENSITIVITY_HIGH\"] = \"START_SENSITIVITY_HIGH\";\n    /**\n     * Automatic detection will detect the start of speech less often.\n     */ StartSensitivity[\"START_SENSITIVITY_LOW\"] = \"START_SENSITIVITY_LOW\";\n})(StartSensitivity || (StartSensitivity = {}));\n/** End of speech sensitivity. */ var EndSensitivity;\n(function(EndSensitivity) {\n    /**\n     * The default is END_SENSITIVITY_LOW.\n     */ EndSensitivity[\"END_SENSITIVITY_UNSPECIFIED\"] = \"END_SENSITIVITY_UNSPECIFIED\";\n    /**\n     * Automatic detection ends speech more often.\n     */ EndSensitivity[\"END_SENSITIVITY_HIGH\"] = \"END_SENSITIVITY_HIGH\";\n    /**\n     * Automatic detection ends speech less often.\n     */ EndSensitivity[\"END_SENSITIVITY_LOW\"] = \"END_SENSITIVITY_LOW\";\n})(EndSensitivity || (EndSensitivity = {}));\n/** The different ways of handling user activity. */ var ActivityHandling;\n(function(ActivityHandling) {\n    /**\n     * If unspecified, the default behavior is `START_OF_ACTIVITY_INTERRUPTS`.\n     */ ActivityHandling[\"ACTIVITY_HANDLING_UNSPECIFIED\"] = \"ACTIVITY_HANDLING_UNSPECIFIED\";\n    /**\n     * If true, start of activity will interrupt the model's response (also called \"barge in\"). The model's current response will be cut-off in the moment of the interruption. This is the default behavior.\n     */ ActivityHandling[\"START_OF_ACTIVITY_INTERRUPTS\"] = \"START_OF_ACTIVITY_INTERRUPTS\";\n    /**\n     * The model's response will not be interrupted.\n     */ ActivityHandling[\"NO_INTERRUPTION\"] = \"NO_INTERRUPTION\";\n})(ActivityHandling || (ActivityHandling = {}));\n/** Options about which input is included in the user's turn. */ var TurnCoverage;\n(function(TurnCoverage) {\n    /**\n     * If unspecified, the default behavior is `TURN_INCLUDES_ONLY_ACTIVITY`.\n     */ TurnCoverage[\"TURN_COVERAGE_UNSPECIFIED\"] = \"TURN_COVERAGE_UNSPECIFIED\";\n    /**\n     * The users turn only includes activity since the last turn, excluding inactivity (e.g. silence on the audio stream). This is the default behavior.\n     */ TurnCoverage[\"TURN_INCLUDES_ONLY_ACTIVITY\"] = \"TURN_INCLUDES_ONLY_ACTIVITY\";\n    /**\n     * The users turn includes all realtime input since the last turn, including inactivity (e.g. silence on the audio stream).\n     */ TurnCoverage[\"TURN_INCLUDES_ALL_INPUT\"] = \"TURN_INCLUDES_ALL_INPUT\";\n})(TurnCoverage || (TurnCoverage = {}));\n/** Specifies how the response should be scheduled in the conversation. */ var FunctionResponseScheduling;\n(function(FunctionResponseScheduling) {\n    /**\n     * This value is unused.\n     */ FunctionResponseScheduling[\"SCHEDULING_UNSPECIFIED\"] = \"SCHEDULING_UNSPECIFIED\";\n    /**\n     * Only add the result to the conversation context, do not interrupt or trigger generation.\n     */ FunctionResponseScheduling[\"SILENT\"] = \"SILENT\";\n    /**\n     * Add the result to the conversation context, and prompt to generate output without interrupting ongoing generation.\n     */ FunctionResponseScheduling[\"WHEN_IDLE\"] = \"WHEN_IDLE\";\n    /**\n     * Add the result to the conversation context, interrupt ongoing generation and prompt to generate output.\n     */ FunctionResponseScheduling[\"INTERRUPT\"] = \"INTERRUPT\";\n})(FunctionResponseScheduling || (FunctionResponseScheduling = {}));\n/** Scale of the generated music. */ var Scale;\n(function(Scale) {\n    /**\n     * Default value. This value is unused.\n     */ Scale[\"SCALE_UNSPECIFIED\"] = \"SCALE_UNSPECIFIED\";\n    /**\n     * C major or A minor.\n     */ Scale[\"C_MAJOR_A_MINOR\"] = \"C_MAJOR_A_MINOR\";\n    /**\n     * Db major or Bb minor.\n     */ Scale[\"D_FLAT_MAJOR_B_FLAT_MINOR\"] = \"D_FLAT_MAJOR_B_FLAT_MINOR\";\n    /**\n     * D major or B minor.\n     */ Scale[\"D_MAJOR_B_MINOR\"] = \"D_MAJOR_B_MINOR\";\n    /**\n     * Eb major or C minor\n     */ Scale[\"E_FLAT_MAJOR_C_MINOR\"] = \"E_FLAT_MAJOR_C_MINOR\";\n    /**\n     * E major or Db minor.\n     */ Scale[\"E_MAJOR_D_FLAT_MINOR\"] = \"E_MAJOR_D_FLAT_MINOR\";\n    /**\n     * F major or D minor.\n     */ Scale[\"F_MAJOR_D_MINOR\"] = \"F_MAJOR_D_MINOR\";\n    /**\n     * Gb major or Eb minor.\n     */ Scale[\"G_FLAT_MAJOR_E_FLAT_MINOR\"] = \"G_FLAT_MAJOR_E_FLAT_MINOR\";\n    /**\n     * G major or E minor.\n     */ Scale[\"G_MAJOR_E_MINOR\"] = \"G_MAJOR_E_MINOR\";\n    /**\n     * Ab major or F minor.\n     */ Scale[\"A_FLAT_MAJOR_F_MINOR\"] = \"A_FLAT_MAJOR_F_MINOR\";\n    /**\n     * A major or Gb minor.\n     */ Scale[\"A_MAJOR_G_FLAT_MINOR\"] = \"A_MAJOR_G_FLAT_MINOR\";\n    /**\n     * Bb major or G minor.\n     */ Scale[\"B_FLAT_MAJOR_G_MINOR\"] = \"B_FLAT_MAJOR_G_MINOR\";\n    /**\n     * B major or Ab minor.\n     */ Scale[\"B_MAJOR_A_FLAT_MINOR\"] = \"B_MAJOR_A_FLAT_MINOR\";\n})(Scale || (Scale = {}));\n/** The playback control signal to apply to the music generation. */ var LiveMusicPlaybackControl;\n(function(LiveMusicPlaybackControl) {\n    /**\n     * This value is unused.\n     */ LiveMusicPlaybackControl[\"PLAYBACK_CONTROL_UNSPECIFIED\"] = \"PLAYBACK_CONTROL_UNSPECIFIED\";\n    /**\n     * Start generating the music.\n     */ LiveMusicPlaybackControl[\"PLAY\"] = \"PLAY\";\n    /**\n     * Hold the music generation. Use PLAY to resume from the current position.\n     */ LiveMusicPlaybackControl[\"PAUSE\"] = \"PAUSE\";\n    /**\n     * Stop the music generation and reset the context (prompts retained).\n        Use PLAY to restart the music generation.\n     */ LiveMusicPlaybackControl[\"STOP\"] = \"STOP\";\n    /**\n     * Reset the context of the music generation without stopping it.\n        Retains the current prompts and config.\n     */ LiveMusicPlaybackControl[\"RESET_CONTEXT\"] = \"RESET_CONTEXT\";\n})(LiveMusicPlaybackControl || (LiveMusicPlaybackControl = {}));\n/** A function response. */ class FunctionResponse {\n}\n/**\n * Creates a `Part` object from a `URI` string.\n */ function createPartFromUri(uri, mimeType) {\n    return {\n        fileData: {\n            fileUri: uri,\n            mimeType: mimeType\n        }\n    };\n}\n/**\n * Creates a `Part` object from a `text` string.\n */ function createPartFromText(text) {\n    return {\n        text: text\n    };\n}\n/**\n * Creates a `Part` object from a `FunctionCall` object.\n */ function createPartFromFunctionCall(name, args) {\n    return {\n        functionCall: {\n            name: name,\n            args: args\n        }\n    };\n}\n/**\n * Creates a `Part` object from a `FunctionResponse` object.\n */ function createPartFromFunctionResponse(id, name, response) {\n    return {\n        functionResponse: {\n            id: id,\n            name: name,\n            response: response\n        }\n    };\n}\n/**\n * Creates a `Part` object from a `base64` encoded `string`.\n */ function createPartFromBase64(data, mimeType) {\n    return {\n        inlineData: {\n            data: data,\n            mimeType: mimeType\n        }\n    };\n}\n/**\n * Creates a `Part` object from the `outcome` and `output` of a `CodeExecutionResult` object.\n */ function createPartFromCodeExecutionResult(outcome, output) {\n    return {\n        codeExecutionResult: {\n            outcome: outcome,\n            output: output\n        }\n    };\n}\n/**\n * Creates a `Part` object from the `code` and `language` of an `ExecutableCode` object.\n */ function createPartFromExecutableCode(code, language) {\n    return {\n        executableCode: {\n            code: code,\n            language: language\n        }\n    };\n}\nfunction _isPart(obj) {\n    if (typeof obj === \"object\" && obj !== null) {\n        return \"fileData\" in obj || \"text\" in obj || \"functionCall\" in obj || \"functionResponse\" in obj || \"inlineData\" in obj || \"videoMetadata\" in obj || \"codeExecutionResult\" in obj || \"executableCode\" in obj;\n    }\n    return false;\n}\nfunction _toParts(partOrString) {\n    const parts = [];\n    if (typeof partOrString === \"string\") {\n        parts.push(createPartFromText(partOrString));\n    } else if (_isPart(partOrString)) {\n        parts.push(partOrString);\n    } else if (Array.isArray(partOrString)) {\n        if (partOrString.length === 0) {\n            throw new Error(\"partOrString cannot be an empty array\");\n        }\n        for (const part of partOrString){\n            if (typeof part === \"string\") {\n                parts.push(createPartFromText(part));\n            } else if (_isPart(part)) {\n                parts.push(part);\n            } else {\n                throw new Error(\"element in PartUnion must be a Part object or string\");\n            }\n        }\n    } else {\n        throw new Error(\"partOrString must be a Part object, string, or array\");\n    }\n    return parts;\n}\n/**\n * Creates a `Content` object with a user role from a `PartListUnion` object or `string`.\n */ function createUserContent(partOrString) {\n    return {\n        role: \"user\",\n        parts: _toParts(partOrString)\n    };\n}\n/**\n * Creates a `Content` object with a model role from a `PartListUnion` object or `string`.\n */ function createModelContent(partOrString) {\n    return {\n        role: \"model\",\n        parts: _toParts(partOrString)\n    };\n}\n/** A wrapper class for the http response. */ class HttpResponse {\n    constructor(response){\n        // Process the headers.\n        const headers = {};\n        for (const pair of response.headers.entries()){\n            headers[pair[0]] = pair[1];\n        }\n        this.headers = headers;\n        // Keep the original response.\n        this.responseInternal = response;\n    }\n    json() {\n        return this.responseInternal.json();\n    }\n}\n/** Content filter results for a prompt sent in the request. */ class GenerateContentResponsePromptFeedback {\n}\n/** Usage metadata about response(s). */ class GenerateContentResponseUsageMetadata {\n}\n/** Response message for PredictionService.GenerateContent. */ class GenerateContentResponse {\n    /**\n     * Returns the concatenation of all text parts from the first candidate in the response.\n     *\n     * @remarks\n     * If there are multiple candidates in the response, the text from the first\n     * one will be returned.\n     * If there are non-text parts in the response, the concatenation of all text\n     * parts will be returned, and a warning will be logged.\n     * If there are thought parts in the response, the concatenation of all text\n     * parts excluding the thought parts will be returned.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.generateContent({\n     *   model: 'gemini-2.0-flash',\n     *   contents:\n     *     'Why is the sky blue?',\n     * });\n     *\n     * console.debug(response.text);\n     * ```\n     */ get text() {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {\n            return undefined;\n        }\n        if (this.candidates && this.candidates.length > 1) {\n            console.warn(\"there are multiple candidates in the response, returning text from the first one.\");\n        }\n        let text = \"\";\n        let anyTextPartText = false;\n        const nonTextParts = [];\n        for (const part of (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) !== null && _h !== void 0 ? _h : []){\n            for (const [fieldName, fieldValue] of Object.entries(part)){\n                if (fieldName !== \"text\" && fieldName !== \"thought\" && (fieldValue !== null || fieldValue !== undefined)) {\n                    nonTextParts.push(fieldName);\n                }\n            }\n            if (typeof part.text === \"string\") {\n                if (typeof part.thought === \"boolean\" && part.thought) {\n                    continue;\n                }\n                anyTextPartText = true;\n                text += part.text;\n            }\n        }\n        if (nonTextParts.length > 0) {\n            console.warn(`there are non-text parts ${nonTextParts} in the response, returning concatenation of all text parts. Please refer to the non text parts for a full response from model.`);\n        }\n        // part.text === '' is different from part.text is null\n        return anyTextPartText ? text : undefined;\n    }\n    /**\n     * Returns the concatenation of all inline data parts from the first candidate\n     * in the response.\n     *\n     * @remarks\n     * If there are multiple candidates in the response, the inline data from the\n     * first one will be returned. If there are non-inline data parts in the\n     * response, the concatenation of all inline data parts will be returned, and\n     * a warning will be logged.\n     */ get data() {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {\n            return undefined;\n        }\n        if (this.candidates && this.candidates.length > 1) {\n            console.warn(\"there are multiple candidates in the response, returning data from the first one.\");\n        }\n        let data = \"\";\n        const nonDataParts = [];\n        for (const part of (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) !== null && _h !== void 0 ? _h : []){\n            for (const [fieldName, fieldValue] of Object.entries(part)){\n                if (fieldName !== \"inlineData\" && (fieldValue !== null || fieldValue !== undefined)) {\n                    nonDataParts.push(fieldName);\n                }\n            }\n            if (part.inlineData && typeof part.inlineData.data === \"string\") {\n                data += atob(part.inlineData.data);\n            }\n        }\n        if (nonDataParts.length > 0) {\n            console.warn(`there are non-data parts ${nonDataParts} in the response, returning concatenation of all data parts. Please refer to the non data parts for a full response from model.`);\n        }\n        return data.length > 0 ? btoa(data) : undefined;\n    }\n    /**\n     * Returns the function calls from the first candidate in the response.\n     *\n     * @remarks\n     * If there are multiple candidates in the response, the function calls from\n     * the first one will be returned.\n     * If there are no function calls in the response, undefined will be returned.\n     *\n     * @example\n     * ```ts\n     * const controlLightFunctionDeclaration: FunctionDeclaration = {\n     *   name: 'controlLight',\n     *   parameters: {\n     *   type: Type.OBJECT,\n     *   description: 'Set the brightness and color temperature of a room light.',\n     *   properties: {\n     *     brightness: {\n     *       type: Type.NUMBER,\n     *       description:\n     *         'Light level from 0 to 100. Zero is off and 100 is full brightness.',\n     *     },\n     *     colorTemperature: {\n     *       type: Type.STRING,\n     *       description:\n     *         'Color temperature of the light fixture which can be `daylight`, `cool` or `warm`.',\n     *     },\n     *   },\n     *   required: ['brightness', 'colorTemperature'],\n     *  };\n     *  const response = await ai.models.generateContent({\n     *     model: 'gemini-2.0-flash',\n     *     contents: 'Dim the lights so the room feels cozy and warm.',\n     *     config: {\n     *       tools: [{functionDeclarations: [controlLightFunctionDeclaration]}],\n     *       toolConfig: {\n     *         functionCallingConfig: {\n     *           mode: FunctionCallingConfigMode.ANY,\n     *           allowedFunctionNames: ['controlLight'],\n     *         },\n     *       },\n     *     },\n     *   });\n     *  console.debug(JSON.stringify(response.functionCalls));\n     * ```\n     */ get functionCalls() {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {\n            return undefined;\n        }\n        if (this.candidates && this.candidates.length > 1) {\n            console.warn(\"there are multiple candidates in the response, returning function calls from the first one.\");\n        }\n        const functionCalls = (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) === null || _h === void 0 ? void 0 : _h.filter((part)=>part.functionCall).map((part)=>part.functionCall).filter((functionCall)=>functionCall !== undefined);\n        if ((functionCalls === null || functionCalls === void 0 ? void 0 : functionCalls.length) === 0) {\n            return undefined;\n        }\n        return functionCalls;\n    }\n    /**\n     * Returns the first executable code from the first candidate in the response.\n     *\n     * @remarks\n     * If there are multiple candidates in the response, the executable code from\n     * the first one will be returned.\n     * If there are no executable code in the response, undefined will be\n     * returned.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.generateContent({\n     *   model: 'gemini-2.0-flash',\n     *   contents:\n     *     'What is the sum of the first 50 prime numbers? Generate and run code for the calculation, and make sure you get all 50.'\n     *   config: {\n     *     tools: [{codeExecution: {}}],\n     *   },\n     * });\n     *\n     * console.debug(response.executableCode);\n     * ```\n     */ get executableCode() {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n        if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {\n            return undefined;\n        }\n        if (this.candidates && this.candidates.length > 1) {\n            console.warn(\"there are multiple candidates in the response, returning executable code from the first one.\");\n        }\n        const executableCode = (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) === null || _h === void 0 ? void 0 : _h.filter((part)=>part.executableCode).map((part)=>part.executableCode).filter((executableCode)=>executableCode !== undefined);\n        if ((executableCode === null || executableCode === void 0 ? void 0 : executableCode.length) === 0) {\n            return undefined;\n        }\n        return (_j = executableCode === null || executableCode === void 0 ? void 0 : executableCode[0]) === null || _j === void 0 ? void 0 : _j.code;\n    }\n    /**\n     * Returns the first code execution result from the first candidate in the response.\n     *\n     * @remarks\n     * If there are multiple candidates in the response, the code execution result from\n     * the first one will be returned.\n     * If there are no code execution result in the response, undefined will be returned.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.generateContent({\n     *   model: 'gemini-2.0-flash',\n     *   contents:\n     *     'What is the sum of the first 50 prime numbers? Generate and run code for the calculation, and make sure you get all 50.'\n     *   config: {\n     *     tools: [{codeExecution: {}}],\n     *   },\n     * });\n     *\n     * console.debug(response.codeExecutionResult);\n     * ```\n     */ get codeExecutionResult() {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n        if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {\n            return undefined;\n        }\n        if (this.candidates && this.candidates.length > 1) {\n            console.warn(\"there are multiple candidates in the response, returning code execution result from the first one.\");\n        }\n        const codeExecutionResult = (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) === null || _h === void 0 ? void 0 : _h.filter((part)=>part.codeExecutionResult).map((part)=>part.codeExecutionResult).filter((codeExecutionResult)=>codeExecutionResult !== undefined);\n        if ((codeExecutionResult === null || codeExecutionResult === void 0 ? void 0 : codeExecutionResult.length) === 0) {\n            return undefined;\n        }\n        return (_j = codeExecutionResult === null || codeExecutionResult === void 0 ? void 0 : codeExecutionResult[0]) === null || _j === void 0 ? void 0 : _j.output;\n    }\n}\n/** Response for the embed_content method. */ class EmbedContentResponse {\n}\n/** The output images response. */ class GenerateImagesResponse {\n}\n/** Response for the request to edit an image. */ class EditImageResponse {\n}\nclass UpscaleImageResponse {\n}\nclass ListModelsResponse {\n}\nclass DeleteModelResponse {\n}\n/** Response for counting tokens. */ class CountTokensResponse {\n}\n/** Response for computing tokens. */ class ComputeTokensResponse {\n}\n/** Response with generated videos. */ class GenerateVideosResponse {\n}\n/** Response for the list tuning jobs method. */ class ListTuningJobsResponse {\n}\n/** Empty response for caches.delete method. */ class DeleteCachedContentResponse {\n}\nclass ListCachedContentsResponse {\n}\n/** Response for the list files method. */ class ListFilesResponse {\n}\n/** Response for the create file method. */ class CreateFileResponse {\n}\n/** Response for the delete file method. */ class DeleteFileResponse {\n}\n/** Config for `inlined_responses` parameter. */ class InlinedResponse {\n}\n/** Config for batches.list return value. */ class ListBatchJobsResponse {\n}\n/** Represents a single response in a replay. */ class ReplayResponse {\n}\n/** A raw reference image.\n\n  A raw reference image represents the base image to edit, provided by the user.\n  It can optionally be provided in addition to a mask reference image or\n  a style reference image.\n   */ class RawReferenceImage {\n    /** Internal method to convert to ReferenceImageAPIInternal. */ toReferenceImageAPI() {\n        const referenceImageAPI = {\n            referenceType: \"REFERENCE_TYPE_RAW\",\n            referenceImage: this.referenceImage,\n            referenceId: this.referenceId\n        };\n        return referenceImageAPI;\n    }\n}\n/** A mask reference image.\n\n  This encapsulates either a mask image provided by the user and configs for\n  the user provided mask, or only config parameters for the model to generate\n  a mask.\n\n  A mask image is an image whose non-zero values indicate where to edit the base\n  image. If the user provides a mask image, the mask must be in the same\n  dimensions as the raw image.\n   */ class MaskReferenceImage {\n    /** Internal method to convert to ReferenceImageAPIInternal. */ toReferenceImageAPI() {\n        const referenceImageAPI = {\n            referenceType: \"REFERENCE_TYPE_MASK\",\n            referenceImage: this.referenceImage,\n            referenceId: this.referenceId,\n            maskImageConfig: this.config\n        };\n        return referenceImageAPI;\n    }\n}\n/** A control reference image.\n\n  The image of the control reference image is either a control image provided\n  by the user, or a regular image which the backend will use to generate a\n  control image of. In the case of the latter, the\n  enable_control_image_computation field in the config should be set to True.\n\n  A control image is an image that represents a sketch image of areas for the\n  model to fill in based on the prompt.\n   */ class ControlReferenceImage {\n    /** Internal method to convert to ReferenceImageAPIInternal. */ toReferenceImageAPI() {\n        const referenceImageAPI = {\n            referenceType: \"REFERENCE_TYPE_CONTROL\",\n            referenceImage: this.referenceImage,\n            referenceId: this.referenceId,\n            controlImageConfig: this.config\n        };\n        return referenceImageAPI;\n    }\n}\n/** A style reference image.\n\n  This encapsulates a style reference image provided by the user, and\n  additionally optional config parameters for the style reference image.\n\n  A raw reference image can also be provided as a destination for the style to\n  be applied to.\n   */ class StyleReferenceImage {\n    /** Internal method to convert to ReferenceImageAPIInternal. */ toReferenceImageAPI() {\n        const referenceImageAPI = {\n            referenceType: \"REFERENCE_TYPE_STYLE\",\n            referenceImage: this.referenceImage,\n            referenceId: this.referenceId,\n            styleImageConfig: this.config\n        };\n        return referenceImageAPI;\n    }\n}\n/** A subject reference image.\n\n  This encapsulates a subject reference image provided by the user, and\n  additionally optional config parameters for the subject reference image.\n\n  A raw reference image can also be provided as a destination for the subject to\n  be applied to.\n   */ class SubjectReferenceImage {\n    /* Internal method to convert to ReferenceImageAPIInternal. */ toReferenceImageAPI() {\n        const referenceImageAPI = {\n            referenceType: \"REFERENCE_TYPE_SUBJECT\",\n            referenceImage: this.referenceImage,\n            referenceId: this.referenceId,\n            subjectImageConfig: this.config\n        };\n        return referenceImageAPI;\n    }\n}\n/** Response message for API call. */ class LiveServerMessage {\n    /**\n     * Returns the concatenation of all text parts from the server content if present.\n     *\n     * @remarks\n     * If there are non-text parts in the response, the concatenation of all text\n     * parts will be returned, and a warning will be logged.\n     */ get text() {\n        var _a, _b, _c;\n        let text = \"\";\n        let anyTextPartFound = false;\n        const nonTextParts = [];\n        for (const part of (_c = (_b = (_a = this.serverContent) === null || _a === void 0 ? void 0 : _a.modelTurn) === null || _b === void 0 ? void 0 : _b.parts) !== null && _c !== void 0 ? _c : []){\n            for (const [fieldName, fieldValue] of Object.entries(part)){\n                if (fieldName !== \"text\" && fieldName !== \"thought\" && fieldValue !== null) {\n                    nonTextParts.push(fieldName);\n                }\n            }\n            if (typeof part.text === \"string\") {\n                if (typeof part.thought === \"boolean\" && part.thought) {\n                    continue;\n                }\n                anyTextPartFound = true;\n                text += part.text;\n            }\n        }\n        if (nonTextParts.length > 0) {\n            console.warn(`there are non-text parts ${nonTextParts} in the response, returning concatenation of all text parts. Please refer to the non text parts for a full response from model.`);\n        }\n        // part.text === '' is different from part.text is null\n        return anyTextPartFound ? text : undefined;\n    }\n    /**\n     * Returns the concatenation of all inline data parts from the server content if present.\n     *\n     * @remarks\n     * If there are non-inline data parts in the\n     * response, the concatenation of all inline data parts will be returned, and\n     * a warning will be logged.\n     */ get data() {\n        var _a, _b, _c;\n        let data = \"\";\n        const nonDataParts = [];\n        for (const part of (_c = (_b = (_a = this.serverContent) === null || _a === void 0 ? void 0 : _a.modelTurn) === null || _b === void 0 ? void 0 : _b.parts) !== null && _c !== void 0 ? _c : []){\n            for (const [fieldName, fieldValue] of Object.entries(part)){\n                if (fieldName !== \"inlineData\" && fieldValue !== null) {\n                    nonDataParts.push(fieldName);\n                }\n            }\n            if (part.inlineData && typeof part.inlineData.data === \"string\") {\n                data += atob(part.inlineData.data);\n            }\n        }\n        if (nonDataParts.length > 0) {\n            console.warn(`there are non-data parts ${nonDataParts} in the response, returning concatenation of all data parts. Please refer to the non data parts for a full response from model.`);\n        }\n        return data.length > 0 ? btoa(data) : undefined;\n    }\n}\n/** Client generated response to a `ToolCall` received from the server.\n\n  Individual `FunctionResponse` objects are matched to the respective\n  `FunctionCall` objects by the `id` field.\n\n  Note that in the unary and server-streaming GenerateContent APIs function\n  calling happens by exchanging the `Content` parts, while in the bidi\n  GenerateContent APIs function calling happens over this dedicated set of\n  messages.\n   */ class LiveClientToolResponse {\n}\n/** Parameters for sending tool responses to the live API. */ class LiveSendToolResponseParameters {\n    constructor(){\n        /** Tool responses to send to the session. */ this.functionResponses = [];\n    }\n}\n/** Response message for the LiveMusicClientMessage call. */ class LiveMusicServerMessage {\n    /**\n     * Returns the first audio chunk from the server content, if present.\n     *\n     * @remarks\n     * If there are no audio chunks in the response, undefined will be returned.\n     */ get audioChunk() {\n        if (this.serverContent && this.serverContent.audioChunks && this.serverContent.audioChunks.length > 0) {\n            return this.serverContent.audioChunks[0];\n        }\n        return undefined;\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ function tModel(apiClient, model) {\n    if (!model || typeof model !== \"string\") {\n        throw new Error(\"model is required and must be a string\");\n    }\n    if (apiClient.isVertexAI()) {\n        if (model.startsWith(\"publishers/\") || model.startsWith(\"projects/\") || model.startsWith(\"models/\")) {\n            return model;\n        } else if (model.indexOf(\"/\") >= 0) {\n            const parts = model.split(\"/\", 2);\n            return `publishers/${parts[0]}/models/${parts[1]}`;\n        } else {\n            return `publishers/google/models/${model}`;\n        }\n    } else {\n        if (model.startsWith(\"models/\") || model.startsWith(\"tunedModels/\")) {\n            return model;\n        } else {\n            return `models/${model}`;\n        }\n    }\n}\nfunction tCachesModel(apiClient, model) {\n    const transformedModel = tModel(apiClient, model);\n    if (!transformedModel) {\n        return \"\";\n    }\n    if (transformedModel.startsWith(\"publishers/\") && apiClient.isVertexAI()) {\n        // vertex caches only support model name start with projects.\n        return `projects/${apiClient.getProject()}/locations/${apiClient.getLocation()}/${transformedModel}`;\n    } else if (transformedModel.startsWith(\"models/\") && apiClient.isVertexAI()) {\n        return `projects/${apiClient.getProject()}/locations/${apiClient.getLocation()}/publishers/google/${transformedModel}`;\n    } else {\n        return transformedModel;\n    }\n}\nfunction tBlobs(blobs) {\n    if (Array.isArray(blobs)) {\n        return blobs.map((blob)=>tBlob(blob));\n    } else {\n        return [\n            tBlob(blobs)\n        ];\n    }\n}\nfunction tBlob(blob) {\n    if (typeof blob === \"object\" && blob !== null) {\n        return blob;\n    }\n    throw new Error(`Could not parse input as Blob. Unsupported blob type: ${typeof blob}`);\n}\nfunction tImageBlob(blob) {\n    const transformedBlob = tBlob(blob);\n    if (transformedBlob.mimeType && transformedBlob.mimeType.startsWith(\"image/\")) {\n        return transformedBlob;\n    }\n    throw new Error(`Unsupported mime type: ${transformedBlob.mimeType}`);\n}\nfunction tAudioBlob(blob) {\n    const transformedBlob = tBlob(blob);\n    if (transformedBlob.mimeType && transformedBlob.mimeType.startsWith(\"audio/\")) {\n        return transformedBlob;\n    }\n    throw new Error(`Unsupported mime type: ${transformedBlob.mimeType}`);\n}\nfunction tPart(origin) {\n    if (origin === null || origin === undefined) {\n        throw new Error(\"PartUnion is required\");\n    }\n    if (typeof origin === \"object\") {\n        return origin;\n    }\n    if (typeof origin === \"string\") {\n        return {\n            text: origin\n        };\n    }\n    throw new Error(`Unsupported part type: ${typeof origin}`);\n}\nfunction tParts(origin) {\n    if (origin === null || origin === undefined || Array.isArray(origin) && origin.length === 0) {\n        throw new Error(\"PartListUnion is required\");\n    }\n    if (Array.isArray(origin)) {\n        return origin.map((item)=>tPart(item));\n    }\n    return [\n        tPart(origin)\n    ];\n}\nfunction _isContent(origin) {\n    return origin !== null && origin !== undefined && typeof origin === \"object\" && \"parts\" in origin && Array.isArray(origin.parts);\n}\nfunction _isFunctionCallPart(origin) {\n    return origin !== null && origin !== undefined && typeof origin === \"object\" && \"functionCall\" in origin;\n}\nfunction _isFunctionResponsePart(origin) {\n    return origin !== null && origin !== undefined && typeof origin === \"object\" && \"functionResponse\" in origin;\n}\nfunction tContent(origin) {\n    if (origin === null || origin === undefined) {\n        throw new Error(\"ContentUnion is required\");\n    }\n    if (_isContent(origin)) {\n        // _isContent is a utility function that checks if the\n        // origin is a Content.\n        return origin;\n    }\n    return {\n        role: \"user\",\n        parts: tParts(origin)\n    };\n}\nfunction tContentsForEmbed(apiClient, origin) {\n    if (!origin) {\n        return [];\n    }\n    if (apiClient.isVertexAI() && Array.isArray(origin)) {\n        return origin.flatMap((item)=>{\n            const content = tContent(item);\n            if (content.parts && content.parts.length > 0 && content.parts[0].text !== undefined) {\n                return [\n                    content.parts[0].text\n                ];\n            }\n            return [];\n        });\n    } else if (apiClient.isVertexAI()) {\n        const content = tContent(origin);\n        if (content.parts && content.parts.length > 0 && content.parts[0].text !== undefined) {\n            return [\n                content.parts[0].text\n            ];\n        }\n        return [];\n    }\n    if (Array.isArray(origin)) {\n        return origin.map((item)=>tContent(item));\n    }\n    return [\n        tContent(origin)\n    ];\n}\nfunction tContents(origin) {\n    if (origin === null || origin === undefined || Array.isArray(origin) && origin.length === 0) {\n        throw new Error(\"contents are required\");\n    }\n    if (!Array.isArray(origin)) {\n        // If it's not an array, it's a single content or a single PartUnion.\n        if (_isFunctionCallPart(origin) || _isFunctionResponsePart(origin)) {\n            throw new Error(\"To specify functionCall or functionResponse parts, please wrap them in a Content object, specifying the role for them\");\n        }\n        return [\n            tContent(origin)\n        ];\n    }\n    const result = [];\n    const accumulatedParts = [];\n    const isContentArray = _isContent(origin[0]);\n    for (const item of origin){\n        const isContent = _isContent(item);\n        if (isContent != isContentArray) {\n            throw new Error(\"Mixing Content and Parts is not supported, please group the parts into a the appropriate Content objects and specify the roles for them\");\n        }\n        if (isContent) {\n            // `isContent` contains the result of _isContent, which is a utility\n            // function that checks if the item is a Content.\n            result.push(item);\n        } else if (_isFunctionCallPart(item) || _isFunctionResponsePart(item)) {\n            throw new Error(\"To specify functionCall or functionResponse parts, please wrap them, and any other parts, in Content objects as appropriate, specifying the role for them\");\n        } else {\n            accumulatedParts.push(item);\n        }\n    }\n    if (!isContentArray) {\n        result.push({\n            role: \"user\",\n            parts: tParts(accumulatedParts)\n        });\n    }\n    return result;\n}\n// The fields that are supported by JSONSchema. Must be kept in sync with the\n// JSONSchema interface above.\nconst supportedJsonSchemaFields = new Set([\n    \"type\",\n    \"format\",\n    \"title\",\n    \"description\",\n    \"default\",\n    \"items\",\n    \"minItems\",\n    \"maxItems\",\n    \"enum\",\n    \"properties\",\n    \"required\",\n    \"minProperties\",\n    \"maxProperties\",\n    \"minimum\",\n    \"maximum\",\n    \"minLength\",\n    \"maxLength\",\n    \"pattern\",\n    \"anyOf\",\n    \"propertyOrdering\"\n]);\nconst jsonSchemaTypeValidator = zod__WEBPACK_IMPORTED_MODULE_0__.z[\"enum\"]([\n    \"string\",\n    \"number\",\n    \"integer\",\n    \"object\",\n    \"array\",\n    \"boolean\",\n    \"null\"\n]);\n// Handles all types and arrays of all types.\nconst schemaTypeUnion = zod__WEBPACK_IMPORTED_MODULE_0__.z.union([\n    jsonSchemaTypeValidator,\n    zod__WEBPACK_IMPORTED_MODULE_0__.z.array(jsonSchemaTypeValidator)\n]);\n/**\n * Creates a zod validator for JSONSchema.\n *\n * @param strictMode Whether to enable strict mode, default to true. When\n * strict mode is enabled, the zod validator will throw error if there\n * are unrecognized fields in the input data. If strict mode is\n * disabled, the zod validator will ignore the unrecognized fields, only\n * populate the fields that are listed in the JSONSchema. Regardless of\n * the mode the type mismatch will always result in an error, for example\n * items field should be a single JSONSchema, but for tuple type it would\n * be an array of JSONSchema, this will always result in an error.\n * @return The zod validator for JSONSchema.\n */ function createJsonSchemaValidator(strictMode = true) {\n    const jsonSchemaValidator = zod__WEBPACK_IMPORTED_MODULE_0__.z.lazy(()=>{\n        // Define the base object shape *inside* the z.lazy callback\n        const baseShape = zod__WEBPACK_IMPORTED_MODULE_0__.z.object({\n            // --- Type ---\n            type: schemaTypeUnion.optional(),\n            // --- Annotations ---\n            format: zod__WEBPACK_IMPORTED_MODULE_0__.z.string().optional(),\n            title: zod__WEBPACK_IMPORTED_MODULE_0__.z.string().optional(),\n            description: zod__WEBPACK_IMPORTED_MODULE_0__.z.string().optional(),\n            default: zod__WEBPACK_IMPORTED_MODULE_0__.z.unknown().optional(),\n            // --- Array Validations ---\n            items: jsonSchemaValidator.optional(),\n            minItems: zod__WEBPACK_IMPORTED_MODULE_0__.z.coerce.string().optional(),\n            maxItems: zod__WEBPACK_IMPORTED_MODULE_0__.z.coerce.string().optional(),\n            // --- Generic Validations ---\n            enum: zod__WEBPACK_IMPORTED_MODULE_0__.z.array(zod__WEBPACK_IMPORTED_MODULE_0__.z.unknown()).optional(),\n            // --- Object Validations ---\n            properties: zod__WEBPACK_IMPORTED_MODULE_0__.z.record(zod__WEBPACK_IMPORTED_MODULE_0__.z.string(), jsonSchemaValidator).optional(),\n            required: zod__WEBPACK_IMPORTED_MODULE_0__.z.array(zod__WEBPACK_IMPORTED_MODULE_0__.z.string()).optional(),\n            minProperties: zod__WEBPACK_IMPORTED_MODULE_0__.z.coerce.string().optional(),\n            maxProperties: zod__WEBPACK_IMPORTED_MODULE_0__.z.coerce.string().optional(),\n            propertyOrdering: zod__WEBPACK_IMPORTED_MODULE_0__.z.array(zod__WEBPACK_IMPORTED_MODULE_0__.z.string()).optional(),\n            // --- Numeric Validations ---\n            minimum: zod__WEBPACK_IMPORTED_MODULE_0__.z.number().optional(),\n            maximum: zod__WEBPACK_IMPORTED_MODULE_0__.z.number().optional(),\n            // --- String Validations ---\n            minLength: zod__WEBPACK_IMPORTED_MODULE_0__.z.coerce.string().optional(),\n            maxLength: zod__WEBPACK_IMPORTED_MODULE_0__.z.coerce.string().optional(),\n            pattern: zod__WEBPACK_IMPORTED_MODULE_0__.z.string().optional(),\n            // --- Schema Composition ---\n            anyOf: zod__WEBPACK_IMPORTED_MODULE_0__.z.array(jsonSchemaValidator).optional(),\n            // --- Additional Properties --- This field is not included in the\n            // JSONSchema, will not be communicated to the model, it is here purely\n            // for enabling the zod validation strict mode.\n            additionalProperties: zod__WEBPACK_IMPORTED_MODULE_0__.z.boolean().optional()\n        });\n        // Conditionally apply .strict() based on the flag\n        return strictMode ? baseShape.strict() : baseShape;\n    });\n    return jsonSchemaValidator;\n}\n/*\nHandle type field:\nThe resulted type field in JSONSchema form zod_to_json_schema can be either\nan array consist of primitive types or a single primitive type.\nThis is due to the optimization of zod_to_json_schema, when the types in the\nunion are primitive types without any additional specifications,\nzod_to_json_schema will squash the types into an array instead of put them\nin anyOf fields. Otherwise, it will put the types in anyOf fields.\nSee the following link for more details:\nhttps://github.com/zodjs/zod-to-json-schema/blob/main/src/index.ts#L101\nThe logic here is trying to undo that optimization, flattening the array of\ntypes to anyOf fields.\n                                 type field\n                                      |\n                            ___________________________\n                           /                           \\\n                          /                              \\\n                         /                                \\\n                       Array                              Type.*\n                /                  \\                       |\n      Include null.              Not included null     type = Type.*.\n      [null, Type.*, Type.*]     multiple types.\n      [null, Type.*]             [Type.*, Type.*]\n            /                                \\\n      remove null                             \\\n      add nullable = true                      \\\n       /                    \\                   \\\n    [Type.*]           [Type.*, Type.*]          \\\n only one type left     multiple types left       \\\n add type = Type.*.           \\                  /\n                               \\                /\n                         not populate the type field in final result\n                           and make the types into anyOf fields\n                          anyOf:[{type: 'Type.*'}, {type: 'Type.*'}];\n*/ function flattenTypeArrayToAnyOf(typeList, resultingSchema) {\n    if (typeList.includes(\"null\")) {\n        resultingSchema[\"nullable\"] = true;\n    }\n    const listWithoutNull = typeList.filter((type)=>type !== \"null\");\n    if (listWithoutNull.length === 1) {\n        resultingSchema[\"type\"] = Object.values(Type).includes(listWithoutNull[0].toUpperCase()) ? listWithoutNull[0].toUpperCase() : Type.TYPE_UNSPECIFIED;\n    } else {\n        resultingSchema[\"anyOf\"] = [];\n        for (const i of listWithoutNull){\n            resultingSchema[\"anyOf\"].push({\n                \"type\": Object.values(Type).includes(i.toUpperCase()) ? i.toUpperCase() : Type.TYPE_UNSPECIFIED\n            });\n        }\n    }\n}\nfunction processJsonSchema(_jsonSchema) {\n    const genAISchema = {};\n    const schemaFieldNames = [\n        \"items\"\n    ];\n    const listSchemaFieldNames = [\n        \"anyOf\"\n    ];\n    const dictSchemaFieldNames = [\n        \"properties\"\n    ];\n    if (_jsonSchema[\"type\"] && _jsonSchema[\"anyOf\"]) {\n        throw new Error(\"type and anyOf cannot be both populated.\");\n    }\n    /*\n    This is to handle the nullable array or object. The _jsonSchema will\n    be in the format of {anyOf: [{type: 'null'}, {type: 'object'}]}. The\n    logic is to check if anyOf has 2 elements and one of the element is null,\n    if so, the anyOf field is unnecessary, so we need to get rid of the anyOf\n    field and make the schema nullable. Then use the other element as the new\n    _jsonSchema for processing. This is because the backend doesn't have a null\n    type.\n    This has to be checked before we process any other fields.\n    For example:\n      const objectNullable = z.object({\n        nullableArray: z.array(z.string()).nullable(),\n      });\n    Will have the raw _jsonSchema as:\n    {\n      type: 'OBJECT',\n      properties: {\n          nullableArray: {\n             anyOf: [\n                {type: 'null'},\n                {\n                  type: 'array',\n                  items: {type: 'string'},\n                },\n              ],\n          }\n      },\n      required: [ 'nullableArray' ],\n    }\n    Will result in following schema compatible with Gemini API:\n      {\n        type: 'OBJECT',\n        properties: {\n           nullableArray: {\n              nullable: true,\n              type: 'ARRAY',\n              items: {type: 'string'},\n           }\n        },\n        required: [ 'nullableArray' ],\n      }\n    */ const incomingAnyOf = _jsonSchema[\"anyOf\"];\n    if (incomingAnyOf != null && incomingAnyOf.length == 2) {\n        if (incomingAnyOf[0][\"type\"] === \"null\") {\n            genAISchema[\"nullable\"] = true;\n            _jsonSchema = incomingAnyOf[1];\n        } else if (incomingAnyOf[1][\"type\"] === \"null\") {\n            genAISchema[\"nullable\"] = true;\n            _jsonSchema = incomingAnyOf[0];\n        }\n    }\n    if (_jsonSchema[\"type\"] instanceof Array) {\n        flattenTypeArrayToAnyOf(_jsonSchema[\"type\"], genAISchema);\n    }\n    for (const [fieldName, fieldValue] of Object.entries(_jsonSchema)){\n        // Skip if the fieldvalue is undefined or null.\n        if (fieldValue == null) {\n            continue;\n        }\n        if (fieldName == \"type\") {\n            if (fieldValue === \"null\") {\n                throw new Error(\"type: null can not be the only possible type for the field.\");\n            }\n            if (fieldValue instanceof Array) {\n                continue;\n            }\n            genAISchema[\"type\"] = Object.values(Type).includes(fieldValue.toUpperCase()) ? fieldValue.toUpperCase() : Type.TYPE_UNSPECIFIED;\n        } else if (schemaFieldNames.includes(fieldName)) {\n            genAISchema[fieldName] = processJsonSchema(fieldValue);\n        } else if (listSchemaFieldNames.includes(fieldName)) {\n            const listSchemaFieldValue = [];\n            for (const item of fieldValue){\n                if (item[\"type\"] == \"null\") {\n                    genAISchema[\"nullable\"] = true;\n                    continue;\n                }\n                listSchemaFieldValue.push(processJsonSchema(item));\n            }\n            genAISchema[fieldName] = listSchemaFieldValue;\n        } else if (dictSchemaFieldNames.includes(fieldName)) {\n            const dictSchemaFieldValue = {};\n            for (const [key, value] of Object.entries(fieldValue)){\n                dictSchemaFieldValue[key] = processJsonSchema(value);\n            }\n            genAISchema[fieldName] = dictSchemaFieldValue;\n        } else {\n            // additionalProperties is not included in JSONSchema, skipping it.\n            if (fieldName === \"additionalProperties\") {\n                continue;\n            }\n            genAISchema[fieldName] = fieldValue;\n        }\n    }\n    return genAISchema;\n}\n// we take the unknown in the schema field because we want enable user to pass\n// the output of major schema declaration tools without casting. Tools such as\n// zodToJsonSchema, typebox, zodToJsonSchema function can return JsonSchema7Type\n// or object, see details in\n// https://github.com/StefanTerdell/zod-to-json-schema/blob/70525efe555cd226691e093d171370a3b10921d1/src/zodToJsonSchema.ts#L7\n// typebox can return unknown, see details in\n// https://github.com/sinclairzx81/typebox/blob/5a5431439f7d5ca6b494d0d18fbfd7b1a356d67c/src/type/create/type.ts#L35\nfunction tSchema(schema) {\n    if (Object.keys(schema).includes(\"$schema\")) {\n        delete schema[\"$schema\"];\n        const validatedJsonSchema = createJsonSchemaValidator().parse(schema);\n        return processJsonSchema(validatedJsonSchema);\n    } else {\n        return processJsonSchema(schema);\n    }\n}\nfunction tSpeechConfig(speechConfig) {\n    if (typeof speechConfig === \"object\") {\n        return speechConfig;\n    } else if (typeof speechConfig === \"string\") {\n        return {\n            voiceConfig: {\n                prebuiltVoiceConfig: {\n                    voiceName: speechConfig\n                }\n            }\n        };\n    } else {\n        throw new Error(`Unsupported speechConfig type: ${typeof speechConfig}`);\n    }\n}\nfunction tLiveSpeechConfig(speechConfig) {\n    if (\"multiSpeakerVoiceConfig\" in speechConfig) {\n        throw new Error(\"multiSpeakerVoiceConfig is not supported in the live API.\");\n    }\n    return speechConfig;\n}\nfunction tTool(tool) {\n    if (tool.functionDeclarations) {\n        for (const functionDeclaration of tool.functionDeclarations){\n            if (functionDeclaration.parameters) {\n                functionDeclaration.parameters = tSchema(functionDeclaration.parameters);\n            }\n            if (functionDeclaration.response) {\n                functionDeclaration.response = tSchema(functionDeclaration.response);\n            }\n        }\n    }\n    return tool;\n}\nfunction tTools(tools) {\n    // Check if the incoming type is defined.\n    if (tools === undefined || tools === null) {\n        throw new Error(\"tools is required\");\n    }\n    if (!Array.isArray(tools)) {\n        throw new Error(\"tools is required and must be an array of Tools\");\n    }\n    const result = [];\n    for (const tool of tools){\n        result.push(tool);\n    }\n    return result;\n}\n/**\n * Prepends resource name with project, location, resource_prefix if needed.\n *\n * @param client The API client.\n * @param resourceName The resource name.\n * @param resourcePrefix The resource prefix.\n * @param splitsAfterPrefix The number of splits after the prefix.\n * @returns The completed resource name.\n *\n * Examples:\n *\n * ```\n * resource_name = '123'\n * resource_prefix = 'cachedContents'\n * splits_after_prefix = 1\n * client.vertexai = True\n * client.project = 'bar'\n * client.location = 'us-west1'\n * _resource_name(client, resource_name, resource_prefix, splits_after_prefix)\n * returns: 'projects/bar/locations/us-west1/cachedContents/123'\n * ```\n *\n * ```\n * resource_name = 'projects/foo/locations/us-central1/cachedContents/123'\n * resource_prefix = 'cachedContents'\n * splits_after_prefix = 1\n * client.vertexai = True\n * client.project = 'bar'\n * client.location = 'us-west1'\n * _resource_name(client, resource_name, resource_prefix, splits_after_prefix)\n * returns: 'projects/foo/locations/us-central1/cachedContents/123'\n * ```\n *\n * ```\n * resource_name = '123'\n * resource_prefix = 'cachedContents'\n * splits_after_prefix = 1\n * client.vertexai = False\n * _resource_name(client, resource_name, resource_prefix, splits_after_prefix)\n * returns 'cachedContents/123'\n * ```\n *\n * ```\n * resource_name = 'some/wrong/cachedContents/resource/name/123'\n * resource_prefix = 'cachedContents'\n * splits_after_prefix = 1\n * client.vertexai = False\n * # client.vertexai = True\n * _resource_name(client, resource_name, resource_prefix, splits_after_prefix)\n * -> 'some/wrong/resource/name/123'\n * ```\n */ function resourceName(client, resourceName, resourcePrefix, splitsAfterPrefix = 1) {\n    const shouldAppendPrefix = !resourceName.startsWith(`${resourcePrefix}/`) && resourceName.split(\"/\").length === splitsAfterPrefix;\n    if (client.isVertexAI()) {\n        if (resourceName.startsWith(\"projects/\")) {\n            return resourceName;\n        } else if (resourceName.startsWith(\"locations/\")) {\n            return `projects/${client.getProject()}/${resourceName}`;\n        } else if (resourceName.startsWith(`${resourcePrefix}/`)) {\n            return `projects/${client.getProject()}/locations/${client.getLocation()}/${resourceName}`;\n        } else if (shouldAppendPrefix) {\n            return `projects/${client.getProject()}/locations/${client.getLocation()}/${resourcePrefix}/${resourceName}`;\n        } else {\n            return resourceName;\n        }\n    }\n    if (shouldAppendPrefix) {\n        return `${resourcePrefix}/${resourceName}`;\n    }\n    return resourceName;\n}\nfunction tCachedContentName(apiClient, name) {\n    if (typeof name !== \"string\") {\n        throw new Error(\"name must be a string\");\n    }\n    return resourceName(apiClient, name, \"cachedContents\");\n}\nfunction tTuningJobStatus(status) {\n    switch(status){\n        case \"STATE_UNSPECIFIED\":\n            return \"JOB_STATE_UNSPECIFIED\";\n        case \"CREATING\":\n            return \"JOB_STATE_RUNNING\";\n        case \"ACTIVE\":\n            return \"JOB_STATE_SUCCEEDED\";\n        case \"FAILED\":\n            return \"JOB_STATE_FAILED\";\n        default:\n            return status;\n    }\n}\nfunction tBytes(fromImageBytes) {\n    if (typeof fromImageBytes !== \"string\") {\n        throw new Error(\"fromImageBytes must be a string\");\n    }\n    // TODO(b/389133914): Remove dummy bytes converter.\n    return fromImageBytes;\n}\nfunction _isFile(origin) {\n    return origin !== null && origin !== undefined && typeof origin === \"object\" && \"name\" in origin;\n}\nfunction isGeneratedVideo(origin) {\n    return origin !== null && origin !== undefined && typeof origin === \"object\" && \"video\" in origin;\n}\nfunction isVideo(origin) {\n    return origin !== null && origin !== undefined && typeof origin === \"object\" && \"uri\" in origin;\n}\nfunction tFileName(fromName) {\n    var _a;\n    let name;\n    if (_isFile(fromName)) {\n        name = fromName.name;\n    }\n    if (isVideo(fromName)) {\n        name = fromName.uri;\n        if (name === undefined) {\n            return undefined;\n        }\n    }\n    if (isGeneratedVideo(fromName)) {\n        name = (_a = fromName.video) === null || _a === void 0 ? void 0 : _a.uri;\n        if (name === undefined) {\n            return undefined;\n        }\n    }\n    if (typeof fromName === \"string\") {\n        name = fromName;\n    }\n    if (name === undefined) {\n        throw new Error(\"Could not extract file name from the provided input.\");\n    }\n    if (name.startsWith(\"https://\")) {\n        const suffix = name.split(\"files/\")[1];\n        const match = suffix.match(/[a-z0-9]+/);\n        if (match === null) {\n            throw new Error(`Could not extract file name from URI ${name}`);\n        }\n        name = match[0];\n    } else if (name.startsWith(\"files/\")) {\n        name = name.split(\"files/\")[1];\n    }\n    return name;\n}\nfunction tModelsUrl(apiClient, baseModels) {\n    let res;\n    if (apiClient.isVertexAI()) {\n        res = baseModels ? \"publishers/google/models\" : \"models\";\n    } else {\n        res = baseModels ? \"models\" : \"tunedModels\";\n    }\n    return res;\n}\nfunction tExtractModels(response) {\n    for (const key of [\n        \"models\",\n        \"tunedModels\",\n        \"publisherModels\"\n    ]){\n        if (hasField(response, key)) {\n            return response[key];\n        }\n    }\n    return [];\n}\nfunction hasField(data, fieldName) {\n    return data !== null && typeof data === \"object\" && fieldName in data;\n}\nfunction mcpToGeminiTool(mcpTool, config = {}) {\n    const mcpToolSchema = mcpTool;\n    const functionDeclaration = {\n        name: mcpToolSchema[\"name\"],\n        description: mcpToolSchema[\"description\"],\n        parameters: processJsonSchema(filterToJsonSchema(mcpToolSchema[\"inputSchema\"]))\n    };\n    if (config.behavior) {\n        functionDeclaration[\"behavior\"] = config.behavior;\n    }\n    const geminiTool = {\n        functionDeclarations: [\n            functionDeclaration\n        ]\n    };\n    return geminiTool;\n}\n/**\n * Converts a list of MCP tools to a single Gemini tool with a list of function\n * declarations.\n */ function mcpToolsToGeminiTool(mcpTools, config = {}) {\n    const functionDeclarations = [];\n    const toolNames = new Set();\n    for (const mcpTool of mcpTools){\n        const mcpToolName = mcpTool.name;\n        if (toolNames.has(mcpToolName)) {\n            throw new Error(`Duplicate function name ${mcpToolName} found in MCP tools. Please ensure function names are unique.`);\n        }\n        toolNames.add(mcpToolName);\n        const geminiTool = mcpToGeminiTool(mcpTool, config);\n        if (geminiTool.functionDeclarations) {\n            functionDeclarations.push(...geminiTool.functionDeclarations);\n        }\n    }\n    return {\n        functionDeclarations: functionDeclarations\n    };\n}\n// Filters the list schema field to only include fields that are supported by\n// JSONSchema.\nfunction filterListSchemaField(fieldValue) {\n    const listSchemaFieldValue = [];\n    for (const listFieldValue of fieldValue){\n        listSchemaFieldValue.push(filterToJsonSchema(listFieldValue));\n    }\n    return listSchemaFieldValue;\n}\n// Filters the dict schema field to only include fields that are supported by\n// JSONSchema.\nfunction filterDictSchemaField(fieldValue) {\n    const dictSchemaFieldValue = {};\n    for (const [key, value] of Object.entries(fieldValue)){\n        const valueRecord = value;\n        dictSchemaFieldValue[key] = filterToJsonSchema(valueRecord);\n    }\n    return dictSchemaFieldValue;\n}\n// Filters the schema to only include fields that are supported by JSONSchema.\nfunction filterToJsonSchema(schema) {\n    const schemaFieldNames = new Set([\n        \"items\"\n    ]); // 'additional_properties' to come\n    const listSchemaFieldNames = new Set([\n        \"anyOf\"\n    ]); // 'one_of', 'all_of', 'not' to come\n    const dictSchemaFieldNames = new Set([\n        \"properties\"\n    ]); // 'defs' to come\n    const filteredSchema = {};\n    for (const [fieldName, fieldValue] of Object.entries(schema)){\n        if (schemaFieldNames.has(fieldName)) {\n            filteredSchema[fieldName] = filterToJsonSchema(fieldValue);\n        } else if (listSchemaFieldNames.has(fieldName)) {\n            filteredSchema[fieldName] = filterListSchemaField(fieldValue);\n        } else if (dictSchemaFieldNames.has(fieldName)) {\n            filteredSchema[fieldName] = filterDictSchemaField(fieldValue);\n        } else if (fieldName === \"type\") {\n            const typeValue = fieldValue.toUpperCase();\n            filteredSchema[fieldName] = Object.values(Type).includes(typeValue) ? typeValue : Type.TYPE_UNSPECIFIED;\n        } else if (supportedJsonSchemaFields.has(fieldName)) {\n            filteredSchema[fieldName] = fieldValue;\n        }\n    }\n    return filteredSchema;\n}\n// Transforms a source input into a BatchJobSource object with validation.\nfunction tBatchJobSource(apiClient, src) {\n    if (typeof src !== \"string\" && !Array.isArray(src)) {\n        if (apiClient && apiClient.isVertexAI()) {\n            if (src.gcsUri && src.bigqueryUri) {\n                throw new Error(\"Only one of `gcsUri` or `bigqueryUri` can be set.\");\n            } else if (!src.gcsUri && !src.bigqueryUri) {\n                throw new Error(\"One of `gcsUri` or `bigqueryUri` must be set.\");\n            }\n        } else {\n            // Logic for non-Vertex AI client (inlined_requests, file_name)\n            if (src.inlinedRequests && src.fileName) {\n                throw new Error(\"Only one of `inlinedRequests` or `fileName` can be set.\");\n            } else if (!src.inlinedRequests && !src.fileName) {\n                throw new Error(\"One of `inlinedRequests` or `fileName` must be set.\");\n            }\n        }\n        return src;\n    } else if (Array.isArray(src)) {\n        return {\n            inlinedRequests: src\n        };\n    } else if (typeof src === \"string\") {\n        if (src.startsWith(\"gs://\")) {\n            return {\n                format: \"jsonl\",\n                gcsUri: [\n                    src\n                ]\n            };\n        } else if (src.startsWith(\"bq://\")) {\n            return {\n                format: \"bigquery\",\n                bigqueryUri: src\n            };\n        } else if (src.startsWith(\"files/\")) {\n            return {\n                fileName: src\n            };\n        }\n    }\n    throw new Error(`Unsupported source: ${src}`);\n}\nfunction tBatchJobDestination(dest) {\n    const destString = dest;\n    if (destString.startsWith(\"gs://\")) {\n        return {\n            format: \"jsonl\",\n            gcsUri: destString\n        };\n    } else if (destString.startsWith(\"bq://\")) {\n        return {\n            format: \"bigquery\",\n            bigqueryUri: destString\n        };\n    } else {\n        throw new Error(`Unsupported destination: ${destString}`);\n    }\n}\nfunction tBatchJobName(apiClient, name) {\n    const nameString = name;\n    if (!apiClient.isVertexAI()) {\n        const mldevPattern = /batches\\/[^/]+$/;\n        if (mldevPattern.test(nameString)) {\n            return nameString.split(\"/\").pop();\n        } else {\n            throw new Error(`Invalid batch job name: ${nameString}.`);\n        }\n    }\n    const vertexPattern = /^projects\\/[^/]+\\/locations\\/[^/]+\\/batchPredictionJobs\\/[^/]+$/;\n    if (vertexPattern.test(nameString)) {\n        return nameString.split(\"/\").pop();\n    } else if (/^\\d+$/.test(nameString)) {\n        return nameString;\n    } else {\n        throw new Error(`Invalid batch job name: ${nameString}.`);\n    }\n}\nfunction tJobState(state) {\n    const stateString = state;\n    if (stateString === \"BATCH_STATE_UNSPECIFIED\") {\n        return \"JOB_STATE_UNSPECIFIED\";\n    } else if (stateString === \"BATCH_STATE_PENDING\") {\n        return \"JOB_STATE_PENDING\";\n    } else if (stateString === \"BATCH_STATE_SUCCEEDED\") {\n        return \"JOB_STATE_SUCCEEDED\";\n    } else if (stateString === \"BATCH_STATE_FAILED\") {\n        return \"JOB_STATE_FAILED\";\n    } else if (stateString === \"BATCH_STATE_CANCELLED\") {\n        return \"JOB_STATE_CANCELLED\";\n    } else {\n        return stateString;\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ function videoMetadataToMldev$4(fromObject) {\n    const toObject = {};\n    const fromFps = getValueByPath(fromObject, [\n        \"fps\"\n    ]);\n    if (fromFps != null) {\n        setValueByPath(toObject, [\n            \"fps\"\n        ], fromFps);\n    }\n    const fromEndOffset = getValueByPath(fromObject, [\n        \"endOffset\"\n    ]);\n    if (fromEndOffset != null) {\n        setValueByPath(toObject, [\n            \"endOffset\"\n        ], fromEndOffset);\n    }\n    const fromStartOffset = getValueByPath(fromObject, [\n        \"startOffset\"\n    ]);\n    if (fromStartOffset != null) {\n        setValueByPath(toObject, [\n            \"startOffset\"\n        ], fromStartOffset);\n    }\n    return toObject;\n}\nfunction blobToMldev$4(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"displayName\"\n    ]) !== undefined) {\n        throw new Error(\"displayName parameter is not supported in Gemini API.\");\n    }\n    const fromData = getValueByPath(fromObject, [\n        \"data\"\n    ]);\n    if (fromData != null) {\n        setValueByPath(toObject, [\n            \"data\"\n        ], fromData);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction fileDataToMldev$4(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"displayName\"\n    ]) !== undefined) {\n        throw new Error(\"displayName parameter is not supported in Gemini API.\");\n    }\n    const fromFileUri = getValueByPath(fromObject, [\n        \"fileUri\"\n    ]);\n    if (fromFileUri != null) {\n        setValueByPath(toObject, [\n            \"fileUri\"\n        ], fromFileUri);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction partToMldev$4(fromObject) {\n    const toObject = {};\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        \"videoMetadata\"\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, [\n            \"videoMetadata\"\n        ], videoMetadataToMldev$4(fromVideoMetadata));\n    }\n    const fromThought = getValueByPath(fromObject, [\n        \"thought\"\n    ]);\n    if (fromThought != null) {\n        setValueByPath(toObject, [\n            \"thought\"\n        ], fromThought);\n    }\n    const fromInlineData = getValueByPath(fromObject, [\n        \"inlineData\"\n    ]);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, [\n            \"inlineData\"\n        ], blobToMldev$4(fromInlineData));\n    }\n    const fromFileData = getValueByPath(fromObject, [\n        \"fileData\"\n    ]);\n    if (fromFileData != null) {\n        setValueByPath(toObject, [\n            \"fileData\"\n        ], fileDataToMldev$4(fromFileData));\n    }\n    const fromThoughtSignature = getValueByPath(fromObject, [\n        \"thoughtSignature\"\n    ]);\n    if (fromThoughtSignature != null) {\n        setValueByPath(toObject, [\n            \"thoughtSignature\"\n        ], fromThoughtSignature);\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        \"codeExecutionResult\"\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, [\n            \"codeExecutionResult\"\n        ], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        \"executableCode\"\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, [\n            \"executableCode\"\n        ], fromExecutableCode);\n    }\n    const fromFunctionCall = getValueByPath(fromObject, [\n        \"functionCall\"\n    ]);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, [\n            \"functionCall\"\n        ], fromFunctionCall);\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        \"functionResponse\"\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, [\n            \"functionResponse\"\n        ], fromFunctionResponse);\n    }\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    return toObject;\n}\nfunction contentToMldev$4(fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, [\n        \"parts\"\n    ]);\n    if (fromParts != null) {\n        let transformedList = fromParts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return partToMldev$4(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"parts\"\n        ], transformedList);\n    }\n    const fromRole = getValueByPath(fromObject, [\n        \"role\"\n    ]);\n    if (fromRole != null) {\n        setValueByPath(toObject, [\n            \"role\"\n        ], fromRole);\n    }\n    return toObject;\n}\nfunction schemaToMldev$1(fromObject) {\n    const toObject = {};\n    const fromAnyOf = getValueByPath(fromObject, [\n        \"anyOf\"\n    ]);\n    if (fromAnyOf != null) {\n        setValueByPath(toObject, [\n            \"anyOf\"\n        ], fromAnyOf);\n    }\n    const fromDefault = getValueByPath(fromObject, [\n        \"default\"\n    ]);\n    if (fromDefault != null) {\n        setValueByPath(toObject, [\n            \"default\"\n        ], fromDefault);\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (fromDescription != null) {\n        setValueByPath(toObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromEnum = getValueByPath(fromObject, [\n        \"enum\"\n    ]);\n    if (fromEnum != null) {\n        setValueByPath(toObject, [\n            \"enum\"\n        ], fromEnum);\n    }\n    const fromExample = getValueByPath(fromObject, [\n        \"example\"\n    ]);\n    if (fromExample != null) {\n        setValueByPath(toObject, [\n            \"example\"\n        ], fromExample);\n    }\n    const fromFormat = getValueByPath(fromObject, [\n        \"format\"\n    ]);\n    if (fromFormat != null) {\n        setValueByPath(toObject, [\n            \"format\"\n        ], fromFormat);\n    }\n    const fromItems = getValueByPath(fromObject, [\n        \"items\"\n    ]);\n    if (fromItems != null) {\n        setValueByPath(toObject, [\n            \"items\"\n        ], fromItems);\n    }\n    const fromMaxItems = getValueByPath(fromObject, [\n        \"maxItems\"\n    ]);\n    if (fromMaxItems != null) {\n        setValueByPath(toObject, [\n            \"maxItems\"\n        ], fromMaxItems);\n    }\n    const fromMaxLength = getValueByPath(fromObject, [\n        \"maxLength\"\n    ]);\n    if (fromMaxLength != null) {\n        setValueByPath(toObject, [\n            \"maxLength\"\n        ], fromMaxLength);\n    }\n    const fromMaxProperties = getValueByPath(fromObject, [\n        \"maxProperties\"\n    ]);\n    if (fromMaxProperties != null) {\n        setValueByPath(toObject, [\n            \"maxProperties\"\n        ], fromMaxProperties);\n    }\n    const fromMaximum = getValueByPath(fromObject, [\n        \"maximum\"\n    ]);\n    if (fromMaximum != null) {\n        setValueByPath(toObject, [\n            \"maximum\"\n        ], fromMaximum);\n    }\n    const fromMinItems = getValueByPath(fromObject, [\n        \"minItems\"\n    ]);\n    if (fromMinItems != null) {\n        setValueByPath(toObject, [\n            \"minItems\"\n        ], fromMinItems);\n    }\n    const fromMinLength = getValueByPath(fromObject, [\n        \"minLength\"\n    ]);\n    if (fromMinLength != null) {\n        setValueByPath(toObject, [\n            \"minLength\"\n        ], fromMinLength);\n    }\n    const fromMinProperties = getValueByPath(fromObject, [\n        \"minProperties\"\n    ]);\n    if (fromMinProperties != null) {\n        setValueByPath(toObject, [\n            \"minProperties\"\n        ], fromMinProperties);\n    }\n    const fromMinimum = getValueByPath(fromObject, [\n        \"minimum\"\n    ]);\n    if (fromMinimum != null) {\n        setValueByPath(toObject, [\n            \"minimum\"\n        ], fromMinimum);\n    }\n    const fromNullable = getValueByPath(fromObject, [\n        \"nullable\"\n    ]);\n    if (fromNullable != null) {\n        setValueByPath(toObject, [\n            \"nullable\"\n        ], fromNullable);\n    }\n    const fromPattern = getValueByPath(fromObject, [\n        \"pattern\"\n    ]);\n    if (fromPattern != null) {\n        setValueByPath(toObject, [\n            \"pattern\"\n        ], fromPattern);\n    }\n    const fromProperties = getValueByPath(fromObject, [\n        \"properties\"\n    ]);\n    if (fromProperties != null) {\n        setValueByPath(toObject, [\n            \"properties\"\n        ], fromProperties);\n    }\n    const fromPropertyOrdering = getValueByPath(fromObject, [\n        \"propertyOrdering\"\n    ]);\n    if (fromPropertyOrdering != null) {\n        setValueByPath(toObject, [\n            \"propertyOrdering\"\n        ], fromPropertyOrdering);\n    }\n    const fromRequired = getValueByPath(fromObject, [\n        \"required\"\n    ]);\n    if (fromRequired != null) {\n        setValueByPath(toObject, [\n            \"required\"\n        ], fromRequired);\n    }\n    const fromTitle = getValueByPath(fromObject, [\n        \"title\"\n    ]);\n    if (fromTitle != null) {\n        setValueByPath(toObject, [\n            \"title\"\n        ], fromTitle);\n    }\n    const fromType = getValueByPath(fromObject, [\n        \"type\"\n    ]);\n    if (fromType != null) {\n        setValueByPath(toObject, [\n            \"type\"\n        ], fromType);\n    }\n    return toObject;\n}\nfunction safetySettingToMldev$1(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"method\"\n    ]) !== undefined) {\n        throw new Error(\"method parameter is not supported in Gemini API.\");\n    }\n    const fromCategory = getValueByPath(fromObject, [\n        \"category\"\n    ]);\n    if (fromCategory != null) {\n        setValueByPath(toObject, [\n            \"category\"\n        ], fromCategory);\n    }\n    const fromThreshold = getValueByPath(fromObject, [\n        \"threshold\"\n    ]);\n    if (fromThreshold != null) {\n        setValueByPath(toObject, [\n            \"threshold\"\n        ], fromThreshold);\n    }\n    return toObject;\n}\nfunction functionDeclarationToMldev$4(fromObject) {\n    const toObject = {};\n    const fromBehavior = getValueByPath(fromObject, [\n        \"behavior\"\n    ]);\n    if (fromBehavior != null) {\n        setValueByPath(toObject, [\n            \"behavior\"\n        ], fromBehavior);\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (fromDescription != null) {\n        setValueByPath(toObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromParameters = getValueByPath(fromObject, [\n        \"parameters\"\n    ]);\n    if (fromParameters != null) {\n        setValueByPath(toObject, [\n            \"parameters\"\n        ], fromParameters);\n    }\n    const fromParametersJsonSchema = getValueByPath(fromObject, [\n        \"parametersJsonSchema\"\n    ]);\n    if (fromParametersJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"parametersJsonSchema\"\n        ], fromParametersJsonSchema);\n    }\n    const fromResponse = getValueByPath(fromObject, [\n        \"response\"\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, [\n            \"response\"\n        ], fromResponse);\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        \"responseJsonSchema\"\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"responseJsonSchema\"\n        ], fromResponseJsonSchema);\n    }\n    return toObject;\n}\nfunction intervalToMldev$4(fromObject) {\n    const toObject = {};\n    const fromStartTime = getValueByPath(fromObject, [\n        \"startTime\"\n    ]);\n    if (fromStartTime != null) {\n        setValueByPath(toObject, [\n            \"startTime\"\n        ], fromStartTime);\n    }\n    const fromEndTime = getValueByPath(fromObject, [\n        \"endTime\"\n    ]);\n    if (fromEndTime != null) {\n        setValueByPath(toObject, [\n            \"endTime\"\n        ], fromEndTime);\n    }\n    return toObject;\n}\nfunction googleSearchToMldev$4(fromObject) {\n    const toObject = {};\n    const fromTimeRangeFilter = getValueByPath(fromObject, [\n        \"timeRangeFilter\"\n    ]);\n    if (fromTimeRangeFilter != null) {\n        setValueByPath(toObject, [\n            \"timeRangeFilter\"\n        ], intervalToMldev$4(fromTimeRangeFilter));\n    }\n    return toObject;\n}\nfunction dynamicRetrievalConfigToMldev$4(fromObject) {\n    const toObject = {};\n    const fromMode = getValueByPath(fromObject, [\n        \"mode\"\n    ]);\n    if (fromMode != null) {\n        setValueByPath(toObject, [\n            \"mode\"\n        ], fromMode);\n    }\n    const fromDynamicThreshold = getValueByPath(fromObject, [\n        \"dynamicThreshold\"\n    ]);\n    if (fromDynamicThreshold != null) {\n        setValueByPath(toObject, [\n            \"dynamicThreshold\"\n        ], fromDynamicThreshold);\n    }\n    return toObject;\n}\nfunction googleSearchRetrievalToMldev$4(fromObject) {\n    const toObject = {};\n    const fromDynamicRetrievalConfig = getValueByPath(fromObject, [\n        \"dynamicRetrievalConfig\"\n    ]);\n    if (fromDynamicRetrievalConfig != null) {\n        setValueByPath(toObject, [\n            \"dynamicRetrievalConfig\"\n        ], dynamicRetrievalConfigToMldev$4(fromDynamicRetrievalConfig));\n    }\n    return toObject;\n}\nfunction urlContextToMldev$4() {\n    const toObject = {};\n    return toObject;\n}\nfunction toolToMldev$4(fromObject) {\n    const toObject = {};\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        \"functionDeclarations\"\n    ]);\n    if (fromFunctionDeclarations != null) {\n        let transformedList = fromFunctionDeclarations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return functionDeclarationToMldev$4(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"functionDeclarations\"\n        ], transformedList);\n    }\n    if (getValueByPath(fromObject, [\n        \"retrieval\"\n    ]) !== undefined) {\n        throw new Error(\"retrieval parameter is not supported in Gemini API.\");\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, [\n        \"googleSearch\"\n    ]);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, [\n            \"googleSearch\"\n        ], googleSearchToMldev$4(fromGoogleSearch));\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        \"googleSearchRetrieval\"\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, [\n            \"googleSearchRetrieval\"\n        ], googleSearchRetrievalToMldev$4(fromGoogleSearchRetrieval));\n    }\n    if (getValueByPath(fromObject, [\n        \"enterpriseWebSearch\"\n    ]) !== undefined) {\n        throw new Error(\"enterpriseWebSearch parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"googleMaps\"\n    ]) !== undefined) {\n        throw new Error(\"googleMaps parameter is not supported in Gemini API.\");\n    }\n    const fromUrlContext = getValueByPath(fromObject, [\n        \"urlContext\"\n    ]);\n    if (fromUrlContext != null) {\n        setValueByPath(toObject, [\n            \"urlContext\"\n        ], urlContextToMldev$4());\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        \"codeExecution\"\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, [\n            \"codeExecution\"\n        ], fromCodeExecution);\n    }\n    return toObject;\n}\nfunction functionCallingConfigToMldev$2(fromObject) {\n    const toObject = {};\n    const fromMode = getValueByPath(fromObject, [\n        \"mode\"\n    ]);\n    if (fromMode != null) {\n        setValueByPath(toObject, [\n            \"mode\"\n        ], fromMode);\n    }\n    const fromAllowedFunctionNames = getValueByPath(fromObject, [\n        \"allowedFunctionNames\"\n    ]);\n    if (fromAllowedFunctionNames != null) {\n        setValueByPath(toObject, [\n            \"allowedFunctionNames\"\n        ], fromAllowedFunctionNames);\n    }\n    return toObject;\n}\nfunction latLngToMldev$2(fromObject) {\n    const toObject = {};\n    const fromLatitude = getValueByPath(fromObject, [\n        \"latitude\"\n    ]);\n    if (fromLatitude != null) {\n        setValueByPath(toObject, [\n            \"latitude\"\n        ], fromLatitude);\n    }\n    const fromLongitude = getValueByPath(fromObject, [\n        \"longitude\"\n    ]);\n    if (fromLongitude != null) {\n        setValueByPath(toObject, [\n            \"longitude\"\n        ], fromLongitude);\n    }\n    return toObject;\n}\nfunction retrievalConfigToMldev$2(fromObject) {\n    const toObject = {};\n    const fromLatLng = getValueByPath(fromObject, [\n        \"latLng\"\n    ]);\n    if (fromLatLng != null) {\n        setValueByPath(toObject, [\n            \"latLng\"\n        ], latLngToMldev$2(fromLatLng));\n    }\n    const fromLanguageCode = getValueByPath(fromObject, [\n        \"languageCode\"\n    ]);\n    if (fromLanguageCode != null) {\n        setValueByPath(toObject, [\n            \"languageCode\"\n        ], fromLanguageCode);\n    }\n    return toObject;\n}\nfunction toolConfigToMldev$2(fromObject) {\n    const toObject = {};\n    const fromFunctionCallingConfig = getValueByPath(fromObject, [\n        \"functionCallingConfig\"\n    ]);\n    if (fromFunctionCallingConfig != null) {\n        setValueByPath(toObject, [\n            \"functionCallingConfig\"\n        ], functionCallingConfigToMldev$2(fromFunctionCallingConfig));\n    }\n    const fromRetrievalConfig = getValueByPath(fromObject, [\n        \"retrievalConfig\"\n    ]);\n    if (fromRetrievalConfig != null) {\n        setValueByPath(toObject, [\n            \"retrievalConfig\"\n        ], retrievalConfigToMldev$2(fromRetrievalConfig));\n    }\n    return toObject;\n}\nfunction prebuiltVoiceConfigToMldev$3(fromObject) {\n    const toObject = {};\n    const fromVoiceName = getValueByPath(fromObject, [\n        \"voiceName\"\n    ]);\n    if (fromVoiceName != null) {\n        setValueByPath(toObject, [\n            \"voiceName\"\n        ], fromVoiceName);\n    }\n    return toObject;\n}\nfunction voiceConfigToMldev$3(fromObject) {\n    const toObject = {};\n    const fromPrebuiltVoiceConfig = getValueByPath(fromObject, [\n        \"prebuiltVoiceConfig\"\n    ]);\n    if (fromPrebuiltVoiceConfig != null) {\n        setValueByPath(toObject, [\n            \"prebuiltVoiceConfig\"\n        ], prebuiltVoiceConfigToMldev$3(fromPrebuiltVoiceConfig));\n    }\n    return toObject;\n}\nfunction speakerVoiceConfigToMldev$3(fromObject) {\n    const toObject = {};\n    const fromSpeaker = getValueByPath(fromObject, [\n        \"speaker\"\n    ]);\n    if (fromSpeaker != null) {\n        setValueByPath(toObject, [\n            \"speaker\"\n        ], fromSpeaker);\n    }\n    const fromVoiceConfig = getValueByPath(fromObject, [\n        \"voiceConfig\"\n    ]);\n    if (fromVoiceConfig != null) {\n        setValueByPath(toObject, [\n            \"voiceConfig\"\n        ], voiceConfigToMldev$3(fromVoiceConfig));\n    }\n    return toObject;\n}\nfunction multiSpeakerVoiceConfigToMldev$3(fromObject) {\n    const toObject = {};\n    const fromSpeakerVoiceConfigs = getValueByPath(fromObject, [\n        \"speakerVoiceConfigs\"\n    ]);\n    if (fromSpeakerVoiceConfigs != null) {\n        let transformedList = fromSpeakerVoiceConfigs;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return speakerVoiceConfigToMldev$3(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"speakerVoiceConfigs\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction speechConfigToMldev$3(fromObject) {\n    const toObject = {};\n    const fromVoiceConfig = getValueByPath(fromObject, [\n        \"voiceConfig\"\n    ]);\n    if (fromVoiceConfig != null) {\n        setValueByPath(toObject, [\n            \"voiceConfig\"\n        ], voiceConfigToMldev$3(fromVoiceConfig));\n    }\n    const fromMultiSpeakerVoiceConfig = getValueByPath(fromObject, [\n        \"multiSpeakerVoiceConfig\"\n    ]);\n    if (fromMultiSpeakerVoiceConfig != null) {\n        setValueByPath(toObject, [\n            \"multiSpeakerVoiceConfig\"\n        ], multiSpeakerVoiceConfigToMldev$3(fromMultiSpeakerVoiceConfig));\n    }\n    const fromLanguageCode = getValueByPath(fromObject, [\n        \"languageCode\"\n    ]);\n    if (fromLanguageCode != null) {\n        setValueByPath(toObject, [\n            \"languageCode\"\n        ], fromLanguageCode);\n    }\n    return toObject;\n}\nfunction thinkingConfigToMldev$1(fromObject) {\n    const toObject = {};\n    const fromIncludeThoughts = getValueByPath(fromObject, [\n        \"includeThoughts\"\n    ]);\n    if (fromIncludeThoughts != null) {\n        setValueByPath(toObject, [\n            \"includeThoughts\"\n        ], fromIncludeThoughts);\n    }\n    const fromThinkingBudget = getValueByPath(fromObject, [\n        \"thinkingBudget\"\n    ]);\n    if (fromThinkingBudget != null) {\n        setValueByPath(toObject, [\n            \"thinkingBudget\"\n        ], fromThinkingBudget);\n    }\n    return toObject;\n}\nfunction generateContentConfigToMldev$1(apiClient, fromObject, parentObject) {\n    const toObject = {};\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        \"systemInstruction\"\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, [\n            \"systemInstruction\"\n        ], contentToMldev$4(tContent(fromSystemInstruction)));\n    }\n    const fromTemperature = getValueByPath(fromObject, [\n        \"temperature\"\n    ]);\n    if (fromTemperature != null) {\n        setValueByPath(toObject, [\n            \"temperature\"\n        ], fromTemperature);\n    }\n    const fromTopP = getValueByPath(fromObject, [\n        \"topP\"\n    ]);\n    if (fromTopP != null) {\n        setValueByPath(toObject, [\n            \"topP\"\n        ], fromTopP);\n    }\n    const fromTopK = getValueByPath(fromObject, [\n        \"topK\"\n    ]);\n    if (fromTopK != null) {\n        setValueByPath(toObject, [\n            \"topK\"\n        ], fromTopK);\n    }\n    const fromCandidateCount = getValueByPath(fromObject, [\n        \"candidateCount\"\n    ]);\n    if (fromCandidateCount != null) {\n        setValueByPath(toObject, [\n            \"candidateCount\"\n        ], fromCandidateCount);\n    }\n    const fromMaxOutputTokens = getValueByPath(fromObject, [\n        \"maxOutputTokens\"\n    ]);\n    if (fromMaxOutputTokens != null) {\n        setValueByPath(toObject, [\n            \"maxOutputTokens\"\n        ], fromMaxOutputTokens);\n    }\n    const fromStopSequences = getValueByPath(fromObject, [\n        \"stopSequences\"\n    ]);\n    if (fromStopSequences != null) {\n        setValueByPath(toObject, [\n            \"stopSequences\"\n        ], fromStopSequences);\n    }\n    const fromResponseLogprobs = getValueByPath(fromObject, [\n        \"responseLogprobs\"\n    ]);\n    if (fromResponseLogprobs != null) {\n        setValueByPath(toObject, [\n            \"responseLogprobs\"\n        ], fromResponseLogprobs);\n    }\n    const fromLogprobs = getValueByPath(fromObject, [\n        \"logprobs\"\n    ]);\n    if (fromLogprobs != null) {\n        setValueByPath(toObject, [\n            \"logprobs\"\n        ], fromLogprobs);\n    }\n    const fromPresencePenalty = getValueByPath(fromObject, [\n        \"presencePenalty\"\n    ]);\n    if (fromPresencePenalty != null) {\n        setValueByPath(toObject, [\n            \"presencePenalty\"\n        ], fromPresencePenalty);\n    }\n    const fromFrequencyPenalty = getValueByPath(fromObject, [\n        \"frequencyPenalty\"\n    ]);\n    if (fromFrequencyPenalty != null) {\n        setValueByPath(toObject, [\n            \"frequencyPenalty\"\n        ], fromFrequencyPenalty);\n    }\n    const fromSeed = getValueByPath(fromObject, [\n        \"seed\"\n    ]);\n    if (fromSeed != null) {\n        setValueByPath(toObject, [\n            \"seed\"\n        ], fromSeed);\n    }\n    const fromResponseMimeType = getValueByPath(fromObject, [\n        \"responseMimeType\"\n    ]);\n    if (fromResponseMimeType != null) {\n        setValueByPath(toObject, [\n            \"responseMimeType\"\n        ], fromResponseMimeType);\n    }\n    const fromResponseSchema = getValueByPath(fromObject, [\n        \"responseSchema\"\n    ]);\n    if (fromResponseSchema != null) {\n        setValueByPath(toObject, [\n            \"responseSchema\"\n        ], schemaToMldev$1(tSchema(fromResponseSchema)));\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        \"responseJsonSchema\"\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"responseJsonSchema\"\n        ], fromResponseJsonSchema);\n    }\n    if (getValueByPath(fromObject, [\n        \"routingConfig\"\n    ]) !== undefined) {\n        throw new Error(\"routingConfig parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"modelSelectionConfig\"\n    ]) !== undefined) {\n        throw new Error(\"modelSelectionConfig parameter is not supported in Gemini API.\");\n    }\n    const fromSafetySettings = getValueByPath(fromObject, [\n        \"safetySettings\"\n    ]);\n    if (parentObject !== undefined && fromSafetySettings != null) {\n        let transformedList = fromSafetySettings;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return safetySettingToMldev$1(item);\n            });\n        }\n        setValueByPath(parentObject, [\n            \"safetySettings\"\n        ], transformedList);\n    }\n    const fromTools = getValueByPath(fromObject, [\n        \"tools\"\n    ]);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = tTools(fromTools);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return toolToMldev$4(tTool(item));\n            });\n        }\n        setValueByPath(parentObject, [\n            \"tools\"\n        ], transformedList);\n    }\n    const fromToolConfig = getValueByPath(fromObject, [\n        \"toolConfig\"\n    ]);\n    if (parentObject !== undefined && fromToolConfig != null) {\n        setValueByPath(parentObject, [\n            \"toolConfig\"\n        ], toolConfigToMldev$2(fromToolConfig));\n    }\n    if (getValueByPath(fromObject, [\n        \"labels\"\n    ]) !== undefined) {\n        throw new Error(\"labels parameter is not supported in Gemini API.\");\n    }\n    const fromCachedContent = getValueByPath(fromObject, [\n        \"cachedContent\"\n    ]);\n    if (parentObject !== undefined && fromCachedContent != null) {\n        setValueByPath(parentObject, [\n            \"cachedContent\"\n        ], tCachedContentName(apiClient, fromCachedContent));\n    }\n    const fromResponseModalities = getValueByPath(fromObject, [\n        \"responseModalities\"\n    ]);\n    if (fromResponseModalities != null) {\n        setValueByPath(toObject, [\n            \"responseModalities\"\n        ], fromResponseModalities);\n    }\n    const fromMediaResolution = getValueByPath(fromObject, [\n        \"mediaResolution\"\n    ]);\n    if (fromMediaResolution != null) {\n        setValueByPath(toObject, [\n            \"mediaResolution\"\n        ], fromMediaResolution);\n    }\n    const fromSpeechConfig = getValueByPath(fromObject, [\n        \"speechConfig\"\n    ]);\n    if (fromSpeechConfig != null) {\n        setValueByPath(toObject, [\n            \"speechConfig\"\n        ], speechConfigToMldev$3(tSpeechConfig(fromSpeechConfig)));\n    }\n    if (getValueByPath(fromObject, [\n        \"audioTimestamp\"\n    ]) !== undefined) {\n        throw new Error(\"audioTimestamp parameter is not supported in Gemini API.\");\n    }\n    const fromThinkingConfig = getValueByPath(fromObject, [\n        \"thinkingConfig\"\n    ]);\n    if (fromThinkingConfig != null) {\n        setValueByPath(toObject, [\n            \"thinkingConfig\"\n        ], thinkingConfigToMldev$1(fromThinkingConfig));\n    }\n    return toObject;\n}\nfunction inlinedRequestToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"request\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, [\n        \"contents\"\n    ]);\n    if (fromContents != null) {\n        let transformedList = tContents(fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return contentToMldev$4(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"request\",\n            \"contents\"\n        ], transformedList);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"request\",\n            \"generationConfig\"\n        ], generateContentConfigToMldev$1(apiClient, fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction batchJobSourceToMldev(apiClient, fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"format\"\n    ]) !== undefined) {\n        throw new Error(\"format parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"gcsUri\"\n    ]) !== undefined) {\n        throw new Error(\"gcsUri parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"bigqueryUri\"\n    ]) !== undefined) {\n        throw new Error(\"bigqueryUri parameter is not supported in Gemini API.\");\n    }\n    const fromFileName = getValueByPath(fromObject, [\n        \"fileName\"\n    ]);\n    if (fromFileName != null) {\n        setValueByPath(toObject, [\n            \"fileName\"\n        ], fromFileName);\n    }\n    const fromInlinedRequests = getValueByPath(fromObject, [\n        \"inlinedRequests\"\n    ]);\n    if (fromInlinedRequests != null) {\n        let transformedList = fromInlinedRequests;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return inlinedRequestToMldev(apiClient, item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"requests\",\n            \"requests\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction createBatchJobConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (parentObject !== undefined && fromDisplayName != null) {\n        setValueByPath(parentObject, [\n            \"batch\",\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    if (getValueByPath(fromObject, [\n        \"dest\"\n    ]) !== undefined) {\n        throw new Error(\"dest parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction createBatchJobParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromSrc = getValueByPath(fromObject, [\n        \"src\"\n    ]);\n    if (fromSrc != null) {\n        setValueByPath(toObject, [\n            \"batch\",\n            \"inputConfig\"\n        ], batchJobSourceToMldev(apiClient, tBatchJobSource(apiClient, fromSrc)));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], createBatchJobConfigToMldev(fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction getBatchJobParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tBatchJobName(apiClient, fromName));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], fromConfig);\n    }\n    return toObject;\n}\nfunction cancelBatchJobParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tBatchJobName(apiClient, fromName));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], fromConfig);\n    }\n    return toObject;\n}\nfunction listBatchJobsConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, [\n        \"pageSize\"\n    ]);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageSize\"\n        ], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, [\n        \"pageToken\"\n    ]);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageToken\"\n        ], fromPageToken);\n    }\n    if (getValueByPath(fromObject, [\n        \"filter\"\n    ]) !== undefined) {\n        throw new Error(\"filter parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction listBatchJobsParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], listBatchJobsConfigToMldev(fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction batchJobSourceToVertex(fromObject) {\n    const toObject = {};\n    const fromFormat = getValueByPath(fromObject, [\n        \"format\"\n    ]);\n    if (fromFormat != null) {\n        setValueByPath(toObject, [\n            \"instancesFormat\"\n        ], fromFormat);\n    }\n    const fromGcsUri = getValueByPath(fromObject, [\n        \"gcsUri\"\n    ]);\n    if (fromGcsUri != null) {\n        setValueByPath(toObject, [\n            \"gcsSource\",\n            \"uris\"\n        ], fromGcsUri);\n    }\n    const fromBigqueryUri = getValueByPath(fromObject, [\n        \"bigqueryUri\"\n    ]);\n    if (fromBigqueryUri != null) {\n        setValueByPath(toObject, [\n            \"bigquerySource\",\n            \"inputUri\"\n        ], fromBigqueryUri);\n    }\n    if (getValueByPath(fromObject, [\n        \"fileName\"\n    ]) !== undefined) {\n        throw new Error(\"fileName parameter is not supported in Vertex AI.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"inlinedRequests\"\n    ]) !== undefined) {\n        throw new Error(\"inlinedRequests parameter is not supported in Vertex AI.\");\n    }\n    return toObject;\n}\nfunction batchJobDestinationToVertex(fromObject) {\n    const toObject = {};\n    const fromFormat = getValueByPath(fromObject, [\n        \"format\"\n    ]);\n    if (fromFormat != null) {\n        setValueByPath(toObject, [\n            \"predictionsFormat\"\n        ], fromFormat);\n    }\n    const fromGcsUri = getValueByPath(fromObject, [\n        \"gcsUri\"\n    ]);\n    if (fromGcsUri != null) {\n        setValueByPath(toObject, [\n            \"gcsDestination\",\n            \"outputUriPrefix\"\n        ], fromGcsUri);\n    }\n    const fromBigqueryUri = getValueByPath(fromObject, [\n        \"bigqueryUri\"\n    ]);\n    if (fromBigqueryUri != null) {\n        setValueByPath(toObject, [\n            \"bigqueryDestination\",\n            \"outputUri\"\n        ], fromBigqueryUri);\n    }\n    if (getValueByPath(fromObject, [\n        \"fileName\"\n    ]) !== undefined) {\n        throw new Error(\"fileName parameter is not supported in Vertex AI.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"inlinedResponses\"\n    ]) !== undefined) {\n        throw new Error(\"inlinedResponses parameter is not supported in Vertex AI.\");\n    }\n    return toObject;\n}\nfunction createBatchJobConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (parentObject !== undefined && fromDisplayName != null) {\n        setValueByPath(parentObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromDest = getValueByPath(fromObject, [\n        \"dest\"\n    ]);\n    if (parentObject !== undefined && fromDest != null) {\n        setValueByPath(parentObject, [\n            \"outputConfig\"\n        ], batchJobDestinationToVertex(tBatchJobDestination(fromDest)));\n    }\n    return toObject;\n}\nfunction createBatchJobParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromSrc = getValueByPath(fromObject, [\n        \"src\"\n    ]);\n    if (fromSrc != null) {\n        setValueByPath(toObject, [\n            \"inputConfig\"\n        ], batchJobSourceToVertex(tBatchJobSource(apiClient, fromSrc)));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], createBatchJobConfigToVertex(fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction getBatchJobParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tBatchJobName(apiClient, fromName));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], fromConfig);\n    }\n    return toObject;\n}\nfunction cancelBatchJobParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tBatchJobName(apiClient, fromName));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], fromConfig);\n    }\n    return toObject;\n}\nfunction listBatchJobsConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, [\n        \"pageSize\"\n    ]);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageSize\"\n        ], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, [\n        \"pageToken\"\n    ]);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageToken\"\n        ], fromPageToken);\n    }\n    const fromFilter = getValueByPath(fromObject, [\n        \"filter\"\n    ]);\n    if (parentObject !== undefined && fromFilter != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"filter\"\n        ], fromFilter);\n    }\n    return toObject;\n}\nfunction listBatchJobsParametersToVertex(fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], listBatchJobsConfigToVertex(fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction jobErrorFromMldev() {\n    const toObject = {};\n    return toObject;\n}\nfunction videoMetadataFromMldev$2(fromObject) {\n    const toObject = {};\n    const fromFps = getValueByPath(fromObject, [\n        \"fps\"\n    ]);\n    if (fromFps != null) {\n        setValueByPath(toObject, [\n            \"fps\"\n        ], fromFps);\n    }\n    const fromEndOffset = getValueByPath(fromObject, [\n        \"endOffset\"\n    ]);\n    if (fromEndOffset != null) {\n        setValueByPath(toObject, [\n            \"endOffset\"\n        ], fromEndOffset);\n    }\n    const fromStartOffset = getValueByPath(fromObject, [\n        \"startOffset\"\n    ]);\n    if (fromStartOffset != null) {\n        setValueByPath(toObject, [\n            \"startOffset\"\n        ], fromStartOffset);\n    }\n    return toObject;\n}\nfunction blobFromMldev$2(fromObject) {\n    const toObject = {};\n    const fromData = getValueByPath(fromObject, [\n        \"data\"\n    ]);\n    if (fromData != null) {\n        setValueByPath(toObject, [\n            \"data\"\n        ], fromData);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction fileDataFromMldev$2(fromObject) {\n    const toObject = {};\n    const fromFileUri = getValueByPath(fromObject, [\n        \"fileUri\"\n    ]);\n    if (fromFileUri != null) {\n        setValueByPath(toObject, [\n            \"fileUri\"\n        ], fromFileUri);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction partFromMldev$2(fromObject) {\n    const toObject = {};\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        \"videoMetadata\"\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, [\n            \"videoMetadata\"\n        ], videoMetadataFromMldev$2(fromVideoMetadata));\n    }\n    const fromThought = getValueByPath(fromObject, [\n        \"thought\"\n    ]);\n    if (fromThought != null) {\n        setValueByPath(toObject, [\n            \"thought\"\n        ], fromThought);\n    }\n    const fromInlineData = getValueByPath(fromObject, [\n        \"inlineData\"\n    ]);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, [\n            \"inlineData\"\n        ], blobFromMldev$2(fromInlineData));\n    }\n    const fromFileData = getValueByPath(fromObject, [\n        \"fileData\"\n    ]);\n    if (fromFileData != null) {\n        setValueByPath(toObject, [\n            \"fileData\"\n        ], fileDataFromMldev$2(fromFileData));\n    }\n    const fromThoughtSignature = getValueByPath(fromObject, [\n        \"thoughtSignature\"\n    ]);\n    if (fromThoughtSignature != null) {\n        setValueByPath(toObject, [\n            \"thoughtSignature\"\n        ], fromThoughtSignature);\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        \"codeExecutionResult\"\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, [\n            \"codeExecutionResult\"\n        ], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        \"executableCode\"\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, [\n            \"executableCode\"\n        ], fromExecutableCode);\n    }\n    const fromFunctionCall = getValueByPath(fromObject, [\n        \"functionCall\"\n    ]);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, [\n            \"functionCall\"\n        ], fromFunctionCall);\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        \"functionResponse\"\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, [\n            \"functionResponse\"\n        ], fromFunctionResponse);\n    }\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    return toObject;\n}\nfunction contentFromMldev$2(fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, [\n        \"parts\"\n    ]);\n    if (fromParts != null) {\n        let transformedList = fromParts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return partFromMldev$2(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"parts\"\n        ], transformedList);\n    }\n    const fromRole = getValueByPath(fromObject, [\n        \"role\"\n    ]);\n    if (fromRole != null) {\n        setValueByPath(toObject, [\n            \"role\"\n        ], fromRole);\n    }\n    return toObject;\n}\nfunction citationMetadataFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromCitations = getValueByPath(fromObject, [\n        \"citationSources\"\n    ]);\n    if (fromCitations != null) {\n        setValueByPath(toObject, [\n            \"citations\"\n        ], fromCitations);\n    }\n    return toObject;\n}\nfunction urlMetadataFromMldev$2(fromObject) {\n    const toObject = {};\n    const fromRetrievedUrl = getValueByPath(fromObject, [\n        \"retrievedUrl\"\n    ]);\n    if (fromRetrievedUrl != null) {\n        setValueByPath(toObject, [\n            \"retrievedUrl\"\n        ], fromRetrievedUrl);\n    }\n    const fromUrlRetrievalStatus = getValueByPath(fromObject, [\n        \"urlRetrievalStatus\"\n    ]);\n    if (fromUrlRetrievalStatus != null) {\n        setValueByPath(toObject, [\n            \"urlRetrievalStatus\"\n        ], fromUrlRetrievalStatus);\n    }\n    return toObject;\n}\nfunction urlContextMetadataFromMldev$2(fromObject) {\n    const toObject = {};\n    const fromUrlMetadata = getValueByPath(fromObject, [\n        \"urlMetadata\"\n    ]);\n    if (fromUrlMetadata != null) {\n        let transformedList = fromUrlMetadata;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return urlMetadataFromMldev$2(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"urlMetadata\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction candidateFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromContent = getValueByPath(fromObject, [\n        \"content\"\n    ]);\n    if (fromContent != null) {\n        setValueByPath(toObject, [\n            \"content\"\n        ], contentFromMldev$2(fromContent));\n    }\n    const fromCitationMetadata = getValueByPath(fromObject, [\n        \"citationMetadata\"\n    ]);\n    if (fromCitationMetadata != null) {\n        setValueByPath(toObject, [\n            \"citationMetadata\"\n        ], citationMetadataFromMldev$1(fromCitationMetadata));\n    }\n    const fromTokenCount = getValueByPath(fromObject, [\n        \"tokenCount\"\n    ]);\n    if (fromTokenCount != null) {\n        setValueByPath(toObject, [\n            \"tokenCount\"\n        ], fromTokenCount);\n    }\n    const fromFinishReason = getValueByPath(fromObject, [\n        \"finishReason\"\n    ]);\n    if (fromFinishReason != null) {\n        setValueByPath(toObject, [\n            \"finishReason\"\n        ], fromFinishReason);\n    }\n    const fromUrlContextMetadata = getValueByPath(fromObject, [\n        \"urlContextMetadata\"\n    ]);\n    if (fromUrlContextMetadata != null) {\n        setValueByPath(toObject, [\n            \"urlContextMetadata\"\n        ], urlContextMetadataFromMldev$2(fromUrlContextMetadata));\n    }\n    const fromAvgLogprobs = getValueByPath(fromObject, [\n        \"avgLogprobs\"\n    ]);\n    if (fromAvgLogprobs != null) {\n        setValueByPath(toObject, [\n            \"avgLogprobs\"\n        ], fromAvgLogprobs);\n    }\n    const fromGroundingMetadata = getValueByPath(fromObject, [\n        \"groundingMetadata\"\n    ]);\n    if (fromGroundingMetadata != null) {\n        setValueByPath(toObject, [\n            \"groundingMetadata\"\n        ], fromGroundingMetadata);\n    }\n    const fromIndex = getValueByPath(fromObject, [\n        \"index\"\n    ]);\n    if (fromIndex != null) {\n        setValueByPath(toObject, [\n            \"index\"\n        ], fromIndex);\n    }\n    const fromLogprobsResult = getValueByPath(fromObject, [\n        \"logprobsResult\"\n    ]);\n    if (fromLogprobsResult != null) {\n        setValueByPath(toObject, [\n            \"logprobsResult\"\n        ], fromLogprobsResult);\n    }\n    const fromSafetyRatings = getValueByPath(fromObject, [\n        \"safetyRatings\"\n    ]);\n    if (fromSafetyRatings != null) {\n        setValueByPath(toObject, [\n            \"safetyRatings\"\n        ], fromSafetyRatings);\n    }\n    return toObject;\n}\nfunction generateContentResponseFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromCandidates = getValueByPath(fromObject, [\n        \"candidates\"\n    ]);\n    if (fromCandidates != null) {\n        let transformedList = fromCandidates;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return candidateFromMldev$1(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"candidates\"\n        ], transformedList);\n    }\n    const fromModelVersion = getValueByPath(fromObject, [\n        \"modelVersion\"\n    ]);\n    if (fromModelVersion != null) {\n        setValueByPath(toObject, [\n            \"modelVersion\"\n        ], fromModelVersion);\n    }\n    const fromPromptFeedback = getValueByPath(fromObject, [\n        \"promptFeedback\"\n    ]);\n    if (fromPromptFeedback != null) {\n        setValueByPath(toObject, [\n            \"promptFeedback\"\n        ], fromPromptFeedback);\n    }\n    const fromUsageMetadata = getValueByPath(fromObject, [\n        \"usageMetadata\"\n    ]);\n    if (fromUsageMetadata != null) {\n        setValueByPath(toObject, [\n            \"usageMetadata\"\n        ], fromUsageMetadata);\n    }\n    return toObject;\n}\nfunction inlinedResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromResponse = getValueByPath(fromObject, [\n        \"response\"\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, [\n            \"response\"\n        ], generateContentResponseFromMldev$1(fromResponse));\n    }\n    const fromError = getValueByPath(fromObject, [\n        \"error\"\n    ]);\n    if (fromError != null) {\n        setValueByPath(toObject, [\n            \"error\"\n        ], jobErrorFromMldev());\n    }\n    return toObject;\n}\nfunction batchJobDestinationFromMldev(fromObject) {\n    const toObject = {};\n    const fromFileName = getValueByPath(fromObject, [\n        \"responsesFile\"\n    ]);\n    if (fromFileName != null) {\n        setValueByPath(toObject, [\n            \"fileName\"\n        ], fromFileName);\n    }\n    const fromInlinedResponses = getValueByPath(fromObject, [\n        \"inlinedResponses\",\n        \"inlinedResponses\"\n    ]);\n    if (fromInlinedResponses != null) {\n        let transformedList = fromInlinedResponses;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return inlinedResponseFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"inlinedResponses\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction batchJobFromMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"metadata\",\n        \"displayName\"\n    ]);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromState = getValueByPath(fromObject, [\n        \"metadata\",\n        \"state\"\n    ]);\n    if (fromState != null) {\n        setValueByPath(toObject, [\n            \"state\"\n        ], tJobState(fromState));\n    }\n    const fromCreateTime = getValueByPath(fromObject, [\n        \"metadata\",\n        \"createTime\"\n    ]);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, [\n            \"createTime\"\n        ], fromCreateTime);\n    }\n    const fromEndTime = getValueByPath(fromObject, [\n        \"metadata\",\n        \"endTime\"\n    ]);\n    if (fromEndTime != null) {\n        setValueByPath(toObject, [\n            \"endTime\"\n        ], fromEndTime);\n    }\n    const fromUpdateTime = getValueByPath(fromObject, [\n        \"metadata\",\n        \"updateTime\"\n    ]);\n    if (fromUpdateTime != null) {\n        setValueByPath(toObject, [\n            \"updateTime\"\n        ], fromUpdateTime);\n    }\n    const fromModel = getValueByPath(fromObject, [\n        \"metadata\",\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"model\"\n        ], fromModel);\n    }\n    const fromDest = getValueByPath(fromObject, [\n        \"metadata\",\n        \"output\"\n    ]);\n    if (fromDest != null) {\n        setValueByPath(toObject, [\n            \"dest\"\n        ], batchJobDestinationFromMldev(fromDest));\n    }\n    return toObject;\n}\nfunction listBatchJobsResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromNextPageToken = getValueByPath(fromObject, [\n        \"nextPageToken\"\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, [\n            \"nextPageToken\"\n        ], fromNextPageToken);\n    }\n    const fromBatchJobs = getValueByPath(fromObject, [\n        \"operations\"\n    ]);\n    if (fromBatchJobs != null) {\n        let transformedList = fromBatchJobs;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return batchJobFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"batchJobs\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction jobErrorFromVertex(fromObject) {\n    const toObject = {};\n    const fromDetails = getValueByPath(fromObject, [\n        \"details\"\n    ]);\n    if (fromDetails != null) {\n        setValueByPath(toObject, [\n            \"details\"\n        ], fromDetails);\n    }\n    const fromCode = getValueByPath(fromObject, [\n        \"code\"\n    ]);\n    if (fromCode != null) {\n        setValueByPath(toObject, [\n            \"code\"\n        ], fromCode);\n    }\n    const fromMessage = getValueByPath(fromObject, [\n        \"message\"\n    ]);\n    if (fromMessage != null) {\n        setValueByPath(toObject, [\n            \"message\"\n        ], fromMessage);\n    }\n    return toObject;\n}\nfunction batchJobSourceFromVertex(fromObject) {\n    const toObject = {};\n    const fromFormat = getValueByPath(fromObject, [\n        \"instancesFormat\"\n    ]);\n    if (fromFormat != null) {\n        setValueByPath(toObject, [\n            \"format\"\n        ], fromFormat);\n    }\n    const fromGcsUri = getValueByPath(fromObject, [\n        \"gcsSource\",\n        \"uris\"\n    ]);\n    if (fromGcsUri != null) {\n        setValueByPath(toObject, [\n            \"gcsUri\"\n        ], fromGcsUri);\n    }\n    const fromBigqueryUri = getValueByPath(fromObject, [\n        \"bigquerySource\",\n        \"inputUri\"\n    ]);\n    if (fromBigqueryUri != null) {\n        setValueByPath(toObject, [\n            \"bigqueryUri\"\n        ], fromBigqueryUri);\n    }\n    return toObject;\n}\nfunction batchJobDestinationFromVertex(fromObject) {\n    const toObject = {};\n    const fromFormat = getValueByPath(fromObject, [\n        \"predictionsFormat\"\n    ]);\n    if (fromFormat != null) {\n        setValueByPath(toObject, [\n            \"format\"\n        ], fromFormat);\n    }\n    const fromGcsUri = getValueByPath(fromObject, [\n        \"gcsDestination\",\n        \"outputUriPrefix\"\n    ]);\n    if (fromGcsUri != null) {\n        setValueByPath(toObject, [\n            \"gcsUri\"\n        ], fromGcsUri);\n    }\n    const fromBigqueryUri = getValueByPath(fromObject, [\n        \"bigqueryDestination\",\n        \"outputUri\"\n    ]);\n    if (fromBigqueryUri != null) {\n        setValueByPath(toObject, [\n            \"bigqueryUri\"\n        ], fromBigqueryUri);\n    }\n    return toObject;\n}\nfunction batchJobFromVertex(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromState = getValueByPath(fromObject, [\n        \"state\"\n    ]);\n    if (fromState != null) {\n        setValueByPath(toObject, [\n            \"state\"\n        ], tJobState(fromState));\n    }\n    const fromError = getValueByPath(fromObject, [\n        \"error\"\n    ]);\n    if (fromError != null) {\n        setValueByPath(toObject, [\n            \"error\"\n        ], jobErrorFromVertex(fromError));\n    }\n    const fromCreateTime = getValueByPath(fromObject, [\n        \"createTime\"\n    ]);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, [\n            \"createTime\"\n        ], fromCreateTime);\n    }\n    const fromStartTime = getValueByPath(fromObject, [\n        \"startTime\"\n    ]);\n    if (fromStartTime != null) {\n        setValueByPath(toObject, [\n            \"startTime\"\n        ], fromStartTime);\n    }\n    const fromEndTime = getValueByPath(fromObject, [\n        \"endTime\"\n    ]);\n    if (fromEndTime != null) {\n        setValueByPath(toObject, [\n            \"endTime\"\n        ], fromEndTime);\n    }\n    const fromUpdateTime = getValueByPath(fromObject, [\n        \"updateTime\"\n    ]);\n    if (fromUpdateTime != null) {\n        setValueByPath(toObject, [\n            \"updateTime\"\n        ], fromUpdateTime);\n    }\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"model\"\n        ], fromModel);\n    }\n    const fromSrc = getValueByPath(fromObject, [\n        \"inputConfig\"\n    ]);\n    if (fromSrc != null) {\n        setValueByPath(toObject, [\n            \"src\"\n        ], batchJobSourceFromVertex(fromSrc));\n    }\n    const fromDest = getValueByPath(fromObject, [\n        \"outputConfig\"\n    ]);\n    if (fromDest != null) {\n        setValueByPath(toObject, [\n            \"dest\"\n        ], batchJobDestinationFromVertex(fromDest));\n    }\n    return toObject;\n}\nfunction listBatchJobsResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromNextPageToken = getValueByPath(fromObject, [\n        \"nextPageToken\"\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, [\n            \"nextPageToken\"\n        ], fromNextPageToken);\n    }\n    const fromBatchJobs = getValueByPath(fromObject, [\n        \"batchPredictionJobs\"\n    ]);\n    if (fromBatchJobs != null) {\n        let transformedList = fromBatchJobs;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return batchJobFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"batchJobs\"\n        ], transformedList);\n    }\n    return toObject;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ /**\n * Pagers for the GenAI List APIs.\n */ var PagedItem;\n(function(PagedItem) {\n    PagedItem[\"PAGED_ITEM_BATCH_JOBS\"] = \"batchJobs\";\n    PagedItem[\"PAGED_ITEM_MODELS\"] = \"models\";\n    PagedItem[\"PAGED_ITEM_TUNING_JOBS\"] = \"tuningJobs\";\n    PagedItem[\"PAGED_ITEM_FILES\"] = \"files\";\n    PagedItem[\"PAGED_ITEM_CACHED_CONTENTS\"] = \"cachedContents\";\n})(PagedItem || (PagedItem = {}));\n/**\n * Pager class for iterating through paginated results.\n */ class Pager {\n    constructor(name, request, response, params){\n        this.pageInternal = [];\n        this.paramsInternal = {};\n        this.requestInternal = request;\n        this.init(name, response, params);\n    }\n    init(name, response, params) {\n        var _a, _b;\n        this.nameInternal = name;\n        this.pageInternal = response[this.nameInternal] || [];\n        this.idxInternal = 0;\n        let requestParams = {\n            config: {}\n        };\n        if (!params) {\n            requestParams = {\n                config: {}\n            };\n        } else if (typeof params === \"object\") {\n            requestParams = Object.assign({}, params);\n        } else {\n            requestParams = params;\n        }\n        if (requestParams[\"config\"]) {\n            requestParams[\"config\"][\"pageToken\"] = response[\"nextPageToken\"];\n        }\n        this.paramsInternal = requestParams;\n        this.pageInternalSize = (_b = (_a = requestParams[\"config\"]) === null || _a === void 0 ? void 0 : _a[\"pageSize\"]) !== null && _b !== void 0 ? _b : this.pageInternal.length;\n    }\n    initNextPage(response) {\n        this.init(this.nameInternal, response, this.paramsInternal);\n    }\n    /**\n     * Returns the current page, which is a list of items.\n     *\n     * @remarks\n     * The first page is retrieved when the pager is created. The returned list of\n     * items could be a subset of the entire list.\n     */ get page() {\n        return this.pageInternal;\n    }\n    /**\n     * Returns the type of paged item (for example, ``batch_jobs``).\n     */ get name() {\n        return this.nameInternal;\n    }\n    /**\n     * Returns the length of the page fetched each time by this pager.\n     *\n     * @remarks\n     * The number of items in the page is less than or equal to the page length.\n     */ get pageSize() {\n        return this.pageInternalSize;\n    }\n    /**\n     * Returns the parameters when making the API request for the next page.\n     *\n     * @remarks\n     * Parameters contain a set of optional configs that can be\n     * used to customize the API request. For example, the `pageToken` parameter\n     * contains the token to request the next page.\n     */ get params() {\n        return this.paramsInternal;\n    }\n    /**\n     * Returns the total number of items in the current page.\n     */ get pageLength() {\n        return this.pageInternal.length;\n    }\n    /**\n     * Returns the item at the given index.\n     */ getItem(index) {\n        return this.pageInternal[index];\n    }\n    /**\n     * Returns an async iterator that support iterating through all items\n     * retrieved from the API.\n     *\n     * @remarks\n     * The iterator will automatically fetch the next page if there are more items\n     * to fetch from the API.\n     *\n     * @example\n     *\n     * ```ts\n     * const pager = await ai.files.list({config: {pageSize: 10}});\n     * for await (const file of pager) {\n     *   console.log(file.name);\n     * }\n     * ```\n     */ [Symbol.asyncIterator]() {\n        return {\n            next: async ()=>{\n                if (this.idxInternal >= this.pageLength) {\n                    if (this.hasNextPage()) {\n                        await this.nextPage();\n                    } else {\n                        return {\n                            value: undefined,\n                            done: true\n                        };\n                    }\n                }\n                const item = this.getItem(this.idxInternal);\n                this.idxInternal += 1;\n                return {\n                    value: item,\n                    done: false\n                };\n            },\n            return: async ()=>{\n                return {\n                    value: undefined,\n                    done: true\n                };\n            }\n        };\n    }\n    /**\n     * Fetches the next page of items. This makes a new API request.\n     *\n     * @throws {Error} If there are no more pages to fetch.\n     *\n     * @example\n     *\n     * ```ts\n     * const pager = await ai.files.list({config: {pageSize: 10}});\n     * let page = pager.page;\n     * while (true) {\n     *   for (const file of page) {\n     *     console.log(file.name);\n     *   }\n     *   if (!pager.hasNextPage()) {\n     *     break;\n     *   }\n     *   page = await pager.nextPage();\n     * }\n     * ```\n     */ async nextPage() {\n        if (!this.hasNextPage()) {\n            throw new Error(\"No more pages to fetch.\");\n        }\n        const response = await this.requestInternal(this.params);\n        this.initNextPage(response);\n        return this.page;\n    }\n    /**\n     * Returns true if there are more pages to fetch from the API.\n     */ hasNextPage() {\n        var _a;\n        if (((_a = this.params[\"config\"]) === null || _a === void 0 ? void 0 : _a[\"pageToken\"]) !== undefined) {\n            return true;\n        }\n        return false;\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ class Batches extends BaseModule {\n    constructor(apiClient){\n        super();\n        this.apiClient = apiClient;\n        /**\n         * Create batch job.\n         *\n         * @param params - The parameters for create batch job request.\n         * @return The created batch job.\n         *\n         * @example\n         * ```ts\n         * const response = await ai.batches.create({\n         *   model: 'gemini-2.0-flash',\n         *   src: {gcsUri: 'gs://bucket/path/to/file.jsonl', format: 'jsonl'},\n         *   config: {\n         *     dest: {gcsUri: 'gs://bucket/path/output/directory', format: 'jsonl'},\n         *   }\n         * });\n         * console.log(response);\n         * ```\n         */ this.create = async (params)=>{\n            if (this.apiClient.isVertexAI()) {\n                if (Array.isArray(params.src)) {\n                    throw new Error(\"InlinedRequest[] is not supported in Vertex AI. Please use \" + \"Google Cloud Storage URI or BigQuery URI instead.\");\n                }\n                params.config = params.config || {};\n                if (params.config.displayName === undefined) {\n                    params.config.displayName = \"genaiBatchJob_\";\n                }\n                if (params.config.dest === undefined && typeof params.src === \"string\") {\n                    if (params.src.startsWith(\"gs://\") && params.src.endsWith(\".jsonl\")) {\n                        params.config.dest = `${params.src.slice(0, -6)}/dest`;\n                    } else if (params.src.startsWith(\"bq://\")) {\n                        params.config.dest = `${params.src}_dest_`;\n                    } else {\n                        throw new Error(\"Unsupported source:\" + params.src);\n                    }\n                }\n            }\n            return await this.createInternal(params);\n        };\n        /**\n         * Lists batch job configurations.\n         *\n         * @param params - The parameters for the list request.\n         * @return The paginated results of the list of batch jobs.\n         *\n         * @example\n         * ```ts\n         * const batchJobs = await ai.batches.list({config: {'pageSize': 2}});\n         * for await (const batchJob of batchJobs) {\n         *   console.log(batchJob);\n         * }\n         * ```\n         */ this.list = async (params = {})=>{\n            return new Pager(PagedItem.PAGED_ITEM_BATCH_JOBS, (x)=>this.listInternal(x), await this.listInternal(params), params);\n        };\n    }\n    /**\n     * Internal method to create batch job.\n     *\n     * @param params - The parameters for create batch job request.\n     * @return The created batch job.\n     *\n     */ async createInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = createBatchJobParametersToVertex(this.apiClient, params);\n            path = formatMap(\"batchPredictionJobs\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = batchJobFromVertex(apiResponse);\n                return resp;\n            });\n        } else {\n            const body = createBatchJobParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{model}:batchGenerateContent\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = batchJobFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n    /**\n     * Gets batch job configurations.\n     *\n     * @param params - The parameters for the get request.\n     * @return The batch job.\n     *\n     * @example\n     * ```ts\n     * await ai.batches.get({name: '...'}); // The server-generated resource name.\n     * ```\n     */ async get(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = getBatchJobParametersToVertex(this.apiClient, params);\n            path = formatMap(\"batchPredictionJobs/{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = batchJobFromVertex(apiResponse);\n                return resp;\n            });\n        } else {\n            const body = getBatchJobParametersToMldev(this.apiClient, params);\n            path = formatMap(\"batches/{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = batchJobFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n    /**\n     * Cancels a batch job.\n     *\n     * @param params - The parameters for the cancel request.\n     * @return The empty response returned by the API.\n     *\n     * @example\n     * ```ts\n     * await ai.batches.cancel({name: '...'}); // The server-generated resource name.\n     * ```\n     */ async cancel(params) {\n        var _a, _b, _c, _d;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = cancelBatchJobParametersToVertex(this.apiClient, params);\n            path = formatMap(\"batchPredictionJobs/{name}:cancel\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            await this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            });\n        } else {\n            const body = cancelBatchJobParametersToMldev(this.apiClient, params);\n            path = formatMap(\"batches/{name}:cancel\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            await this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            });\n        }\n    }\n    async listInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = listBatchJobsParametersToVertex(params);\n            path = formatMap(\"batchPredictionJobs\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = listBatchJobsResponseFromVertex(apiResponse);\n                const typedResp = new ListBatchJobsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            const body = listBatchJobsParametersToMldev(params);\n            path = formatMap(\"batches\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = listBatchJobsResponseFromMldev(apiResponse);\n                const typedResp = new ListBatchJobsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ function videoMetadataToMldev$3(fromObject) {\n    const toObject = {};\n    const fromFps = getValueByPath(fromObject, [\n        \"fps\"\n    ]);\n    if (fromFps != null) {\n        setValueByPath(toObject, [\n            \"fps\"\n        ], fromFps);\n    }\n    const fromEndOffset = getValueByPath(fromObject, [\n        \"endOffset\"\n    ]);\n    if (fromEndOffset != null) {\n        setValueByPath(toObject, [\n            \"endOffset\"\n        ], fromEndOffset);\n    }\n    const fromStartOffset = getValueByPath(fromObject, [\n        \"startOffset\"\n    ]);\n    if (fromStartOffset != null) {\n        setValueByPath(toObject, [\n            \"startOffset\"\n        ], fromStartOffset);\n    }\n    return toObject;\n}\nfunction blobToMldev$3(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"displayName\"\n    ]) !== undefined) {\n        throw new Error(\"displayName parameter is not supported in Gemini API.\");\n    }\n    const fromData = getValueByPath(fromObject, [\n        \"data\"\n    ]);\n    if (fromData != null) {\n        setValueByPath(toObject, [\n            \"data\"\n        ], fromData);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction fileDataToMldev$3(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"displayName\"\n    ]) !== undefined) {\n        throw new Error(\"displayName parameter is not supported in Gemini API.\");\n    }\n    const fromFileUri = getValueByPath(fromObject, [\n        \"fileUri\"\n    ]);\n    if (fromFileUri != null) {\n        setValueByPath(toObject, [\n            \"fileUri\"\n        ], fromFileUri);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction partToMldev$3(fromObject) {\n    const toObject = {};\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        \"videoMetadata\"\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, [\n            \"videoMetadata\"\n        ], videoMetadataToMldev$3(fromVideoMetadata));\n    }\n    const fromThought = getValueByPath(fromObject, [\n        \"thought\"\n    ]);\n    if (fromThought != null) {\n        setValueByPath(toObject, [\n            \"thought\"\n        ], fromThought);\n    }\n    const fromInlineData = getValueByPath(fromObject, [\n        \"inlineData\"\n    ]);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, [\n            \"inlineData\"\n        ], blobToMldev$3(fromInlineData));\n    }\n    const fromFileData = getValueByPath(fromObject, [\n        \"fileData\"\n    ]);\n    if (fromFileData != null) {\n        setValueByPath(toObject, [\n            \"fileData\"\n        ], fileDataToMldev$3(fromFileData));\n    }\n    const fromThoughtSignature = getValueByPath(fromObject, [\n        \"thoughtSignature\"\n    ]);\n    if (fromThoughtSignature != null) {\n        setValueByPath(toObject, [\n            \"thoughtSignature\"\n        ], fromThoughtSignature);\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        \"codeExecutionResult\"\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, [\n            \"codeExecutionResult\"\n        ], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        \"executableCode\"\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, [\n            \"executableCode\"\n        ], fromExecutableCode);\n    }\n    const fromFunctionCall = getValueByPath(fromObject, [\n        \"functionCall\"\n    ]);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, [\n            \"functionCall\"\n        ], fromFunctionCall);\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        \"functionResponse\"\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, [\n            \"functionResponse\"\n        ], fromFunctionResponse);\n    }\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    return toObject;\n}\nfunction contentToMldev$3(fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, [\n        \"parts\"\n    ]);\n    if (fromParts != null) {\n        let transformedList = fromParts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return partToMldev$3(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"parts\"\n        ], transformedList);\n    }\n    const fromRole = getValueByPath(fromObject, [\n        \"role\"\n    ]);\n    if (fromRole != null) {\n        setValueByPath(toObject, [\n            \"role\"\n        ], fromRole);\n    }\n    return toObject;\n}\nfunction functionDeclarationToMldev$3(fromObject) {\n    const toObject = {};\n    const fromBehavior = getValueByPath(fromObject, [\n        \"behavior\"\n    ]);\n    if (fromBehavior != null) {\n        setValueByPath(toObject, [\n            \"behavior\"\n        ], fromBehavior);\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (fromDescription != null) {\n        setValueByPath(toObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromParameters = getValueByPath(fromObject, [\n        \"parameters\"\n    ]);\n    if (fromParameters != null) {\n        setValueByPath(toObject, [\n            \"parameters\"\n        ], fromParameters);\n    }\n    const fromParametersJsonSchema = getValueByPath(fromObject, [\n        \"parametersJsonSchema\"\n    ]);\n    if (fromParametersJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"parametersJsonSchema\"\n        ], fromParametersJsonSchema);\n    }\n    const fromResponse = getValueByPath(fromObject, [\n        \"response\"\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, [\n            \"response\"\n        ], fromResponse);\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        \"responseJsonSchema\"\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"responseJsonSchema\"\n        ], fromResponseJsonSchema);\n    }\n    return toObject;\n}\nfunction intervalToMldev$3(fromObject) {\n    const toObject = {};\n    const fromStartTime = getValueByPath(fromObject, [\n        \"startTime\"\n    ]);\n    if (fromStartTime != null) {\n        setValueByPath(toObject, [\n            \"startTime\"\n        ], fromStartTime);\n    }\n    const fromEndTime = getValueByPath(fromObject, [\n        \"endTime\"\n    ]);\n    if (fromEndTime != null) {\n        setValueByPath(toObject, [\n            \"endTime\"\n        ], fromEndTime);\n    }\n    return toObject;\n}\nfunction googleSearchToMldev$3(fromObject) {\n    const toObject = {};\n    const fromTimeRangeFilter = getValueByPath(fromObject, [\n        \"timeRangeFilter\"\n    ]);\n    if (fromTimeRangeFilter != null) {\n        setValueByPath(toObject, [\n            \"timeRangeFilter\"\n        ], intervalToMldev$3(fromTimeRangeFilter));\n    }\n    return toObject;\n}\nfunction dynamicRetrievalConfigToMldev$3(fromObject) {\n    const toObject = {};\n    const fromMode = getValueByPath(fromObject, [\n        \"mode\"\n    ]);\n    if (fromMode != null) {\n        setValueByPath(toObject, [\n            \"mode\"\n        ], fromMode);\n    }\n    const fromDynamicThreshold = getValueByPath(fromObject, [\n        \"dynamicThreshold\"\n    ]);\n    if (fromDynamicThreshold != null) {\n        setValueByPath(toObject, [\n            \"dynamicThreshold\"\n        ], fromDynamicThreshold);\n    }\n    return toObject;\n}\nfunction googleSearchRetrievalToMldev$3(fromObject) {\n    const toObject = {};\n    const fromDynamicRetrievalConfig = getValueByPath(fromObject, [\n        \"dynamicRetrievalConfig\"\n    ]);\n    if (fromDynamicRetrievalConfig != null) {\n        setValueByPath(toObject, [\n            \"dynamicRetrievalConfig\"\n        ], dynamicRetrievalConfigToMldev$3(fromDynamicRetrievalConfig));\n    }\n    return toObject;\n}\nfunction urlContextToMldev$3() {\n    const toObject = {};\n    return toObject;\n}\nfunction toolToMldev$3(fromObject) {\n    const toObject = {};\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        \"functionDeclarations\"\n    ]);\n    if (fromFunctionDeclarations != null) {\n        let transformedList = fromFunctionDeclarations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return functionDeclarationToMldev$3(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"functionDeclarations\"\n        ], transformedList);\n    }\n    if (getValueByPath(fromObject, [\n        \"retrieval\"\n    ]) !== undefined) {\n        throw new Error(\"retrieval parameter is not supported in Gemini API.\");\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, [\n        \"googleSearch\"\n    ]);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, [\n            \"googleSearch\"\n        ], googleSearchToMldev$3(fromGoogleSearch));\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        \"googleSearchRetrieval\"\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, [\n            \"googleSearchRetrieval\"\n        ], googleSearchRetrievalToMldev$3(fromGoogleSearchRetrieval));\n    }\n    if (getValueByPath(fromObject, [\n        \"enterpriseWebSearch\"\n    ]) !== undefined) {\n        throw new Error(\"enterpriseWebSearch parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"googleMaps\"\n    ]) !== undefined) {\n        throw new Error(\"googleMaps parameter is not supported in Gemini API.\");\n    }\n    const fromUrlContext = getValueByPath(fromObject, [\n        \"urlContext\"\n    ]);\n    if (fromUrlContext != null) {\n        setValueByPath(toObject, [\n            \"urlContext\"\n        ], urlContextToMldev$3());\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        \"codeExecution\"\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, [\n            \"codeExecution\"\n        ], fromCodeExecution);\n    }\n    return toObject;\n}\nfunction functionCallingConfigToMldev$1(fromObject) {\n    const toObject = {};\n    const fromMode = getValueByPath(fromObject, [\n        \"mode\"\n    ]);\n    if (fromMode != null) {\n        setValueByPath(toObject, [\n            \"mode\"\n        ], fromMode);\n    }\n    const fromAllowedFunctionNames = getValueByPath(fromObject, [\n        \"allowedFunctionNames\"\n    ]);\n    if (fromAllowedFunctionNames != null) {\n        setValueByPath(toObject, [\n            \"allowedFunctionNames\"\n        ], fromAllowedFunctionNames);\n    }\n    return toObject;\n}\nfunction latLngToMldev$1(fromObject) {\n    const toObject = {};\n    const fromLatitude = getValueByPath(fromObject, [\n        \"latitude\"\n    ]);\n    if (fromLatitude != null) {\n        setValueByPath(toObject, [\n            \"latitude\"\n        ], fromLatitude);\n    }\n    const fromLongitude = getValueByPath(fromObject, [\n        \"longitude\"\n    ]);\n    if (fromLongitude != null) {\n        setValueByPath(toObject, [\n            \"longitude\"\n        ], fromLongitude);\n    }\n    return toObject;\n}\nfunction retrievalConfigToMldev$1(fromObject) {\n    const toObject = {};\n    const fromLatLng = getValueByPath(fromObject, [\n        \"latLng\"\n    ]);\n    if (fromLatLng != null) {\n        setValueByPath(toObject, [\n            \"latLng\"\n        ], latLngToMldev$1(fromLatLng));\n    }\n    const fromLanguageCode = getValueByPath(fromObject, [\n        \"languageCode\"\n    ]);\n    if (fromLanguageCode != null) {\n        setValueByPath(toObject, [\n            \"languageCode\"\n        ], fromLanguageCode);\n    }\n    return toObject;\n}\nfunction toolConfigToMldev$1(fromObject) {\n    const toObject = {};\n    const fromFunctionCallingConfig = getValueByPath(fromObject, [\n        \"functionCallingConfig\"\n    ]);\n    if (fromFunctionCallingConfig != null) {\n        setValueByPath(toObject, [\n            \"functionCallingConfig\"\n        ], functionCallingConfigToMldev$1(fromFunctionCallingConfig));\n    }\n    const fromRetrievalConfig = getValueByPath(fromObject, [\n        \"retrievalConfig\"\n    ]);\n    if (fromRetrievalConfig != null) {\n        setValueByPath(toObject, [\n            \"retrievalConfig\"\n        ], retrievalConfigToMldev$1(fromRetrievalConfig));\n    }\n    return toObject;\n}\nfunction createCachedContentConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromTtl = getValueByPath(fromObject, [\n        \"ttl\"\n    ]);\n    if (parentObject !== undefined && fromTtl != null) {\n        setValueByPath(parentObject, [\n            \"ttl\"\n        ], fromTtl);\n    }\n    const fromExpireTime = getValueByPath(fromObject, [\n        \"expireTime\"\n    ]);\n    if (parentObject !== undefined && fromExpireTime != null) {\n        setValueByPath(parentObject, [\n            \"expireTime\"\n        ], fromExpireTime);\n    }\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (parentObject !== undefined && fromDisplayName != null) {\n        setValueByPath(parentObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromContents = getValueByPath(fromObject, [\n        \"contents\"\n    ]);\n    if (parentObject !== undefined && fromContents != null) {\n        let transformedList = tContents(fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return contentToMldev$3(item);\n            });\n        }\n        setValueByPath(parentObject, [\n            \"contents\"\n        ], transformedList);\n    }\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        \"systemInstruction\"\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, [\n            \"systemInstruction\"\n        ], contentToMldev$3(tContent(fromSystemInstruction)));\n    }\n    const fromTools = getValueByPath(fromObject, [\n        \"tools\"\n    ]);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = fromTools;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return toolToMldev$3(item);\n            });\n        }\n        setValueByPath(parentObject, [\n            \"tools\"\n        ], transformedList);\n    }\n    const fromToolConfig = getValueByPath(fromObject, [\n        \"toolConfig\"\n    ]);\n    if (parentObject !== undefined && fromToolConfig != null) {\n        setValueByPath(parentObject, [\n            \"toolConfig\"\n        ], toolConfigToMldev$1(fromToolConfig));\n    }\n    if (getValueByPath(fromObject, [\n        \"kmsKeyName\"\n    ]) !== undefined) {\n        throw new Error(\"kmsKeyName parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction createCachedContentParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"model\"\n        ], tCachesModel(apiClient, fromModel));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], createCachedContentConfigToMldev(fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction getCachedContentParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tCachedContentName(apiClient, fromName));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], fromConfig);\n    }\n    return toObject;\n}\nfunction deleteCachedContentParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tCachedContentName(apiClient, fromName));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], fromConfig);\n    }\n    return toObject;\n}\nfunction updateCachedContentConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromTtl = getValueByPath(fromObject, [\n        \"ttl\"\n    ]);\n    if (parentObject !== undefined && fromTtl != null) {\n        setValueByPath(parentObject, [\n            \"ttl\"\n        ], fromTtl);\n    }\n    const fromExpireTime = getValueByPath(fromObject, [\n        \"expireTime\"\n    ]);\n    if (parentObject !== undefined && fromExpireTime != null) {\n        setValueByPath(parentObject, [\n            \"expireTime\"\n        ], fromExpireTime);\n    }\n    return toObject;\n}\nfunction updateCachedContentParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tCachedContentName(apiClient, fromName));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], updateCachedContentConfigToMldev(fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction listCachedContentsConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, [\n        \"pageSize\"\n    ]);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageSize\"\n        ], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, [\n        \"pageToken\"\n    ]);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageToken\"\n        ], fromPageToken);\n    }\n    return toObject;\n}\nfunction listCachedContentsParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], listCachedContentsConfigToMldev(fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction videoMetadataToVertex$2(fromObject) {\n    const toObject = {};\n    const fromFps = getValueByPath(fromObject, [\n        \"fps\"\n    ]);\n    if (fromFps != null) {\n        setValueByPath(toObject, [\n            \"fps\"\n        ], fromFps);\n    }\n    const fromEndOffset = getValueByPath(fromObject, [\n        \"endOffset\"\n    ]);\n    if (fromEndOffset != null) {\n        setValueByPath(toObject, [\n            \"endOffset\"\n        ], fromEndOffset);\n    }\n    const fromStartOffset = getValueByPath(fromObject, [\n        \"startOffset\"\n    ]);\n    if (fromStartOffset != null) {\n        setValueByPath(toObject, [\n            \"startOffset\"\n        ], fromStartOffset);\n    }\n    return toObject;\n}\nfunction blobToVertex$2(fromObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromData = getValueByPath(fromObject, [\n        \"data\"\n    ]);\n    if (fromData != null) {\n        setValueByPath(toObject, [\n            \"data\"\n        ], fromData);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction fileDataToVertex$2(fromObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromFileUri = getValueByPath(fromObject, [\n        \"fileUri\"\n    ]);\n    if (fromFileUri != null) {\n        setValueByPath(toObject, [\n            \"fileUri\"\n        ], fromFileUri);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction partToVertex$2(fromObject) {\n    const toObject = {};\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        \"videoMetadata\"\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, [\n            \"videoMetadata\"\n        ], videoMetadataToVertex$2(fromVideoMetadata));\n    }\n    const fromThought = getValueByPath(fromObject, [\n        \"thought\"\n    ]);\n    if (fromThought != null) {\n        setValueByPath(toObject, [\n            \"thought\"\n        ], fromThought);\n    }\n    const fromInlineData = getValueByPath(fromObject, [\n        \"inlineData\"\n    ]);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, [\n            \"inlineData\"\n        ], blobToVertex$2(fromInlineData));\n    }\n    const fromFileData = getValueByPath(fromObject, [\n        \"fileData\"\n    ]);\n    if (fromFileData != null) {\n        setValueByPath(toObject, [\n            \"fileData\"\n        ], fileDataToVertex$2(fromFileData));\n    }\n    const fromThoughtSignature = getValueByPath(fromObject, [\n        \"thoughtSignature\"\n    ]);\n    if (fromThoughtSignature != null) {\n        setValueByPath(toObject, [\n            \"thoughtSignature\"\n        ], fromThoughtSignature);\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        \"codeExecutionResult\"\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, [\n            \"codeExecutionResult\"\n        ], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        \"executableCode\"\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, [\n            \"executableCode\"\n        ], fromExecutableCode);\n    }\n    const fromFunctionCall = getValueByPath(fromObject, [\n        \"functionCall\"\n    ]);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, [\n            \"functionCall\"\n        ], fromFunctionCall);\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        \"functionResponse\"\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, [\n            \"functionResponse\"\n        ], fromFunctionResponse);\n    }\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    return toObject;\n}\nfunction contentToVertex$2(fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, [\n        \"parts\"\n    ]);\n    if (fromParts != null) {\n        let transformedList = fromParts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return partToVertex$2(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"parts\"\n        ], transformedList);\n    }\n    const fromRole = getValueByPath(fromObject, [\n        \"role\"\n    ]);\n    if (fromRole != null) {\n        setValueByPath(toObject, [\n            \"role\"\n        ], fromRole);\n    }\n    return toObject;\n}\nfunction functionDeclarationToVertex$2(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"behavior\"\n    ]) !== undefined) {\n        throw new Error(\"behavior parameter is not supported in Vertex AI.\");\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (fromDescription != null) {\n        setValueByPath(toObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromParameters = getValueByPath(fromObject, [\n        \"parameters\"\n    ]);\n    if (fromParameters != null) {\n        setValueByPath(toObject, [\n            \"parameters\"\n        ], fromParameters);\n    }\n    const fromParametersJsonSchema = getValueByPath(fromObject, [\n        \"parametersJsonSchema\"\n    ]);\n    if (fromParametersJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"parametersJsonSchema\"\n        ], fromParametersJsonSchema);\n    }\n    const fromResponse = getValueByPath(fromObject, [\n        \"response\"\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, [\n            \"response\"\n        ], fromResponse);\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        \"responseJsonSchema\"\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"responseJsonSchema\"\n        ], fromResponseJsonSchema);\n    }\n    return toObject;\n}\nfunction intervalToVertex$2(fromObject) {\n    const toObject = {};\n    const fromStartTime = getValueByPath(fromObject, [\n        \"startTime\"\n    ]);\n    if (fromStartTime != null) {\n        setValueByPath(toObject, [\n            \"startTime\"\n        ], fromStartTime);\n    }\n    const fromEndTime = getValueByPath(fromObject, [\n        \"endTime\"\n    ]);\n    if (fromEndTime != null) {\n        setValueByPath(toObject, [\n            \"endTime\"\n        ], fromEndTime);\n    }\n    return toObject;\n}\nfunction googleSearchToVertex$2(fromObject) {\n    const toObject = {};\n    const fromTimeRangeFilter = getValueByPath(fromObject, [\n        \"timeRangeFilter\"\n    ]);\n    if (fromTimeRangeFilter != null) {\n        setValueByPath(toObject, [\n            \"timeRangeFilter\"\n        ], intervalToVertex$2(fromTimeRangeFilter));\n    }\n    return toObject;\n}\nfunction dynamicRetrievalConfigToVertex$2(fromObject) {\n    const toObject = {};\n    const fromMode = getValueByPath(fromObject, [\n        \"mode\"\n    ]);\n    if (fromMode != null) {\n        setValueByPath(toObject, [\n            \"mode\"\n        ], fromMode);\n    }\n    const fromDynamicThreshold = getValueByPath(fromObject, [\n        \"dynamicThreshold\"\n    ]);\n    if (fromDynamicThreshold != null) {\n        setValueByPath(toObject, [\n            \"dynamicThreshold\"\n        ], fromDynamicThreshold);\n    }\n    return toObject;\n}\nfunction googleSearchRetrievalToVertex$2(fromObject) {\n    const toObject = {};\n    const fromDynamicRetrievalConfig = getValueByPath(fromObject, [\n        \"dynamicRetrievalConfig\"\n    ]);\n    if (fromDynamicRetrievalConfig != null) {\n        setValueByPath(toObject, [\n            \"dynamicRetrievalConfig\"\n        ], dynamicRetrievalConfigToVertex$2(fromDynamicRetrievalConfig));\n    }\n    return toObject;\n}\nfunction enterpriseWebSearchToVertex$2() {\n    const toObject = {};\n    return toObject;\n}\nfunction apiKeyConfigToVertex$2(fromObject) {\n    const toObject = {};\n    const fromApiKeyString = getValueByPath(fromObject, [\n        \"apiKeyString\"\n    ]);\n    if (fromApiKeyString != null) {\n        setValueByPath(toObject, [\n            \"apiKeyString\"\n        ], fromApiKeyString);\n    }\n    return toObject;\n}\nfunction authConfigToVertex$2(fromObject) {\n    const toObject = {};\n    const fromApiKeyConfig = getValueByPath(fromObject, [\n        \"apiKeyConfig\"\n    ]);\n    if (fromApiKeyConfig != null) {\n        setValueByPath(toObject, [\n            \"apiKeyConfig\"\n        ], apiKeyConfigToVertex$2(fromApiKeyConfig));\n    }\n    const fromAuthType = getValueByPath(fromObject, [\n        \"authType\"\n    ]);\n    if (fromAuthType != null) {\n        setValueByPath(toObject, [\n            \"authType\"\n        ], fromAuthType);\n    }\n    const fromGoogleServiceAccountConfig = getValueByPath(fromObject, [\n        \"googleServiceAccountConfig\"\n    ]);\n    if (fromGoogleServiceAccountConfig != null) {\n        setValueByPath(toObject, [\n            \"googleServiceAccountConfig\"\n        ], fromGoogleServiceAccountConfig);\n    }\n    const fromHttpBasicAuthConfig = getValueByPath(fromObject, [\n        \"httpBasicAuthConfig\"\n    ]);\n    if (fromHttpBasicAuthConfig != null) {\n        setValueByPath(toObject, [\n            \"httpBasicAuthConfig\"\n        ], fromHttpBasicAuthConfig);\n    }\n    const fromOauthConfig = getValueByPath(fromObject, [\n        \"oauthConfig\"\n    ]);\n    if (fromOauthConfig != null) {\n        setValueByPath(toObject, [\n            \"oauthConfig\"\n        ], fromOauthConfig);\n    }\n    const fromOidcConfig = getValueByPath(fromObject, [\n        \"oidcConfig\"\n    ]);\n    if (fromOidcConfig != null) {\n        setValueByPath(toObject, [\n            \"oidcConfig\"\n        ], fromOidcConfig);\n    }\n    return toObject;\n}\nfunction googleMapsToVertex$2(fromObject) {\n    const toObject = {};\n    const fromAuthConfig = getValueByPath(fromObject, [\n        \"authConfig\"\n    ]);\n    if (fromAuthConfig != null) {\n        setValueByPath(toObject, [\n            \"authConfig\"\n        ], authConfigToVertex$2(fromAuthConfig));\n    }\n    return toObject;\n}\nfunction urlContextToVertex$2() {\n    const toObject = {};\n    return toObject;\n}\nfunction toolToVertex$2(fromObject) {\n    const toObject = {};\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        \"functionDeclarations\"\n    ]);\n    if (fromFunctionDeclarations != null) {\n        let transformedList = fromFunctionDeclarations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return functionDeclarationToVertex$2(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"functionDeclarations\"\n        ], transformedList);\n    }\n    const fromRetrieval = getValueByPath(fromObject, [\n        \"retrieval\"\n    ]);\n    if (fromRetrieval != null) {\n        setValueByPath(toObject, [\n            \"retrieval\"\n        ], fromRetrieval);\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, [\n        \"googleSearch\"\n    ]);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, [\n            \"googleSearch\"\n        ], googleSearchToVertex$2(fromGoogleSearch));\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        \"googleSearchRetrieval\"\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, [\n            \"googleSearchRetrieval\"\n        ], googleSearchRetrievalToVertex$2(fromGoogleSearchRetrieval));\n    }\n    const fromEnterpriseWebSearch = getValueByPath(fromObject, [\n        \"enterpriseWebSearch\"\n    ]);\n    if (fromEnterpriseWebSearch != null) {\n        setValueByPath(toObject, [\n            \"enterpriseWebSearch\"\n        ], enterpriseWebSearchToVertex$2());\n    }\n    const fromGoogleMaps = getValueByPath(fromObject, [\n        \"googleMaps\"\n    ]);\n    if (fromGoogleMaps != null) {\n        setValueByPath(toObject, [\n            \"googleMaps\"\n        ], googleMapsToVertex$2(fromGoogleMaps));\n    }\n    const fromUrlContext = getValueByPath(fromObject, [\n        \"urlContext\"\n    ]);\n    if (fromUrlContext != null) {\n        setValueByPath(toObject, [\n            \"urlContext\"\n        ], urlContextToVertex$2());\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        \"codeExecution\"\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, [\n            \"codeExecution\"\n        ], fromCodeExecution);\n    }\n    return toObject;\n}\nfunction functionCallingConfigToVertex$1(fromObject) {\n    const toObject = {};\n    const fromMode = getValueByPath(fromObject, [\n        \"mode\"\n    ]);\n    if (fromMode != null) {\n        setValueByPath(toObject, [\n            \"mode\"\n        ], fromMode);\n    }\n    const fromAllowedFunctionNames = getValueByPath(fromObject, [\n        \"allowedFunctionNames\"\n    ]);\n    if (fromAllowedFunctionNames != null) {\n        setValueByPath(toObject, [\n            \"allowedFunctionNames\"\n        ], fromAllowedFunctionNames);\n    }\n    return toObject;\n}\nfunction latLngToVertex$1(fromObject) {\n    const toObject = {};\n    const fromLatitude = getValueByPath(fromObject, [\n        \"latitude\"\n    ]);\n    if (fromLatitude != null) {\n        setValueByPath(toObject, [\n            \"latitude\"\n        ], fromLatitude);\n    }\n    const fromLongitude = getValueByPath(fromObject, [\n        \"longitude\"\n    ]);\n    if (fromLongitude != null) {\n        setValueByPath(toObject, [\n            \"longitude\"\n        ], fromLongitude);\n    }\n    return toObject;\n}\nfunction retrievalConfigToVertex$1(fromObject) {\n    const toObject = {};\n    const fromLatLng = getValueByPath(fromObject, [\n        \"latLng\"\n    ]);\n    if (fromLatLng != null) {\n        setValueByPath(toObject, [\n            \"latLng\"\n        ], latLngToVertex$1(fromLatLng));\n    }\n    const fromLanguageCode = getValueByPath(fromObject, [\n        \"languageCode\"\n    ]);\n    if (fromLanguageCode != null) {\n        setValueByPath(toObject, [\n            \"languageCode\"\n        ], fromLanguageCode);\n    }\n    return toObject;\n}\nfunction toolConfigToVertex$1(fromObject) {\n    const toObject = {};\n    const fromFunctionCallingConfig = getValueByPath(fromObject, [\n        \"functionCallingConfig\"\n    ]);\n    if (fromFunctionCallingConfig != null) {\n        setValueByPath(toObject, [\n            \"functionCallingConfig\"\n        ], functionCallingConfigToVertex$1(fromFunctionCallingConfig));\n    }\n    const fromRetrievalConfig = getValueByPath(fromObject, [\n        \"retrievalConfig\"\n    ]);\n    if (fromRetrievalConfig != null) {\n        setValueByPath(toObject, [\n            \"retrievalConfig\"\n        ], retrievalConfigToVertex$1(fromRetrievalConfig));\n    }\n    return toObject;\n}\nfunction createCachedContentConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromTtl = getValueByPath(fromObject, [\n        \"ttl\"\n    ]);\n    if (parentObject !== undefined && fromTtl != null) {\n        setValueByPath(parentObject, [\n            \"ttl\"\n        ], fromTtl);\n    }\n    const fromExpireTime = getValueByPath(fromObject, [\n        \"expireTime\"\n    ]);\n    if (parentObject !== undefined && fromExpireTime != null) {\n        setValueByPath(parentObject, [\n            \"expireTime\"\n        ], fromExpireTime);\n    }\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (parentObject !== undefined && fromDisplayName != null) {\n        setValueByPath(parentObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromContents = getValueByPath(fromObject, [\n        \"contents\"\n    ]);\n    if (parentObject !== undefined && fromContents != null) {\n        let transformedList = tContents(fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return contentToVertex$2(item);\n            });\n        }\n        setValueByPath(parentObject, [\n            \"contents\"\n        ], transformedList);\n    }\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        \"systemInstruction\"\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, [\n            \"systemInstruction\"\n        ], contentToVertex$2(tContent(fromSystemInstruction)));\n    }\n    const fromTools = getValueByPath(fromObject, [\n        \"tools\"\n    ]);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = fromTools;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return toolToVertex$2(item);\n            });\n        }\n        setValueByPath(parentObject, [\n            \"tools\"\n        ], transformedList);\n    }\n    const fromToolConfig = getValueByPath(fromObject, [\n        \"toolConfig\"\n    ]);\n    if (parentObject !== undefined && fromToolConfig != null) {\n        setValueByPath(parentObject, [\n            \"toolConfig\"\n        ], toolConfigToVertex$1(fromToolConfig));\n    }\n    const fromKmsKeyName = getValueByPath(fromObject, [\n        \"kmsKeyName\"\n    ]);\n    if (parentObject !== undefined && fromKmsKeyName != null) {\n        setValueByPath(parentObject, [\n            \"encryption_spec\",\n            \"kmsKeyName\"\n        ], fromKmsKeyName);\n    }\n    return toObject;\n}\nfunction createCachedContentParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"model\"\n        ], tCachesModel(apiClient, fromModel));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], createCachedContentConfigToVertex(fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction getCachedContentParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tCachedContentName(apiClient, fromName));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], fromConfig);\n    }\n    return toObject;\n}\nfunction deleteCachedContentParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tCachedContentName(apiClient, fromName));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], fromConfig);\n    }\n    return toObject;\n}\nfunction updateCachedContentConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromTtl = getValueByPath(fromObject, [\n        \"ttl\"\n    ]);\n    if (parentObject !== undefined && fromTtl != null) {\n        setValueByPath(parentObject, [\n            \"ttl\"\n        ], fromTtl);\n    }\n    const fromExpireTime = getValueByPath(fromObject, [\n        \"expireTime\"\n    ]);\n    if (parentObject !== undefined && fromExpireTime != null) {\n        setValueByPath(parentObject, [\n            \"expireTime\"\n        ], fromExpireTime);\n    }\n    return toObject;\n}\nfunction updateCachedContentParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tCachedContentName(apiClient, fromName));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], updateCachedContentConfigToVertex(fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction listCachedContentsConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, [\n        \"pageSize\"\n    ]);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageSize\"\n        ], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, [\n        \"pageToken\"\n    ]);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageToken\"\n        ], fromPageToken);\n    }\n    return toObject;\n}\nfunction listCachedContentsParametersToVertex(fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], listCachedContentsConfigToVertex(fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction cachedContentFromMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"model\"\n        ], fromModel);\n    }\n    const fromCreateTime = getValueByPath(fromObject, [\n        \"createTime\"\n    ]);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, [\n            \"createTime\"\n        ], fromCreateTime);\n    }\n    const fromUpdateTime = getValueByPath(fromObject, [\n        \"updateTime\"\n    ]);\n    if (fromUpdateTime != null) {\n        setValueByPath(toObject, [\n            \"updateTime\"\n        ], fromUpdateTime);\n    }\n    const fromExpireTime = getValueByPath(fromObject, [\n        \"expireTime\"\n    ]);\n    if (fromExpireTime != null) {\n        setValueByPath(toObject, [\n            \"expireTime\"\n        ], fromExpireTime);\n    }\n    const fromUsageMetadata = getValueByPath(fromObject, [\n        \"usageMetadata\"\n    ]);\n    if (fromUsageMetadata != null) {\n        setValueByPath(toObject, [\n            \"usageMetadata\"\n        ], fromUsageMetadata);\n    }\n    return toObject;\n}\nfunction deleteCachedContentResponseFromMldev() {\n    const toObject = {};\n    return toObject;\n}\nfunction listCachedContentsResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromNextPageToken = getValueByPath(fromObject, [\n        \"nextPageToken\"\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, [\n            \"nextPageToken\"\n        ], fromNextPageToken);\n    }\n    const fromCachedContents = getValueByPath(fromObject, [\n        \"cachedContents\"\n    ]);\n    if (fromCachedContents != null) {\n        let transformedList = fromCachedContents;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return cachedContentFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"cachedContents\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction cachedContentFromVertex(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"model\"\n        ], fromModel);\n    }\n    const fromCreateTime = getValueByPath(fromObject, [\n        \"createTime\"\n    ]);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, [\n            \"createTime\"\n        ], fromCreateTime);\n    }\n    const fromUpdateTime = getValueByPath(fromObject, [\n        \"updateTime\"\n    ]);\n    if (fromUpdateTime != null) {\n        setValueByPath(toObject, [\n            \"updateTime\"\n        ], fromUpdateTime);\n    }\n    const fromExpireTime = getValueByPath(fromObject, [\n        \"expireTime\"\n    ]);\n    if (fromExpireTime != null) {\n        setValueByPath(toObject, [\n            \"expireTime\"\n        ], fromExpireTime);\n    }\n    const fromUsageMetadata = getValueByPath(fromObject, [\n        \"usageMetadata\"\n    ]);\n    if (fromUsageMetadata != null) {\n        setValueByPath(toObject, [\n            \"usageMetadata\"\n        ], fromUsageMetadata);\n    }\n    return toObject;\n}\nfunction deleteCachedContentResponseFromVertex() {\n    const toObject = {};\n    return toObject;\n}\nfunction listCachedContentsResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromNextPageToken = getValueByPath(fromObject, [\n        \"nextPageToken\"\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, [\n            \"nextPageToken\"\n        ], fromNextPageToken);\n    }\n    const fromCachedContents = getValueByPath(fromObject, [\n        \"cachedContents\"\n    ]);\n    if (fromCachedContents != null) {\n        let transformedList = fromCachedContents;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return cachedContentFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"cachedContents\"\n        ], transformedList);\n    }\n    return toObject;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ class Caches extends BaseModule {\n    constructor(apiClient){\n        super();\n        this.apiClient = apiClient;\n        /**\n         * Lists cached content configurations.\n         *\n         * @param params - The parameters for the list request.\n         * @return The paginated results of the list of cached contents.\n         *\n         * @example\n         * ```ts\n         * const cachedContents = await ai.caches.list({config: {'pageSize': 2}});\n         * for await (const cachedContent of cachedContents) {\n         *   console.log(cachedContent);\n         * }\n         * ```\n         */ this.list = async (params = {})=>{\n            return new Pager(PagedItem.PAGED_ITEM_CACHED_CONTENTS, (x)=>this.listInternal(x), await this.listInternal(params), params);\n        };\n    }\n    /**\n     * Creates a cached contents resource.\n     *\n     * @remarks\n     * Context caching is only supported for specific models. See [Gemini\n     * Developer API reference](https://ai.google.dev/gemini-api/docs/caching?lang=node/context-cac)\n     * and [Vertex AI reference](https://cloud.google.com/vertex-ai/generative-ai/docs/context-cache/context-cache-overview#supported_models)\n     * for more information.\n     *\n     * @param params - The parameters for the create request.\n     * @return The created cached content.\n     *\n     * @example\n     * ```ts\n     * const contents = ...; // Initialize the content to cache.\n     * const response = await ai.caches.create({\n     *   model: 'gemini-2.0-flash-001',\n     *   config: {\n     *    'contents': contents,\n     *    'displayName': 'test cache',\n     *    'systemInstruction': 'What is the sum of the two pdfs?',\n     *    'ttl': '86400s',\n     *  }\n     * });\n     * ```\n     */ async create(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = createCachedContentParametersToVertex(this.apiClient, params);\n            path = formatMap(\"cachedContents\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = cachedContentFromVertex(apiResponse);\n                return resp;\n            });\n        } else {\n            const body = createCachedContentParametersToMldev(this.apiClient, params);\n            path = formatMap(\"cachedContents\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = cachedContentFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n    /**\n     * Gets cached content configurations.\n     *\n     * @param params - The parameters for the get request.\n     * @return The cached content.\n     *\n     * @example\n     * ```ts\n     * await ai.caches.get({name: '...'}); // The server-generated resource name.\n     * ```\n     */ async get(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = getCachedContentParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = cachedContentFromVertex(apiResponse);\n                return resp;\n            });\n        } else {\n            const body = getCachedContentParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = cachedContentFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n    /**\n     * Deletes cached content.\n     *\n     * @param params - The parameters for the delete request.\n     * @return The empty response returned by the API.\n     *\n     * @example\n     * ```ts\n     * await ai.caches.delete({name: '...'}); // The server-generated resource name.\n     * ```\n     */ async delete(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = deleteCachedContentParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"DELETE\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then(()=>{\n                const resp = deleteCachedContentResponseFromVertex();\n                const typedResp = new DeleteCachedContentResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            const body = deleteCachedContentParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"DELETE\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then(()=>{\n                const resp = deleteCachedContentResponseFromMldev();\n                const typedResp = new DeleteCachedContentResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Updates cached content configurations.\n     *\n     * @param params - The parameters for the update request.\n     * @return The updated cached content.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.caches.update({\n     *   name: '...',  // The server-generated resource name.\n     *   config: {'ttl': '7600s'}\n     * });\n     * ```\n     */ async update(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = updateCachedContentParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"PATCH\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = cachedContentFromVertex(apiResponse);\n                return resp;\n            });\n        } else {\n            const body = updateCachedContentParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"PATCH\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = cachedContentFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n    async listInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = listCachedContentsParametersToVertex(params);\n            path = formatMap(\"cachedContents\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = listCachedContentsResponseFromVertex(apiResponse);\n                const typedResp = new ListCachedContentsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            const body = listCachedContentsParametersToMldev(params);\n            path = formatMap(\"cachedContents\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = listCachedContentsResponseFromMldev(apiResponse);\n                const typedResp = new ListCachedContentsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n}\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ /* global Reflect, Promise, SuppressedError, Symbol, Iterator */ function __values(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function() {\n            if (o && i >= o.length) o = void 0;\n            return {\n                value: o && o[i++],\n                done: !o\n            };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\nfunction __await(v) {\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\nfunction __asyncGenerator(thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function() {\n        return this;\n    }, i;\n    function awaitReturn(f) {\n        return function(v) {\n            return Promise.resolve(v).then(f, reject);\n        };\n    }\n    function verb(n, f) {\n        if (g[n]) {\n            i[n] = function(v) {\n                return new Promise(function(a, b) {\n                    q.push([\n                        n,\n                        v,\n                        a,\n                        b\n                    ]) > 1 || resume(n, v);\n                });\n            };\n            if (f) i[n] = f(i[n]);\n        }\n    }\n    function resume(n, v) {\n        try {\n            step(g[n](v));\n        } catch (e) {\n            settle(q[0][3], e);\n        }\n    }\n    function step(r) {\n        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);\n    }\n    function fulfill(value) {\n        resume(\"next\", value);\n    }\n    function reject(value) {\n        resume(\"throw\", value);\n    }\n    function settle(f, v) {\n        if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);\n    }\n}\nfunction __asyncValues(o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n        return this;\n    }, i);\n    function verb(n) {\n        i[n] = o[n] && function(v) {\n            return new Promise(function(resolve, reject) {\n                v = o[n](v), settle(resolve, reject, v.done, v.value);\n            });\n        };\n    }\n    function settle(resolve, reject, d, v) {\n        Promise.resolve(v).then(function(v) {\n            resolve({\n                value: v,\n                done: d\n            });\n        }, reject);\n    }\n}\ntypeof SuppressedError === \"function\" ? SuppressedError : function(error, suppressed, message) {\n    var e = new Error(message);\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ /**\n * Returns true if the response is valid, false otherwise.\n */ function isValidResponse(response) {\n    var _a;\n    if (response.candidates == undefined || response.candidates.length === 0) {\n        return false;\n    }\n    const content = (_a = response.candidates[0]) === null || _a === void 0 ? void 0 : _a.content;\n    if (content === undefined) {\n        return false;\n    }\n    return isValidContent(content);\n}\nfunction isValidContent(content) {\n    if (content.parts === undefined || content.parts.length === 0) {\n        return false;\n    }\n    for (const part of content.parts){\n        if (part === undefined || Object.keys(part).length === 0) {\n            return false;\n        }\n        if (!part.thought && part.text !== undefined && part.text === \"\") {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Validates the history contains the correct roles.\n *\n * @throws Error if the history does not start with a user turn.\n * @throws Error if the history contains an invalid role.\n */ function validateHistory(history) {\n    // Empty history is valid.\n    if (history.length === 0) {\n        return;\n    }\n    for (const content of history){\n        if (content.role !== \"user\" && content.role !== \"model\") {\n            throw new Error(`Role must be user or model, but got ${content.role}.`);\n        }\n    }\n}\n/**\n * Extracts the curated (valid) history from a comprehensive history.\n *\n * @remarks\n * The model may sometimes generate invalid or empty contents(e.g., due to safty\n * filters or recitation). Extracting valid turns from the history\n * ensures that subsequent requests could be accpeted by the model.\n */ function extractCuratedHistory(comprehensiveHistory) {\n    if (comprehensiveHistory === undefined || comprehensiveHistory.length === 0) {\n        return [];\n    }\n    const curatedHistory = [];\n    const length = comprehensiveHistory.length;\n    let i = 0;\n    while(i < length){\n        if (comprehensiveHistory[i].role === \"user\") {\n            curatedHistory.push(comprehensiveHistory[i]);\n            i++;\n        } else {\n            const modelOutput = [];\n            let isValid = true;\n            while(i < length && comprehensiveHistory[i].role === \"model\"){\n                modelOutput.push(comprehensiveHistory[i]);\n                if (isValid && !isValidContent(comprehensiveHistory[i])) {\n                    isValid = false;\n                }\n                i++;\n            }\n            if (isValid) {\n                curatedHistory.push(...modelOutput);\n            } else {\n                // Remove the last user input when model content is invalid.\n                curatedHistory.pop();\n            }\n        }\n    }\n    return curatedHistory;\n}\n/**\n * A utility class to create a chat session.\n */ class Chats {\n    constructor(modelsModule, apiClient){\n        this.modelsModule = modelsModule;\n        this.apiClient = apiClient;\n    }\n    /**\n     * Creates a new chat session.\n     *\n     * @remarks\n     * The config in the params will be used for all requests within the chat\n     * session unless overridden by a per-request `config` in\n     * @see {@link types.SendMessageParameters#config}.\n     *\n     * @param params - Parameters for creating a chat session.\n     * @returns A new chat session.\n     *\n     * @example\n     * ```ts\n     * const chat = ai.chats.create({\n     *   model: 'gemini-2.0-flash'\n     *   config: {\n     *     temperature: 0.5,\n     *     maxOutputTokens: 1024,\n     *   }\n     * });\n     * ```\n     */ create(params) {\n        return new Chat(this.apiClient, this.modelsModule, params.model, params.config, // Deep copy the history to avoid mutating the history outside of the\n        // chat session.\n        structuredClone(params.history));\n    }\n}\n/**\n * Chat session that enables sending messages to the model with previous\n * conversation context.\n *\n * @remarks\n * The session maintains all the turns between user and model.\n */ class Chat {\n    constructor(apiClient, modelsModule, model, config = {}, history = []){\n        this.apiClient = apiClient;\n        this.modelsModule = modelsModule;\n        this.model = model;\n        this.config = config;\n        this.history = history;\n        // A promise to represent the current state of the message being sent to the\n        // model.\n        this.sendPromise = Promise.resolve();\n        validateHistory(history);\n    }\n    /**\n     * Sends a message to the model and returns the response.\n     *\n     * @remarks\n     * This method will wait for the previous message to be processed before\n     * sending the next message.\n     *\n     * @see {@link Chat#sendMessageStream} for streaming method.\n     * @param params - parameters for sending messages within a chat session.\n     * @returns The model's response.\n     *\n     * @example\n     * ```ts\n     * const chat = ai.chats.create({model: 'gemini-2.0-flash'});\n     * const response = await chat.sendMessage({\n     *   message: 'Why is the sky blue?'\n     * });\n     * console.log(response.text);\n     * ```\n     */ async sendMessage(params) {\n        var _a;\n        await this.sendPromise;\n        const inputContent = tContent(params.message);\n        const responsePromise = this.modelsModule.generateContent({\n            model: this.model,\n            contents: this.getHistory(true).concat(inputContent),\n            config: (_a = params.config) !== null && _a !== void 0 ? _a : this.config\n        });\n        this.sendPromise = (async ()=>{\n            var _a, _b, _c;\n            const response = await responsePromise;\n            const outputContent = (_b = (_a = response.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content;\n            // Because the AFC input contains the entire curated chat history in\n            // addition to the new user input, we need to truncate the AFC history\n            // to deduplicate the existing chat history.\n            const fullAutomaticFunctionCallingHistory = response.automaticFunctionCallingHistory;\n            const index = this.getHistory(true).length;\n            let automaticFunctionCallingHistory = [];\n            if (fullAutomaticFunctionCallingHistory != null) {\n                automaticFunctionCallingHistory = (_c = fullAutomaticFunctionCallingHistory.slice(index)) !== null && _c !== void 0 ? _c : [];\n            }\n            const modelOutput = outputContent ? [\n                outputContent\n            ] : [];\n            this.recordHistory(inputContent, modelOutput, automaticFunctionCallingHistory);\n            return;\n        })();\n        await this.sendPromise.catch(()=>{\n            // Resets sendPromise to avoid subsequent calls failing\n            this.sendPromise = Promise.resolve();\n        });\n        return responsePromise;\n    }\n    /**\n     * Sends a message to the model and returns the response in chunks.\n     *\n     * @remarks\n     * This method will wait for the previous message to be processed before\n     * sending the next message.\n     *\n     * @see {@link Chat#sendMessage} for non-streaming method.\n     * @param params - parameters for sending the message.\n     * @return The model's response.\n     *\n     * @example\n     * ```ts\n     * const chat = ai.chats.create({model: 'gemini-2.0-flash'});\n     * const response = await chat.sendMessageStream({\n     *   message: 'Why is the sky blue?'\n     * });\n     * for await (const chunk of response) {\n     *   console.log(chunk.text);\n     * }\n     * ```\n     */ async sendMessageStream(params) {\n        var _a;\n        await this.sendPromise;\n        const inputContent = tContent(params.message);\n        const streamResponse = this.modelsModule.generateContentStream({\n            model: this.model,\n            contents: this.getHistory(true).concat(inputContent),\n            config: (_a = params.config) !== null && _a !== void 0 ? _a : this.config\n        });\n        // Resolve the internal tracking of send completion promise - `sendPromise`\n        // for both success and failure response. The actual failure is still\n        // propagated by the `await streamResponse`.\n        this.sendPromise = streamResponse.then(()=>undefined).catch(()=>undefined);\n        const response = await streamResponse;\n        const result = this.processStreamResponse(response, inputContent);\n        return result;\n    }\n    /**\n     * Returns the chat history.\n     *\n     * @remarks\n     * The history is a list of contents alternating between user and model.\n     *\n     * There are two types of history:\n     * - The `curated history` contains only the valid turns between user and\n     * model, which will be included in the subsequent requests sent to the model.\n     * - The `comprehensive history` contains all turns, including invalid or\n     *   empty model outputs, providing a complete record of the history.\n     *\n     * The history is updated after receiving the response from the model,\n     * for streaming response, it means receiving the last chunk of the response.\n     *\n     * The `comprehensive history` is returned by default. To get the `curated\n     * history`, set the `curated` parameter to `true`.\n     *\n     * @param curated - whether to return the curated history or the comprehensive\n     *     history.\n     * @return History contents alternating between user and model for the entire\n     *     chat session.\n     */ getHistory(curated = false) {\n        const history = curated ? extractCuratedHistory(this.history) : this.history;\n        // Deep copy the history to avoid mutating the history outside of the\n        // chat session.\n        return structuredClone(history);\n    }\n    processStreamResponse(streamResponse, inputContent) {\n        var _a, _b;\n        return __asyncGenerator(this, arguments, function* processStreamResponse_1() {\n            var _c, e_1, _d, _e;\n            const outputContent = [];\n            try {\n                for(var _f = true, streamResponse_1 = __asyncValues(streamResponse), streamResponse_1_1; streamResponse_1_1 = yield __await(streamResponse_1.next()), _c = streamResponse_1_1.done, !_c; _f = true){\n                    _e = streamResponse_1_1.value;\n                    _f = false;\n                    const chunk = _e;\n                    if (isValidResponse(chunk)) {\n                        const content = (_b = (_a = chunk.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content;\n                        if (content !== undefined) {\n                            outputContent.push(content);\n                        }\n                    }\n                    yield yield __await(chunk);\n                }\n            } catch (e_1_1) {\n                e_1 = {\n                    error: e_1_1\n                };\n            } finally{\n                try {\n                    if (!_f && !_c && (_d = streamResponse_1.return)) yield __await(_d.call(streamResponse_1));\n                } finally{\n                    if (e_1) throw e_1.error;\n                }\n            }\n            this.recordHistory(inputContent, outputContent);\n        });\n    }\n    recordHistory(userInput, modelOutput, automaticFunctionCallingHistory) {\n        let outputContents = [];\n        if (modelOutput.length > 0 && modelOutput.every((content)=>content.role !== undefined)) {\n            outputContents = modelOutput;\n        } else {\n            // Appends an empty content when model returns empty response, so that the\n            // history is always alternating between user and model.\n            outputContents.push({\n                role: \"model\",\n                parts: []\n            });\n        }\n        if (automaticFunctionCallingHistory && automaticFunctionCallingHistory.length > 0) {\n            this.history.push(...extractCuratedHistory(automaticFunctionCallingHistory));\n        } else {\n            this.history.push(userInput);\n        }\n        this.history.push(...outputContents);\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ /**\n * API errors raised by the GenAI API.\n */ class ApiError extends Error {\n    constructor(options){\n        super(options.message);\n        this.name = \"ApiError\";\n        this.status = options.status;\n        Object.setPrototypeOf(this, ApiError.prototype);\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ // Code generated by the Google Gen AI SDK generator DO NOT EDIT.\nfunction listFilesConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, [\n        \"pageSize\"\n    ]);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageSize\"\n        ], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, [\n        \"pageToken\"\n    ]);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageToken\"\n        ], fromPageToken);\n    }\n    return toObject;\n}\nfunction listFilesParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], listFilesConfigToMldev(fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction fileStatusToMldev(fromObject) {\n    const toObject = {};\n    const fromDetails = getValueByPath(fromObject, [\n        \"details\"\n    ]);\n    if (fromDetails != null) {\n        setValueByPath(toObject, [\n            \"details\"\n        ], fromDetails);\n    }\n    const fromMessage = getValueByPath(fromObject, [\n        \"message\"\n    ]);\n    if (fromMessage != null) {\n        setValueByPath(toObject, [\n            \"message\"\n        ], fromMessage);\n    }\n    const fromCode = getValueByPath(fromObject, [\n        \"code\"\n    ]);\n    if (fromCode != null) {\n        setValueByPath(toObject, [\n            \"code\"\n        ], fromCode);\n    }\n    return toObject;\n}\nfunction fileToMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    const fromSizeBytes = getValueByPath(fromObject, [\n        \"sizeBytes\"\n    ]);\n    if (fromSizeBytes != null) {\n        setValueByPath(toObject, [\n            \"sizeBytes\"\n        ], fromSizeBytes);\n    }\n    const fromCreateTime = getValueByPath(fromObject, [\n        \"createTime\"\n    ]);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, [\n            \"createTime\"\n        ], fromCreateTime);\n    }\n    const fromExpirationTime = getValueByPath(fromObject, [\n        \"expirationTime\"\n    ]);\n    if (fromExpirationTime != null) {\n        setValueByPath(toObject, [\n            \"expirationTime\"\n        ], fromExpirationTime);\n    }\n    const fromUpdateTime = getValueByPath(fromObject, [\n        \"updateTime\"\n    ]);\n    if (fromUpdateTime != null) {\n        setValueByPath(toObject, [\n            \"updateTime\"\n        ], fromUpdateTime);\n    }\n    const fromSha256Hash = getValueByPath(fromObject, [\n        \"sha256Hash\"\n    ]);\n    if (fromSha256Hash != null) {\n        setValueByPath(toObject, [\n            \"sha256Hash\"\n        ], fromSha256Hash);\n    }\n    const fromUri = getValueByPath(fromObject, [\n        \"uri\"\n    ]);\n    if (fromUri != null) {\n        setValueByPath(toObject, [\n            \"uri\"\n        ], fromUri);\n    }\n    const fromDownloadUri = getValueByPath(fromObject, [\n        \"downloadUri\"\n    ]);\n    if (fromDownloadUri != null) {\n        setValueByPath(toObject, [\n            \"downloadUri\"\n        ], fromDownloadUri);\n    }\n    const fromState = getValueByPath(fromObject, [\n        \"state\"\n    ]);\n    if (fromState != null) {\n        setValueByPath(toObject, [\n            \"state\"\n        ], fromState);\n    }\n    const fromSource = getValueByPath(fromObject, [\n        \"source\"\n    ]);\n    if (fromSource != null) {\n        setValueByPath(toObject, [\n            \"source\"\n        ], fromSource);\n    }\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        \"videoMetadata\"\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, [\n            \"videoMetadata\"\n        ], fromVideoMetadata);\n    }\n    const fromError = getValueByPath(fromObject, [\n        \"error\"\n    ]);\n    if (fromError != null) {\n        setValueByPath(toObject, [\n            \"error\"\n        ], fileStatusToMldev(fromError));\n    }\n    return toObject;\n}\nfunction createFileParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromFile = getValueByPath(fromObject, [\n        \"file\"\n    ]);\n    if (fromFile != null) {\n        setValueByPath(toObject, [\n            \"file\"\n        ], fileToMldev(fromFile));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], fromConfig);\n    }\n    return toObject;\n}\nfunction getFileParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"file\"\n        ], tFileName(fromName));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], fromConfig);\n    }\n    return toObject;\n}\nfunction deleteFileParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"file\"\n        ], tFileName(fromName));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], fromConfig);\n    }\n    return toObject;\n}\nfunction fileStatusFromMldev(fromObject) {\n    const toObject = {};\n    const fromDetails = getValueByPath(fromObject, [\n        \"details\"\n    ]);\n    if (fromDetails != null) {\n        setValueByPath(toObject, [\n            \"details\"\n        ], fromDetails);\n    }\n    const fromMessage = getValueByPath(fromObject, [\n        \"message\"\n    ]);\n    if (fromMessage != null) {\n        setValueByPath(toObject, [\n            \"message\"\n        ], fromMessage);\n    }\n    const fromCode = getValueByPath(fromObject, [\n        \"code\"\n    ]);\n    if (fromCode != null) {\n        setValueByPath(toObject, [\n            \"code\"\n        ], fromCode);\n    }\n    return toObject;\n}\nfunction fileFromMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    const fromSizeBytes = getValueByPath(fromObject, [\n        \"sizeBytes\"\n    ]);\n    if (fromSizeBytes != null) {\n        setValueByPath(toObject, [\n            \"sizeBytes\"\n        ], fromSizeBytes);\n    }\n    const fromCreateTime = getValueByPath(fromObject, [\n        \"createTime\"\n    ]);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, [\n            \"createTime\"\n        ], fromCreateTime);\n    }\n    const fromExpirationTime = getValueByPath(fromObject, [\n        \"expirationTime\"\n    ]);\n    if (fromExpirationTime != null) {\n        setValueByPath(toObject, [\n            \"expirationTime\"\n        ], fromExpirationTime);\n    }\n    const fromUpdateTime = getValueByPath(fromObject, [\n        \"updateTime\"\n    ]);\n    if (fromUpdateTime != null) {\n        setValueByPath(toObject, [\n            \"updateTime\"\n        ], fromUpdateTime);\n    }\n    const fromSha256Hash = getValueByPath(fromObject, [\n        \"sha256Hash\"\n    ]);\n    if (fromSha256Hash != null) {\n        setValueByPath(toObject, [\n            \"sha256Hash\"\n        ], fromSha256Hash);\n    }\n    const fromUri = getValueByPath(fromObject, [\n        \"uri\"\n    ]);\n    if (fromUri != null) {\n        setValueByPath(toObject, [\n            \"uri\"\n        ], fromUri);\n    }\n    const fromDownloadUri = getValueByPath(fromObject, [\n        \"downloadUri\"\n    ]);\n    if (fromDownloadUri != null) {\n        setValueByPath(toObject, [\n            \"downloadUri\"\n        ], fromDownloadUri);\n    }\n    const fromState = getValueByPath(fromObject, [\n        \"state\"\n    ]);\n    if (fromState != null) {\n        setValueByPath(toObject, [\n            \"state\"\n        ], fromState);\n    }\n    const fromSource = getValueByPath(fromObject, [\n        \"source\"\n    ]);\n    if (fromSource != null) {\n        setValueByPath(toObject, [\n            \"source\"\n        ], fromSource);\n    }\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        \"videoMetadata\"\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, [\n            \"videoMetadata\"\n        ], fromVideoMetadata);\n    }\n    const fromError = getValueByPath(fromObject, [\n        \"error\"\n    ]);\n    if (fromError != null) {\n        setValueByPath(toObject, [\n            \"error\"\n        ], fileStatusFromMldev(fromError));\n    }\n    return toObject;\n}\nfunction listFilesResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromNextPageToken = getValueByPath(fromObject, [\n        \"nextPageToken\"\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, [\n            \"nextPageToken\"\n        ], fromNextPageToken);\n    }\n    const fromFiles = getValueByPath(fromObject, [\n        \"files\"\n    ]);\n    if (fromFiles != null) {\n        let transformedList = fromFiles;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return fileFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"files\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction createFileResponseFromMldev() {\n    const toObject = {};\n    return toObject;\n}\nfunction deleteFileResponseFromMldev() {\n    const toObject = {};\n    return toObject;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ class Files extends BaseModule {\n    constructor(apiClient){\n        super();\n        this.apiClient = apiClient;\n        /**\n         * Lists all current project files from the service.\n         *\n         * @param params - The parameters for the list request\n         * @return The paginated results of the list of files\n         *\n         * @example\n         * The following code prints the names of all files from the service, the\n         * size of each page is 10.\n         *\n         * ```ts\n         * const listResponse = await ai.files.list({config: {'pageSize': 10}});\n         * for await (const file of listResponse) {\n         *   console.log(file.name);\n         * }\n         * ```\n         */ this.list = async (params = {})=>{\n            return new Pager(PagedItem.PAGED_ITEM_FILES, (x)=>this.listInternal(x), await this.listInternal(params), params);\n        };\n    }\n    /**\n     * Uploads a file asynchronously to the Gemini API.\n     * This method is not available in Vertex AI.\n     * Supported upload sources:\n     * - Node.js: File path (string) or Blob object.\n     * - Browser: Blob object (e.g., File).\n     *\n     * @remarks\n     * The `mimeType` can be specified in the `config` parameter. If omitted:\n     *  - For file path (string) inputs, the `mimeType` will be inferred from the\n     *     file extension.\n     *  - For Blob object inputs, the `mimeType` will be set to the Blob's `type`\n     *     property.\n     * Somex eamples for file extension to mimeType mapping:\n     * .txt -> text/plain\n     * .json -> application/json\n     * .jpg  -> image/jpeg\n     * .png -> image/png\n     * .mp3 -> audio/mpeg\n     * .mp4 -> video/mp4\n     *\n     * This section can contain multiple paragraphs and code examples.\n     *\n     * @param params - Optional parameters specified in the\n     *        `types.UploadFileParameters` interface.\n     *         @see {@link types.UploadFileParameters#config} for the optional\n     *         config in the parameters.\n     * @return A promise that resolves to a `types.File` object.\n     * @throws An error if called on a Vertex AI client.\n     * @throws An error if the `mimeType` is not provided and can not be inferred,\n     * the `mimeType` can be provided in the `params.config` parameter.\n     * @throws An error occurs if a suitable upload location cannot be established.\n     *\n     * @example\n     * The following code uploads a file to Gemini API.\n     *\n     * ```ts\n     * const file = await ai.files.upload({file: 'file.txt', config: {\n     *   mimeType: 'text/plain',\n     * }});\n     * console.log(file.name);\n     * ```\n     */ async upload(params) {\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"Vertex AI does not support uploading files. You can share files through a GCS bucket.\");\n        }\n        return this.apiClient.uploadFile(params.file, params.config).then((response)=>{\n            const file = fileFromMldev(response);\n            return file;\n        });\n    }\n    /**\n     * Downloads a remotely stored file asynchronously to a location specified in\n     * the `params` object. This method only works on Node environment, to\n     * download files in the browser, use a browser compliant method like an <a>\n     * tag.\n     *\n     * @param params - The parameters for the download request.\n     *\n     * @example\n     * The following code downloads an example file named \"files/mehozpxf877d\" as\n     * \"file.txt\".\n     *\n     * ```ts\n     * await ai.files.download({file: file.name, downloadPath: 'file.txt'});\n     * ```\n     */ async download(params) {\n        await this.apiClient.downloadFile(params);\n    }\n    async listInternal(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"This method is only supported by the Gemini Developer API.\");\n        } else {\n            const body = listFilesParametersToMldev(params);\n            path = formatMap(\"files\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = listFilesResponseFromMldev(apiResponse);\n                const typedResp = new ListFilesResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    async createInternal(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"This method is only supported by the Gemini Developer API.\");\n        } else {\n            const body = createFileParametersToMldev(params);\n            path = formatMap(\"upload/v1beta/files\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then(()=>{\n                const resp = createFileResponseFromMldev();\n                const typedResp = new CreateFileResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Retrieves the file information from the service.\n     *\n     * @param params - The parameters for the get request\n     * @return The Promise that resolves to the types.File object requested.\n     *\n     * @example\n     * ```ts\n     * const config: GetFileParameters = {\n     *   name: fileName,\n     * };\n     * file = await ai.files.get(config);\n     * console.log(file.name);\n     * ```\n     */ async get(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"This method is only supported by the Gemini Developer API.\");\n        } else {\n            const body = getFileParametersToMldev(params);\n            path = formatMap(\"files/{file}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = fileFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n    /**\n     * Deletes a remotely stored file.\n     *\n     * @param params - The parameters for the delete request.\n     * @return The DeleteFileResponse, the response for the delete method.\n     *\n     * @example\n     * The following code deletes an example file named \"files/mehozpxf877d\".\n     *\n     * ```ts\n     * await ai.files.delete({name: file.name});\n     * ```\n     */ async delete(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"This method is only supported by the Gemini Developer API.\");\n        } else {\n            const body = deleteFileParametersToMldev(params);\n            path = formatMap(\"files/{file}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"DELETE\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then(()=>{\n                const resp = deleteFileResponseFromMldev();\n                const typedResp = new DeleteFileResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ function prebuiltVoiceConfigToMldev$2(fromObject) {\n    const toObject = {};\n    const fromVoiceName = getValueByPath(fromObject, [\n        \"voiceName\"\n    ]);\n    if (fromVoiceName != null) {\n        setValueByPath(toObject, [\n            \"voiceName\"\n        ], fromVoiceName);\n    }\n    return toObject;\n}\nfunction prebuiltVoiceConfigToVertex$1(fromObject) {\n    const toObject = {};\n    const fromVoiceName = getValueByPath(fromObject, [\n        \"voiceName\"\n    ]);\n    if (fromVoiceName != null) {\n        setValueByPath(toObject, [\n            \"voiceName\"\n        ], fromVoiceName);\n    }\n    return toObject;\n}\nfunction voiceConfigToMldev$2(fromObject) {\n    const toObject = {};\n    const fromPrebuiltVoiceConfig = getValueByPath(fromObject, [\n        \"prebuiltVoiceConfig\"\n    ]);\n    if (fromPrebuiltVoiceConfig != null) {\n        setValueByPath(toObject, [\n            \"prebuiltVoiceConfig\"\n        ], prebuiltVoiceConfigToMldev$2(fromPrebuiltVoiceConfig));\n    }\n    return toObject;\n}\nfunction voiceConfigToVertex$1(fromObject) {\n    const toObject = {};\n    const fromPrebuiltVoiceConfig = getValueByPath(fromObject, [\n        \"prebuiltVoiceConfig\"\n    ]);\n    if (fromPrebuiltVoiceConfig != null) {\n        setValueByPath(toObject, [\n            \"prebuiltVoiceConfig\"\n        ], prebuiltVoiceConfigToVertex$1(fromPrebuiltVoiceConfig));\n    }\n    return toObject;\n}\nfunction speakerVoiceConfigToMldev$2(fromObject) {\n    const toObject = {};\n    const fromSpeaker = getValueByPath(fromObject, [\n        \"speaker\"\n    ]);\n    if (fromSpeaker != null) {\n        setValueByPath(toObject, [\n            \"speaker\"\n        ], fromSpeaker);\n    }\n    const fromVoiceConfig = getValueByPath(fromObject, [\n        \"voiceConfig\"\n    ]);\n    if (fromVoiceConfig != null) {\n        setValueByPath(toObject, [\n            \"voiceConfig\"\n        ], voiceConfigToMldev$2(fromVoiceConfig));\n    }\n    return toObject;\n}\nfunction multiSpeakerVoiceConfigToMldev$2(fromObject) {\n    const toObject = {};\n    const fromSpeakerVoiceConfigs = getValueByPath(fromObject, [\n        \"speakerVoiceConfigs\"\n    ]);\n    if (fromSpeakerVoiceConfigs != null) {\n        let transformedList = fromSpeakerVoiceConfigs;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return speakerVoiceConfigToMldev$2(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"speakerVoiceConfigs\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction speechConfigToMldev$2(fromObject) {\n    const toObject = {};\n    const fromVoiceConfig = getValueByPath(fromObject, [\n        \"voiceConfig\"\n    ]);\n    if (fromVoiceConfig != null) {\n        setValueByPath(toObject, [\n            \"voiceConfig\"\n        ], voiceConfigToMldev$2(fromVoiceConfig));\n    }\n    const fromMultiSpeakerVoiceConfig = getValueByPath(fromObject, [\n        \"multiSpeakerVoiceConfig\"\n    ]);\n    if (fromMultiSpeakerVoiceConfig != null) {\n        setValueByPath(toObject, [\n            \"multiSpeakerVoiceConfig\"\n        ], multiSpeakerVoiceConfigToMldev$2(fromMultiSpeakerVoiceConfig));\n    }\n    const fromLanguageCode = getValueByPath(fromObject, [\n        \"languageCode\"\n    ]);\n    if (fromLanguageCode != null) {\n        setValueByPath(toObject, [\n            \"languageCode\"\n        ], fromLanguageCode);\n    }\n    return toObject;\n}\nfunction speechConfigToVertex$1(fromObject) {\n    const toObject = {};\n    const fromVoiceConfig = getValueByPath(fromObject, [\n        \"voiceConfig\"\n    ]);\n    if (fromVoiceConfig != null) {\n        setValueByPath(toObject, [\n            \"voiceConfig\"\n        ], voiceConfigToVertex$1(fromVoiceConfig));\n    }\n    if (getValueByPath(fromObject, [\n        \"multiSpeakerVoiceConfig\"\n    ]) !== undefined) {\n        throw new Error(\"multiSpeakerVoiceConfig parameter is not supported in Vertex AI.\");\n    }\n    const fromLanguageCode = getValueByPath(fromObject, [\n        \"languageCode\"\n    ]);\n    if (fromLanguageCode != null) {\n        setValueByPath(toObject, [\n            \"languageCode\"\n        ], fromLanguageCode);\n    }\n    return toObject;\n}\nfunction videoMetadataToMldev$2(fromObject) {\n    const toObject = {};\n    const fromFps = getValueByPath(fromObject, [\n        \"fps\"\n    ]);\n    if (fromFps != null) {\n        setValueByPath(toObject, [\n            \"fps\"\n        ], fromFps);\n    }\n    const fromEndOffset = getValueByPath(fromObject, [\n        \"endOffset\"\n    ]);\n    if (fromEndOffset != null) {\n        setValueByPath(toObject, [\n            \"endOffset\"\n        ], fromEndOffset);\n    }\n    const fromStartOffset = getValueByPath(fromObject, [\n        \"startOffset\"\n    ]);\n    if (fromStartOffset != null) {\n        setValueByPath(toObject, [\n            \"startOffset\"\n        ], fromStartOffset);\n    }\n    return toObject;\n}\nfunction videoMetadataToVertex$1(fromObject) {\n    const toObject = {};\n    const fromFps = getValueByPath(fromObject, [\n        \"fps\"\n    ]);\n    if (fromFps != null) {\n        setValueByPath(toObject, [\n            \"fps\"\n        ], fromFps);\n    }\n    const fromEndOffset = getValueByPath(fromObject, [\n        \"endOffset\"\n    ]);\n    if (fromEndOffset != null) {\n        setValueByPath(toObject, [\n            \"endOffset\"\n        ], fromEndOffset);\n    }\n    const fromStartOffset = getValueByPath(fromObject, [\n        \"startOffset\"\n    ]);\n    if (fromStartOffset != null) {\n        setValueByPath(toObject, [\n            \"startOffset\"\n        ], fromStartOffset);\n    }\n    return toObject;\n}\nfunction blobToMldev$2(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"displayName\"\n    ]) !== undefined) {\n        throw new Error(\"displayName parameter is not supported in Gemini API.\");\n    }\n    const fromData = getValueByPath(fromObject, [\n        \"data\"\n    ]);\n    if (fromData != null) {\n        setValueByPath(toObject, [\n            \"data\"\n        ], fromData);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction blobToVertex$1(fromObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromData = getValueByPath(fromObject, [\n        \"data\"\n    ]);\n    if (fromData != null) {\n        setValueByPath(toObject, [\n            \"data\"\n        ], fromData);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction fileDataToMldev$2(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"displayName\"\n    ]) !== undefined) {\n        throw new Error(\"displayName parameter is not supported in Gemini API.\");\n    }\n    const fromFileUri = getValueByPath(fromObject, [\n        \"fileUri\"\n    ]);\n    if (fromFileUri != null) {\n        setValueByPath(toObject, [\n            \"fileUri\"\n        ], fromFileUri);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction fileDataToVertex$1(fromObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromFileUri = getValueByPath(fromObject, [\n        \"fileUri\"\n    ]);\n    if (fromFileUri != null) {\n        setValueByPath(toObject, [\n            \"fileUri\"\n        ], fromFileUri);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction partToMldev$2(fromObject) {\n    const toObject = {};\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        \"videoMetadata\"\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, [\n            \"videoMetadata\"\n        ], videoMetadataToMldev$2(fromVideoMetadata));\n    }\n    const fromThought = getValueByPath(fromObject, [\n        \"thought\"\n    ]);\n    if (fromThought != null) {\n        setValueByPath(toObject, [\n            \"thought\"\n        ], fromThought);\n    }\n    const fromInlineData = getValueByPath(fromObject, [\n        \"inlineData\"\n    ]);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, [\n            \"inlineData\"\n        ], blobToMldev$2(fromInlineData));\n    }\n    const fromFileData = getValueByPath(fromObject, [\n        \"fileData\"\n    ]);\n    if (fromFileData != null) {\n        setValueByPath(toObject, [\n            \"fileData\"\n        ], fileDataToMldev$2(fromFileData));\n    }\n    const fromThoughtSignature = getValueByPath(fromObject, [\n        \"thoughtSignature\"\n    ]);\n    if (fromThoughtSignature != null) {\n        setValueByPath(toObject, [\n            \"thoughtSignature\"\n        ], fromThoughtSignature);\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        \"codeExecutionResult\"\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, [\n            \"codeExecutionResult\"\n        ], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        \"executableCode\"\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, [\n            \"executableCode\"\n        ], fromExecutableCode);\n    }\n    const fromFunctionCall = getValueByPath(fromObject, [\n        \"functionCall\"\n    ]);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, [\n            \"functionCall\"\n        ], fromFunctionCall);\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        \"functionResponse\"\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, [\n            \"functionResponse\"\n        ], fromFunctionResponse);\n    }\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    return toObject;\n}\nfunction partToVertex$1(fromObject) {\n    const toObject = {};\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        \"videoMetadata\"\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, [\n            \"videoMetadata\"\n        ], videoMetadataToVertex$1(fromVideoMetadata));\n    }\n    const fromThought = getValueByPath(fromObject, [\n        \"thought\"\n    ]);\n    if (fromThought != null) {\n        setValueByPath(toObject, [\n            \"thought\"\n        ], fromThought);\n    }\n    const fromInlineData = getValueByPath(fromObject, [\n        \"inlineData\"\n    ]);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, [\n            \"inlineData\"\n        ], blobToVertex$1(fromInlineData));\n    }\n    const fromFileData = getValueByPath(fromObject, [\n        \"fileData\"\n    ]);\n    if (fromFileData != null) {\n        setValueByPath(toObject, [\n            \"fileData\"\n        ], fileDataToVertex$1(fromFileData));\n    }\n    const fromThoughtSignature = getValueByPath(fromObject, [\n        \"thoughtSignature\"\n    ]);\n    if (fromThoughtSignature != null) {\n        setValueByPath(toObject, [\n            \"thoughtSignature\"\n        ], fromThoughtSignature);\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        \"codeExecutionResult\"\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, [\n            \"codeExecutionResult\"\n        ], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        \"executableCode\"\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, [\n            \"executableCode\"\n        ], fromExecutableCode);\n    }\n    const fromFunctionCall = getValueByPath(fromObject, [\n        \"functionCall\"\n    ]);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, [\n            \"functionCall\"\n        ], fromFunctionCall);\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        \"functionResponse\"\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, [\n            \"functionResponse\"\n        ], fromFunctionResponse);\n    }\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    return toObject;\n}\nfunction contentToMldev$2(fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, [\n        \"parts\"\n    ]);\n    if (fromParts != null) {\n        let transformedList = fromParts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return partToMldev$2(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"parts\"\n        ], transformedList);\n    }\n    const fromRole = getValueByPath(fromObject, [\n        \"role\"\n    ]);\n    if (fromRole != null) {\n        setValueByPath(toObject, [\n            \"role\"\n        ], fromRole);\n    }\n    return toObject;\n}\nfunction contentToVertex$1(fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, [\n        \"parts\"\n    ]);\n    if (fromParts != null) {\n        let transformedList = fromParts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return partToVertex$1(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"parts\"\n        ], transformedList);\n    }\n    const fromRole = getValueByPath(fromObject, [\n        \"role\"\n    ]);\n    if (fromRole != null) {\n        setValueByPath(toObject, [\n            \"role\"\n        ], fromRole);\n    }\n    return toObject;\n}\nfunction functionDeclarationToMldev$2(fromObject) {\n    const toObject = {};\n    const fromBehavior = getValueByPath(fromObject, [\n        \"behavior\"\n    ]);\n    if (fromBehavior != null) {\n        setValueByPath(toObject, [\n            \"behavior\"\n        ], fromBehavior);\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (fromDescription != null) {\n        setValueByPath(toObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromParameters = getValueByPath(fromObject, [\n        \"parameters\"\n    ]);\n    if (fromParameters != null) {\n        setValueByPath(toObject, [\n            \"parameters\"\n        ], fromParameters);\n    }\n    const fromParametersJsonSchema = getValueByPath(fromObject, [\n        \"parametersJsonSchema\"\n    ]);\n    if (fromParametersJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"parametersJsonSchema\"\n        ], fromParametersJsonSchema);\n    }\n    const fromResponse = getValueByPath(fromObject, [\n        \"response\"\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, [\n            \"response\"\n        ], fromResponse);\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        \"responseJsonSchema\"\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"responseJsonSchema\"\n        ], fromResponseJsonSchema);\n    }\n    return toObject;\n}\nfunction functionDeclarationToVertex$1(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"behavior\"\n    ]) !== undefined) {\n        throw new Error(\"behavior parameter is not supported in Vertex AI.\");\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (fromDescription != null) {\n        setValueByPath(toObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromParameters = getValueByPath(fromObject, [\n        \"parameters\"\n    ]);\n    if (fromParameters != null) {\n        setValueByPath(toObject, [\n            \"parameters\"\n        ], fromParameters);\n    }\n    const fromParametersJsonSchema = getValueByPath(fromObject, [\n        \"parametersJsonSchema\"\n    ]);\n    if (fromParametersJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"parametersJsonSchema\"\n        ], fromParametersJsonSchema);\n    }\n    const fromResponse = getValueByPath(fromObject, [\n        \"response\"\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, [\n            \"response\"\n        ], fromResponse);\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        \"responseJsonSchema\"\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"responseJsonSchema\"\n        ], fromResponseJsonSchema);\n    }\n    return toObject;\n}\nfunction intervalToMldev$2(fromObject) {\n    const toObject = {};\n    const fromStartTime = getValueByPath(fromObject, [\n        \"startTime\"\n    ]);\n    if (fromStartTime != null) {\n        setValueByPath(toObject, [\n            \"startTime\"\n        ], fromStartTime);\n    }\n    const fromEndTime = getValueByPath(fromObject, [\n        \"endTime\"\n    ]);\n    if (fromEndTime != null) {\n        setValueByPath(toObject, [\n            \"endTime\"\n        ], fromEndTime);\n    }\n    return toObject;\n}\nfunction intervalToVertex$1(fromObject) {\n    const toObject = {};\n    const fromStartTime = getValueByPath(fromObject, [\n        \"startTime\"\n    ]);\n    if (fromStartTime != null) {\n        setValueByPath(toObject, [\n            \"startTime\"\n        ], fromStartTime);\n    }\n    const fromEndTime = getValueByPath(fromObject, [\n        \"endTime\"\n    ]);\n    if (fromEndTime != null) {\n        setValueByPath(toObject, [\n            \"endTime\"\n        ], fromEndTime);\n    }\n    return toObject;\n}\nfunction googleSearchToMldev$2(fromObject) {\n    const toObject = {};\n    const fromTimeRangeFilter = getValueByPath(fromObject, [\n        \"timeRangeFilter\"\n    ]);\n    if (fromTimeRangeFilter != null) {\n        setValueByPath(toObject, [\n            \"timeRangeFilter\"\n        ], intervalToMldev$2(fromTimeRangeFilter));\n    }\n    return toObject;\n}\nfunction googleSearchToVertex$1(fromObject) {\n    const toObject = {};\n    const fromTimeRangeFilter = getValueByPath(fromObject, [\n        \"timeRangeFilter\"\n    ]);\n    if (fromTimeRangeFilter != null) {\n        setValueByPath(toObject, [\n            \"timeRangeFilter\"\n        ], intervalToVertex$1(fromTimeRangeFilter));\n    }\n    return toObject;\n}\nfunction dynamicRetrievalConfigToMldev$2(fromObject) {\n    const toObject = {};\n    const fromMode = getValueByPath(fromObject, [\n        \"mode\"\n    ]);\n    if (fromMode != null) {\n        setValueByPath(toObject, [\n            \"mode\"\n        ], fromMode);\n    }\n    const fromDynamicThreshold = getValueByPath(fromObject, [\n        \"dynamicThreshold\"\n    ]);\n    if (fromDynamicThreshold != null) {\n        setValueByPath(toObject, [\n            \"dynamicThreshold\"\n        ], fromDynamicThreshold);\n    }\n    return toObject;\n}\nfunction dynamicRetrievalConfigToVertex$1(fromObject) {\n    const toObject = {};\n    const fromMode = getValueByPath(fromObject, [\n        \"mode\"\n    ]);\n    if (fromMode != null) {\n        setValueByPath(toObject, [\n            \"mode\"\n        ], fromMode);\n    }\n    const fromDynamicThreshold = getValueByPath(fromObject, [\n        \"dynamicThreshold\"\n    ]);\n    if (fromDynamicThreshold != null) {\n        setValueByPath(toObject, [\n            \"dynamicThreshold\"\n        ], fromDynamicThreshold);\n    }\n    return toObject;\n}\nfunction googleSearchRetrievalToMldev$2(fromObject) {\n    const toObject = {};\n    const fromDynamicRetrievalConfig = getValueByPath(fromObject, [\n        \"dynamicRetrievalConfig\"\n    ]);\n    if (fromDynamicRetrievalConfig != null) {\n        setValueByPath(toObject, [\n            \"dynamicRetrievalConfig\"\n        ], dynamicRetrievalConfigToMldev$2(fromDynamicRetrievalConfig));\n    }\n    return toObject;\n}\nfunction googleSearchRetrievalToVertex$1(fromObject) {\n    const toObject = {};\n    const fromDynamicRetrievalConfig = getValueByPath(fromObject, [\n        \"dynamicRetrievalConfig\"\n    ]);\n    if (fromDynamicRetrievalConfig != null) {\n        setValueByPath(toObject, [\n            \"dynamicRetrievalConfig\"\n        ], dynamicRetrievalConfigToVertex$1(fromDynamicRetrievalConfig));\n    }\n    return toObject;\n}\nfunction enterpriseWebSearchToVertex$1() {\n    const toObject = {};\n    return toObject;\n}\nfunction apiKeyConfigToVertex$1(fromObject) {\n    const toObject = {};\n    const fromApiKeyString = getValueByPath(fromObject, [\n        \"apiKeyString\"\n    ]);\n    if (fromApiKeyString != null) {\n        setValueByPath(toObject, [\n            \"apiKeyString\"\n        ], fromApiKeyString);\n    }\n    return toObject;\n}\nfunction authConfigToVertex$1(fromObject) {\n    const toObject = {};\n    const fromApiKeyConfig = getValueByPath(fromObject, [\n        \"apiKeyConfig\"\n    ]);\n    if (fromApiKeyConfig != null) {\n        setValueByPath(toObject, [\n            \"apiKeyConfig\"\n        ], apiKeyConfigToVertex$1(fromApiKeyConfig));\n    }\n    const fromAuthType = getValueByPath(fromObject, [\n        \"authType\"\n    ]);\n    if (fromAuthType != null) {\n        setValueByPath(toObject, [\n            \"authType\"\n        ], fromAuthType);\n    }\n    const fromGoogleServiceAccountConfig = getValueByPath(fromObject, [\n        \"googleServiceAccountConfig\"\n    ]);\n    if (fromGoogleServiceAccountConfig != null) {\n        setValueByPath(toObject, [\n            \"googleServiceAccountConfig\"\n        ], fromGoogleServiceAccountConfig);\n    }\n    const fromHttpBasicAuthConfig = getValueByPath(fromObject, [\n        \"httpBasicAuthConfig\"\n    ]);\n    if (fromHttpBasicAuthConfig != null) {\n        setValueByPath(toObject, [\n            \"httpBasicAuthConfig\"\n        ], fromHttpBasicAuthConfig);\n    }\n    const fromOauthConfig = getValueByPath(fromObject, [\n        \"oauthConfig\"\n    ]);\n    if (fromOauthConfig != null) {\n        setValueByPath(toObject, [\n            \"oauthConfig\"\n        ], fromOauthConfig);\n    }\n    const fromOidcConfig = getValueByPath(fromObject, [\n        \"oidcConfig\"\n    ]);\n    if (fromOidcConfig != null) {\n        setValueByPath(toObject, [\n            \"oidcConfig\"\n        ], fromOidcConfig);\n    }\n    return toObject;\n}\nfunction googleMapsToVertex$1(fromObject) {\n    const toObject = {};\n    const fromAuthConfig = getValueByPath(fromObject, [\n        \"authConfig\"\n    ]);\n    if (fromAuthConfig != null) {\n        setValueByPath(toObject, [\n            \"authConfig\"\n        ], authConfigToVertex$1(fromAuthConfig));\n    }\n    return toObject;\n}\nfunction urlContextToMldev$2() {\n    const toObject = {};\n    return toObject;\n}\nfunction urlContextToVertex$1() {\n    const toObject = {};\n    return toObject;\n}\nfunction toolToMldev$2(fromObject) {\n    const toObject = {};\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        \"functionDeclarations\"\n    ]);\n    if (fromFunctionDeclarations != null) {\n        let transformedList = fromFunctionDeclarations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return functionDeclarationToMldev$2(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"functionDeclarations\"\n        ], transformedList);\n    }\n    if (getValueByPath(fromObject, [\n        \"retrieval\"\n    ]) !== undefined) {\n        throw new Error(\"retrieval parameter is not supported in Gemini API.\");\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, [\n        \"googleSearch\"\n    ]);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, [\n            \"googleSearch\"\n        ], googleSearchToMldev$2(fromGoogleSearch));\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        \"googleSearchRetrieval\"\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, [\n            \"googleSearchRetrieval\"\n        ], googleSearchRetrievalToMldev$2(fromGoogleSearchRetrieval));\n    }\n    if (getValueByPath(fromObject, [\n        \"enterpriseWebSearch\"\n    ]) !== undefined) {\n        throw new Error(\"enterpriseWebSearch parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"googleMaps\"\n    ]) !== undefined) {\n        throw new Error(\"googleMaps parameter is not supported in Gemini API.\");\n    }\n    const fromUrlContext = getValueByPath(fromObject, [\n        \"urlContext\"\n    ]);\n    if (fromUrlContext != null) {\n        setValueByPath(toObject, [\n            \"urlContext\"\n        ], urlContextToMldev$2());\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        \"codeExecution\"\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, [\n            \"codeExecution\"\n        ], fromCodeExecution);\n    }\n    return toObject;\n}\nfunction toolToVertex$1(fromObject) {\n    const toObject = {};\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        \"functionDeclarations\"\n    ]);\n    if (fromFunctionDeclarations != null) {\n        let transformedList = fromFunctionDeclarations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return functionDeclarationToVertex$1(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"functionDeclarations\"\n        ], transformedList);\n    }\n    const fromRetrieval = getValueByPath(fromObject, [\n        \"retrieval\"\n    ]);\n    if (fromRetrieval != null) {\n        setValueByPath(toObject, [\n            \"retrieval\"\n        ], fromRetrieval);\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, [\n        \"googleSearch\"\n    ]);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, [\n            \"googleSearch\"\n        ], googleSearchToVertex$1(fromGoogleSearch));\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        \"googleSearchRetrieval\"\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, [\n            \"googleSearchRetrieval\"\n        ], googleSearchRetrievalToVertex$1(fromGoogleSearchRetrieval));\n    }\n    const fromEnterpriseWebSearch = getValueByPath(fromObject, [\n        \"enterpriseWebSearch\"\n    ]);\n    if (fromEnterpriseWebSearch != null) {\n        setValueByPath(toObject, [\n            \"enterpriseWebSearch\"\n        ], enterpriseWebSearchToVertex$1());\n    }\n    const fromGoogleMaps = getValueByPath(fromObject, [\n        \"googleMaps\"\n    ]);\n    if (fromGoogleMaps != null) {\n        setValueByPath(toObject, [\n            \"googleMaps\"\n        ], googleMapsToVertex$1(fromGoogleMaps));\n    }\n    const fromUrlContext = getValueByPath(fromObject, [\n        \"urlContext\"\n    ]);\n    if (fromUrlContext != null) {\n        setValueByPath(toObject, [\n            \"urlContext\"\n        ], urlContextToVertex$1());\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        \"codeExecution\"\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, [\n            \"codeExecution\"\n        ], fromCodeExecution);\n    }\n    return toObject;\n}\nfunction sessionResumptionConfigToMldev$1(fromObject) {\n    const toObject = {};\n    const fromHandle = getValueByPath(fromObject, [\n        \"handle\"\n    ]);\n    if (fromHandle != null) {\n        setValueByPath(toObject, [\n            \"handle\"\n        ], fromHandle);\n    }\n    if (getValueByPath(fromObject, [\n        \"transparent\"\n    ]) !== undefined) {\n        throw new Error(\"transparent parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction sessionResumptionConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromHandle = getValueByPath(fromObject, [\n        \"handle\"\n    ]);\n    if (fromHandle != null) {\n        setValueByPath(toObject, [\n            \"handle\"\n        ], fromHandle);\n    }\n    const fromTransparent = getValueByPath(fromObject, [\n        \"transparent\"\n    ]);\n    if (fromTransparent != null) {\n        setValueByPath(toObject, [\n            \"transparent\"\n        ], fromTransparent);\n    }\n    return toObject;\n}\nfunction audioTranscriptionConfigToMldev$1() {\n    const toObject = {};\n    return toObject;\n}\nfunction audioTranscriptionConfigToVertex() {\n    const toObject = {};\n    return toObject;\n}\nfunction automaticActivityDetectionToMldev$1(fromObject) {\n    const toObject = {};\n    const fromDisabled = getValueByPath(fromObject, [\n        \"disabled\"\n    ]);\n    if (fromDisabled != null) {\n        setValueByPath(toObject, [\n            \"disabled\"\n        ], fromDisabled);\n    }\n    const fromStartOfSpeechSensitivity = getValueByPath(fromObject, [\n        \"startOfSpeechSensitivity\"\n    ]);\n    if (fromStartOfSpeechSensitivity != null) {\n        setValueByPath(toObject, [\n            \"startOfSpeechSensitivity\"\n        ], fromStartOfSpeechSensitivity);\n    }\n    const fromEndOfSpeechSensitivity = getValueByPath(fromObject, [\n        \"endOfSpeechSensitivity\"\n    ]);\n    if (fromEndOfSpeechSensitivity != null) {\n        setValueByPath(toObject, [\n            \"endOfSpeechSensitivity\"\n        ], fromEndOfSpeechSensitivity);\n    }\n    const fromPrefixPaddingMs = getValueByPath(fromObject, [\n        \"prefixPaddingMs\"\n    ]);\n    if (fromPrefixPaddingMs != null) {\n        setValueByPath(toObject, [\n            \"prefixPaddingMs\"\n        ], fromPrefixPaddingMs);\n    }\n    const fromSilenceDurationMs = getValueByPath(fromObject, [\n        \"silenceDurationMs\"\n    ]);\n    if (fromSilenceDurationMs != null) {\n        setValueByPath(toObject, [\n            \"silenceDurationMs\"\n        ], fromSilenceDurationMs);\n    }\n    return toObject;\n}\nfunction automaticActivityDetectionToVertex(fromObject) {\n    const toObject = {};\n    const fromDisabled = getValueByPath(fromObject, [\n        \"disabled\"\n    ]);\n    if (fromDisabled != null) {\n        setValueByPath(toObject, [\n            \"disabled\"\n        ], fromDisabled);\n    }\n    const fromStartOfSpeechSensitivity = getValueByPath(fromObject, [\n        \"startOfSpeechSensitivity\"\n    ]);\n    if (fromStartOfSpeechSensitivity != null) {\n        setValueByPath(toObject, [\n            \"startOfSpeechSensitivity\"\n        ], fromStartOfSpeechSensitivity);\n    }\n    const fromEndOfSpeechSensitivity = getValueByPath(fromObject, [\n        \"endOfSpeechSensitivity\"\n    ]);\n    if (fromEndOfSpeechSensitivity != null) {\n        setValueByPath(toObject, [\n            \"endOfSpeechSensitivity\"\n        ], fromEndOfSpeechSensitivity);\n    }\n    const fromPrefixPaddingMs = getValueByPath(fromObject, [\n        \"prefixPaddingMs\"\n    ]);\n    if (fromPrefixPaddingMs != null) {\n        setValueByPath(toObject, [\n            \"prefixPaddingMs\"\n        ], fromPrefixPaddingMs);\n    }\n    const fromSilenceDurationMs = getValueByPath(fromObject, [\n        \"silenceDurationMs\"\n    ]);\n    if (fromSilenceDurationMs != null) {\n        setValueByPath(toObject, [\n            \"silenceDurationMs\"\n        ], fromSilenceDurationMs);\n    }\n    return toObject;\n}\nfunction realtimeInputConfigToMldev$1(fromObject) {\n    const toObject = {};\n    const fromAutomaticActivityDetection = getValueByPath(fromObject, [\n        \"automaticActivityDetection\"\n    ]);\n    if (fromAutomaticActivityDetection != null) {\n        setValueByPath(toObject, [\n            \"automaticActivityDetection\"\n        ], automaticActivityDetectionToMldev$1(fromAutomaticActivityDetection));\n    }\n    const fromActivityHandling = getValueByPath(fromObject, [\n        \"activityHandling\"\n    ]);\n    if (fromActivityHandling != null) {\n        setValueByPath(toObject, [\n            \"activityHandling\"\n        ], fromActivityHandling);\n    }\n    const fromTurnCoverage = getValueByPath(fromObject, [\n        \"turnCoverage\"\n    ]);\n    if (fromTurnCoverage != null) {\n        setValueByPath(toObject, [\n            \"turnCoverage\"\n        ], fromTurnCoverage);\n    }\n    return toObject;\n}\nfunction realtimeInputConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromAutomaticActivityDetection = getValueByPath(fromObject, [\n        \"automaticActivityDetection\"\n    ]);\n    if (fromAutomaticActivityDetection != null) {\n        setValueByPath(toObject, [\n            \"automaticActivityDetection\"\n        ], automaticActivityDetectionToVertex(fromAutomaticActivityDetection));\n    }\n    const fromActivityHandling = getValueByPath(fromObject, [\n        \"activityHandling\"\n    ]);\n    if (fromActivityHandling != null) {\n        setValueByPath(toObject, [\n            \"activityHandling\"\n        ], fromActivityHandling);\n    }\n    const fromTurnCoverage = getValueByPath(fromObject, [\n        \"turnCoverage\"\n    ]);\n    if (fromTurnCoverage != null) {\n        setValueByPath(toObject, [\n            \"turnCoverage\"\n        ], fromTurnCoverage);\n    }\n    return toObject;\n}\nfunction slidingWindowToMldev$1(fromObject) {\n    const toObject = {};\n    const fromTargetTokens = getValueByPath(fromObject, [\n        \"targetTokens\"\n    ]);\n    if (fromTargetTokens != null) {\n        setValueByPath(toObject, [\n            \"targetTokens\"\n        ], fromTargetTokens);\n    }\n    return toObject;\n}\nfunction slidingWindowToVertex(fromObject) {\n    const toObject = {};\n    const fromTargetTokens = getValueByPath(fromObject, [\n        \"targetTokens\"\n    ]);\n    if (fromTargetTokens != null) {\n        setValueByPath(toObject, [\n            \"targetTokens\"\n        ], fromTargetTokens);\n    }\n    return toObject;\n}\nfunction contextWindowCompressionConfigToMldev$1(fromObject) {\n    const toObject = {};\n    const fromTriggerTokens = getValueByPath(fromObject, [\n        \"triggerTokens\"\n    ]);\n    if (fromTriggerTokens != null) {\n        setValueByPath(toObject, [\n            \"triggerTokens\"\n        ], fromTriggerTokens);\n    }\n    const fromSlidingWindow = getValueByPath(fromObject, [\n        \"slidingWindow\"\n    ]);\n    if (fromSlidingWindow != null) {\n        setValueByPath(toObject, [\n            \"slidingWindow\"\n        ], slidingWindowToMldev$1(fromSlidingWindow));\n    }\n    return toObject;\n}\nfunction contextWindowCompressionConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromTriggerTokens = getValueByPath(fromObject, [\n        \"triggerTokens\"\n    ]);\n    if (fromTriggerTokens != null) {\n        setValueByPath(toObject, [\n            \"triggerTokens\"\n        ], fromTriggerTokens);\n    }\n    const fromSlidingWindow = getValueByPath(fromObject, [\n        \"slidingWindow\"\n    ]);\n    if (fromSlidingWindow != null) {\n        setValueByPath(toObject, [\n            \"slidingWindow\"\n        ], slidingWindowToVertex(fromSlidingWindow));\n    }\n    return toObject;\n}\nfunction proactivityConfigToMldev$1(fromObject) {\n    const toObject = {};\n    const fromProactiveAudio = getValueByPath(fromObject, [\n        \"proactiveAudio\"\n    ]);\n    if (fromProactiveAudio != null) {\n        setValueByPath(toObject, [\n            \"proactiveAudio\"\n        ], fromProactiveAudio);\n    }\n    return toObject;\n}\nfunction proactivityConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromProactiveAudio = getValueByPath(fromObject, [\n        \"proactiveAudio\"\n    ]);\n    if (fromProactiveAudio != null) {\n        setValueByPath(toObject, [\n            \"proactiveAudio\"\n        ], fromProactiveAudio);\n    }\n    return toObject;\n}\nfunction liveConnectConfigToMldev$1(fromObject, parentObject) {\n    const toObject = {};\n    const fromGenerationConfig = getValueByPath(fromObject, [\n        \"generationConfig\"\n    ]);\n    if (parentObject !== undefined && fromGenerationConfig != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\"\n        ], fromGenerationConfig);\n    }\n    const fromResponseModalities = getValueByPath(fromObject, [\n        \"responseModalities\"\n    ]);\n    if (parentObject !== undefined && fromResponseModalities != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"responseModalities\"\n        ], fromResponseModalities);\n    }\n    const fromTemperature = getValueByPath(fromObject, [\n        \"temperature\"\n    ]);\n    if (parentObject !== undefined && fromTemperature != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"temperature\"\n        ], fromTemperature);\n    }\n    const fromTopP = getValueByPath(fromObject, [\n        \"topP\"\n    ]);\n    if (parentObject !== undefined && fromTopP != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"topP\"\n        ], fromTopP);\n    }\n    const fromTopK = getValueByPath(fromObject, [\n        \"topK\"\n    ]);\n    if (parentObject !== undefined && fromTopK != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"topK\"\n        ], fromTopK);\n    }\n    const fromMaxOutputTokens = getValueByPath(fromObject, [\n        \"maxOutputTokens\"\n    ]);\n    if (parentObject !== undefined && fromMaxOutputTokens != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"maxOutputTokens\"\n        ], fromMaxOutputTokens);\n    }\n    const fromMediaResolution = getValueByPath(fromObject, [\n        \"mediaResolution\"\n    ]);\n    if (parentObject !== undefined && fromMediaResolution != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"mediaResolution\"\n        ], fromMediaResolution);\n    }\n    const fromSeed = getValueByPath(fromObject, [\n        \"seed\"\n    ]);\n    if (parentObject !== undefined && fromSeed != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"seed\"\n        ], fromSeed);\n    }\n    const fromSpeechConfig = getValueByPath(fromObject, [\n        \"speechConfig\"\n    ]);\n    if (parentObject !== undefined && fromSpeechConfig != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"speechConfig\"\n        ], speechConfigToMldev$2(tLiveSpeechConfig(fromSpeechConfig)));\n    }\n    const fromEnableAffectiveDialog = getValueByPath(fromObject, [\n        \"enableAffectiveDialog\"\n    ]);\n    if (parentObject !== undefined && fromEnableAffectiveDialog != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"enableAffectiveDialog\"\n        ], fromEnableAffectiveDialog);\n    }\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        \"systemInstruction\"\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"systemInstruction\"\n        ], contentToMldev$2(tContent(fromSystemInstruction)));\n    }\n    const fromTools = getValueByPath(fromObject, [\n        \"tools\"\n    ]);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = tTools(fromTools);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return toolToMldev$2(tTool(item));\n            });\n        }\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"tools\"\n        ], transformedList);\n    }\n    const fromSessionResumption = getValueByPath(fromObject, [\n        \"sessionResumption\"\n    ]);\n    if (parentObject !== undefined && fromSessionResumption != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"sessionResumption\"\n        ], sessionResumptionConfigToMldev$1(fromSessionResumption));\n    }\n    const fromInputAudioTranscription = getValueByPath(fromObject, [\n        \"inputAudioTranscription\"\n    ]);\n    if (parentObject !== undefined && fromInputAudioTranscription != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"inputAudioTranscription\"\n        ], audioTranscriptionConfigToMldev$1());\n    }\n    const fromOutputAudioTranscription = getValueByPath(fromObject, [\n        \"outputAudioTranscription\"\n    ]);\n    if (parentObject !== undefined && fromOutputAudioTranscription != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"outputAudioTranscription\"\n        ], audioTranscriptionConfigToMldev$1());\n    }\n    const fromRealtimeInputConfig = getValueByPath(fromObject, [\n        \"realtimeInputConfig\"\n    ]);\n    if (parentObject !== undefined && fromRealtimeInputConfig != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"realtimeInputConfig\"\n        ], realtimeInputConfigToMldev$1(fromRealtimeInputConfig));\n    }\n    const fromContextWindowCompression = getValueByPath(fromObject, [\n        \"contextWindowCompression\"\n    ]);\n    if (parentObject !== undefined && fromContextWindowCompression != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"contextWindowCompression\"\n        ], contextWindowCompressionConfigToMldev$1(fromContextWindowCompression));\n    }\n    const fromProactivity = getValueByPath(fromObject, [\n        \"proactivity\"\n    ]);\n    if (parentObject !== undefined && fromProactivity != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"proactivity\"\n        ], proactivityConfigToMldev$1(fromProactivity));\n    }\n    return toObject;\n}\nfunction liveConnectConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromGenerationConfig = getValueByPath(fromObject, [\n        \"generationConfig\"\n    ]);\n    if (parentObject !== undefined && fromGenerationConfig != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\"\n        ], fromGenerationConfig);\n    }\n    const fromResponseModalities = getValueByPath(fromObject, [\n        \"responseModalities\"\n    ]);\n    if (parentObject !== undefined && fromResponseModalities != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"responseModalities\"\n        ], fromResponseModalities);\n    }\n    const fromTemperature = getValueByPath(fromObject, [\n        \"temperature\"\n    ]);\n    if (parentObject !== undefined && fromTemperature != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"temperature\"\n        ], fromTemperature);\n    }\n    const fromTopP = getValueByPath(fromObject, [\n        \"topP\"\n    ]);\n    if (parentObject !== undefined && fromTopP != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"topP\"\n        ], fromTopP);\n    }\n    const fromTopK = getValueByPath(fromObject, [\n        \"topK\"\n    ]);\n    if (parentObject !== undefined && fromTopK != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"topK\"\n        ], fromTopK);\n    }\n    const fromMaxOutputTokens = getValueByPath(fromObject, [\n        \"maxOutputTokens\"\n    ]);\n    if (parentObject !== undefined && fromMaxOutputTokens != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"maxOutputTokens\"\n        ], fromMaxOutputTokens);\n    }\n    const fromMediaResolution = getValueByPath(fromObject, [\n        \"mediaResolution\"\n    ]);\n    if (parentObject !== undefined && fromMediaResolution != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"mediaResolution\"\n        ], fromMediaResolution);\n    }\n    const fromSeed = getValueByPath(fromObject, [\n        \"seed\"\n    ]);\n    if (parentObject !== undefined && fromSeed != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"seed\"\n        ], fromSeed);\n    }\n    const fromSpeechConfig = getValueByPath(fromObject, [\n        \"speechConfig\"\n    ]);\n    if (parentObject !== undefined && fromSpeechConfig != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"speechConfig\"\n        ], speechConfigToVertex$1(tLiveSpeechConfig(fromSpeechConfig)));\n    }\n    const fromEnableAffectiveDialog = getValueByPath(fromObject, [\n        \"enableAffectiveDialog\"\n    ]);\n    if (parentObject !== undefined && fromEnableAffectiveDialog != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"enableAffectiveDialog\"\n        ], fromEnableAffectiveDialog);\n    }\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        \"systemInstruction\"\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"systemInstruction\"\n        ], contentToVertex$1(tContent(fromSystemInstruction)));\n    }\n    const fromTools = getValueByPath(fromObject, [\n        \"tools\"\n    ]);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = tTools(fromTools);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return toolToVertex$1(tTool(item));\n            });\n        }\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"tools\"\n        ], transformedList);\n    }\n    const fromSessionResumption = getValueByPath(fromObject, [\n        \"sessionResumption\"\n    ]);\n    if (parentObject !== undefined && fromSessionResumption != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"sessionResumption\"\n        ], sessionResumptionConfigToVertex(fromSessionResumption));\n    }\n    const fromInputAudioTranscription = getValueByPath(fromObject, [\n        \"inputAudioTranscription\"\n    ]);\n    if (parentObject !== undefined && fromInputAudioTranscription != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"inputAudioTranscription\"\n        ], audioTranscriptionConfigToVertex());\n    }\n    const fromOutputAudioTranscription = getValueByPath(fromObject, [\n        \"outputAudioTranscription\"\n    ]);\n    if (parentObject !== undefined && fromOutputAudioTranscription != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"outputAudioTranscription\"\n        ], audioTranscriptionConfigToVertex());\n    }\n    const fromRealtimeInputConfig = getValueByPath(fromObject, [\n        \"realtimeInputConfig\"\n    ]);\n    if (parentObject !== undefined && fromRealtimeInputConfig != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"realtimeInputConfig\"\n        ], realtimeInputConfigToVertex(fromRealtimeInputConfig));\n    }\n    const fromContextWindowCompression = getValueByPath(fromObject, [\n        \"contextWindowCompression\"\n    ]);\n    if (parentObject !== undefined && fromContextWindowCompression != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"contextWindowCompression\"\n        ], contextWindowCompressionConfigToVertex(fromContextWindowCompression));\n    }\n    const fromProactivity = getValueByPath(fromObject, [\n        \"proactivity\"\n    ]);\n    if (parentObject !== undefined && fromProactivity != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"proactivity\"\n        ], proactivityConfigToVertex(fromProactivity));\n    }\n    return toObject;\n}\nfunction liveConnectParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"setup\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], liveConnectConfigToMldev$1(fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction liveConnectParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"setup\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], liveConnectConfigToVertex(fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction activityStartToMldev() {\n    const toObject = {};\n    return toObject;\n}\nfunction activityStartToVertex() {\n    const toObject = {};\n    return toObject;\n}\nfunction activityEndToMldev() {\n    const toObject = {};\n    return toObject;\n}\nfunction activityEndToVertex() {\n    const toObject = {};\n    return toObject;\n}\nfunction liveSendRealtimeInputParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromMedia = getValueByPath(fromObject, [\n        \"media\"\n    ]);\n    if (fromMedia != null) {\n        setValueByPath(toObject, [\n            \"mediaChunks\"\n        ], tBlobs(fromMedia));\n    }\n    const fromAudio = getValueByPath(fromObject, [\n        \"audio\"\n    ]);\n    if (fromAudio != null) {\n        setValueByPath(toObject, [\n            \"audio\"\n        ], tAudioBlob(fromAudio));\n    }\n    const fromAudioStreamEnd = getValueByPath(fromObject, [\n        \"audioStreamEnd\"\n    ]);\n    if (fromAudioStreamEnd != null) {\n        setValueByPath(toObject, [\n            \"audioStreamEnd\"\n        ], fromAudioStreamEnd);\n    }\n    const fromVideo = getValueByPath(fromObject, [\n        \"video\"\n    ]);\n    if (fromVideo != null) {\n        setValueByPath(toObject, [\n            \"video\"\n        ], tImageBlob(fromVideo));\n    }\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    const fromActivityStart = getValueByPath(fromObject, [\n        \"activityStart\"\n    ]);\n    if (fromActivityStart != null) {\n        setValueByPath(toObject, [\n            \"activityStart\"\n        ], activityStartToMldev());\n    }\n    const fromActivityEnd = getValueByPath(fromObject, [\n        \"activityEnd\"\n    ]);\n    if (fromActivityEnd != null) {\n        setValueByPath(toObject, [\n            \"activityEnd\"\n        ], activityEndToMldev());\n    }\n    return toObject;\n}\nfunction liveSendRealtimeInputParametersToVertex(fromObject) {\n    const toObject = {};\n    const fromMedia = getValueByPath(fromObject, [\n        \"media\"\n    ]);\n    if (fromMedia != null) {\n        setValueByPath(toObject, [\n            \"mediaChunks\"\n        ], tBlobs(fromMedia));\n    }\n    if (getValueByPath(fromObject, [\n        \"audio\"\n    ]) !== undefined) {\n        throw new Error(\"audio parameter is not supported in Vertex AI.\");\n    }\n    const fromAudioStreamEnd = getValueByPath(fromObject, [\n        \"audioStreamEnd\"\n    ]);\n    if (fromAudioStreamEnd != null) {\n        setValueByPath(toObject, [\n            \"audioStreamEnd\"\n        ], fromAudioStreamEnd);\n    }\n    if (getValueByPath(fromObject, [\n        \"video\"\n    ]) !== undefined) {\n        throw new Error(\"video parameter is not supported in Vertex AI.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"text\"\n    ]) !== undefined) {\n        throw new Error(\"text parameter is not supported in Vertex AI.\");\n    }\n    const fromActivityStart = getValueByPath(fromObject, [\n        \"activityStart\"\n    ]);\n    if (fromActivityStart != null) {\n        setValueByPath(toObject, [\n            \"activityStart\"\n        ], activityStartToVertex());\n    }\n    const fromActivityEnd = getValueByPath(fromObject, [\n        \"activityEnd\"\n    ]);\n    if (fromActivityEnd != null) {\n        setValueByPath(toObject, [\n            \"activityEnd\"\n        ], activityEndToVertex());\n    }\n    return toObject;\n}\nfunction weightedPromptToMldev(fromObject) {\n    const toObject = {};\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    const fromWeight = getValueByPath(fromObject, [\n        \"weight\"\n    ]);\n    if (fromWeight != null) {\n        setValueByPath(toObject, [\n            \"weight\"\n        ], fromWeight);\n    }\n    return toObject;\n}\nfunction liveMusicSetWeightedPromptsParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromWeightedPrompts = getValueByPath(fromObject, [\n        \"weightedPrompts\"\n    ]);\n    if (fromWeightedPrompts != null) {\n        let transformedList = fromWeightedPrompts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return weightedPromptToMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"weightedPrompts\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction liveMusicGenerationConfigToMldev(fromObject) {\n    const toObject = {};\n    const fromTemperature = getValueByPath(fromObject, [\n        \"temperature\"\n    ]);\n    if (fromTemperature != null) {\n        setValueByPath(toObject, [\n            \"temperature\"\n        ], fromTemperature);\n    }\n    const fromTopK = getValueByPath(fromObject, [\n        \"topK\"\n    ]);\n    if (fromTopK != null) {\n        setValueByPath(toObject, [\n            \"topK\"\n        ], fromTopK);\n    }\n    const fromSeed = getValueByPath(fromObject, [\n        \"seed\"\n    ]);\n    if (fromSeed != null) {\n        setValueByPath(toObject, [\n            \"seed\"\n        ], fromSeed);\n    }\n    const fromGuidance = getValueByPath(fromObject, [\n        \"guidance\"\n    ]);\n    if (fromGuidance != null) {\n        setValueByPath(toObject, [\n            \"guidance\"\n        ], fromGuidance);\n    }\n    const fromBpm = getValueByPath(fromObject, [\n        \"bpm\"\n    ]);\n    if (fromBpm != null) {\n        setValueByPath(toObject, [\n            \"bpm\"\n        ], fromBpm);\n    }\n    const fromDensity = getValueByPath(fromObject, [\n        \"density\"\n    ]);\n    if (fromDensity != null) {\n        setValueByPath(toObject, [\n            \"density\"\n        ], fromDensity);\n    }\n    const fromBrightness = getValueByPath(fromObject, [\n        \"brightness\"\n    ]);\n    if (fromBrightness != null) {\n        setValueByPath(toObject, [\n            \"brightness\"\n        ], fromBrightness);\n    }\n    const fromScale = getValueByPath(fromObject, [\n        \"scale\"\n    ]);\n    if (fromScale != null) {\n        setValueByPath(toObject, [\n            \"scale\"\n        ], fromScale);\n    }\n    const fromMuteBass = getValueByPath(fromObject, [\n        \"muteBass\"\n    ]);\n    if (fromMuteBass != null) {\n        setValueByPath(toObject, [\n            \"muteBass\"\n        ], fromMuteBass);\n    }\n    const fromMuteDrums = getValueByPath(fromObject, [\n        \"muteDrums\"\n    ]);\n    if (fromMuteDrums != null) {\n        setValueByPath(toObject, [\n            \"muteDrums\"\n        ], fromMuteDrums);\n    }\n    const fromOnlyBassAndDrums = getValueByPath(fromObject, [\n        \"onlyBassAndDrums\"\n    ]);\n    if (fromOnlyBassAndDrums != null) {\n        setValueByPath(toObject, [\n            \"onlyBassAndDrums\"\n        ], fromOnlyBassAndDrums);\n    }\n    return toObject;\n}\nfunction liveMusicSetConfigParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromMusicGenerationConfig = getValueByPath(fromObject, [\n        \"musicGenerationConfig\"\n    ]);\n    if (fromMusicGenerationConfig != null) {\n        setValueByPath(toObject, [\n            \"musicGenerationConfig\"\n        ], liveMusicGenerationConfigToMldev(fromMusicGenerationConfig));\n    }\n    return toObject;\n}\nfunction liveMusicClientSetupToMldev(fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"model\"\n        ], fromModel);\n    }\n    return toObject;\n}\nfunction liveMusicClientContentToMldev(fromObject) {\n    const toObject = {};\n    const fromWeightedPrompts = getValueByPath(fromObject, [\n        \"weightedPrompts\"\n    ]);\n    if (fromWeightedPrompts != null) {\n        let transformedList = fromWeightedPrompts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return weightedPromptToMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"weightedPrompts\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction liveMusicClientMessageToMldev(fromObject) {\n    const toObject = {};\n    const fromSetup = getValueByPath(fromObject, [\n        \"setup\"\n    ]);\n    if (fromSetup != null) {\n        setValueByPath(toObject, [\n            \"setup\"\n        ], liveMusicClientSetupToMldev(fromSetup));\n    }\n    const fromClientContent = getValueByPath(fromObject, [\n        \"clientContent\"\n    ]);\n    if (fromClientContent != null) {\n        setValueByPath(toObject, [\n            \"clientContent\"\n        ], liveMusicClientContentToMldev(fromClientContent));\n    }\n    const fromMusicGenerationConfig = getValueByPath(fromObject, [\n        \"musicGenerationConfig\"\n    ]);\n    if (fromMusicGenerationConfig != null) {\n        setValueByPath(toObject, [\n            \"musicGenerationConfig\"\n        ], liveMusicGenerationConfigToMldev(fromMusicGenerationConfig));\n    }\n    const fromPlaybackControl = getValueByPath(fromObject, [\n        \"playbackControl\"\n    ]);\n    if (fromPlaybackControl != null) {\n        setValueByPath(toObject, [\n            \"playbackControl\"\n        ], fromPlaybackControl);\n    }\n    return toObject;\n}\nfunction liveServerSetupCompleteFromMldev() {\n    const toObject = {};\n    return toObject;\n}\nfunction liveServerSetupCompleteFromVertex() {\n    const toObject = {};\n    return toObject;\n}\nfunction videoMetadataFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromFps = getValueByPath(fromObject, [\n        \"fps\"\n    ]);\n    if (fromFps != null) {\n        setValueByPath(toObject, [\n            \"fps\"\n        ], fromFps);\n    }\n    const fromEndOffset = getValueByPath(fromObject, [\n        \"endOffset\"\n    ]);\n    if (fromEndOffset != null) {\n        setValueByPath(toObject, [\n            \"endOffset\"\n        ], fromEndOffset);\n    }\n    const fromStartOffset = getValueByPath(fromObject, [\n        \"startOffset\"\n    ]);\n    if (fromStartOffset != null) {\n        setValueByPath(toObject, [\n            \"startOffset\"\n        ], fromStartOffset);\n    }\n    return toObject;\n}\nfunction videoMetadataFromVertex$1(fromObject) {\n    const toObject = {};\n    const fromFps = getValueByPath(fromObject, [\n        \"fps\"\n    ]);\n    if (fromFps != null) {\n        setValueByPath(toObject, [\n            \"fps\"\n        ], fromFps);\n    }\n    const fromEndOffset = getValueByPath(fromObject, [\n        \"endOffset\"\n    ]);\n    if (fromEndOffset != null) {\n        setValueByPath(toObject, [\n            \"endOffset\"\n        ], fromEndOffset);\n    }\n    const fromStartOffset = getValueByPath(fromObject, [\n        \"startOffset\"\n    ]);\n    if (fromStartOffset != null) {\n        setValueByPath(toObject, [\n            \"startOffset\"\n        ], fromStartOffset);\n    }\n    return toObject;\n}\nfunction blobFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromData = getValueByPath(fromObject, [\n        \"data\"\n    ]);\n    if (fromData != null) {\n        setValueByPath(toObject, [\n            \"data\"\n        ], fromData);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction blobFromVertex$1(fromObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromData = getValueByPath(fromObject, [\n        \"data\"\n    ]);\n    if (fromData != null) {\n        setValueByPath(toObject, [\n            \"data\"\n        ], fromData);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction fileDataFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromFileUri = getValueByPath(fromObject, [\n        \"fileUri\"\n    ]);\n    if (fromFileUri != null) {\n        setValueByPath(toObject, [\n            \"fileUri\"\n        ], fromFileUri);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction fileDataFromVertex$1(fromObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromFileUri = getValueByPath(fromObject, [\n        \"fileUri\"\n    ]);\n    if (fromFileUri != null) {\n        setValueByPath(toObject, [\n            \"fileUri\"\n        ], fromFileUri);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction partFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        \"videoMetadata\"\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, [\n            \"videoMetadata\"\n        ], videoMetadataFromMldev$1(fromVideoMetadata));\n    }\n    const fromThought = getValueByPath(fromObject, [\n        \"thought\"\n    ]);\n    if (fromThought != null) {\n        setValueByPath(toObject, [\n            \"thought\"\n        ], fromThought);\n    }\n    const fromInlineData = getValueByPath(fromObject, [\n        \"inlineData\"\n    ]);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, [\n            \"inlineData\"\n        ], blobFromMldev$1(fromInlineData));\n    }\n    const fromFileData = getValueByPath(fromObject, [\n        \"fileData\"\n    ]);\n    if (fromFileData != null) {\n        setValueByPath(toObject, [\n            \"fileData\"\n        ], fileDataFromMldev$1(fromFileData));\n    }\n    const fromThoughtSignature = getValueByPath(fromObject, [\n        \"thoughtSignature\"\n    ]);\n    if (fromThoughtSignature != null) {\n        setValueByPath(toObject, [\n            \"thoughtSignature\"\n        ], fromThoughtSignature);\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        \"codeExecutionResult\"\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, [\n            \"codeExecutionResult\"\n        ], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        \"executableCode\"\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, [\n            \"executableCode\"\n        ], fromExecutableCode);\n    }\n    const fromFunctionCall = getValueByPath(fromObject, [\n        \"functionCall\"\n    ]);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, [\n            \"functionCall\"\n        ], fromFunctionCall);\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        \"functionResponse\"\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, [\n            \"functionResponse\"\n        ], fromFunctionResponse);\n    }\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    return toObject;\n}\nfunction partFromVertex$1(fromObject) {\n    const toObject = {};\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        \"videoMetadata\"\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, [\n            \"videoMetadata\"\n        ], videoMetadataFromVertex$1(fromVideoMetadata));\n    }\n    const fromThought = getValueByPath(fromObject, [\n        \"thought\"\n    ]);\n    if (fromThought != null) {\n        setValueByPath(toObject, [\n            \"thought\"\n        ], fromThought);\n    }\n    const fromInlineData = getValueByPath(fromObject, [\n        \"inlineData\"\n    ]);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, [\n            \"inlineData\"\n        ], blobFromVertex$1(fromInlineData));\n    }\n    const fromFileData = getValueByPath(fromObject, [\n        \"fileData\"\n    ]);\n    if (fromFileData != null) {\n        setValueByPath(toObject, [\n            \"fileData\"\n        ], fileDataFromVertex$1(fromFileData));\n    }\n    const fromThoughtSignature = getValueByPath(fromObject, [\n        \"thoughtSignature\"\n    ]);\n    if (fromThoughtSignature != null) {\n        setValueByPath(toObject, [\n            \"thoughtSignature\"\n        ], fromThoughtSignature);\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        \"codeExecutionResult\"\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, [\n            \"codeExecutionResult\"\n        ], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        \"executableCode\"\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, [\n            \"executableCode\"\n        ], fromExecutableCode);\n    }\n    const fromFunctionCall = getValueByPath(fromObject, [\n        \"functionCall\"\n    ]);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, [\n            \"functionCall\"\n        ], fromFunctionCall);\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        \"functionResponse\"\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, [\n            \"functionResponse\"\n        ], fromFunctionResponse);\n    }\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    return toObject;\n}\nfunction contentFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, [\n        \"parts\"\n    ]);\n    if (fromParts != null) {\n        let transformedList = fromParts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return partFromMldev$1(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"parts\"\n        ], transformedList);\n    }\n    const fromRole = getValueByPath(fromObject, [\n        \"role\"\n    ]);\n    if (fromRole != null) {\n        setValueByPath(toObject, [\n            \"role\"\n        ], fromRole);\n    }\n    return toObject;\n}\nfunction contentFromVertex$1(fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, [\n        \"parts\"\n    ]);\n    if (fromParts != null) {\n        let transformedList = fromParts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return partFromVertex$1(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"parts\"\n        ], transformedList);\n    }\n    const fromRole = getValueByPath(fromObject, [\n        \"role\"\n    ]);\n    if (fromRole != null) {\n        setValueByPath(toObject, [\n            \"role\"\n        ], fromRole);\n    }\n    return toObject;\n}\nfunction transcriptionFromMldev(fromObject) {\n    const toObject = {};\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    const fromFinished = getValueByPath(fromObject, [\n        \"finished\"\n    ]);\n    if (fromFinished != null) {\n        setValueByPath(toObject, [\n            \"finished\"\n        ], fromFinished);\n    }\n    return toObject;\n}\nfunction transcriptionFromVertex(fromObject) {\n    const toObject = {};\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    const fromFinished = getValueByPath(fromObject, [\n        \"finished\"\n    ]);\n    if (fromFinished != null) {\n        setValueByPath(toObject, [\n            \"finished\"\n        ], fromFinished);\n    }\n    return toObject;\n}\nfunction urlMetadataFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromRetrievedUrl = getValueByPath(fromObject, [\n        \"retrievedUrl\"\n    ]);\n    if (fromRetrievedUrl != null) {\n        setValueByPath(toObject, [\n            \"retrievedUrl\"\n        ], fromRetrievedUrl);\n    }\n    const fromUrlRetrievalStatus = getValueByPath(fromObject, [\n        \"urlRetrievalStatus\"\n    ]);\n    if (fromUrlRetrievalStatus != null) {\n        setValueByPath(toObject, [\n            \"urlRetrievalStatus\"\n        ], fromUrlRetrievalStatus);\n    }\n    return toObject;\n}\nfunction urlContextMetadataFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromUrlMetadata = getValueByPath(fromObject, [\n        \"urlMetadata\"\n    ]);\n    if (fromUrlMetadata != null) {\n        let transformedList = fromUrlMetadata;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return urlMetadataFromMldev$1(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"urlMetadata\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction liveServerContentFromMldev(fromObject) {\n    const toObject = {};\n    const fromModelTurn = getValueByPath(fromObject, [\n        \"modelTurn\"\n    ]);\n    if (fromModelTurn != null) {\n        setValueByPath(toObject, [\n            \"modelTurn\"\n        ], contentFromMldev$1(fromModelTurn));\n    }\n    const fromTurnComplete = getValueByPath(fromObject, [\n        \"turnComplete\"\n    ]);\n    if (fromTurnComplete != null) {\n        setValueByPath(toObject, [\n            \"turnComplete\"\n        ], fromTurnComplete);\n    }\n    const fromInterrupted = getValueByPath(fromObject, [\n        \"interrupted\"\n    ]);\n    if (fromInterrupted != null) {\n        setValueByPath(toObject, [\n            \"interrupted\"\n        ], fromInterrupted);\n    }\n    const fromGroundingMetadata = getValueByPath(fromObject, [\n        \"groundingMetadata\"\n    ]);\n    if (fromGroundingMetadata != null) {\n        setValueByPath(toObject, [\n            \"groundingMetadata\"\n        ], fromGroundingMetadata);\n    }\n    const fromGenerationComplete = getValueByPath(fromObject, [\n        \"generationComplete\"\n    ]);\n    if (fromGenerationComplete != null) {\n        setValueByPath(toObject, [\n            \"generationComplete\"\n        ], fromGenerationComplete);\n    }\n    const fromInputTranscription = getValueByPath(fromObject, [\n        \"inputTranscription\"\n    ]);\n    if (fromInputTranscription != null) {\n        setValueByPath(toObject, [\n            \"inputTranscription\"\n        ], transcriptionFromMldev(fromInputTranscription));\n    }\n    const fromOutputTranscription = getValueByPath(fromObject, [\n        \"outputTranscription\"\n    ]);\n    if (fromOutputTranscription != null) {\n        setValueByPath(toObject, [\n            \"outputTranscription\"\n        ], transcriptionFromMldev(fromOutputTranscription));\n    }\n    const fromUrlContextMetadata = getValueByPath(fromObject, [\n        \"urlContextMetadata\"\n    ]);\n    if (fromUrlContextMetadata != null) {\n        setValueByPath(toObject, [\n            \"urlContextMetadata\"\n        ], urlContextMetadataFromMldev$1(fromUrlContextMetadata));\n    }\n    return toObject;\n}\nfunction liveServerContentFromVertex(fromObject) {\n    const toObject = {};\n    const fromModelTurn = getValueByPath(fromObject, [\n        \"modelTurn\"\n    ]);\n    if (fromModelTurn != null) {\n        setValueByPath(toObject, [\n            \"modelTurn\"\n        ], contentFromVertex$1(fromModelTurn));\n    }\n    const fromTurnComplete = getValueByPath(fromObject, [\n        \"turnComplete\"\n    ]);\n    if (fromTurnComplete != null) {\n        setValueByPath(toObject, [\n            \"turnComplete\"\n        ], fromTurnComplete);\n    }\n    const fromInterrupted = getValueByPath(fromObject, [\n        \"interrupted\"\n    ]);\n    if (fromInterrupted != null) {\n        setValueByPath(toObject, [\n            \"interrupted\"\n        ], fromInterrupted);\n    }\n    const fromGroundingMetadata = getValueByPath(fromObject, [\n        \"groundingMetadata\"\n    ]);\n    if (fromGroundingMetadata != null) {\n        setValueByPath(toObject, [\n            \"groundingMetadata\"\n        ], fromGroundingMetadata);\n    }\n    const fromGenerationComplete = getValueByPath(fromObject, [\n        \"generationComplete\"\n    ]);\n    if (fromGenerationComplete != null) {\n        setValueByPath(toObject, [\n            \"generationComplete\"\n        ], fromGenerationComplete);\n    }\n    const fromInputTranscription = getValueByPath(fromObject, [\n        \"inputTranscription\"\n    ]);\n    if (fromInputTranscription != null) {\n        setValueByPath(toObject, [\n            \"inputTranscription\"\n        ], transcriptionFromVertex(fromInputTranscription));\n    }\n    const fromOutputTranscription = getValueByPath(fromObject, [\n        \"outputTranscription\"\n    ]);\n    if (fromOutputTranscription != null) {\n        setValueByPath(toObject, [\n            \"outputTranscription\"\n        ], transcriptionFromVertex(fromOutputTranscription));\n    }\n    return toObject;\n}\nfunction functionCallFromMldev(fromObject) {\n    const toObject = {};\n    const fromId = getValueByPath(fromObject, [\n        \"id\"\n    ]);\n    if (fromId != null) {\n        setValueByPath(toObject, [\n            \"id\"\n        ], fromId);\n    }\n    const fromArgs = getValueByPath(fromObject, [\n        \"args\"\n    ]);\n    if (fromArgs != null) {\n        setValueByPath(toObject, [\n            \"args\"\n        ], fromArgs);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    return toObject;\n}\nfunction functionCallFromVertex(fromObject) {\n    const toObject = {};\n    const fromArgs = getValueByPath(fromObject, [\n        \"args\"\n    ]);\n    if (fromArgs != null) {\n        setValueByPath(toObject, [\n            \"args\"\n        ], fromArgs);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    return toObject;\n}\nfunction liveServerToolCallFromMldev(fromObject) {\n    const toObject = {};\n    const fromFunctionCalls = getValueByPath(fromObject, [\n        \"functionCalls\"\n    ]);\n    if (fromFunctionCalls != null) {\n        let transformedList = fromFunctionCalls;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return functionCallFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"functionCalls\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction liveServerToolCallFromVertex(fromObject) {\n    const toObject = {};\n    const fromFunctionCalls = getValueByPath(fromObject, [\n        \"functionCalls\"\n    ]);\n    if (fromFunctionCalls != null) {\n        let transformedList = fromFunctionCalls;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return functionCallFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"functionCalls\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction liveServerToolCallCancellationFromMldev(fromObject) {\n    const toObject = {};\n    const fromIds = getValueByPath(fromObject, [\n        \"ids\"\n    ]);\n    if (fromIds != null) {\n        setValueByPath(toObject, [\n            \"ids\"\n        ], fromIds);\n    }\n    return toObject;\n}\nfunction liveServerToolCallCancellationFromVertex(fromObject) {\n    const toObject = {};\n    const fromIds = getValueByPath(fromObject, [\n        \"ids\"\n    ]);\n    if (fromIds != null) {\n        setValueByPath(toObject, [\n            \"ids\"\n        ], fromIds);\n    }\n    return toObject;\n}\nfunction modalityTokenCountFromMldev(fromObject) {\n    const toObject = {};\n    const fromModality = getValueByPath(fromObject, [\n        \"modality\"\n    ]);\n    if (fromModality != null) {\n        setValueByPath(toObject, [\n            \"modality\"\n        ], fromModality);\n    }\n    const fromTokenCount = getValueByPath(fromObject, [\n        \"tokenCount\"\n    ]);\n    if (fromTokenCount != null) {\n        setValueByPath(toObject, [\n            \"tokenCount\"\n        ], fromTokenCount);\n    }\n    return toObject;\n}\nfunction modalityTokenCountFromVertex(fromObject) {\n    const toObject = {};\n    const fromModality = getValueByPath(fromObject, [\n        \"modality\"\n    ]);\n    if (fromModality != null) {\n        setValueByPath(toObject, [\n            \"modality\"\n        ], fromModality);\n    }\n    const fromTokenCount = getValueByPath(fromObject, [\n        \"tokenCount\"\n    ]);\n    if (fromTokenCount != null) {\n        setValueByPath(toObject, [\n            \"tokenCount\"\n        ], fromTokenCount);\n    }\n    return toObject;\n}\nfunction usageMetadataFromMldev(fromObject) {\n    const toObject = {};\n    const fromPromptTokenCount = getValueByPath(fromObject, [\n        \"promptTokenCount\"\n    ]);\n    if (fromPromptTokenCount != null) {\n        setValueByPath(toObject, [\n            \"promptTokenCount\"\n        ], fromPromptTokenCount);\n    }\n    const fromCachedContentTokenCount = getValueByPath(fromObject, [\n        \"cachedContentTokenCount\"\n    ]);\n    if (fromCachedContentTokenCount != null) {\n        setValueByPath(toObject, [\n            \"cachedContentTokenCount\"\n        ], fromCachedContentTokenCount);\n    }\n    const fromResponseTokenCount = getValueByPath(fromObject, [\n        \"responseTokenCount\"\n    ]);\n    if (fromResponseTokenCount != null) {\n        setValueByPath(toObject, [\n            \"responseTokenCount\"\n        ], fromResponseTokenCount);\n    }\n    const fromToolUsePromptTokenCount = getValueByPath(fromObject, [\n        \"toolUsePromptTokenCount\"\n    ]);\n    if (fromToolUsePromptTokenCount != null) {\n        setValueByPath(toObject, [\n            \"toolUsePromptTokenCount\"\n        ], fromToolUsePromptTokenCount);\n    }\n    const fromThoughtsTokenCount = getValueByPath(fromObject, [\n        \"thoughtsTokenCount\"\n    ]);\n    if (fromThoughtsTokenCount != null) {\n        setValueByPath(toObject, [\n            \"thoughtsTokenCount\"\n        ], fromThoughtsTokenCount);\n    }\n    const fromTotalTokenCount = getValueByPath(fromObject, [\n        \"totalTokenCount\"\n    ]);\n    if (fromTotalTokenCount != null) {\n        setValueByPath(toObject, [\n            \"totalTokenCount\"\n        ], fromTotalTokenCount);\n    }\n    const fromPromptTokensDetails = getValueByPath(fromObject, [\n        \"promptTokensDetails\"\n    ]);\n    if (fromPromptTokensDetails != null) {\n        let transformedList = fromPromptTokensDetails;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return modalityTokenCountFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"promptTokensDetails\"\n        ], transformedList);\n    }\n    const fromCacheTokensDetails = getValueByPath(fromObject, [\n        \"cacheTokensDetails\"\n    ]);\n    if (fromCacheTokensDetails != null) {\n        let transformedList = fromCacheTokensDetails;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return modalityTokenCountFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"cacheTokensDetails\"\n        ], transformedList);\n    }\n    const fromResponseTokensDetails = getValueByPath(fromObject, [\n        \"responseTokensDetails\"\n    ]);\n    if (fromResponseTokensDetails != null) {\n        let transformedList = fromResponseTokensDetails;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return modalityTokenCountFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"responseTokensDetails\"\n        ], transformedList);\n    }\n    const fromToolUsePromptTokensDetails = getValueByPath(fromObject, [\n        \"toolUsePromptTokensDetails\"\n    ]);\n    if (fromToolUsePromptTokensDetails != null) {\n        let transformedList = fromToolUsePromptTokensDetails;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return modalityTokenCountFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"toolUsePromptTokensDetails\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction usageMetadataFromVertex(fromObject) {\n    const toObject = {};\n    const fromPromptTokenCount = getValueByPath(fromObject, [\n        \"promptTokenCount\"\n    ]);\n    if (fromPromptTokenCount != null) {\n        setValueByPath(toObject, [\n            \"promptTokenCount\"\n        ], fromPromptTokenCount);\n    }\n    const fromCachedContentTokenCount = getValueByPath(fromObject, [\n        \"cachedContentTokenCount\"\n    ]);\n    if (fromCachedContentTokenCount != null) {\n        setValueByPath(toObject, [\n            \"cachedContentTokenCount\"\n        ], fromCachedContentTokenCount);\n    }\n    const fromResponseTokenCount = getValueByPath(fromObject, [\n        \"candidatesTokenCount\"\n    ]);\n    if (fromResponseTokenCount != null) {\n        setValueByPath(toObject, [\n            \"responseTokenCount\"\n        ], fromResponseTokenCount);\n    }\n    const fromToolUsePromptTokenCount = getValueByPath(fromObject, [\n        \"toolUsePromptTokenCount\"\n    ]);\n    if (fromToolUsePromptTokenCount != null) {\n        setValueByPath(toObject, [\n            \"toolUsePromptTokenCount\"\n        ], fromToolUsePromptTokenCount);\n    }\n    const fromThoughtsTokenCount = getValueByPath(fromObject, [\n        \"thoughtsTokenCount\"\n    ]);\n    if (fromThoughtsTokenCount != null) {\n        setValueByPath(toObject, [\n            \"thoughtsTokenCount\"\n        ], fromThoughtsTokenCount);\n    }\n    const fromTotalTokenCount = getValueByPath(fromObject, [\n        \"totalTokenCount\"\n    ]);\n    if (fromTotalTokenCount != null) {\n        setValueByPath(toObject, [\n            \"totalTokenCount\"\n        ], fromTotalTokenCount);\n    }\n    const fromPromptTokensDetails = getValueByPath(fromObject, [\n        \"promptTokensDetails\"\n    ]);\n    if (fromPromptTokensDetails != null) {\n        let transformedList = fromPromptTokensDetails;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return modalityTokenCountFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"promptTokensDetails\"\n        ], transformedList);\n    }\n    const fromCacheTokensDetails = getValueByPath(fromObject, [\n        \"cacheTokensDetails\"\n    ]);\n    if (fromCacheTokensDetails != null) {\n        let transformedList = fromCacheTokensDetails;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return modalityTokenCountFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"cacheTokensDetails\"\n        ], transformedList);\n    }\n    const fromResponseTokensDetails = getValueByPath(fromObject, [\n        \"candidatesTokensDetails\"\n    ]);\n    if (fromResponseTokensDetails != null) {\n        let transformedList = fromResponseTokensDetails;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return modalityTokenCountFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"responseTokensDetails\"\n        ], transformedList);\n    }\n    const fromToolUsePromptTokensDetails = getValueByPath(fromObject, [\n        \"toolUsePromptTokensDetails\"\n    ]);\n    if (fromToolUsePromptTokensDetails != null) {\n        let transformedList = fromToolUsePromptTokensDetails;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return modalityTokenCountFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"toolUsePromptTokensDetails\"\n        ], transformedList);\n    }\n    const fromTrafficType = getValueByPath(fromObject, [\n        \"trafficType\"\n    ]);\n    if (fromTrafficType != null) {\n        setValueByPath(toObject, [\n            \"trafficType\"\n        ], fromTrafficType);\n    }\n    return toObject;\n}\nfunction liveServerGoAwayFromMldev(fromObject) {\n    const toObject = {};\n    const fromTimeLeft = getValueByPath(fromObject, [\n        \"timeLeft\"\n    ]);\n    if (fromTimeLeft != null) {\n        setValueByPath(toObject, [\n            \"timeLeft\"\n        ], fromTimeLeft);\n    }\n    return toObject;\n}\nfunction liveServerGoAwayFromVertex(fromObject) {\n    const toObject = {};\n    const fromTimeLeft = getValueByPath(fromObject, [\n        \"timeLeft\"\n    ]);\n    if (fromTimeLeft != null) {\n        setValueByPath(toObject, [\n            \"timeLeft\"\n        ], fromTimeLeft);\n    }\n    return toObject;\n}\nfunction liveServerSessionResumptionUpdateFromMldev(fromObject) {\n    const toObject = {};\n    const fromNewHandle = getValueByPath(fromObject, [\n        \"newHandle\"\n    ]);\n    if (fromNewHandle != null) {\n        setValueByPath(toObject, [\n            \"newHandle\"\n        ], fromNewHandle);\n    }\n    const fromResumable = getValueByPath(fromObject, [\n        \"resumable\"\n    ]);\n    if (fromResumable != null) {\n        setValueByPath(toObject, [\n            \"resumable\"\n        ], fromResumable);\n    }\n    const fromLastConsumedClientMessageIndex = getValueByPath(fromObject, [\n        \"lastConsumedClientMessageIndex\"\n    ]);\n    if (fromLastConsumedClientMessageIndex != null) {\n        setValueByPath(toObject, [\n            \"lastConsumedClientMessageIndex\"\n        ], fromLastConsumedClientMessageIndex);\n    }\n    return toObject;\n}\nfunction liveServerSessionResumptionUpdateFromVertex(fromObject) {\n    const toObject = {};\n    const fromNewHandle = getValueByPath(fromObject, [\n        \"newHandle\"\n    ]);\n    if (fromNewHandle != null) {\n        setValueByPath(toObject, [\n            \"newHandle\"\n        ], fromNewHandle);\n    }\n    const fromResumable = getValueByPath(fromObject, [\n        \"resumable\"\n    ]);\n    if (fromResumable != null) {\n        setValueByPath(toObject, [\n            \"resumable\"\n        ], fromResumable);\n    }\n    const fromLastConsumedClientMessageIndex = getValueByPath(fromObject, [\n        \"lastConsumedClientMessageIndex\"\n    ]);\n    if (fromLastConsumedClientMessageIndex != null) {\n        setValueByPath(toObject, [\n            \"lastConsumedClientMessageIndex\"\n        ], fromLastConsumedClientMessageIndex);\n    }\n    return toObject;\n}\nfunction liveServerMessageFromMldev(fromObject) {\n    const toObject = {};\n    const fromSetupComplete = getValueByPath(fromObject, [\n        \"setupComplete\"\n    ]);\n    if (fromSetupComplete != null) {\n        setValueByPath(toObject, [\n            \"setupComplete\"\n        ], liveServerSetupCompleteFromMldev());\n    }\n    const fromServerContent = getValueByPath(fromObject, [\n        \"serverContent\"\n    ]);\n    if (fromServerContent != null) {\n        setValueByPath(toObject, [\n            \"serverContent\"\n        ], liveServerContentFromMldev(fromServerContent));\n    }\n    const fromToolCall = getValueByPath(fromObject, [\n        \"toolCall\"\n    ]);\n    if (fromToolCall != null) {\n        setValueByPath(toObject, [\n            \"toolCall\"\n        ], liveServerToolCallFromMldev(fromToolCall));\n    }\n    const fromToolCallCancellation = getValueByPath(fromObject, [\n        \"toolCallCancellation\"\n    ]);\n    if (fromToolCallCancellation != null) {\n        setValueByPath(toObject, [\n            \"toolCallCancellation\"\n        ], liveServerToolCallCancellationFromMldev(fromToolCallCancellation));\n    }\n    const fromUsageMetadata = getValueByPath(fromObject, [\n        \"usageMetadata\"\n    ]);\n    if (fromUsageMetadata != null) {\n        setValueByPath(toObject, [\n            \"usageMetadata\"\n        ], usageMetadataFromMldev(fromUsageMetadata));\n    }\n    const fromGoAway = getValueByPath(fromObject, [\n        \"goAway\"\n    ]);\n    if (fromGoAway != null) {\n        setValueByPath(toObject, [\n            \"goAway\"\n        ], liveServerGoAwayFromMldev(fromGoAway));\n    }\n    const fromSessionResumptionUpdate = getValueByPath(fromObject, [\n        \"sessionResumptionUpdate\"\n    ]);\n    if (fromSessionResumptionUpdate != null) {\n        setValueByPath(toObject, [\n            \"sessionResumptionUpdate\"\n        ], liveServerSessionResumptionUpdateFromMldev(fromSessionResumptionUpdate));\n    }\n    return toObject;\n}\nfunction liveServerMessageFromVertex(fromObject) {\n    const toObject = {};\n    const fromSetupComplete = getValueByPath(fromObject, [\n        \"setupComplete\"\n    ]);\n    if (fromSetupComplete != null) {\n        setValueByPath(toObject, [\n            \"setupComplete\"\n        ], liveServerSetupCompleteFromVertex());\n    }\n    const fromServerContent = getValueByPath(fromObject, [\n        \"serverContent\"\n    ]);\n    if (fromServerContent != null) {\n        setValueByPath(toObject, [\n            \"serverContent\"\n        ], liveServerContentFromVertex(fromServerContent));\n    }\n    const fromToolCall = getValueByPath(fromObject, [\n        \"toolCall\"\n    ]);\n    if (fromToolCall != null) {\n        setValueByPath(toObject, [\n            \"toolCall\"\n        ], liveServerToolCallFromVertex(fromToolCall));\n    }\n    const fromToolCallCancellation = getValueByPath(fromObject, [\n        \"toolCallCancellation\"\n    ]);\n    if (fromToolCallCancellation != null) {\n        setValueByPath(toObject, [\n            \"toolCallCancellation\"\n        ], liveServerToolCallCancellationFromVertex(fromToolCallCancellation));\n    }\n    const fromUsageMetadata = getValueByPath(fromObject, [\n        \"usageMetadata\"\n    ]);\n    if (fromUsageMetadata != null) {\n        setValueByPath(toObject, [\n            \"usageMetadata\"\n        ], usageMetadataFromVertex(fromUsageMetadata));\n    }\n    const fromGoAway = getValueByPath(fromObject, [\n        \"goAway\"\n    ]);\n    if (fromGoAway != null) {\n        setValueByPath(toObject, [\n            \"goAway\"\n        ], liveServerGoAwayFromVertex(fromGoAway));\n    }\n    const fromSessionResumptionUpdate = getValueByPath(fromObject, [\n        \"sessionResumptionUpdate\"\n    ]);\n    if (fromSessionResumptionUpdate != null) {\n        setValueByPath(toObject, [\n            \"sessionResumptionUpdate\"\n        ], liveServerSessionResumptionUpdateFromVertex(fromSessionResumptionUpdate));\n    }\n    return toObject;\n}\nfunction liveMusicServerSetupCompleteFromMldev() {\n    const toObject = {};\n    return toObject;\n}\nfunction weightedPromptFromMldev(fromObject) {\n    const toObject = {};\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    const fromWeight = getValueByPath(fromObject, [\n        \"weight\"\n    ]);\n    if (fromWeight != null) {\n        setValueByPath(toObject, [\n            \"weight\"\n        ], fromWeight);\n    }\n    return toObject;\n}\nfunction liveMusicClientContentFromMldev(fromObject) {\n    const toObject = {};\n    const fromWeightedPrompts = getValueByPath(fromObject, [\n        \"weightedPrompts\"\n    ]);\n    if (fromWeightedPrompts != null) {\n        let transformedList = fromWeightedPrompts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return weightedPromptFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"weightedPrompts\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction liveMusicGenerationConfigFromMldev(fromObject) {\n    const toObject = {};\n    const fromTemperature = getValueByPath(fromObject, [\n        \"temperature\"\n    ]);\n    if (fromTemperature != null) {\n        setValueByPath(toObject, [\n            \"temperature\"\n        ], fromTemperature);\n    }\n    const fromTopK = getValueByPath(fromObject, [\n        \"topK\"\n    ]);\n    if (fromTopK != null) {\n        setValueByPath(toObject, [\n            \"topK\"\n        ], fromTopK);\n    }\n    const fromSeed = getValueByPath(fromObject, [\n        \"seed\"\n    ]);\n    if (fromSeed != null) {\n        setValueByPath(toObject, [\n            \"seed\"\n        ], fromSeed);\n    }\n    const fromGuidance = getValueByPath(fromObject, [\n        \"guidance\"\n    ]);\n    if (fromGuidance != null) {\n        setValueByPath(toObject, [\n            \"guidance\"\n        ], fromGuidance);\n    }\n    const fromBpm = getValueByPath(fromObject, [\n        \"bpm\"\n    ]);\n    if (fromBpm != null) {\n        setValueByPath(toObject, [\n            \"bpm\"\n        ], fromBpm);\n    }\n    const fromDensity = getValueByPath(fromObject, [\n        \"density\"\n    ]);\n    if (fromDensity != null) {\n        setValueByPath(toObject, [\n            \"density\"\n        ], fromDensity);\n    }\n    const fromBrightness = getValueByPath(fromObject, [\n        \"brightness\"\n    ]);\n    if (fromBrightness != null) {\n        setValueByPath(toObject, [\n            \"brightness\"\n        ], fromBrightness);\n    }\n    const fromScale = getValueByPath(fromObject, [\n        \"scale\"\n    ]);\n    if (fromScale != null) {\n        setValueByPath(toObject, [\n            \"scale\"\n        ], fromScale);\n    }\n    const fromMuteBass = getValueByPath(fromObject, [\n        \"muteBass\"\n    ]);\n    if (fromMuteBass != null) {\n        setValueByPath(toObject, [\n            \"muteBass\"\n        ], fromMuteBass);\n    }\n    const fromMuteDrums = getValueByPath(fromObject, [\n        \"muteDrums\"\n    ]);\n    if (fromMuteDrums != null) {\n        setValueByPath(toObject, [\n            \"muteDrums\"\n        ], fromMuteDrums);\n    }\n    const fromOnlyBassAndDrums = getValueByPath(fromObject, [\n        \"onlyBassAndDrums\"\n    ]);\n    if (fromOnlyBassAndDrums != null) {\n        setValueByPath(toObject, [\n            \"onlyBassAndDrums\"\n        ], fromOnlyBassAndDrums);\n    }\n    return toObject;\n}\nfunction liveMusicSourceMetadataFromMldev(fromObject) {\n    const toObject = {};\n    const fromClientContent = getValueByPath(fromObject, [\n        \"clientContent\"\n    ]);\n    if (fromClientContent != null) {\n        setValueByPath(toObject, [\n            \"clientContent\"\n        ], liveMusicClientContentFromMldev(fromClientContent));\n    }\n    const fromMusicGenerationConfig = getValueByPath(fromObject, [\n        \"musicGenerationConfig\"\n    ]);\n    if (fromMusicGenerationConfig != null) {\n        setValueByPath(toObject, [\n            \"musicGenerationConfig\"\n        ], liveMusicGenerationConfigFromMldev(fromMusicGenerationConfig));\n    }\n    return toObject;\n}\nfunction audioChunkFromMldev(fromObject) {\n    const toObject = {};\n    const fromData = getValueByPath(fromObject, [\n        \"data\"\n    ]);\n    if (fromData != null) {\n        setValueByPath(toObject, [\n            \"data\"\n        ], fromData);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    const fromSourceMetadata = getValueByPath(fromObject, [\n        \"sourceMetadata\"\n    ]);\n    if (fromSourceMetadata != null) {\n        setValueByPath(toObject, [\n            \"sourceMetadata\"\n        ], liveMusicSourceMetadataFromMldev(fromSourceMetadata));\n    }\n    return toObject;\n}\nfunction liveMusicServerContentFromMldev(fromObject) {\n    const toObject = {};\n    const fromAudioChunks = getValueByPath(fromObject, [\n        \"audioChunks\"\n    ]);\n    if (fromAudioChunks != null) {\n        let transformedList = fromAudioChunks;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return audioChunkFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"audioChunks\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction liveMusicFilteredPromptFromMldev(fromObject) {\n    const toObject = {};\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    const fromFilteredReason = getValueByPath(fromObject, [\n        \"filteredReason\"\n    ]);\n    if (fromFilteredReason != null) {\n        setValueByPath(toObject, [\n            \"filteredReason\"\n        ], fromFilteredReason);\n    }\n    return toObject;\n}\nfunction liveMusicServerMessageFromMldev(fromObject) {\n    const toObject = {};\n    const fromSetupComplete = getValueByPath(fromObject, [\n        \"setupComplete\"\n    ]);\n    if (fromSetupComplete != null) {\n        setValueByPath(toObject, [\n            \"setupComplete\"\n        ], liveMusicServerSetupCompleteFromMldev());\n    }\n    const fromServerContent = getValueByPath(fromObject, [\n        \"serverContent\"\n    ]);\n    if (fromServerContent != null) {\n        setValueByPath(toObject, [\n            \"serverContent\"\n        ], liveMusicServerContentFromMldev(fromServerContent));\n    }\n    const fromFilteredPrompt = getValueByPath(fromObject, [\n        \"filteredPrompt\"\n    ]);\n    if (fromFilteredPrompt != null) {\n        setValueByPath(toObject, [\n            \"filteredPrompt\"\n        ], liveMusicFilteredPromptFromMldev(fromFilteredPrompt));\n    }\n    return toObject;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ function videoMetadataToMldev$1(fromObject) {\n    const toObject = {};\n    const fromFps = getValueByPath(fromObject, [\n        \"fps\"\n    ]);\n    if (fromFps != null) {\n        setValueByPath(toObject, [\n            \"fps\"\n        ], fromFps);\n    }\n    const fromEndOffset = getValueByPath(fromObject, [\n        \"endOffset\"\n    ]);\n    if (fromEndOffset != null) {\n        setValueByPath(toObject, [\n            \"endOffset\"\n        ], fromEndOffset);\n    }\n    const fromStartOffset = getValueByPath(fromObject, [\n        \"startOffset\"\n    ]);\n    if (fromStartOffset != null) {\n        setValueByPath(toObject, [\n            \"startOffset\"\n        ], fromStartOffset);\n    }\n    return toObject;\n}\nfunction blobToMldev$1(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"displayName\"\n    ]) !== undefined) {\n        throw new Error(\"displayName parameter is not supported in Gemini API.\");\n    }\n    const fromData = getValueByPath(fromObject, [\n        \"data\"\n    ]);\n    if (fromData != null) {\n        setValueByPath(toObject, [\n            \"data\"\n        ], fromData);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction fileDataToMldev$1(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"displayName\"\n    ]) !== undefined) {\n        throw new Error(\"displayName parameter is not supported in Gemini API.\");\n    }\n    const fromFileUri = getValueByPath(fromObject, [\n        \"fileUri\"\n    ]);\n    if (fromFileUri != null) {\n        setValueByPath(toObject, [\n            \"fileUri\"\n        ], fromFileUri);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction partToMldev$1(fromObject) {\n    const toObject = {};\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        \"videoMetadata\"\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, [\n            \"videoMetadata\"\n        ], videoMetadataToMldev$1(fromVideoMetadata));\n    }\n    const fromThought = getValueByPath(fromObject, [\n        \"thought\"\n    ]);\n    if (fromThought != null) {\n        setValueByPath(toObject, [\n            \"thought\"\n        ], fromThought);\n    }\n    const fromInlineData = getValueByPath(fromObject, [\n        \"inlineData\"\n    ]);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, [\n            \"inlineData\"\n        ], blobToMldev$1(fromInlineData));\n    }\n    const fromFileData = getValueByPath(fromObject, [\n        \"fileData\"\n    ]);\n    if (fromFileData != null) {\n        setValueByPath(toObject, [\n            \"fileData\"\n        ], fileDataToMldev$1(fromFileData));\n    }\n    const fromThoughtSignature = getValueByPath(fromObject, [\n        \"thoughtSignature\"\n    ]);\n    if (fromThoughtSignature != null) {\n        setValueByPath(toObject, [\n            \"thoughtSignature\"\n        ], fromThoughtSignature);\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        \"codeExecutionResult\"\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, [\n            \"codeExecutionResult\"\n        ], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        \"executableCode\"\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, [\n            \"executableCode\"\n        ], fromExecutableCode);\n    }\n    const fromFunctionCall = getValueByPath(fromObject, [\n        \"functionCall\"\n    ]);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, [\n            \"functionCall\"\n        ], fromFunctionCall);\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        \"functionResponse\"\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, [\n            \"functionResponse\"\n        ], fromFunctionResponse);\n    }\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    return toObject;\n}\nfunction contentToMldev$1(fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, [\n        \"parts\"\n    ]);\n    if (fromParts != null) {\n        let transformedList = fromParts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return partToMldev$1(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"parts\"\n        ], transformedList);\n    }\n    const fromRole = getValueByPath(fromObject, [\n        \"role\"\n    ]);\n    if (fromRole != null) {\n        setValueByPath(toObject, [\n            \"role\"\n        ], fromRole);\n    }\n    return toObject;\n}\nfunction schemaToMldev(fromObject) {\n    const toObject = {};\n    const fromAnyOf = getValueByPath(fromObject, [\n        \"anyOf\"\n    ]);\n    if (fromAnyOf != null) {\n        setValueByPath(toObject, [\n            \"anyOf\"\n        ], fromAnyOf);\n    }\n    const fromDefault = getValueByPath(fromObject, [\n        \"default\"\n    ]);\n    if (fromDefault != null) {\n        setValueByPath(toObject, [\n            \"default\"\n        ], fromDefault);\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (fromDescription != null) {\n        setValueByPath(toObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromEnum = getValueByPath(fromObject, [\n        \"enum\"\n    ]);\n    if (fromEnum != null) {\n        setValueByPath(toObject, [\n            \"enum\"\n        ], fromEnum);\n    }\n    const fromExample = getValueByPath(fromObject, [\n        \"example\"\n    ]);\n    if (fromExample != null) {\n        setValueByPath(toObject, [\n            \"example\"\n        ], fromExample);\n    }\n    const fromFormat = getValueByPath(fromObject, [\n        \"format\"\n    ]);\n    if (fromFormat != null) {\n        setValueByPath(toObject, [\n            \"format\"\n        ], fromFormat);\n    }\n    const fromItems = getValueByPath(fromObject, [\n        \"items\"\n    ]);\n    if (fromItems != null) {\n        setValueByPath(toObject, [\n            \"items\"\n        ], fromItems);\n    }\n    const fromMaxItems = getValueByPath(fromObject, [\n        \"maxItems\"\n    ]);\n    if (fromMaxItems != null) {\n        setValueByPath(toObject, [\n            \"maxItems\"\n        ], fromMaxItems);\n    }\n    const fromMaxLength = getValueByPath(fromObject, [\n        \"maxLength\"\n    ]);\n    if (fromMaxLength != null) {\n        setValueByPath(toObject, [\n            \"maxLength\"\n        ], fromMaxLength);\n    }\n    const fromMaxProperties = getValueByPath(fromObject, [\n        \"maxProperties\"\n    ]);\n    if (fromMaxProperties != null) {\n        setValueByPath(toObject, [\n            \"maxProperties\"\n        ], fromMaxProperties);\n    }\n    const fromMaximum = getValueByPath(fromObject, [\n        \"maximum\"\n    ]);\n    if (fromMaximum != null) {\n        setValueByPath(toObject, [\n            \"maximum\"\n        ], fromMaximum);\n    }\n    const fromMinItems = getValueByPath(fromObject, [\n        \"minItems\"\n    ]);\n    if (fromMinItems != null) {\n        setValueByPath(toObject, [\n            \"minItems\"\n        ], fromMinItems);\n    }\n    const fromMinLength = getValueByPath(fromObject, [\n        \"minLength\"\n    ]);\n    if (fromMinLength != null) {\n        setValueByPath(toObject, [\n            \"minLength\"\n        ], fromMinLength);\n    }\n    const fromMinProperties = getValueByPath(fromObject, [\n        \"minProperties\"\n    ]);\n    if (fromMinProperties != null) {\n        setValueByPath(toObject, [\n            \"minProperties\"\n        ], fromMinProperties);\n    }\n    const fromMinimum = getValueByPath(fromObject, [\n        \"minimum\"\n    ]);\n    if (fromMinimum != null) {\n        setValueByPath(toObject, [\n            \"minimum\"\n        ], fromMinimum);\n    }\n    const fromNullable = getValueByPath(fromObject, [\n        \"nullable\"\n    ]);\n    if (fromNullable != null) {\n        setValueByPath(toObject, [\n            \"nullable\"\n        ], fromNullable);\n    }\n    const fromPattern = getValueByPath(fromObject, [\n        \"pattern\"\n    ]);\n    if (fromPattern != null) {\n        setValueByPath(toObject, [\n            \"pattern\"\n        ], fromPattern);\n    }\n    const fromProperties = getValueByPath(fromObject, [\n        \"properties\"\n    ]);\n    if (fromProperties != null) {\n        setValueByPath(toObject, [\n            \"properties\"\n        ], fromProperties);\n    }\n    const fromPropertyOrdering = getValueByPath(fromObject, [\n        \"propertyOrdering\"\n    ]);\n    if (fromPropertyOrdering != null) {\n        setValueByPath(toObject, [\n            \"propertyOrdering\"\n        ], fromPropertyOrdering);\n    }\n    const fromRequired = getValueByPath(fromObject, [\n        \"required\"\n    ]);\n    if (fromRequired != null) {\n        setValueByPath(toObject, [\n            \"required\"\n        ], fromRequired);\n    }\n    const fromTitle = getValueByPath(fromObject, [\n        \"title\"\n    ]);\n    if (fromTitle != null) {\n        setValueByPath(toObject, [\n            \"title\"\n        ], fromTitle);\n    }\n    const fromType = getValueByPath(fromObject, [\n        \"type\"\n    ]);\n    if (fromType != null) {\n        setValueByPath(toObject, [\n            \"type\"\n        ], fromType);\n    }\n    return toObject;\n}\nfunction safetySettingToMldev(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"method\"\n    ]) !== undefined) {\n        throw new Error(\"method parameter is not supported in Gemini API.\");\n    }\n    const fromCategory = getValueByPath(fromObject, [\n        \"category\"\n    ]);\n    if (fromCategory != null) {\n        setValueByPath(toObject, [\n            \"category\"\n        ], fromCategory);\n    }\n    const fromThreshold = getValueByPath(fromObject, [\n        \"threshold\"\n    ]);\n    if (fromThreshold != null) {\n        setValueByPath(toObject, [\n            \"threshold\"\n        ], fromThreshold);\n    }\n    return toObject;\n}\nfunction functionDeclarationToMldev$1(fromObject) {\n    const toObject = {};\n    const fromBehavior = getValueByPath(fromObject, [\n        \"behavior\"\n    ]);\n    if (fromBehavior != null) {\n        setValueByPath(toObject, [\n            \"behavior\"\n        ], fromBehavior);\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (fromDescription != null) {\n        setValueByPath(toObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromParameters = getValueByPath(fromObject, [\n        \"parameters\"\n    ]);\n    if (fromParameters != null) {\n        setValueByPath(toObject, [\n            \"parameters\"\n        ], fromParameters);\n    }\n    const fromParametersJsonSchema = getValueByPath(fromObject, [\n        \"parametersJsonSchema\"\n    ]);\n    if (fromParametersJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"parametersJsonSchema\"\n        ], fromParametersJsonSchema);\n    }\n    const fromResponse = getValueByPath(fromObject, [\n        \"response\"\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, [\n            \"response\"\n        ], fromResponse);\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        \"responseJsonSchema\"\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"responseJsonSchema\"\n        ], fromResponseJsonSchema);\n    }\n    return toObject;\n}\nfunction intervalToMldev$1(fromObject) {\n    const toObject = {};\n    const fromStartTime = getValueByPath(fromObject, [\n        \"startTime\"\n    ]);\n    if (fromStartTime != null) {\n        setValueByPath(toObject, [\n            \"startTime\"\n        ], fromStartTime);\n    }\n    const fromEndTime = getValueByPath(fromObject, [\n        \"endTime\"\n    ]);\n    if (fromEndTime != null) {\n        setValueByPath(toObject, [\n            \"endTime\"\n        ], fromEndTime);\n    }\n    return toObject;\n}\nfunction googleSearchToMldev$1(fromObject) {\n    const toObject = {};\n    const fromTimeRangeFilter = getValueByPath(fromObject, [\n        \"timeRangeFilter\"\n    ]);\n    if (fromTimeRangeFilter != null) {\n        setValueByPath(toObject, [\n            \"timeRangeFilter\"\n        ], intervalToMldev$1(fromTimeRangeFilter));\n    }\n    return toObject;\n}\nfunction dynamicRetrievalConfigToMldev$1(fromObject) {\n    const toObject = {};\n    const fromMode = getValueByPath(fromObject, [\n        \"mode\"\n    ]);\n    if (fromMode != null) {\n        setValueByPath(toObject, [\n            \"mode\"\n        ], fromMode);\n    }\n    const fromDynamicThreshold = getValueByPath(fromObject, [\n        \"dynamicThreshold\"\n    ]);\n    if (fromDynamicThreshold != null) {\n        setValueByPath(toObject, [\n            \"dynamicThreshold\"\n        ], fromDynamicThreshold);\n    }\n    return toObject;\n}\nfunction googleSearchRetrievalToMldev$1(fromObject) {\n    const toObject = {};\n    const fromDynamicRetrievalConfig = getValueByPath(fromObject, [\n        \"dynamicRetrievalConfig\"\n    ]);\n    if (fromDynamicRetrievalConfig != null) {\n        setValueByPath(toObject, [\n            \"dynamicRetrievalConfig\"\n        ], dynamicRetrievalConfigToMldev$1(fromDynamicRetrievalConfig));\n    }\n    return toObject;\n}\nfunction urlContextToMldev$1() {\n    const toObject = {};\n    return toObject;\n}\nfunction toolToMldev$1(fromObject) {\n    const toObject = {};\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        \"functionDeclarations\"\n    ]);\n    if (fromFunctionDeclarations != null) {\n        let transformedList = fromFunctionDeclarations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return functionDeclarationToMldev$1(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"functionDeclarations\"\n        ], transformedList);\n    }\n    if (getValueByPath(fromObject, [\n        \"retrieval\"\n    ]) !== undefined) {\n        throw new Error(\"retrieval parameter is not supported in Gemini API.\");\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, [\n        \"googleSearch\"\n    ]);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, [\n            \"googleSearch\"\n        ], googleSearchToMldev$1(fromGoogleSearch));\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        \"googleSearchRetrieval\"\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, [\n            \"googleSearchRetrieval\"\n        ], googleSearchRetrievalToMldev$1(fromGoogleSearchRetrieval));\n    }\n    if (getValueByPath(fromObject, [\n        \"enterpriseWebSearch\"\n    ]) !== undefined) {\n        throw new Error(\"enterpriseWebSearch parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"googleMaps\"\n    ]) !== undefined) {\n        throw new Error(\"googleMaps parameter is not supported in Gemini API.\");\n    }\n    const fromUrlContext = getValueByPath(fromObject, [\n        \"urlContext\"\n    ]);\n    if (fromUrlContext != null) {\n        setValueByPath(toObject, [\n            \"urlContext\"\n        ], urlContextToMldev$1());\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        \"codeExecution\"\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, [\n            \"codeExecution\"\n        ], fromCodeExecution);\n    }\n    return toObject;\n}\nfunction functionCallingConfigToMldev(fromObject) {\n    const toObject = {};\n    const fromMode = getValueByPath(fromObject, [\n        \"mode\"\n    ]);\n    if (fromMode != null) {\n        setValueByPath(toObject, [\n            \"mode\"\n        ], fromMode);\n    }\n    const fromAllowedFunctionNames = getValueByPath(fromObject, [\n        \"allowedFunctionNames\"\n    ]);\n    if (fromAllowedFunctionNames != null) {\n        setValueByPath(toObject, [\n            \"allowedFunctionNames\"\n        ], fromAllowedFunctionNames);\n    }\n    return toObject;\n}\nfunction latLngToMldev(fromObject) {\n    const toObject = {};\n    const fromLatitude = getValueByPath(fromObject, [\n        \"latitude\"\n    ]);\n    if (fromLatitude != null) {\n        setValueByPath(toObject, [\n            \"latitude\"\n        ], fromLatitude);\n    }\n    const fromLongitude = getValueByPath(fromObject, [\n        \"longitude\"\n    ]);\n    if (fromLongitude != null) {\n        setValueByPath(toObject, [\n            \"longitude\"\n        ], fromLongitude);\n    }\n    return toObject;\n}\nfunction retrievalConfigToMldev(fromObject) {\n    const toObject = {};\n    const fromLatLng = getValueByPath(fromObject, [\n        \"latLng\"\n    ]);\n    if (fromLatLng != null) {\n        setValueByPath(toObject, [\n            \"latLng\"\n        ], latLngToMldev(fromLatLng));\n    }\n    const fromLanguageCode = getValueByPath(fromObject, [\n        \"languageCode\"\n    ]);\n    if (fromLanguageCode != null) {\n        setValueByPath(toObject, [\n            \"languageCode\"\n        ], fromLanguageCode);\n    }\n    return toObject;\n}\nfunction toolConfigToMldev(fromObject) {\n    const toObject = {};\n    const fromFunctionCallingConfig = getValueByPath(fromObject, [\n        \"functionCallingConfig\"\n    ]);\n    if (fromFunctionCallingConfig != null) {\n        setValueByPath(toObject, [\n            \"functionCallingConfig\"\n        ], functionCallingConfigToMldev(fromFunctionCallingConfig));\n    }\n    const fromRetrievalConfig = getValueByPath(fromObject, [\n        \"retrievalConfig\"\n    ]);\n    if (fromRetrievalConfig != null) {\n        setValueByPath(toObject, [\n            \"retrievalConfig\"\n        ], retrievalConfigToMldev(fromRetrievalConfig));\n    }\n    return toObject;\n}\nfunction prebuiltVoiceConfigToMldev$1(fromObject) {\n    const toObject = {};\n    const fromVoiceName = getValueByPath(fromObject, [\n        \"voiceName\"\n    ]);\n    if (fromVoiceName != null) {\n        setValueByPath(toObject, [\n            \"voiceName\"\n        ], fromVoiceName);\n    }\n    return toObject;\n}\nfunction voiceConfigToMldev$1(fromObject) {\n    const toObject = {};\n    const fromPrebuiltVoiceConfig = getValueByPath(fromObject, [\n        \"prebuiltVoiceConfig\"\n    ]);\n    if (fromPrebuiltVoiceConfig != null) {\n        setValueByPath(toObject, [\n            \"prebuiltVoiceConfig\"\n        ], prebuiltVoiceConfigToMldev$1(fromPrebuiltVoiceConfig));\n    }\n    return toObject;\n}\nfunction speakerVoiceConfigToMldev$1(fromObject) {\n    const toObject = {};\n    const fromSpeaker = getValueByPath(fromObject, [\n        \"speaker\"\n    ]);\n    if (fromSpeaker != null) {\n        setValueByPath(toObject, [\n            \"speaker\"\n        ], fromSpeaker);\n    }\n    const fromVoiceConfig = getValueByPath(fromObject, [\n        \"voiceConfig\"\n    ]);\n    if (fromVoiceConfig != null) {\n        setValueByPath(toObject, [\n            \"voiceConfig\"\n        ], voiceConfigToMldev$1(fromVoiceConfig));\n    }\n    return toObject;\n}\nfunction multiSpeakerVoiceConfigToMldev$1(fromObject) {\n    const toObject = {};\n    const fromSpeakerVoiceConfigs = getValueByPath(fromObject, [\n        \"speakerVoiceConfigs\"\n    ]);\n    if (fromSpeakerVoiceConfigs != null) {\n        let transformedList = fromSpeakerVoiceConfigs;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return speakerVoiceConfigToMldev$1(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"speakerVoiceConfigs\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction speechConfigToMldev$1(fromObject) {\n    const toObject = {};\n    const fromVoiceConfig = getValueByPath(fromObject, [\n        \"voiceConfig\"\n    ]);\n    if (fromVoiceConfig != null) {\n        setValueByPath(toObject, [\n            \"voiceConfig\"\n        ], voiceConfigToMldev$1(fromVoiceConfig));\n    }\n    const fromMultiSpeakerVoiceConfig = getValueByPath(fromObject, [\n        \"multiSpeakerVoiceConfig\"\n    ]);\n    if (fromMultiSpeakerVoiceConfig != null) {\n        setValueByPath(toObject, [\n            \"multiSpeakerVoiceConfig\"\n        ], multiSpeakerVoiceConfigToMldev$1(fromMultiSpeakerVoiceConfig));\n    }\n    const fromLanguageCode = getValueByPath(fromObject, [\n        \"languageCode\"\n    ]);\n    if (fromLanguageCode != null) {\n        setValueByPath(toObject, [\n            \"languageCode\"\n        ], fromLanguageCode);\n    }\n    return toObject;\n}\nfunction thinkingConfigToMldev(fromObject) {\n    const toObject = {};\n    const fromIncludeThoughts = getValueByPath(fromObject, [\n        \"includeThoughts\"\n    ]);\n    if (fromIncludeThoughts != null) {\n        setValueByPath(toObject, [\n            \"includeThoughts\"\n        ], fromIncludeThoughts);\n    }\n    const fromThinkingBudget = getValueByPath(fromObject, [\n        \"thinkingBudget\"\n    ]);\n    if (fromThinkingBudget != null) {\n        setValueByPath(toObject, [\n            \"thinkingBudget\"\n        ], fromThinkingBudget);\n    }\n    return toObject;\n}\nfunction generateContentConfigToMldev(apiClient, fromObject, parentObject) {\n    const toObject = {};\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        \"systemInstruction\"\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, [\n            \"systemInstruction\"\n        ], contentToMldev$1(tContent(fromSystemInstruction)));\n    }\n    const fromTemperature = getValueByPath(fromObject, [\n        \"temperature\"\n    ]);\n    if (fromTemperature != null) {\n        setValueByPath(toObject, [\n            \"temperature\"\n        ], fromTemperature);\n    }\n    const fromTopP = getValueByPath(fromObject, [\n        \"topP\"\n    ]);\n    if (fromTopP != null) {\n        setValueByPath(toObject, [\n            \"topP\"\n        ], fromTopP);\n    }\n    const fromTopK = getValueByPath(fromObject, [\n        \"topK\"\n    ]);\n    if (fromTopK != null) {\n        setValueByPath(toObject, [\n            \"topK\"\n        ], fromTopK);\n    }\n    const fromCandidateCount = getValueByPath(fromObject, [\n        \"candidateCount\"\n    ]);\n    if (fromCandidateCount != null) {\n        setValueByPath(toObject, [\n            \"candidateCount\"\n        ], fromCandidateCount);\n    }\n    const fromMaxOutputTokens = getValueByPath(fromObject, [\n        \"maxOutputTokens\"\n    ]);\n    if (fromMaxOutputTokens != null) {\n        setValueByPath(toObject, [\n            \"maxOutputTokens\"\n        ], fromMaxOutputTokens);\n    }\n    const fromStopSequences = getValueByPath(fromObject, [\n        \"stopSequences\"\n    ]);\n    if (fromStopSequences != null) {\n        setValueByPath(toObject, [\n            \"stopSequences\"\n        ], fromStopSequences);\n    }\n    const fromResponseLogprobs = getValueByPath(fromObject, [\n        \"responseLogprobs\"\n    ]);\n    if (fromResponseLogprobs != null) {\n        setValueByPath(toObject, [\n            \"responseLogprobs\"\n        ], fromResponseLogprobs);\n    }\n    const fromLogprobs = getValueByPath(fromObject, [\n        \"logprobs\"\n    ]);\n    if (fromLogprobs != null) {\n        setValueByPath(toObject, [\n            \"logprobs\"\n        ], fromLogprobs);\n    }\n    const fromPresencePenalty = getValueByPath(fromObject, [\n        \"presencePenalty\"\n    ]);\n    if (fromPresencePenalty != null) {\n        setValueByPath(toObject, [\n            \"presencePenalty\"\n        ], fromPresencePenalty);\n    }\n    const fromFrequencyPenalty = getValueByPath(fromObject, [\n        \"frequencyPenalty\"\n    ]);\n    if (fromFrequencyPenalty != null) {\n        setValueByPath(toObject, [\n            \"frequencyPenalty\"\n        ], fromFrequencyPenalty);\n    }\n    const fromSeed = getValueByPath(fromObject, [\n        \"seed\"\n    ]);\n    if (fromSeed != null) {\n        setValueByPath(toObject, [\n            \"seed\"\n        ], fromSeed);\n    }\n    const fromResponseMimeType = getValueByPath(fromObject, [\n        \"responseMimeType\"\n    ]);\n    if (fromResponseMimeType != null) {\n        setValueByPath(toObject, [\n            \"responseMimeType\"\n        ], fromResponseMimeType);\n    }\n    const fromResponseSchema = getValueByPath(fromObject, [\n        \"responseSchema\"\n    ]);\n    if (fromResponseSchema != null) {\n        setValueByPath(toObject, [\n            \"responseSchema\"\n        ], schemaToMldev(tSchema(fromResponseSchema)));\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        \"responseJsonSchema\"\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"responseJsonSchema\"\n        ], fromResponseJsonSchema);\n    }\n    if (getValueByPath(fromObject, [\n        \"routingConfig\"\n    ]) !== undefined) {\n        throw new Error(\"routingConfig parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"modelSelectionConfig\"\n    ]) !== undefined) {\n        throw new Error(\"modelSelectionConfig parameter is not supported in Gemini API.\");\n    }\n    const fromSafetySettings = getValueByPath(fromObject, [\n        \"safetySettings\"\n    ]);\n    if (parentObject !== undefined && fromSafetySettings != null) {\n        let transformedList = fromSafetySettings;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return safetySettingToMldev(item);\n            });\n        }\n        setValueByPath(parentObject, [\n            \"safetySettings\"\n        ], transformedList);\n    }\n    const fromTools = getValueByPath(fromObject, [\n        \"tools\"\n    ]);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = tTools(fromTools);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return toolToMldev$1(tTool(item));\n            });\n        }\n        setValueByPath(parentObject, [\n            \"tools\"\n        ], transformedList);\n    }\n    const fromToolConfig = getValueByPath(fromObject, [\n        \"toolConfig\"\n    ]);\n    if (parentObject !== undefined && fromToolConfig != null) {\n        setValueByPath(parentObject, [\n            \"toolConfig\"\n        ], toolConfigToMldev(fromToolConfig));\n    }\n    if (getValueByPath(fromObject, [\n        \"labels\"\n    ]) !== undefined) {\n        throw new Error(\"labels parameter is not supported in Gemini API.\");\n    }\n    const fromCachedContent = getValueByPath(fromObject, [\n        \"cachedContent\"\n    ]);\n    if (parentObject !== undefined && fromCachedContent != null) {\n        setValueByPath(parentObject, [\n            \"cachedContent\"\n        ], tCachedContentName(apiClient, fromCachedContent));\n    }\n    const fromResponseModalities = getValueByPath(fromObject, [\n        \"responseModalities\"\n    ]);\n    if (fromResponseModalities != null) {\n        setValueByPath(toObject, [\n            \"responseModalities\"\n        ], fromResponseModalities);\n    }\n    const fromMediaResolution = getValueByPath(fromObject, [\n        \"mediaResolution\"\n    ]);\n    if (fromMediaResolution != null) {\n        setValueByPath(toObject, [\n            \"mediaResolution\"\n        ], fromMediaResolution);\n    }\n    const fromSpeechConfig = getValueByPath(fromObject, [\n        \"speechConfig\"\n    ]);\n    if (fromSpeechConfig != null) {\n        setValueByPath(toObject, [\n            \"speechConfig\"\n        ], speechConfigToMldev$1(tSpeechConfig(fromSpeechConfig)));\n    }\n    if (getValueByPath(fromObject, [\n        \"audioTimestamp\"\n    ]) !== undefined) {\n        throw new Error(\"audioTimestamp parameter is not supported in Gemini API.\");\n    }\n    const fromThinkingConfig = getValueByPath(fromObject, [\n        \"thinkingConfig\"\n    ]);\n    if (fromThinkingConfig != null) {\n        setValueByPath(toObject, [\n            \"thinkingConfig\"\n        ], thinkingConfigToMldev(fromThinkingConfig));\n    }\n    return toObject;\n}\nfunction generateContentParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, [\n        \"contents\"\n    ]);\n    if (fromContents != null) {\n        let transformedList = tContents(fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return contentToMldev$1(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"contents\"\n        ], transformedList);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"generationConfig\"\n        ], generateContentConfigToMldev(apiClient, fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction embedContentConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromTaskType = getValueByPath(fromObject, [\n        \"taskType\"\n    ]);\n    if (parentObject !== undefined && fromTaskType != null) {\n        setValueByPath(parentObject, [\n            \"requests[]\",\n            \"taskType\"\n        ], fromTaskType);\n    }\n    const fromTitle = getValueByPath(fromObject, [\n        \"title\"\n    ]);\n    if (parentObject !== undefined && fromTitle != null) {\n        setValueByPath(parentObject, [\n            \"requests[]\",\n            \"title\"\n        ], fromTitle);\n    }\n    const fromOutputDimensionality = getValueByPath(fromObject, [\n        \"outputDimensionality\"\n    ]);\n    if (parentObject !== undefined && fromOutputDimensionality != null) {\n        setValueByPath(parentObject, [\n            \"requests[]\",\n            \"outputDimensionality\"\n        ], fromOutputDimensionality);\n    }\n    if (getValueByPath(fromObject, [\n        \"mimeType\"\n    ]) !== undefined) {\n        throw new Error(\"mimeType parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"autoTruncate\"\n    ]) !== undefined) {\n        throw new Error(\"autoTruncate parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction embedContentParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, [\n        \"contents\"\n    ]);\n    if (fromContents != null) {\n        setValueByPath(toObject, [\n            \"requests[]\",\n            \"content\"\n        ], tContentsForEmbed(apiClient, fromContents));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], embedContentConfigToMldev(fromConfig, toObject));\n    }\n    const fromModelForEmbedContent = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModelForEmbedContent !== undefined) {\n        setValueByPath(toObject, [\n            \"requests[]\",\n            \"model\"\n        ], tModel(apiClient, fromModelForEmbedContent));\n    }\n    return toObject;\n}\nfunction generateImagesConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"outputGcsUri\"\n    ]) !== undefined) {\n        throw new Error(\"outputGcsUri parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"negativePrompt\"\n    ]) !== undefined) {\n        throw new Error(\"negativePrompt parameter is not supported in Gemini API.\");\n    }\n    const fromNumberOfImages = getValueByPath(fromObject, [\n        \"numberOfImages\"\n    ]);\n    if (parentObject !== undefined && fromNumberOfImages != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"sampleCount\"\n        ], fromNumberOfImages);\n    }\n    const fromAspectRatio = getValueByPath(fromObject, [\n        \"aspectRatio\"\n    ]);\n    if (parentObject !== undefined && fromAspectRatio != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"aspectRatio\"\n        ], fromAspectRatio);\n    }\n    const fromGuidanceScale = getValueByPath(fromObject, [\n        \"guidanceScale\"\n    ]);\n    if (parentObject !== undefined && fromGuidanceScale != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"guidanceScale\"\n        ], fromGuidanceScale);\n    }\n    if (getValueByPath(fromObject, [\n        \"seed\"\n    ]) !== undefined) {\n        throw new Error(\"seed parameter is not supported in Gemini API.\");\n    }\n    const fromSafetyFilterLevel = getValueByPath(fromObject, [\n        \"safetyFilterLevel\"\n    ]);\n    if (parentObject !== undefined && fromSafetyFilterLevel != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"safetySetting\"\n        ], fromSafetyFilterLevel);\n    }\n    const fromPersonGeneration = getValueByPath(fromObject, [\n        \"personGeneration\"\n    ]);\n    if (parentObject !== undefined && fromPersonGeneration != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"personGeneration\"\n        ], fromPersonGeneration);\n    }\n    const fromIncludeSafetyAttributes = getValueByPath(fromObject, [\n        \"includeSafetyAttributes\"\n    ]);\n    if (parentObject !== undefined && fromIncludeSafetyAttributes != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"includeSafetyAttributes\"\n        ], fromIncludeSafetyAttributes);\n    }\n    const fromIncludeRaiReason = getValueByPath(fromObject, [\n        \"includeRaiReason\"\n    ]);\n    if (parentObject !== undefined && fromIncludeRaiReason != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"includeRaiReason\"\n        ], fromIncludeRaiReason);\n    }\n    const fromLanguage = getValueByPath(fromObject, [\n        \"language\"\n    ]);\n    if (parentObject !== undefined && fromLanguage != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"language\"\n        ], fromLanguage);\n    }\n    const fromOutputMimeType = getValueByPath(fromObject, [\n        \"outputMimeType\"\n    ]);\n    if (parentObject !== undefined && fromOutputMimeType != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"outputOptions\",\n            \"mimeType\"\n        ], fromOutputMimeType);\n    }\n    const fromOutputCompressionQuality = getValueByPath(fromObject, [\n        \"outputCompressionQuality\"\n    ]);\n    if (parentObject !== undefined && fromOutputCompressionQuality != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"outputOptions\",\n            \"compressionQuality\"\n        ], fromOutputCompressionQuality);\n    }\n    if (getValueByPath(fromObject, [\n        \"addWatermark\"\n    ]) !== undefined) {\n        throw new Error(\"addWatermark parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"enhancePrompt\"\n    ]) !== undefined) {\n        throw new Error(\"enhancePrompt parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction generateImagesParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromPrompt = getValueByPath(fromObject, [\n        \"prompt\"\n    ]);\n    if (fromPrompt != null) {\n        setValueByPath(toObject, [\n            \"instances[0]\",\n            \"prompt\"\n        ], fromPrompt);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], generateImagesConfigToMldev(fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction getModelParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], fromConfig);\n    }\n    return toObject;\n}\nfunction listModelsConfigToMldev(apiClient, fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, [\n        \"pageSize\"\n    ]);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageSize\"\n        ], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, [\n        \"pageToken\"\n    ]);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageToken\"\n        ], fromPageToken);\n    }\n    const fromFilter = getValueByPath(fromObject, [\n        \"filter\"\n    ]);\n    if (parentObject !== undefined && fromFilter != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"filter\"\n        ], fromFilter);\n    }\n    const fromQueryBase = getValueByPath(fromObject, [\n        \"queryBase\"\n    ]);\n    if (parentObject !== undefined && fromQueryBase != null) {\n        setValueByPath(parentObject, [\n            \"_url\",\n            \"models_url\"\n        ], tModelsUrl(apiClient, fromQueryBase));\n    }\n    return toObject;\n}\nfunction listModelsParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], listModelsConfigToMldev(apiClient, fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction updateModelConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (parentObject !== undefined && fromDisplayName != null) {\n        setValueByPath(parentObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (parentObject !== undefined && fromDescription != null) {\n        setValueByPath(parentObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromDefaultCheckpointId = getValueByPath(fromObject, [\n        \"defaultCheckpointId\"\n    ]);\n    if (parentObject !== undefined && fromDefaultCheckpointId != null) {\n        setValueByPath(parentObject, [\n            \"defaultCheckpointId\"\n        ], fromDefaultCheckpointId);\n    }\n    return toObject;\n}\nfunction updateModelParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], updateModelConfigToMldev(fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction deleteModelParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], fromConfig);\n    }\n    return toObject;\n}\nfunction countTokensConfigToMldev(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"systemInstruction\"\n    ]) !== undefined) {\n        throw new Error(\"systemInstruction parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"tools\"\n    ]) !== undefined) {\n        throw new Error(\"tools parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"generationConfig\"\n    ]) !== undefined) {\n        throw new Error(\"generationConfig parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction countTokensParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, [\n        \"contents\"\n    ]);\n    if (fromContents != null) {\n        let transformedList = tContents(fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return contentToMldev$1(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"contents\"\n        ], transformedList);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], countTokensConfigToMldev(fromConfig));\n    }\n    return toObject;\n}\nfunction imageToMldev(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"gcsUri\"\n    ]) !== undefined) {\n        throw new Error(\"gcsUri parameter is not supported in Gemini API.\");\n    }\n    const fromImageBytes = getValueByPath(fromObject, [\n        \"imageBytes\"\n    ]);\n    if (fromImageBytes != null) {\n        setValueByPath(toObject, [\n            \"bytesBase64Encoded\"\n        ], tBytes(fromImageBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction generateVideosConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromNumberOfVideos = getValueByPath(fromObject, [\n        \"numberOfVideos\"\n    ]);\n    if (parentObject !== undefined && fromNumberOfVideos != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"sampleCount\"\n        ], fromNumberOfVideos);\n    }\n    if (getValueByPath(fromObject, [\n        \"outputGcsUri\"\n    ]) !== undefined) {\n        throw new Error(\"outputGcsUri parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"fps\"\n    ]) !== undefined) {\n        throw new Error(\"fps parameter is not supported in Gemini API.\");\n    }\n    const fromDurationSeconds = getValueByPath(fromObject, [\n        \"durationSeconds\"\n    ]);\n    if (parentObject !== undefined && fromDurationSeconds != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"durationSeconds\"\n        ], fromDurationSeconds);\n    }\n    if (getValueByPath(fromObject, [\n        \"seed\"\n    ]) !== undefined) {\n        throw new Error(\"seed parameter is not supported in Gemini API.\");\n    }\n    const fromAspectRatio = getValueByPath(fromObject, [\n        \"aspectRatio\"\n    ]);\n    if (parentObject !== undefined && fromAspectRatio != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"aspectRatio\"\n        ], fromAspectRatio);\n    }\n    if (getValueByPath(fromObject, [\n        \"resolution\"\n    ]) !== undefined) {\n        throw new Error(\"resolution parameter is not supported in Gemini API.\");\n    }\n    const fromPersonGeneration = getValueByPath(fromObject, [\n        \"personGeneration\"\n    ]);\n    if (parentObject !== undefined && fromPersonGeneration != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"personGeneration\"\n        ], fromPersonGeneration);\n    }\n    if (getValueByPath(fromObject, [\n        \"pubsubTopic\"\n    ]) !== undefined) {\n        throw new Error(\"pubsubTopic parameter is not supported in Gemini API.\");\n    }\n    const fromNegativePrompt = getValueByPath(fromObject, [\n        \"negativePrompt\"\n    ]);\n    if (parentObject !== undefined && fromNegativePrompt != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"negativePrompt\"\n        ], fromNegativePrompt);\n    }\n    const fromEnhancePrompt = getValueByPath(fromObject, [\n        \"enhancePrompt\"\n    ]);\n    if (parentObject !== undefined && fromEnhancePrompt != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"enhancePrompt\"\n        ], fromEnhancePrompt);\n    }\n    if (getValueByPath(fromObject, [\n        \"generateAudio\"\n    ]) !== undefined) {\n        throw new Error(\"generateAudio parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"lastFrame\"\n    ]) !== undefined) {\n        throw new Error(\"lastFrame parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"compressionQuality\"\n    ]) !== undefined) {\n        throw new Error(\"compressionQuality parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction generateVideosParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromPrompt = getValueByPath(fromObject, [\n        \"prompt\"\n    ]);\n    if (fromPrompt != null) {\n        setValueByPath(toObject, [\n            \"instances[0]\",\n            \"prompt\"\n        ], fromPrompt);\n    }\n    const fromImage = getValueByPath(fromObject, [\n        \"image\"\n    ]);\n    if (fromImage != null) {\n        setValueByPath(toObject, [\n            \"instances[0]\",\n            \"image\"\n        ], imageToMldev(fromImage));\n    }\n    if (getValueByPath(fromObject, [\n        \"video\"\n    ]) !== undefined) {\n        throw new Error(\"video parameter is not supported in Gemini API.\");\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], generateVideosConfigToMldev(fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction videoMetadataToVertex(fromObject) {\n    const toObject = {};\n    const fromFps = getValueByPath(fromObject, [\n        \"fps\"\n    ]);\n    if (fromFps != null) {\n        setValueByPath(toObject, [\n            \"fps\"\n        ], fromFps);\n    }\n    const fromEndOffset = getValueByPath(fromObject, [\n        \"endOffset\"\n    ]);\n    if (fromEndOffset != null) {\n        setValueByPath(toObject, [\n            \"endOffset\"\n        ], fromEndOffset);\n    }\n    const fromStartOffset = getValueByPath(fromObject, [\n        \"startOffset\"\n    ]);\n    if (fromStartOffset != null) {\n        setValueByPath(toObject, [\n            \"startOffset\"\n        ], fromStartOffset);\n    }\n    return toObject;\n}\nfunction blobToVertex(fromObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromData = getValueByPath(fromObject, [\n        \"data\"\n    ]);\n    if (fromData != null) {\n        setValueByPath(toObject, [\n            \"data\"\n        ], fromData);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction fileDataToVertex(fromObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromFileUri = getValueByPath(fromObject, [\n        \"fileUri\"\n    ]);\n    if (fromFileUri != null) {\n        setValueByPath(toObject, [\n            \"fileUri\"\n        ], fromFileUri);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction partToVertex(fromObject) {\n    const toObject = {};\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        \"videoMetadata\"\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, [\n            \"videoMetadata\"\n        ], videoMetadataToVertex(fromVideoMetadata));\n    }\n    const fromThought = getValueByPath(fromObject, [\n        \"thought\"\n    ]);\n    if (fromThought != null) {\n        setValueByPath(toObject, [\n            \"thought\"\n        ], fromThought);\n    }\n    const fromInlineData = getValueByPath(fromObject, [\n        \"inlineData\"\n    ]);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, [\n            \"inlineData\"\n        ], blobToVertex(fromInlineData));\n    }\n    const fromFileData = getValueByPath(fromObject, [\n        \"fileData\"\n    ]);\n    if (fromFileData != null) {\n        setValueByPath(toObject, [\n            \"fileData\"\n        ], fileDataToVertex(fromFileData));\n    }\n    const fromThoughtSignature = getValueByPath(fromObject, [\n        \"thoughtSignature\"\n    ]);\n    if (fromThoughtSignature != null) {\n        setValueByPath(toObject, [\n            \"thoughtSignature\"\n        ], fromThoughtSignature);\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        \"codeExecutionResult\"\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, [\n            \"codeExecutionResult\"\n        ], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        \"executableCode\"\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, [\n            \"executableCode\"\n        ], fromExecutableCode);\n    }\n    const fromFunctionCall = getValueByPath(fromObject, [\n        \"functionCall\"\n    ]);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, [\n            \"functionCall\"\n        ], fromFunctionCall);\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        \"functionResponse\"\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, [\n            \"functionResponse\"\n        ], fromFunctionResponse);\n    }\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    return toObject;\n}\nfunction contentToVertex(fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, [\n        \"parts\"\n    ]);\n    if (fromParts != null) {\n        let transformedList = fromParts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return partToVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"parts\"\n        ], transformedList);\n    }\n    const fromRole = getValueByPath(fromObject, [\n        \"role\"\n    ]);\n    if (fromRole != null) {\n        setValueByPath(toObject, [\n            \"role\"\n        ], fromRole);\n    }\n    return toObject;\n}\nfunction schemaToVertex(fromObject) {\n    const toObject = {};\n    const fromAnyOf = getValueByPath(fromObject, [\n        \"anyOf\"\n    ]);\n    if (fromAnyOf != null) {\n        setValueByPath(toObject, [\n            \"anyOf\"\n        ], fromAnyOf);\n    }\n    const fromDefault = getValueByPath(fromObject, [\n        \"default\"\n    ]);\n    if (fromDefault != null) {\n        setValueByPath(toObject, [\n            \"default\"\n        ], fromDefault);\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (fromDescription != null) {\n        setValueByPath(toObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromEnum = getValueByPath(fromObject, [\n        \"enum\"\n    ]);\n    if (fromEnum != null) {\n        setValueByPath(toObject, [\n            \"enum\"\n        ], fromEnum);\n    }\n    const fromExample = getValueByPath(fromObject, [\n        \"example\"\n    ]);\n    if (fromExample != null) {\n        setValueByPath(toObject, [\n            \"example\"\n        ], fromExample);\n    }\n    const fromFormat = getValueByPath(fromObject, [\n        \"format\"\n    ]);\n    if (fromFormat != null) {\n        setValueByPath(toObject, [\n            \"format\"\n        ], fromFormat);\n    }\n    const fromItems = getValueByPath(fromObject, [\n        \"items\"\n    ]);\n    if (fromItems != null) {\n        setValueByPath(toObject, [\n            \"items\"\n        ], fromItems);\n    }\n    const fromMaxItems = getValueByPath(fromObject, [\n        \"maxItems\"\n    ]);\n    if (fromMaxItems != null) {\n        setValueByPath(toObject, [\n            \"maxItems\"\n        ], fromMaxItems);\n    }\n    const fromMaxLength = getValueByPath(fromObject, [\n        \"maxLength\"\n    ]);\n    if (fromMaxLength != null) {\n        setValueByPath(toObject, [\n            \"maxLength\"\n        ], fromMaxLength);\n    }\n    const fromMaxProperties = getValueByPath(fromObject, [\n        \"maxProperties\"\n    ]);\n    if (fromMaxProperties != null) {\n        setValueByPath(toObject, [\n            \"maxProperties\"\n        ], fromMaxProperties);\n    }\n    const fromMaximum = getValueByPath(fromObject, [\n        \"maximum\"\n    ]);\n    if (fromMaximum != null) {\n        setValueByPath(toObject, [\n            \"maximum\"\n        ], fromMaximum);\n    }\n    const fromMinItems = getValueByPath(fromObject, [\n        \"minItems\"\n    ]);\n    if (fromMinItems != null) {\n        setValueByPath(toObject, [\n            \"minItems\"\n        ], fromMinItems);\n    }\n    const fromMinLength = getValueByPath(fromObject, [\n        \"minLength\"\n    ]);\n    if (fromMinLength != null) {\n        setValueByPath(toObject, [\n            \"minLength\"\n        ], fromMinLength);\n    }\n    const fromMinProperties = getValueByPath(fromObject, [\n        \"minProperties\"\n    ]);\n    if (fromMinProperties != null) {\n        setValueByPath(toObject, [\n            \"minProperties\"\n        ], fromMinProperties);\n    }\n    const fromMinimum = getValueByPath(fromObject, [\n        \"minimum\"\n    ]);\n    if (fromMinimum != null) {\n        setValueByPath(toObject, [\n            \"minimum\"\n        ], fromMinimum);\n    }\n    const fromNullable = getValueByPath(fromObject, [\n        \"nullable\"\n    ]);\n    if (fromNullable != null) {\n        setValueByPath(toObject, [\n            \"nullable\"\n        ], fromNullable);\n    }\n    const fromPattern = getValueByPath(fromObject, [\n        \"pattern\"\n    ]);\n    if (fromPattern != null) {\n        setValueByPath(toObject, [\n            \"pattern\"\n        ], fromPattern);\n    }\n    const fromProperties = getValueByPath(fromObject, [\n        \"properties\"\n    ]);\n    if (fromProperties != null) {\n        setValueByPath(toObject, [\n            \"properties\"\n        ], fromProperties);\n    }\n    const fromPropertyOrdering = getValueByPath(fromObject, [\n        \"propertyOrdering\"\n    ]);\n    if (fromPropertyOrdering != null) {\n        setValueByPath(toObject, [\n            \"propertyOrdering\"\n        ], fromPropertyOrdering);\n    }\n    const fromRequired = getValueByPath(fromObject, [\n        \"required\"\n    ]);\n    if (fromRequired != null) {\n        setValueByPath(toObject, [\n            \"required\"\n        ], fromRequired);\n    }\n    const fromTitle = getValueByPath(fromObject, [\n        \"title\"\n    ]);\n    if (fromTitle != null) {\n        setValueByPath(toObject, [\n            \"title\"\n        ], fromTitle);\n    }\n    const fromType = getValueByPath(fromObject, [\n        \"type\"\n    ]);\n    if (fromType != null) {\n        setValueByPath(toObject, [\n            \"type\"\n        ], fromType);\n    }\n    return toObject;\n}\nfunction modelSelectionConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromFeatureSelectionPreference = getValueByPath(fromObject, [\n        \"featureSelectionPreference\"\n    ]);\n    if (fromFeatureSelectionPreference != null) {\n        setValueByPath(toObject, [\n            \"featureSelectionPreference\"\n        ], fromFeatureSelectionPreference);\n    }\n    return toObject;\n}\nfunction safetySettingToVertex(fromObject) {\n    const toObject = {};\n    const fromMethod = getValueByPath(fromObject, [\n        \"method\"\n    ]);\n    if (fromMethod != null) {\n        setValueByPath(toObject, [\n            \"method\"\n        ], fromMethod);\n    }\n    const fromCategory = getValueByPath(fromObject, [\n        \"category\"\n    ]);\n    if (fromCategory != null) {\n        setValueByPath(toObject, [\n            \"category\"\n        ], fromCategory);\n    }\n    const fromThreshold = getValueByPath(fromObject, [\n        \"threshold\"\n    ]);\n    if (fromThreshold != null) {\n        setValueByPath(toObject, [\n            \"threshold\"\n        ], fromThreshold);\n    }\n    return toObject;\n}\nfunction functionDeclarationToVertex(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"behavior\"\n    ]) !== undefined) {\n        throw new Error(\"behavior parameter is not supported in Vertex AI.\");\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (fromDescription != null) {\n        setValueByPath(toObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromParameters = getValueByPath(fromObject, [\n        \"parameters\"\n    ]);\n    if (fromParameters != null) {\n        setValueByPath(toObject, [\n            \"parameters\"\n        ], fromParameters);\n    }\n    const fromParametersJsonSchema = getValueByPath(fromObject, [\n        \"parametersJsonSchema\"\n    ]);\n    if (fromParametersJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"parametersJsonSchema\"\n        ], fromParametersJsonSchema);\n    }\n    const fromResponse = getValueByPath(fromObject, [\n        \"response\"\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, [\n            \"response\"\n        ], fromResponse);\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        \"responseJsonSchema\"\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"responseJsonSchema\"\n        ], fromResponseJsonSchema);\n    }\n    return toObject;\n}\nfunction intervalToVertex(fromObject) {\n    const toObject = {};\n    const fromStartTime = getValueByPath(fromObject, [\n        \"startTime\"\n    ]);\n    if (fromStartTime != null) {\n        setValueByPath(toObject, [\n            \"startTime\"\n        ], fromStartTime);\n    }\n    const fromEndTime = getValueByPath(fromObject, [\n        \"endTime\"\n    ]);\n    if (fromEndTime != null) {\n        setValueByPath(toObject, [\n            \"endTime\"\n        ], fromEndTime);\n    }\n    return toObject;\n}\nfunction googleSearchToVertex(fromObject) {\n    const toObject = {};\n    const fromTimeRangeFilter = getValueByPath(fromObject, [\n        \"timeRangeFilter\"\n    ]);\n    if (fromTimeRangeFilter != null) {\n        setValueByPath(toObject, [\n            \"timeRangeFilter\"\n        ], intervalToVertex(fromTimeRangeFilter));\n    }\n    return toObject;\n}\nfunction dynamicRetrievalConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromMode = getValueByPath(fromObject, [\n        \"mode\"\n    ]);\n    if (fromMode != null) {\n        setValueByPath(toObject, [\n            \"mode\"\n        ], fromMode);\n    }\n    const fromDynamicThreshold = getValueByPath(fromObject, [\n        \"dynamicThreshold\"\n    ]);\n    if (fromDynamicThreshold != null) {\n        setValueByPath(toObject, [\n            \"dynamicThreshold\"\n        ], fromDynamicThreshold);\n    }\n    return toObject;\n}\nfunction googleSearchRetrievalToVertex(fromObject) {\n    const toObject = {};\n    const fromDynamicRetrievalConfig = getValueByPath(fromObject, [\n        \"dynamicRetrievalConfig\"\n    ]);\n    if (fromDynamicRetrievalConfig != null) {\n        setValueByPath(toObject, [\n            \"dynamicRetrievalConfig\"\n        ], dynamicRetrievalConfigToVertex(fromDynamicRetrievalConfig));\n    }\n    return toObject;\n}\nfunction enterpriseWebSearchToVertex() {\n    const toObject = {};\n    return toObject;\n}\nfunction apiKeyConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromApiKeyString = getValueByPath(fromObject, [\n        \"apiKeyString\"\n    ]);\n    if (fromApiKeyString != null) {\n        setValueByPath(toObject, [\n            \"apiKeyString\"\n        ], fromApiKeyString);\n    }\n    return toObject;\n}\nfunction authConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromApiKeyConfig = getValueByPath(fromObject, [\n        \"apiKeyConfig\"\n    ]);\n    if (fromApiKeyConfig != null) {\n        setValueByPath(toObject, [\n            \"apiKeyConfig\"\n        ], apiKeyConfigToVertex(fromApiKeyConfig));\n    }\n    const fromAuthType = getValueByPath(fromObject, [\n        \"authType\"\n    ]);\n    if (fromAuthType != null) {\n        setValueByPath(toObject, [\n            \"authType\"\n        ], fromAuthType);\n    }\n    const fromGoogleServiceAccountConfig = getValueByPath(fromObject, [\n        \"googleServiceAccountConfig\"\n    ]);\n    if (fromGoogleServiceAccountConfig != null) {\n        setValueByPath(toObject, [\n            \"googleServiceAccountConfig\"\n        ], fromGoogleServiceAccountConfig);\n    }\n    const fromHttpBasicAuthConfig = getValueByPath(fromObject, [\n        \"httpBasicAuthConfig\"\n    ]);\n    if (fromHttpBasicAuthConfig != null) {\n        setValueByPath(toObject, [\n            \"httpBasicAuthConfig\"\n        ], fromHttpBasicAuthConfig);\n    }\n    const fromOauthConfig = getValueByPath(fromObject, [\n        \"oauthConfig\"\n    ]);\n    if (fromOauthConfig != null) {\n        setValueByPath(toObject, [\n            \"oauthConfig\"\n        ], fromOauthConfig);\n    }\n    const fromOidcConfig = getValueByPath(fromObject, [\n        \"oidcConfig\"\n    ]);\n    if (fromOidcConfig != null) {\n        setValueByPath(toObject, [\n            \"oidcConfig\"\n        ], fromOidcConfig);\n    }\n    return toObject;\n}\nfunction googleMapsToVertex(fromObject) {\n    const toObject = {};\n    const fromAuthConfig = getValueByPath(fromObject, [\n        \"authConfig\"\n    ]);\n    if (fromAuthConfig != null) {\n        setValueByPath(toObject, [\n            \"authConfig\"\n        ], authConfigToVertex(fromAuthConfig));\n    }\n    return toObject;\n}\nfunction urlContextToVertex() {\n    const toObject = {};\n    return toObject;\n}\nfunction toolToVertex(fromObject) {\n    const toObject = {};\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        \"functionDeclarations\"\n    ]);\n    if (fromFunctionDeclarations != null) {\n        let transformedList = fromFunctionDeclarations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return functionDeclarationToVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"functionDeclarations\"\n        ], transformedList);\n    }\n    const fromRetrieval = getValueByPath(fromObject, [\n        \"retrieval\"\n    ]);\n    if (fromRetrieval != null) {\n        setValueByPath(toObject, [\n            \"retrieval\"\n        ], fromRetrieval);\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, [\n        \"googleSearch\"\n    ]);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, [\n            \"googleSearch\"\n        ], googleSearchToVertex(fromGoogleSearch));\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        \"googleSearchRetrieval\"\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, [\n            \"googleSearchRetrieval\"\n        ], googleSearchRetrievalToVertex(fromGoogleSearchRetrieval));\n    }\n    const fromEnterpriseWebSearch = getValueByPath(fromObject, [\n        \"enterpriseWebSearch\"\n    ]);\n    if (fromEnterpriseWebSearch != null) {\n        setValueByPath(toObject, [\n            \"enterpriseWebSearch\"\n        ], enterpriseWebSearchToVertex());\n    }\n    const fromGoogleMaps = getValueByPath(fromObject, [\n        \"googleMaps\"\n    ]);\n    if (fromGoogleMaps != null) {\n        setValueByPath(toObject, [\n            \"googleMaps\"\n        ], googleMapsToVertex(fromGoogleMaps));\n    }\n    const fromUrlContext = getValueByPath(fromObject, [\n        \"urlContext\"\n    ]);\n    if (fromUrlContext != null) {\n        setValueByPath(toObject, [\n            \"urlContext\"\n        ], urlContextToVertex());\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        \"codeExecution\"\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, [\n            \"codeExecution\"\n        ], fromCodeExecution);\n    }\n    return toObject;\n}\nfunction functionCallingConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromMode = getValueByPath(fromObject, [\n        \"mode\"\n    ]);\n    if (fromMode != null) {\n        setValueByPath(toObject, [\n            \"mode\"\n        ], fromMode);\n    }\n    const fromAllowedFunctionNames = getValueByPath(fromObject, [\n        \"allowedFunctionNames\"\n    ]);\n    if (fromAllowedFunctionNames != null) {\n        setValueByPath(toObject, [\n            \"allowedFunctionNames\"\n        ], fromAllowedFunctionNames);\n    }\n    return toObject;\n}\nfunction latLngToVertex(fromObject) {\n    const toObject = {};\n    const fromLatitude = getValueByPath(fromObject, [\n        \"latitude\"\n    ]);\n    if (fromLatitude != null) {\n        setValueByPath(toObject, [\n            \"latitude\"\n        ], fromLatitude);\n    }\n    const fromLongitude = getValueByPath(fromObject, [\n        \"longitude\"\n    ]);\n    if (fromLongitude != null) {\n        setValueByPath(toObject, [\n            \"longitude\"\n        ], fromLongitude);\n    }\n    return toObject;\n}\nfunction retrievalConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromLatLng = getValueByPath(fromObject, [\n        \"latLng\"\n    ]);\n    if (fromLatLng != null) {\n        setValueByPath(toObject, [\n            \"latLng\"\n        ], latLngToVertex(fromLatLng));\n    }\n    const fromLanguageCode = getValueByPath(fromObject, [\n        \"languageCode\"\n    ]);\n    if (fromLanguageCode != null) {\n        setValueByPath(toObject, [\n            \"languageCode\"\n        ], fromLanguageCode);\n    }\n    return toObject;\n}\nfunction toolConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromFunctionCallingConfig = getValueByPath(fromObject, [\n        \"functionCallingConfig\"\n    ]);\n    if (fromFunctionCallingConfig != null) {\n        setValueByPath(toObject, [\n            \"functionCallingConfig\"\n        ], functionCallingConfigToVertex(fromFunctionCallingConfig));\n    }\n    const fromRetrievalConfig = getValueByPath(fromObject, [\n        \"retrievalConfig\"\n    ]);\n    if (fromRetrievalConfig != null) {\n        setValueByPath(toObject, [\n            \"retrievalConfig\"\n        ], retrievalConfigToVertex(fromRetrievalConfig));\n    }\n    return toObject;\n}\nfunction prebuiltVoiceConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromVoiceName = getValueByPath(fromObject, [\n        \"voiceName\"\n    ]);\n    if (fromVoiceName != null) {\n        setValueByPath(toObject, [\n            \"voiceName\"\n        ], fromVoiceName);\n    }\n    return toObject;\n}\nfunction voiceConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromPrebuiltVoiceConfig = getValueByPath(fromObject, [\n        \"prebuiltVoiceConfig\"\n    ]);\n    if (fromPrebuiltVoiceConfig != null) {\n        setValueByPath(toObject, [\n            \"prebuiltVoiceConfig\"\n        ], prebuiltVoiceConfigToVertex(fromPrebuiltVoiceConfig));\n    }\n    return toObject;\n}\nfunction speechConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromVoiceConfig = getValueByPath(fromObject, [\n        \"voiceConfig\"\n    ]);\n    if (fromVoiceConfig != null) {\n        setValueByPath(toObject, [\n            \"voiceConfig\"\n        ], voiceConfigToVertex(fromVoiceConfig));\n    }\n    if (getValueByPath(fromObject, [\n        \"multiSpeakerVoiceConfig\"\n    ]) !== undefined) {\n        throw new Error(\"multiSpeakerVoiceConfig parameter is not supported in Vertex AI.\");\n    }\n    const fromLanguageCode = getValueByPath(fromObject, [\n        \"languageCode\"\n    ]);\n    if (fromLanguageCode != null) {\n        setValueByPath(toObject, [\n            \"languageCode\"\n        ], fromLanguageCode);\n    }\n    return toObject;\n}\nfunction thinkingConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromIncludeThoughts = getValueByPath(fromObject, [\n        \"includeThoughts\"\n    ]);\n    if (fromIncludeThoughts != null) {\n        setValueByPath(toObject, [\n            \"includeThoughts\"\n        ], fromIncludeThoughts);\n    }\n    const fromThinkingBudget = getValueByPath(fromObject, [\n        \"thinkingBudget\"\n    ]);\n    if (fromThinkingBudget != null) {\n        setValueByPath(toObject, [\n            \"thinkingBudget\"\n        ], fromThinkingBudget);\n    }\n    return toObject;\n}\nfunction generateContentConfigToVertex(apiClient, fromObject, parentObject) {\n    const toObject = {};\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        \"systemInstruction\"\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, [\n            \"systemInstruction\"\n        ], contentToVertex(tContent(fromSystemInstruction)));\n    }\n    const fromTemperature = getValueByPath(fromObject, [\n        \"temperature\"\n    ]);\n    if (fromTemperature != null) {\n        setValueByPath(toObject, [\n            \"temperature\"\n        ], fromTemperature);\n    }\n    const fromTopP = getValueByPath(fromObject, [\n        \"topP\"\n    ]);\n    if (fromTopP != null) {\n        setValueByPath(toObject, [\n            \"topP\"\n        ], fromTopP);\n    }\n    const fromTopK = getValueByPath(fromObject, [\n        \"topK\"\n    ]);\n    if (fromTopK != null) {\n        setValueByPath(toObject, [\n            \"topK\"\n        ], fromTopK);\n    }\n    const fromCandidateCount = getValueByPath(fromObject, [\n        \"candidateCount\"\n    ]);\n    if (fromCandidateCount != null) {\n        setValueByPath(toObject, [\n            \"candidateCount\"\n        ], fromCandidateCount);\n    }\n    const fromMaxOutputTokens = getValueByPath(fromObject, [\n        \"maxOutputTokens\"\n    ]);\n    if (fromMaxOutputTokens != null) {\n        setValueByPath(toObject, [\n            \"maxOutputTokens\"\n        ], fromMaxOutputTokens);\n    }\n    const fromStopSequences = getValueByPath(fromObject, [\n        \"stopSequences\"\n    ]);\n    if (fromStopSequences != null) {\n        setValueByPath(toObject, [\n            \"stopSequences\"\n        ], fromStopSequences);\n    }\n    const fromResponseLogprobs = getValueByPath(fromObject, [\n        \"responseLogprobs\"\n    ]);\n    if (fromResponseLogprobs != null) {\n        setValueByPath(toObject, [\n            \"responseLogprobs\"\n        ], fromResponseLogprobs);\n    }\n    const fromLogprobs = getValueByPath(fromObject, [\n        \"logprobs\"\n    ]);\n    if (fromLogprobs != null) {\n        setValueByPath(toObject, [\n            \"logprobs\"\n        ], fromLogprobs);\n    }\n    const fromPresencePenalty = getValueByPath(fromObject, [\n        \"presencePenalty\"\n    ]);\n    if (fromPresencePenalty != null) {\n        setValueByPath(toObject, [\n            \"presencePenalty\"\n        ], fromPresencePenalty);\n    }\n    const fromFrequencyPenalty = getValueByPath(fromObject, [\n        \"frequencyPenalty\"\n    ]);\n    if (fromFrequencyPenalty != null) {\n        setValueByPath(toObject, [\n            \"frequencyPenalty\"\n        ], fromFrequencyPenalty);\n    }\n    const fromSeed = getValueByPath(fromObject, [\n        \"seed\"\n    ]);\n    if (fromSeed != null) {\n        setValueByPath(toObject, [\n            \"seed\"\n        ], fromSeed);\n    }\n    const fromResponseMimeType = getValueByPath(fromObject, [\n        \"responseMimeType\"\n    ]);\n    if (fromResponseMimeType != null) {\n        setValueByPath(toObject, [\n            \"responseMimeType\"\n        ], fromResponseMimeType);\n    }\n    const fromResponseSchema = getValueByPath(fromObject, [\n        \"responseSchema\"\n    ]);\n    if (fromResponseSchema != null) {\n        setValueByPath(toObject, [\n            \"responseSchema\"\n        ], schemaToVertex(tSchema(fromResponseSchema)));\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        \"responseJsonSchema\"\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"responseJsonSchema\"\n        ], fromResponseJsonSchema);\n    }\n    const fromRoutingConfig = getValueByPath(fromObject, [\n        \"routingConfig\"\n    ]);\n    if (fromRoutingConfig != null) {\n        setValueByPath(toObject, [\n            \"routingConfig\"\n        ], fromRoutingConfig);\n    }\n    const fromModelSelectionConfig = getValueByPath(fromObject, [\n        \"modelSelectionConfig\"\n    ]);\n    if (fromModelSelectionConfig != null) {\n        setValueByPath(toObject, [\n            \"modelConfig\"\n        ], modelSelectionConfigToVertex(fromModelSelectionConfig));\n    }\n    const fromSafetySettings = getValueByPath(fromObject, [\n        \"safetySettings\"\n    ]);\n    if (parentObject !== undefined && fromSafetySettings != null) {\n        let transformedList = fromSafetySettings;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return safetySettingToVertex(item);\n            });\n        }\n        setValueByPath(parentObject, [\n            \"safetySettings\"\n        ], transformedList);\n    }\n    const fromTools = getValueByPath(fromObject, [\n        \"tools\"\n    ]);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = tTools(fromTools);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return toolToVertex(tTool(item));\n            });\n        }\n        setValueByPath(parentObject, [\n            \"tools\"\n        ], transformedList);\n    }\n    const fromToolConfig = getValueByPath(fromObject, [\n        \"toolConfig\"\n    ]);\n    if (parentObject !== undefined && fromToolConfig != null) {\n        setValueByPath(parentObject, [\n            \"toolConfig\"\n        ], toolConfigToVertex(fromToolConfig));\n    }\n    const fromLabels = getValueByPath(fromObject, [\n        \"labels\"\n    ]);\n    if (parentObject !== undefined && fromLabels != null) {\n        setValueByPath(parentObject, [\n            \"labels\"\n        ], fromLabels);\n    }\n    const fromCachedContent = getValueByPath(fromObject, [\n        \"cachedContent\"\n    ]);\n    if (parentObject !== undefined && fromCachedContent != null) {\n        setValueByPath(parentObject, [\n            \"cachedContent\"\n        ], tCachedContentName(apiClient, fromCachedContent));\n    }\n    const fromResponseModalities = getValueByPath(fromObject, [\n        \"responseModalities\"\n    ]);\n    if (fromResponseModalities != null) {\n        setValueByPath(toObject, [\n            \"responseModalities\"\n        ], fromResponseModalities);\n    }\n    const fromMediaResolution = getValueByPath(fromObject, [\n        \"mediaResolution\"\n    ]);\n    if (fromMediaResolution != null) {\n        setValueByPath(toObject, [\n            \"mediaResolution\"\n        ], fromMediaResolution);\n    }\n    const fromSpeechConfig = getValueByPath(fromObject, [\n        \"speechConfig\"\n    ]);\n    if (fromSpeechConfig != null) {\n        setValueByPath(toObject, [\n            \"speechConfig\"\n        ], speechConfigToVertex(tSpeechConfig(fromSpeechConfig)));\n    }\n    const fromAudioTimestamp = getValueByPath(fromObject, [\n        \"audioTimestamp\"\n    ]);\n    if (fromAudioTimestamp != null) {\n        setValueByPath(toObject, [\n            \"audioTimestamp\"\n        ], fromAudioTimestamp);\n    }\n    const fromThinkingConfig = getValueByPath(fromObject, [\n        \"thinkingConfig\"\n    ]);\n    if (fromThinkingConfig != null) {\n        setValueByPath(toObject, [\n            \"thinkingConfig\"\n        ], thinkingConfigToVertex(fromThinkingConfig));\n    }\n    return toObject;\n}\nfunction generateContentParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, [\n        \"contents\"\n    ]);\n    if (fromContents != null) {\n        let transformedList = tContents(fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return contentToVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"contents\"\n        ], transformedList);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"generationConfig\"\n        ], generateContentConfigToVertex(apiClient, fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction embedContentConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromTaskType = getValueByPath(fromObject, [\n        \"taskType\"\n    ]);\n    if (parentObject !== undefined && fromTaskType != null) {\n        setValueByPath(parentObject, [\n            \"instances[]\",\n            \"task_type\"\n        ], fromTaskType);\n    }\n    const fromTitle = getValueByPath(fromObject, [\n        \"title\"\n    ]);\n    if (parentObject !== undefined && fromTitle != null) {\n        setValueByPath(parentObject, [\n            \"instances[]\",\n            \"title\"\n        ], fromTitle);\n    }\n    const fromOutputDimensionality = getValueByPath(fromObject, [\n        \"outputDimensionality\"\n    ]);\n    if (parentObject !== undefined && fromOutputDimensionality != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"outputDimensionality\"\n        ], fromOutputDimensionality);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (parentObject !== undefined && fromMimeType != null) {\n        setValueByPath(parentObject, [\n            \"instances[]\",\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    const fromAutoTruncate = getValueByPath(fromObject, [\n        \"autoTruncate\"\n    ]);\n    if (parentObject !== undefined && fromAutoTruncate != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"autoTruncate\"\n        ], fromAutoTruncate);\n    }\n    return toObject;\n}\nfunction embedContentParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, [\n        \"contents\"\n    ]);\n    if (fromContents != null) {\n        setValueByPath(toObject, [\n            \"instances[]\",\n            \"content\"\n        ], tContentsForEmbed(apiClient, fromContents));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], embedContentConfigToVertex(fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction generateImagesConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromOutputGcsUri = getValueByPath(fromObject, [\n        \"outputGcsUri\"\n    ]);\n    if (parentObject !== undefined && fromOutputGcsUri != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"storageUri\"\n        ], fromOutputGcsUri);\n    }\n    const fromNegativePrompt = getValueByPath(fromObject, [\n        \"negativePrompt\"\n    ]);\n    if (parentObject !== undefined && fromNegativePrompt != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"negativePrompt\"\n        ], fromNegativePrompt);\n    }\n    const fromNumberOfImages = getValueByPath(fromObject, [\n        \"numberOfImages\"\n    ]);\n    if (parentObject !== undefined && fromNumberOfImages != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"sampleCount\"\n        ], fromNumberOfImages);\n    }\n    const fromAspectRatio = getValueByPath(fromObject, [\n        \"aspectRatio\"\n    ]);\n    if (parentObject !== undefined && fromAspectRatio != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"aspectRatio\"\n        ], fromAspectRatio);\n    }\n    const fromGuidanceScale = getValueByPath(fromObject, [\n        \"guidanceScale\"\n    ]);\n    if (parentObject !== undefined && fromGuidanceScale != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"guidanceScale\"\n        ], fromGuidanceScale);\n    }\n    const fromSeed = getValueByPath(fromObject, [\n        \"seed\"\n    ]);\n    if (parentObject !== undefined && fromSeed != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"seed\"\n        ], fromSeed);\n    }\n    const fromSafetyFilterLevel = getValueByPath(fromObject, [\n        \"safetyFilterLevel\"\n    ]);\n    if (parentObject !== undefined && fromSafetyFilterLevel != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"safetySetting\"\n        ], fromSafetyFilterLevel);\n    }\n    const fromPersonGeneration = getValueByPath(fromObject, [\n        \"personGeneration\"\n    ]);\n    if (parentObject !== undefined && fromPersonGeneration != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"personGeneration\"\n        ], fromPersonGeneration);\n    }\n    const fromIncludeSafetyAttributes = getValueByPath(fromObject, [\n        \"includeSafetyAttributes\"\n    ]);\n    if (parentObject !== undefined && fromIncludeSafetyAttributes != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"includeSafetyAttributes\"\n        ], fromIncludeSafetyAttributes);\n    }\n    const fromIncludeRaiReason = getValueByPath(fromObject, [\n        \"includeRaiReason\"\n    ]);\n    if (parentObject !== undefined && fromIncludeRaiReason != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"includeRaiReason\"\n        ], fromIncludeRaiReason);\n    }\n    const fromLanguage = getValueByPath(fromObject, [\n        \"language\"\n    ]);\n    if (parentObject !== undefined && fromLanguage != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"language\"\n        ], fromLanguage);\n    }\n    const fromOutputMimeType = getValueByPath(fromObject, [\n        \"outputMimeType\"\n    ]);\n    if (parentObject !== undefined && fromOutputMimeType != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"outputOptions\",\n            \"mimeType\"\n        ], fromOutputMimeType);\n    }\n    const fromOutputCompressionQuality = getValueByPath(fromObject, [\n        \"outputCompressionQuality\"\n    ]);\n    if (parentObject !== undefined && fromOutputCompressionQuality != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"outputOptions\",\n            \"compressionQuality\"\n        ], fromOutputCompressionQuality);\n    }\n    const fromAddWatermark = getValueByPath(fromObject, [\n        \"addWatermark\"\n    ]);\n    if (parentObject !== undefined && fromAddWatermark != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"addWatermark\"\n        ], fromAddWatermark);\n    }\n    const fromEnhancePrompt = getValueByPath(fromObject, [\n        \"enhancePrompt\"\n    ]);\n    if (parentObject !== undefined && fromEnhancePrompt != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"enhancePrompt\"\n        ], fromEnhancePrompt);\n    }\n    return toObject;\n}\nfunction generateImagesParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromPrompt = getValueByPath(fromObject, [\n        \"prompt\"\n    ]);\n    if (fromPrompt != null) {\n        setValueByPath(toObject, [\n            \"instances[0]\",\n            \"prompt\"\n        ], fromPrompt);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], generateImagesConfigToVertex(fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction imageToVertex(fromObject) {\n    const toObject = {};\n    const fromGcsUri = getValueByPath(fromObject, [\n        \"gcsUri\"\n    ]);\n    if (fromGcsUri != null) {\n        setValueByPath(toObject, [\n            \"gcsUri\"\n        ], fromGcsUri);\n    }\n    const fromImageBytes = getValueByPath(fromObject, [\n        \"imageBytes\"\n    ]);\n    if (fromImageBytes != null) {\n        setValueByPath(toObject, [\n            \"bytesBase64Encoded\"\n        ], tBytes(fromImageBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction maskReferenceConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromMaskMode = getValueByPath(fromObject, [\n        \"maskMode\"\n    ]);\n    if (fromMaskMode != null) {\n        setValueByPath(toObject, [\n            \"maskMode\"\n        ], fromMaskMode);\n    }\n    const fromSegmentationClasses = getValueByPath(fromObject, [\n        \"segmentationClasses\"\n    ]);\n    if (fromSegmentationClasses != null) {\n        setValueByPath(toObject, [\n            \"maskClasses\"\n        ], fromSegmentationClasses);\n    }\n    const fromMaskDilation = getValueByPath(fromObject, [\n        \"maskDilation\"\n    ]);\n    if (fromMaskDilation != null) {\n        setValueByPath(toObject, [\n            \"dilation\"\n        ], fromMaskDilation);\n    }\n    return toObject;\n}\nfunction controlReferenceConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromControlType = getValueByPath(fromObject, [\n        \"controlType\"\n    ]);\n    if (fromControlType != null) {\n        setValueByPath(toObject, [\n            \"controlType\"\n        ], fromControlType);\n    }\n    const fromEnableControlImageComputation = getValueByPath(fromObject, [\n        \"enableControlImageComputation\"\n    ]);\n    if (fromEnableControlImageComputation != null) {\n        setValueByPath(toObject, [\n            \"computeControl\"\n        ], fromEnableControlImageComputation);\n    }\n    return toObject;\n}\nfunction styleReferenceConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromStyleDescription = getValueByPath(fromObject, [\n        \"styleDescription\"\n    ]);\n    if (fromStyleDescription != null) {\n        setValueByPath(toObject, [\n            \"styleDescription\"\n        ], fromStyleDescription);\n    }\n    return toObject;\n}\nfunction subjectReferenceConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromSubjectType = getValueByPath(fromObject, [\n        \"subjectType\"\n    ]);\n    if (fromSubjectType != null) {\n        setValueByPath(toObject, [\n            \"subjectType\"\n        ], fromSubjectType);\n    }\n    const fromSubjectDescription = getValueByPath(fromObject, [\n        \"subjectDescription\"\n    ]);\n    if (fromSubjectDescription != null) {\n        setValueByPath(toObject, [\n            \"subjectDescription\"\n        ], fromSubjectDescription);\n    }\n    return toObject;\n}\nfunction referenceImageAPIInternalToVertex(fromObject) {\n    const toObject = {};\n    const fromReferenceImage = getValueByPath(fromObject, [\n        \"referenceImage\"\n    ]);\n    if (fromReferenceImage != null) {\n        setValueByPath(toObject, [\n            \"referenceImage\"\n        ], imageToVertex(fromReferenceImage));\n    }\n    const fromReferenceId = getValueByPath(fromObject, [\n        \"referenceId\"\n    ]);\n    if (fromReferenceId != null) {\n        setValueByPath(toObject, [\n            \"referenceId\"\n        ], fromReferenceId);\n    }\n    const fromReferenceType = getValueByPath(fromObject, [\n        \"referenceType\"\n    ]);\n    if (fromReferenceType != null) {\n        setValueByPath(toObject, [\n            \"referenceType\"\n        ], fromReferenceType);\n    }\n    const fromMaskImageConfig = getValueByPath(fromObject, [\n        \"maskImageConfig\"\n    ]);\n    if (fromMaskImageConfig != null) {\n        setValueByPath(toObject, [\n            \"maskImageConfig\"\n        ], maskReferenceConfigToVertex(fromMaskImageConfig));\n    }\n    const fromControlImageConfig = getValueByPath(fromObject, [\n        \"controlImageConfig\"\n    ]);\n    if (fromControlImageConfig != null) {\n        setValueByPath(toObject, [\n            \"controlImageConfig\"\n        ], controlReferenceConfigToVertex(fromControlImageConfig));\n    }\n    const fromStyleImageConfig = getValueByPath(fromObject, [\n        \"styleImageConfig\"\n    ]);\n    if (fromStyleImageConfig != null) {\n        setValueByPath(toObject, [\n            \"styleImageConfig\"\n        ], styleReferenceConfigToVertex(fromStyleImageConfig));\n    }\n    const fromSubjectImageConfig = getValueByPath(fromObject, [\n        \"subjectImageConfig\"\n    ]);\n    if (fromSubjectImageConfig != null) {\n        setValueByPath(toObject, [\n            \"subjectImageConfig\"\n        ], subjectReferenceConfigToVertex(fromSubjectImageConfig));\n    }\n    return toObject;\n}\nfunction editImageConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromOutputGcsUri = getValueByPath(fromObject, [\n        \"outputGcsUri\"\n    ]);\n    if (parentObject !== undefined && fromOutputGcsUri != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"storageUri\"\n        ], fromOutputGcsUri);\n    }\n    const fromNegativePrompt = getValueByPath(fromObject, [\n        \"negativePrompt\"\n    ]);\n    if (parentObject !== undefined && fromNegativePrompt != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"negativePrompt\"\n        ], fromNegativePrompt);\n    }\n    const fromNumberOfImages = getValueByPath(fromObject, [\n        \"numberOfImages\"\n    ]);\n    if (parentObject !== undefined && fromNumberOfImages != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"sampleCount\"\n        ], fromNumberOfImages);\n    }\n    const fromAspectRatio = getValueByPath(fromObject, [\n        \"aspectRatio\"\n    ]);\n    if (parentObject !== undefined && fromAspectRatio != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"aspectRatio\"\n        ], fromAspectRatio);\n    }\n    const fromGuidanceScale = getValueByPath(fromObject, [\n        \"guidanceScale\"\n    ]);\n    if (parentObject !== undefined && fromGuidanceScale != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"guidanceScale\"\n        ], fromGuidanceScale);\n    }\n    const fromSeed = getValueByPath(fromObject, [\n        \"seed\"\n    ]);\n    if (parentObject !== undefined && fromSeed != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"seed\"\n        ], fromSeed);\n    }\n    const fromSafetyFilterLevel = getValueByPath(fromObject, [\n        \"safetyFilterLevel\"\n    ]);\n    if (parentObject !== undefined && fromSafetyFilterLevel != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"safetySetting\"\n        ], fromSafetyFilterLevel);\n    }\n    const fromPersonGeneration = getValueByPath(fromObject, [\n        \"personGeneration\"\n    ]);\n    if (parentObject !== undefined && fromPersonGeneration != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"personGeneration\"\n        ], fromPersonGeneration);\n    }\n    const fromIncludeSafetyAttributes = getValueByPath(fromObject, [\n        \"includeSafetyAttributes\"\n    ]);\n    if (parentObject !== undefined && fromIncludeSafetyAttributes != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"includeSafetyAttributes\"\n        ], fromIncludeSafetyAttributes);\n    }\n    const fromIncludeRaiReason = getValueByPath(fromObject, [\n        \"includeRaiReason\"\n    ]);\n    if (parentObject !== undefined && fromIncludeRaiReason != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"includeRaiReason\"\n        ], fromIncludeRaiReason);\n    }\n    const fromLanguage = getValueByPath(fromObject, [\n        \"language\"\n    ]);\n    if (parentObject !== undefined && fromLanguage != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"language\"\n        ], fromLanguage);\n    }\n    const fromOutputMimeType = getValueByPath(fromObject, [\n        \"outputMimeType\"\n    ]);\n    if (parentObject !== undefined && fromOutputMimeType != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"outputOptions\",\n            \"mimeType\"\n        ], fromOutputMimeType);\n    }\n    const fromOutputCompressionQuality = getValueByPath(fromObject, [\n        \"outputCompressionQuality\"\n    ]);\n    if (parentObject !== undefined && fromOutputCompressionQuality != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"outputOptions\",\n            \"compressionQuality\"\n        ], fromOutputCompressionQuality);\n    }\n    const fromEditMode = getValueByPath(fromObject, [\n        \"editMode\"\n    ]);\n    if (parentObject !== undefined && fromEditMode != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"editMode\"\n        ], fromEditMode);\n    }\n    const fromBaseSteps = getValueByPath(fromObject, [\n        \"baseSteps\"\n    ]);\n    if (parentObject !== undefined && fromBaseSteps != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"editConfig\",\n            \"baseSteps\"\n        ], fromBaseSteps);\n    }\n    return toObject;\n}\nfunction editImageParametersInternalToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromPrompt = getValueByPath(fromObject, [\n        \"prompt\"\n    ]);\n    if (fromPrompt != null) {\n        setValueByPath(toObject, [\n            \"instances[0]\",\n            \"prompt\"\n        ], fromPrompt);\n    }\n    const fromReferenceImages = getValueByPath(fromObject, [\n        \"referenceImages\"\n    ]);\n    if (fromReferenceImages != null) {\n        let transformedList = fromReferenceImages;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return referenceImageAPIInternalToVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"instances[0]\",\n            \"referenceImages\"\n        ], transformedList);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], editImageConfigToVertex(fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction upscaleImageAPIConfigInternalToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromIncludeRaiReason = getValueByPath(fromObject, [\n        \"includeRaiReason\"\n    ]);\n    if (parentObject !== undefined && fromIncludeRaiReason != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"includeRaiReason\"\n        ], fromIncludeRaiReason);\n    }\n    const fromOutputMimeType = getValueByPath(fromObject, [\n        \"outputMimeType\"\n    ]);\n    if (parentObject !== undefined && fromOutputMimeType != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"outputOptions\",\n            \"mimeType\"\n        ], fromOutputMimeType);\n    }\n    const fromOutputCompressionQuality = getValueByPath(fromObject, [\n        \"outputCompressionQuality\"\n    ]);\n    if (parentObject !== undefined && fromOutputCompressionQuality != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"outputOptions\",\n            \"compressionQuality\"\n        ], fromOutputCompressionQuality);\n    }\n    const fromEnhanceInputImage = getValueByPath(fromObject, [\n        \"enhanceInputImage\"\n    ]);\n    if (parentObject !== undefined && fromEnhanceInputImage != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"upscaleConfig\",\n            \"enhanceInputImage\"\n        ], fromEnhanceInputImage);\n    }\n    const fromImagePreservationFactor = getValueByPath(fromObject, [\n        \"imagePreservationFactor\"\n    ]);\n    if (parentObject !== undefined && fromImagePreservationFactor != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"upscaleConfig\",\n            \"imagePreservationFactor\"\n        ], fromImagePreservationFactor);\n    }\n    const fromNumberOfImages = getValueByPath(fromObject, [\n        \"numberOfImages\"\n    ]);\n    if (parentObject !== undefined && fromNumberOfImages != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"sampleCount\"\n        ], fromNumberOfImages);\n    }\n    const fromMode = getValueByPath(fromObject, [\n        \"mode\"\n    ]);\n    if (parentObject !== undefined && fromMode != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"mode\"\n        ], fromMode);\n    }\n    return toObject;\n}\nfunction upscaleImageAPIParametersInternalToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromImage = getValueByPath(fromObject, [\n        \"image\"\n    ]);\n    if (fromImage != null) {\n        setValueByPath(toObject, [\n            \"instances[0]\",\n            \"image\"\n        ], imageToVertex(fromImage));\n    }\n    const fromUpscaleFactor = getValueByPath(fromObject, [\n        \"upscaleFactor\"\n    ]);\n    if (fromUpscaleFactor != null) {\n        setValueByPath(toObject, [\n            \"parameters\",\n            \"upscaleConfig\",\n            \"upscaleFactor\"\n        ], fromUpscaleFactor);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], upscaleImageAPIConfigInternalToVertex(fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction getModelParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], fromConfig);\n    }\n    return toObject;\n}\nfunction listModelsConfigToVertex(apiClient, fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, [\n        \"pageSize\"\n    ]);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageSize\"\n        ], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, [\n        \"pageToken\"\n    ]);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageToken\"\n        ], fromPageToken);\n    }\n    const fromFilter = getValueByPath(fromObject, [\n        \"filter\"\n    ]);\n    if (parentObject !== undefined && fromFilter != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"filter\"\n        ], fromFilter);\n    }\n    const fromQueryBase = getValueByPath(fromObject, [\n        \"queryBase\"\n    ]);\n    if (parentObject !== undefined && fromQueryBase != null) {\n        setValueByPath(parentObject, [\n            \"_url\",\n            \"models_url\"\n        ], tModelsUrl(apiClient, fromQueryBase));\n    }\n    return toObject;\n}\nfunction listModelsParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], listModelsConfigToVertex(apiClient, fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction updateModelConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (parentObject !== undefined && fromDisplayName != null) {\n        setValueByPath(parentObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (parentObject !== undefined && fromDescription != null) {\n        setValueByPath(parentObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromDefaultCheckpointId = getValueByPath(fromObject, [\n        \"defaultCheckpointId\"\n    ]);\n    if (parentObject !== undefined && fromDefaultCheckpointId != null) {\n        setValueByPath(parentObject, [\n            \"defaultCheckpointId\"\n        ], fromDefaultCheckpointId);\n    }\n    return toObject;\n}\nfunction updateModelParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], updateModelConfigToVertex(fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction deleteModelParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], fromConfig);\n    }\n    return toObject;\n}\nfunction countTokensConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        \"systemInstruction\"\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, [\n            \"systemInstruction\"\n        ], contentToVertex(tContent(fromSystemInstruction)));\n    }\n    const fromTools = getValueByPath(fromObject, [\n        \"tools\"\n    ]);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = fromTools;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return toolToVertex(item);\n            });\n        }\n        setValueByPath(parentObject, [\n            \"tools\"\n        ], transformedList);\n    }\n    const fromGenerationConfig = getValueByPath(fromObject, [\n        \"generationConfig\"\n    ]);\n    if (parentObject !== undefined && fromGenerationConfig != null) {\n        setValueByPath(parentObject, [\n            \"generationConfig\"\n        ], fromGenerationConfig);\n    }\n    return toObject;\n}\nfunction countTokensParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, [\n        \"contents\"\n    ]);\n    if (fromContents != null) {\n        let transformedList = tContents(fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return contentToVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"contents\"\n        ], transformedList);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], countTokensConfigToVertex(fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction computeTokensParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, [\n        \"contents\"\n    ]);\n    if (fromContents != null) {\n        let transformedList = tContents(fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return contentToVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"contents\"\n        ], transformedList);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], fromConfig);\n    }\n    return toObject;\n}\nfunction videoToVertex(fromObject) {\n    const toObject = {};\n    const fromUri = getValueByPath(fromObject, [\n        \"uri\"\n    ]);\n    if (fromUri != null) {\n        setValueByPath(toObject, [\n            \"gcsUri\"\n        ], fromUri);\n    }\n    const fromVideoBytes = getValueByPath(fromObject, [\n        \"videoBytes\"\n    ]);\n    if (fromVideoBytes != null) {\n        setValueByPath(toObject, [\n            \"bytesBase64Encoded\"\n        ], tBytes(fromVideoBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction generateVideosConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromNumberOfVideos = getValueByPath(fromObject, [\n        \"numberOfVideos\"\n    ]);\n    if (parentObject !== undefined && fromNumberOfVideos != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"sampleCount\"\n        ], fromNumberOfVideos);\n    }\n    const fromOutputGcsUri = getValueByPath(fromObject, [\n        \"outputGcsUri\"\n    ]);\n    if (parentObject !== undefined && fromOutputGcsUri != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"storageUri\"\n        ], fromOutputGcsUri);\n    }\n    const fromFps = getValueByPath(fromObject, [\n        \"fps\"\n    ]);\n    if (parentObject !== undefined && fromFps != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"fps\"\n        ], fromFps);\n    }\n    const fromDurationSeconds = getValueByPath(fromObject, [\n        \"durationSeconds\"\n    ]);\n    if (parentObject !== undefined && fromDurationSeconds != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"durationSeconds\"\n        ], fromDurationSeconds);\n    }\n    const fromSeed = getValueByPath(fromObject, [\n        \"seed\"\n    ]);\n    if (parentObject !== undefined && fromSeed != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"seed\"\n        ], fromSeed);\n    }\n    const fromAspectRatio = getValueByPath(fromObject, [\n        \"aspectRatio\"\n    ]);\n    if (parentObject !== undefined && fromAspectRatio != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"aspectRatio\"\n        ], fromAspectRatio);\n    }\n    const fromResolution = getValueByPath(fromObject, [\n        \"resolution\"\n    ]);\n    if (parentObject !== undefined && fromResolution != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"resolution\"\n        ], fromResolution);\n    }\n    const fromPersonGeneration = getValueByPath(fromObject, [\n        \"personGeneration\"\n    ]);\n    if (parentObject !== undefined && fromPersonGeneration != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"personGeneration\"\n        ], fromPersonGeneration);\n    }\n    const fromPubsubTopic = getValueByPath(fromObject, [\n        \"pubsubTopic\"\n    ]);\n    if (parentObject !== undefined && fromPubsubTopic != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"pubsubTopic\"\n        ], fromPubsubTopic);\n    }\n    const fromNegativePrompt = getValueByPath(fromObject, [\n        \"negativePrompt\"\n    ]);\n    if (parentObject !== undefined && fromNegativePrompt != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"negativePrompt\"\n        ], fromNegativePrompt);\n    }\n    const fromEnhancePrompt = getValueByPath(fromObject, [\n        \"enhancePrompt\"\n    ]);\n    if (parentObject !== undefined && fromEnhancePrompt != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"enhancePrompt\"\n        ], fromEnhancePrompt);\n    }\n    const fromGenerateAudio = getValueByPath(fromObject, [\n        \"generateAudio\"\n    ]);\n    if (parentObject !== undefined && fromGenerateAudio != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"generateAudio\"\n        ], fromGenerateAudio);\n    }\n    const fromLastFrame = getValueByPath(fromObject, [\n        \"lastFrame\"\n    ]);\n    if (parentObject !== undefined && fromLastFrame != null) {\n        setValueByPath(parentObject, [\n            \"instances[0]\",\n            \"lastFrame\"\n        ], imageToVertex(fromLastFrame));\n    }\n    const fromCompressionQuality = getValueByPath(fromObject, [\n        \"compressionQuality\"\n    ]);\n    if (parentObject !== undefined && fromCompressionQuality != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"compressionQuality\"\n        ], fromCompressionQuality);\n    }\n    return toObject;\n}\nfunction generateVideosParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromPrompt = getValueByPath(fromObject, [\n        \"prompt\"\n    ]);\n    if (fromPrompt != null) {\n        setValueByPath(toObject, [\n            \"instances[0]\",\n            \"prompt\"\n        ], fromPrompt);\n    }\n    const fromImage = getValueByPath(fromObject, [\n        \"image\"\n    ]);\n    if (fromImage != null) {\n        setValueByPath(toObject, [\n            \"instances[0]\",\n            \"image\"\n        ], imageToVertex(fromImage));\n    }\n    const fromVideo = getValueByPath(fromObject, [\n        \"video\"\n    ]);\n    if (fromVideo != null) {\n        setValueByPath(toObject, [\n            \"instances[0]\",\n            \"video\"\n        ], videoToVertex(fromVideo));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], generateVideosConfigToVertex(fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction videoMetadataFromMldev(fromObject) {\n    const toObject = {};\n    const fromFps = getValueByPath(fromObject, [\n        \"fps\"\n    ]);\n    if (fromFps != null) {\n        setValueByPath(toObject, [\n            \"fps\"\n        ], fromFps);\n    }\n    const fromEndOffset = getValueByPath(fromObject, [\n        \"endOffset\"\n    ]);\n    if (fromEndOffset != null) {\n        setValueByPath(toObject, [\n            \"endOffset\"\n        ], fromEndOffset);\n    }\n    const fromStartOffset = getValueByPath(fromObject, [\n        \"startOffset\"\n    ]);\n    if (fromStartOffset != null) {\n        setValueByPath(toObject, [\n            \"startOffset\"\n        ], fromStartOffset);\n    }\n    return toObject;\n}\nfunction blobFromMldev(fromObject) {\n    const toObject = {};\n    const fromData = getValueByPath(fromObject, [\n        \"data\"\n    ]);\n    if (fromData != null) {\n        setValueByPath(toObject, [\n            \"data\"\n        ], fromData);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction fileDataFromMldev(fromObject) {\n    const toObject = {};\n    const fromFileUri = getValueByPath(fromObject, [\n        \"fileUri\"\n    ]);\n    if (fromFileUri != null) {\n        setValueByPath(toObject, [\n            \"fileUri\"\n        ], fromFileUri);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction partFromMldev(fromObject) {\n    const toObject = {};\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        \"videoMetadata\"\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, [\n            \"videoMetadata\"\n        ], videoMetadataFromMldev(fromVideoMetadata));\n    }\n    const fromThought = getValueByPath(fromObject, [\n        \"thought\"\n    ]);\n    if (fromThought != null) {\n        setValueByPath(toObject, [\n            \"thought\"\n        ], fromThought);\n    }\n    const fromInlineData = getValueByPath(fromObject, [\n        \"inlineData\"\n    ]);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, [\n            \"inlineData\"\n        ], blobFromMldev(fromInlineData));\n    }\n    const fromFileData = getValueByPath(fromObject, [\n        \"fileData\"\n    ]);\n    if (fromFileData != null) {\n        setValueByPath(toObject, [\n            \"fileData\"\n        ], fileDataFromMldev(fromFileData));\n    }\n    const fromThoughtSignature = getValueByPath(fromObject, [\n        \"thoughtSignature\"\n    ]);\n    if (fromThoughtSignature != null) {\n        setValueByPath(toObject, [\n            \"thoughtSignature\"\n        ], fromThoughtSignature);\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        \"codeExecutionResult\"\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, [\n            \"codeExecutionResult\"\n        ], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        \"executableCode\"\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, [\n            \"executableCode\"\n        ], fromExecutableCode);\n    }\n    const fromFunctionCall = getValueByPath(fromObject, [\n        \"functionCall\"\n    ]);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, [\n            \"functionCall\"\n        ], fromFunctionCall);\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        \"functionResponse\"\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, [\n            \"functionResponse\"\n        ], fromFunctionResponse);\n    }\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    return toObject;\n}\nfunction contentFromMldev(fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, [\n        \"parts\"\n    ]);\n    if (fromParts != null) {\n        let transformedList = fromParts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return partFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"parts\"\n        ], transformedList);\n    }\n    const fromRole = getValueByPath(fromObject, [\n        \"role\"\n    ]);\n    if (fromRole != null) {\n        setValueByPath(toObject, [\n            \"role\"\n        ], fromRole);\n    }\n    return toObject;\n}\nfunction citationMetadataFromMldev(fromObject) {\n    const toObject = {};\n    const fromCitations = getValueByPath(fromObject, [\n        \"citationSources\"\n    ]);\n    if (fromCitations != null) {\n        setValueByPath(toObject, [\n            \"citations\"\n        ], fromCitations);\n    }\n    return toObject;\n}\nfunction urlMetadataFromMldev(fromObject) {\n    const toObject = {};\n    const fromRetrievedUrl = getValueByPath(fromObject, [\n        \"retrievedUrl\"\n    ]);\n    if (fromRetrievedUrl != null) {\n        setValueByPath(toObject, [\n            \"retrievedUrl\"\n        ], fromRetrievedUrl);\n    }\n    const fromUrlRetrievalStatus = getValueByPath(fromObject, [\n        \"urlRetrievalStatus\"\n    ]);\n    if (fromUrlRetrievalStatus != null) {\n        setValueByPath(toObject, [\n            \"urlRetrievalStatus\"\n        ], fromUrlRetrievalStatus);\n    }\n    return toObject;\n}\nfunction urlContextMetadataFromMldev(fromObject) {\n    const toObject = {};\n    const fromUrlMetadata = getValueByPath(fromObject, [\n        \"urlMetadata\"\n    ]);\n    if (fromUrlMetadata != null) {\n        let transformedList = fromUrlMetadata;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return urlMetadataFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"urlMetadata\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction candidateFromMldev(fromObject) {\n    const toObject = {};\n    const fromContent = getValueByPath(fromObject, [\n        \"content\"\n    ]);\n    if (fromContent != null) {\n        setValueByPath(toObject, [\n            \"content\"\n        ], contentFromMldev(fromContent));\n    }\n    const fromCitationMetadata = getValueByPath(fromObject, [\n        \"citationMetadata\"\n    ]);\n    if (fromCitationMetadata != null) {\n        setValueByPath(toObject, [\n            \"citationMetadata\"\n        ], citationMetadataFromMldev(fromCitationMetadata));\n    }\n    const fromTokenCount = getValueByPath(fromObject, [\n        \"tokenCount\"\n    ]);\n    if (fromTokenCount != null) {\n        setValueByPath(toObject, [\n            \"tokenCount\"\n        ], fromTokenCount);\n    }\n    const fromFinishReason = getValueByPath(fromObject, [\n        \"finishReason\"\n    ]);\n    if (fromFinishReason != null) {\n        setValueByPath(toObject, [\n            \"finishReason\"\n        ], fromFinishReason);\n    }\n    const fromUrlContextMetadata = getValueByPath(fromObject, [\n        \"urlContextMetadata\"\n    ]);\n    if (fromUrlContextMetadata != null) {\n        setValueByPath(toObject, [\n            \"urlContextMetadata\"\n        ], urlContextMetadataFromMldev(fromUrlContextMetadata));\n    }\n    const fromAvgLogprobs = getValueByPath(fromObject, [\n        \"avgLogprobs\"\n    ]);\n    if (fromAvgLogprobs != null) {\n        setValueByPath(toObject, [\n            \"avgLogprobs\"\n        ], fromAvgLogprobs);\n    }\n    const fromGroundingMetadata = getValueByPath(fromObject, [\n        \"groundingMetadata\"\n    ]);\n    if (fromGroundingMetadata != null) {\n        setValueByPath(toObject, [\n            \"groundingMetadata\"\n        ], fromGroundingMetadata);\n    }\n    const fromIndex = getValueByPath(fromObject, [\n        \"index\"\n    ]);\n    if (fromIndex != null) {\n        setValueByPath(toObject, [\n            \"index\"\n        ], fromIndex);\n    }\n    const fromLogprobsResult = getValueByPath(fromObject, [\n        \"logprobsResult\"\n    ]);\n    if (fromLogprobsResult != null) {\n        setValueByPath(toObject, [\n            \"logprobsResult\"\n        ], fromLogprobsResult);\n    }\n    const fromSafetyRatings = getValueByPath(fromObject, [\n        \"safetyRatings\"\n    ]);\n    if (fromSafetyRatings != null) {\n        setValueByPath(toObject, [\n            \"safetyRatings\"\n        ], fromSafetyRatings);\n    }\n    return toObject;\n}\nfunction generateContentResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromCandidates = getValueByPath(fromObject, [\n        \"candidates\"\n    ]);\n    if (fromCandidates != null) {\n        let transformedList = fromCandidates;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return candidateFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"candidates\"\n        ], transformedList);\n    }\n    const fromModelVersion = getValueByPath(fromObject, [\n        \"modelVersion\"\n    ]);\n    if (fromModelVersion != null) {\n        setValueByPath(toObject, [\n            \"modelVersion\"\n        ], fromModelVersion);\n    }\n    const fromPromptFeedback = getValueByPath(fromObject, [\n        \"promptFeedback\"\n    ]);\n    if (fromPromptFeedback != null) {\n        setValueByPath(toObject, [\n            \"promptFeedback\"\n        ], fromPromptFeedback);\n    }\n    const fromUsageMetadata = getValueByPath(fromObject, [\n        \"usageMetadata\"\n    ]);\n    if (fromUsageMetadata != null) {\n        setValueByPath(toObject, [\n            \"usageMetadata\"\n        ], fromUsageMetadata);\n    }\n    return toObject;\n}\nfunction contentEmbeddingFromMldev(fromObject) {\n    const toObject = {};\n    const fromValues = getValueByPath(fromObject, [\n        \"values\"\n    ]);\n    if (fromValues != null) {\n        setValueByPath(toObject, [\n            \"values\"\n        ], fromValues);\n    }\n    return toObject;\n}\nfunction embedContentMetadataFromMldev() {\n    const toObject = {};\n    return toObject;\n}\nfunction embedContentResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromEmbeddings = getValueByPath(fromObject, [\n        \"embeddings\"\n    ]);\n    if (fromEmbeddings != null) {\n        let transformedList = fromEmbeddings;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return contentEmbeddingFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"embeddings\"\n        ], transformedList);\n    }\n    const fromMetadata = getValueByPath(fromObject, [\n        \"metadata\"\n    ]);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, [\n            \"metadata\"\n        ], embedContentMetadataFromMldev());\n    }\n    return toObject;\n}\nfunction imageFromMldev(fromObject) {\n    const toObject = {};\n    const fromImageBytes = getValueByPath(fromObject, [\n        \"bytesBase64Encoded\"\n    ]);\n    if (fromImageBytes != null) {\n        setValueByPath(toObject, [\n            \"imageBytes\"\n        ], tBytes(fromImageBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction safetyAttributesFromMldev(fromObject) {\n    const toObject = {};\n    const fromCategories = getValueByPath(fromObject, [\n        \"safetyAttributes\",\n        \"categories\"\n    ]);\n    if (fromCategories != null) {\n        setValueByPath(toObject, [\n            \"categories\"\n        ], fromCategories);\n    }\n    const fromScores = getValueByPath(fromObject, [\n        \"safetyAttributes\",\n        \"scores\"\n    ]);\n    if (fromScores != null) {\n        setValueByPath(toObject, [\n            \"scores\"\n        ], fromScores);\n    }\n    const fromContentType = getValueByPath(fromObject, [\n        \"contentType\"\n    ]);\n    if (fromContentType != null) {\n        setValueByPath(toObject, [\n            \"contentType\"\n        ], fromContentType);\n    }\n    return toObject;\n}\nfunction generatedImageFromMldev(fromObject) {\n    const toObject = {};\n    const fromImage = getValueByPath(fromObject, [\n        \"_self\"\n    ]);\n    if (fromImage != null) {\n        setValueByPath(toObject, [\n            \"image\"\n        ], imageFromMldev(fromImage));\n    }\n    const fromRaiFilteredReason = getValueByPath(fromObject, [\n        \"raiFilteredReason\"\n    ]);\n    if (fromRaiFilteredReason != null) {\n        setValueByPath(toObject, [\n            \"raiFilteredReason\"\n        ], fromRaiFilteredReason);\n    }\n    const fromSafetyAttributes = getValueByPath(fromObject, [\n        \"_self\"\n    ]);\n    if (fromSafetyAttributes != null) {\n        setValueByPath(toObject, [\n            \"safetyAttributes\"\n        ], safetyAttributesFromMldev(fromSafetyAttributes));\n    }\n    return toObject;\n}\nfunction generateImagesResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromGeneratedImages = getValueByPath(fromObject, [\n        \"predictions\"\n    ]);\n    if (fromGeneratedImages != null) {\n        let transformedList = fromGeneratedImages;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return generatedImageFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"generatedImages\"\n        ], transformedList);\n    }\n    const fromPositivePromptSafetyAttributes = getValueByPath(fromObject, [\n        \"positivePromptSafetyAttributes\"\n    ]);\n    if (fromPositivePromptSafetyAttributes != null) {\n        setValueByPath(toObject, [\n            \"positivePromptSafetyAttributes\"\n        ], safetyAttributesFromMldev(fromPositivePromptSafetyAttributes));\n    }\n    return toObject;\n}\nfunction tunedModelInfoFromMldev(fromObject) {\n    const toObject = {};\n    const fromBaseModel = getValueByPath(fromObject, [\n        \"baseModel\"\n    ]);\n    if (fromBaseModel != null) {\n        setValueByPath(toObject, [\n            \"baseModel\"\n        ], fromBaseModel);\n    }\n    const fromCreateTime = getValueByPath(fromObject, [\n        \"createTime\"\n    ]);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, [\n            \"createTime\"\n        ], fromCreateTime);\n    }\n    const fromUpdateTime = getValueByPath(fromObject, [\n        \"updateTime\"\n    ]);\n    if (fromUpdateTime != null) {\n        setValueByPath(toObject, [\n            \"updateTime\"\n        ], fromUpdateTime);\n    }\n    return toObject;\n}\nfunction modelFromMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (fromDescription != null) {\n        setValueByPath(toObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromVersion = getValueByPath(fromObject, [\n        \"version\"\n    ]);\n    if (fromVersion != null) {\n        setValueByPath(toObject, [\n            \"version\"\n        ], fromVersion);\n    }\n    const fromTunedModelInfo = getValueByPath(fromObject, [\n        \"_self\"\n    ]);\n    if (fromTunedModelInfo != null) {\n        setValueByPath(toObject, [\n            \"tunedModelInfo\"\n        ], tunedModelInfoFromMldev(fromTunedModelInfo));\n    }\n    const fromInputTokenLimit = getValueByPath(fromObject, [\n        \"inputTokenLimit\"\n    ]);\n    if (fromInputTokenLimit != null) {\n        setValueByPath(toObject, [\n            \"inputTokenLimit\"\n        ], fromInputTokenLimit);\n    }\n    const fromOutputTokenLimit = getValueByPath(fromObject, [\n        \"outputTokenLimit\"\n    ]);\n    if (fromOutputTokenLimit != null) {\n        setValueByPath(toObject, [\n            \"outputTokenLimit\"\n        ], fromOutputTokenLimit);\n    }\n    const fromSupportedActions = getValueByPath(fromObject, [\n        \"supportedGenerationMethods\"\n    ]);\n    if (fromSupportedActions != null) {\n        setValueByPath(toObject, [\n            \"supportedActions\"\n        ], fromSupportedActions);\n    }\n    return toObject;\n}\nfunction listModelsResponseFromMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromNextPageToken = getValueByPath(fromObject, [\n        \"nextPageToken\"\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, [\n            \"nextPageToken\"\n        ], fromNextPageToken);\n    }\n    const fromModels = getValueByPath(fromObject, [\n        \"_self\"\n    ]);\n    if (fromModels != null) {\n        let transformedList = tExtractModels(fromModels);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return modelFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"models\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction deleteModelResponseFromMldev() {\n    const toObject = {};\n    return toObject;\n}\nfunction countTokensResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromTotalTokens = getValueByPath(fromObject, [\n        \"totalTokens\"\n    ]);\n    if (fromTotalTokens != null) {\n        setValueByPath(toObject, [\n            \"totalTokens\"\n        ], fromTotalTokens);\n    }\n    const fromCachedContentTokenCount = getValueByPath(fromObject, [\n        \"cachedContentTokenCount\"\n    ]);\n    if (fromCachedContentTokenCount != null) {\n        setValueByPath(toObject, [\n            \"cachedContentTokenCount\"\n        ], fromCachedContentTokenCount);\n    }\n    return toObject;\n}\nfunction videoFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromUri = getValueByPath(fromObject, [\n        \"video\",\n        \"uri\"\n    ]);\n    if (fromUri != null) {\n        setValueByPath(toObject, [\n            \"uri\"\n        ], fromUri);\n    }\n    const fromVideoBytes = getValueByPath(fromObject, [\n        \"video\",\n        \"encodedVideo\"\n    ]);\n    if (fromVideoBytes != null) {\n        setValueByPath(toObject, [\n            \"videoBytes\"\n        ], tBytes(fromVideoBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"encoding\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction generatedVideoFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromVideo = getValueByPath(fromObject, [\n        \"_self\"\n    ]);\n    if (fromVideo != null) {\n        setValueByPath(toObject, [\n            \"video\"\n        ], videoFromMldev$1(fromVideo));\n    }\n    return toObject;\n}\nfunction generateVideosResponseFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromGeneratedVideos = getValueByPath(fromObject, [\n        \"generatedSamples\"\n    ]);\n    if (fromGeneratedVideos != null) {\n        let transformedList = fromGeneratedVideos;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return generatedVideoFromMldev$1(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"generatedVideos\"\n        ], transformedList);\n    }\n    const fromRaiMediaFilteredCount = getValueByPath(fromObject, [\n        \"raiMediaFilteredCount\"\n    ]);\n    if (fromRaiMediaFilteredCount != null) {\n        setValueByPath(toObject, [\n            \"raiMediaFilteredCount\"\n        ], fromRaiMediaFilteredCount);\n    }\n    const fromRaiMediaFilteredReasons = getValueByPath(fromObject, [\n        \"raiMediaFilteredReasons\"\n    ]);\n    if (fromRaiMediaFilteredReasons != null) {\n        setValueByPath(toObject, [\n            \"raiMediaFilteredReasons\"\n        ], fromRaiMediaFilteredReasons);\n    }\n    return toObject;\n}\nfunction generateVideosOperationFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromMetadata = getValueByPath(fromObject, [\n        \"metadata\"\n    ]);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, [\n            \"metadata\"\n        ], fromMetadata);\n    }\n    const fromDone = getValueByPath(fromObject, [\n        \"done\"\n    ]);\n    if (fromDone != null) {\n        setValueByPath(toObject, [\n            \"done\"\n        ], fromDone);\n    }\n    const fromError = getValueByPath(fromObject, [\n        \"error\"\n    ]);\n    if (fromError != null) {\n        setValueByPath(toObject, [\n            \"error\"\n        ], fromError);\n    }\n    const fromResponse = getValueByPath(fromObject, [\n        \"response\",\n        \"generateVideoResponse\"\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, [\n            \"response\"\n        ], generateVideosResponseFromMldev$1(fromResponse));\n    }\n    return toObject;\n}\nfunction videoMetadataFromVertex(fromObject) {\n    const toObject = {};\n    const fromFps = getValueByPath(fromObject, [\n        \"fps\"\n    ]);\n    if (fromFps != null) {\n        setValueByPath(toObject, [\n            \"fps\"\n        ], fromFps);\n    }\n    const fromEndOffset = getValueByPath(fromObject, [\n        \"endOffset\"\n    ]);\n    if (fromEndOffset != null) {\n        setValueByPath(toObject, [\n            \"endOffset\"\n        ], fromEndOffset);\n    }\n    const fromStartOffset = getValueByPath(fromObject, [\n        \"startOffset\"\n    ]);\n    if (fromStartOffset != null) {\n        setValueByPath(toObject, [\n            \"startOffset\"\n        ], fromStartOffset);\n    }\n    return toObject;\n}\nfunction blobFromVertex(fromObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromData = getValueByPath(fromObject, [\n        \"data\"\n    ]);\n    if (fromData != null) {\n        setValueByPath(toObject, [\n            \"data\"\n        ], fromData);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction fileDataFromVertex(fromObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromFileUri = getValueByPath(fromObject, [\n        \"fileUri\"\n    ]);\n    if (fromFileUri != null) {\n        setValueByPath(toObject, [\n            \"fileUri\"\n        ], fromFileUri);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction partFromVertex(fromObject) {\n    const toObject = {};\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        \"videoMetadata\"\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, [\n            \"videoMetadata\"\n        ], videoMetadataFromVertex(fromVideoMetadata));\n    }\n    const fromThought = getValueByPath(fromObject, [\n        \"thought\"\n    ]);\n    if (fromThought != null) {\n        setValueByPath(toObject, [\n            \"thought\"\n        ], fromThought);\n    }\n    const fromInlineData = getValueByPath(fromObject, [\n        \"inlineData\"\n    ]);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, [\n            \"inlineData\"\n        ], blobFromVertex(fromInlineData));\n    }\n    const fromFileData = getValueByPath(fromObject, [\n        \"fileData\"\n    ]);\n    if (fromFileData != null) {\n        setValueByPath(toObject, [\n            \"fileData\"\n        ], fileDataFromVertex(fromFileData));\n    }\n    const fromThoughtSignature = getValueByPath(fromObject, [\n        \"thoughtSignature\"\n    ]);\n    if (fromThoughtSignature != null) {\n        setValueByPath(toObject, [\n            \"thoughtSignature\"\n        ], fromThoughtSignature);\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        \"codeExecutionResult\"\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, [\n            \"codeExecutionResult\"\n        ], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        \"executableCode\"\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, [\n            \"executableCode\"\n        ], fromExecutableCode);\n    }\n    const fromFunctionCall = getValueByPath(fromObject, [\n        \"functionCall\"\n    ]);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, [\n            \"functionCall\"\n        ], fromFunctionCall);\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        \"functionResponse\"\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, [\n            \"functionResponse\"\n        ], fromFunctionResponse);\n    }\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    return toObject;\n}\nfunction contentFromVertex(fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, [\n        \"parts\"\n    ]);\n    if (fromParts != null) {\n        let transformedList = fromParts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return partFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"parts\"\n        ], transformedList);\n    }\n    const fromRole = getValueByPath(fromObject, [\n        \"role\"\n    ]);\n    if (fromRole != null) {\n        setValueByPath(toObject, [\n            \"role\"\n        ], fromRole);\n    }\n    return toObject;\n}\nfunction citationMetadataFromVertex(fromObject) {\n    const toObject = {};\n    const fromCitations = getValueByPath(fromObject, [\n        \"citations\"\n    ]);\n    if (fromCitations != null) {\n        setValueByPath(toObject, [\n            \"citations\"\n        ], fromCitations);\n    }\n    return toObject;\n}\nfunction urlMetadataFromVertex(fromObject) {\n    const toObject = {};\n    const fromRetrievedUrl = getValueByPath(fromObject, [\n        \"retrievedUrl\"\n    ]);\n    if (fromRetrievedUrl != null) {\n        setValueByPath(toObject, [\n            \"retrievedUrl\"\n        ], fromRetrievedUrl);\n    }\n    const fromUrlRetrievalStatus = getValueByPath(fromObject, [\n        \"urlRetrievalStatus\"\n    ]);\n    if (fromUrlRetrievalStatus != null) {\n        setValueByPath(toObject, [\n            \"urlRetrievalStatus\"\n        ], fromUrlRetrievalStatus);\n    }\n    return toObject;\n}\nfunction urlContextMetadataFromVertex(fromObject) {\n    const toObject = {};\n    const fromUrlMetadata = getValueByPath(fromObject, [\n        \"urlMetadata\"\n    ]);\n    if (fromUrlMetadata != null) {\n        let transformedList = fromUrlMetadata;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return urlMetadataFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"urlMetadata\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction candidateFromVertex(fromObject) {\n    const toObject = {};\n    const fromContent = getValueByPath(fromObject, [\n        \"content\"\n    ]);\n    if (fromContent != null) {\n        setValueByPath(toObject, [\n            \"content\"\n        ], contentFromVertex(fromContent));\n    }\n    const fromCitationMetadata = getValueByPath(fromObject, [\n        \"citationMetadata\"\n    ]);\n    if (fromCitationMetadata != null) {\n        setValueByPath(toObject, [\n            \"citationMetadata\"\n        ], citationMetadataFromVertex(fromCitationMetadata));\n    }\n    const fromFinishMessage = getValueByPath(fromObject, [\n        \"finishMessage\"\n    ]);\n    if (fromFinishMessage != null) {\n        setValueByPath(toObject, [\n            \"finishMessage\"\n        ], fromFinishMessage);\n    }\n    const fromFinishReason = getValueByPath(fromObject, [\n        \"finishReason\"\n    ]);\n    if (fromFinishReason != null) {\n        setValueByPath(toObject, [\n            \"finishReason\"\n        ], fromFinishReason);\n    }\n    const fromUrlContextMetadata = getValueByPath(fromObject, [\n        \"urlContextMetadata\"\n    ]);\n    if (fromUrlContextMetadata != null) {\n        setValueByPath(toObject, [\n            \"urlContextMetadata\"\n        ], urlContextMetadataFromVertex(fromUrlContextMetadata));\n    }\n    const fromAvgLogprobs = getValueByPath(fromObject, [\n        \"avgLogprobs\"\n    ]);\n    if (fromAvgLogprobs != null) {\n        setValueByPath(toObject, [\n            \"avgLogprobs\"\n        ], fromAvgLogprobs);\n    }\n    const fromGroundingMetadata = getValueByPath(fromObject, [\n        \"groundingMetadata\"\n    ]);\n    if (fromGroundingMetadata != null) {\n        setValueByPath(toObject, [\n            \"groundingMetadata\"\n        ], fromGroundingMetadata);\n    }\n    const fromIndex = getValueByPath(fromObject, [\n        \"index\"\n    ]);\n    if (fromIndex != null) {\n        setValueByPath(toObject, [\n            \"index\"\n        ], fromIndex);\n    }\n    const fromLogprobsResult = getValueByPath(fromObject, [\n        \"logprobsResult\"\n    ]);\n    if (fromLogprobsResult != null) {\n        setValueByPath(toObject, [\n            \"logprobsResult\"\n        ], fromLogprobsResult);\n    }\n    const fromSafetyRatings = getValueByPath(fromObject, [\n        \"safetyRatings\"\n    ]);\n    if (fromSafetyRatings != null) {\n        setValueByPath(toObject, [\n            \"safetyRatings\"\n        ], fromSafetyRatings);\n    }\n    return toObject;\n}\nfunction generateContentResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromCandidates = getValueByPath(fromObject, [\n        \"candidates\"\n    ]);\n    if (fromCandidates != null) {\n        let transformedList = fromCandidates;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return candidateFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"candidates\"\n        ], transformedList);\n    }\n    const fromCreateTime = getValueByPath(fromObject, [\n        \"createTime\"\n    ]);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, [\n            \"createTime\"\n        ], fromCreateTime);\n    }\n    const fromResponseId = getValueByPath(fromObject, [\n        \"responseId\"\n    ]);\n    if (fromResponseId != null) {\n        setValueByPath(toObject, [\n            \"responseId\"\n        ], fromResponseId);\n    }\n    const fromModelVersion = getValueByPath(fromObject, [\n        \"modelVersion\"\n    ]);\n    if (fromModelVersion != null) {\n        setValueByPath(toObject, [\n            \"modelVersion\"\n        ], fromModelVersion);\n    }\n    const fromPromptFeedback = getValueByPath(fromObject, [\n        \"promptFeedback\"\n    ]);\n    if (fromPromptFeedback != null) {\n        setValueByPath(toObject, [\n            \"promptFeedback\"\n        ], fromPromptFeedback);\n    }\n    const fromUsageMetadata = getValueByPath(fromObject, [\n        \"usageMetadata\"\n    ]);\n    if (fromUsageMetadata != null) {\n        setValueByPath(toObject, [\n            \"usageMetadata\"\n        ], fromUsageMetadata);\n    }\n    return toObject;\n}\nfunction contentEmbeddingStatisticsFromVertex(fromObject) {\n    const toObject = {};\n    const fromTruncated = getValueByPath(fromObject, [\n        \"truncated\"\n    ]);\n    if (fromTruncated != null) {\n        setValueByPath(toObject, [\n            \"truncated\"\n        ], fromTruncated);\n    }\n    const fromTokenCount = getValueByPath(fromObject, [\n        \"token_count\"\n    ]);\n    if (fromTokenCount != null) {\n        setValueByPath(toObject, [\n            \"tokenCount\"\n        ], fromTokenCount);\n    }\n    return toObject;\n}\nfunction contentEmbeddingFromVertex(fromObject) {\n    const toObject = {};\n    const fromValues = getValueByPath(fromObject, [\n        \"values\"\n    ]);\n    if (fromValues != null) {\n        setValueByPath(toObject, [\n            \"values\"\n        ], fromValues);\n    }\n    const fromStatistics = getValueByPath(fromObject, [\n        \"statistics\"\n    ]);\n    if (fromStatistics != null) {\n        setValueByPath(toObject, [\n            \"statistics\"\n        ], contentEmbeddingStatisticsFromVertex(fromStatistics));\n    }\n    return toObject;\n}\nfunction embedContentMetadataFromVertex(fromObject) {\n    const toObject = {};\n    const fromBillableCharacterCount = getValueByPath(fromObject, [\n        \"billableCharacterCount\"\n    ]);\n    if (fromBillableCharacterCount != null) {\n        setValueByPath(toObject, [\n            \"billableCharacterCount\"\n        ], fromBillableCharacterCount);\n    }\n    return toObject;\n}\nfunction embedContentResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromEmbeddings = getValueByPath(fromObject, [\n        \"predictions[]\",\n        \"embeddings\"\n    ]);\n    if (fromEmbeddings != null) {\n        let transformedList = fromEmbeddings;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return contentEmbeddingFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"embeddings\"\n        ], transformedList);\n    }\n    const fromMetadata = getValueByPath(fromObject, [\n        \"metadata\"\n    ]);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, [\n            \"metadata\"\n        ], embedContentMetadataFromVertex(fromMetadata));\n    }\n    return toObject;\n}\nfunction imageFromVertex(fromObject) {\n    const toObject = {};\n    const fromGcsUri = getValueByPath(fromObject, [\n        \"gcsUri\"\n    ]);\n    if (fromGcsUri != null) {\n        setValueByPath(toObject, [\n            \"gcsUri\"\n        ], fromGcsUri);\n    }\n    const fromImageBytes = getValueByPath(fromObject, [\n        \"bytesBase64Encoded\"\n    ]);\n    if (fromImageBytes != null) {\n        setValueByPath(toObject, [\n            \"imageBytes\"\n        ], tBytes(fromImageBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction safetyAttributesFromVertex(fromObject) {\n    const toObject = {};\n    const fromCategories = getValueByPath(fromObject, [\n        \"safetyAttributes\",\n        \"categories\"\n    ]);\n    if (fromCategories != null) {\n        setValueByPath(toObject, [\n            \"categories\"\n        ], fromCategories);\n    }\n    const fromScores = getValueByPath(fromObject, [\n        \"safetyAttributes\",\n        \"scores\"\n    ]);\n    if (fromScores != null) {\n        setValueByPath(toObject, [\n            \"scores\"\n        ], fromScores);\n    }\n    const fromContentType = getValueByPath(fromObject, [\n        \"contentType\"\n    ]);\n    if (fromContentType != null) {\n        setValueByPath(toObject, [\n            \"contentType\"\n        ], fromContentType);\n    }\n    return toObject;\n}\nfunction generatedImageFromVertex(fromObject) {\n    const toObject = {};\n    const fromImage = getValueByPath(fromObject, [\n        \"_self\"\n    ]);\n    if (fromImage != null) {\n        setValueByPath(toObject, [\n            \"image\"\n        ], imageFromVertex(fromImage));\n    }\n    const fromRaiFilteredReason = getValueByPath(fromObject, [\n        \"raiFilteredReason\"\n    ]);\n    if (fromRaiFilteredReason != null) {\n        setValueByPath(toObject, [\n            \"raiFilteredReason\"\n        ], fromRaiFilteredReason);\n    }\n    const fromSafetyAttributes = getValueByPath(fromObject, [\n        \"_self\"\n    ]);\n    if (fromSafetyAttributes != null) {\n        setValueByPath(toObject, [\n            \"safetyAttributes\"\n        ], safetyAttributesFromVertex(fromSafetyAttributes));\n    }\n    const fromEnhancedPrompt = getValueByPath(fromObject, [\n        \"prompt\"\n    ]);\n    if (fromEnhancedPrompt != null) {\n        setValueByPath(toObject, [\n            \"enhancedPrompt\"\n        ], fromEnhancedPrompt);\n    }\n    return toObject;\n}\nfunction generateImagesResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromGeneratedImages = getValueByPath(fromObject, [\n        \"predictions\"\n    ]);\n    if (fromGeneratedImages != null) {\n        let transformedList = fromGeneratedImages;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return generatedImageFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"generatedImages\"\n        ], transformedList);\n    }\n    const fromPositivePromptSafetyAttributes = getValueByPath(fromObject, [\n        \"positivePromptSafetyAttributes\"\n    ]);\n    if (fromPositivePromptSafetyAttributes != null) {\n        setValueByPath(toObject, [\n            \"positivePromptSafetyAttributes\"\n        ], safetyAttributesFromVertex(fromPositivePromptSafetyAttributes));\n    }\n    return toObject;\n}\nfunction editImageResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromGeneratedImages = getValueByPath(fromObject, [\n        \"predictions\"\n    ]);\n    if (fromGeneratedImages != null) {\n        let transformedList = fromGeneratedImages;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return generatedImageFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"generatedImages\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction upscaleImageResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromGeneratedImages = getValueByPath(fromObject, [\n        \"predictions\"\n    ]);\n    if (fromGeneratedImages != null) {\n        let transformedList = fromGeneratedImages;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return generatedImageFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"generatedImages\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction endpointFromVertex(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"endpoint\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromDeployedModelId = getValueByPath(fromObject, [\n        \"deployedModelId\"\n    ]);\n    if (fromDeployedModelId != null) {\n        setValueByPath(toObject, [\n            \"deployedModelId\"\n        ], fromDeployedModelId);\n    }\n    return toObject;\n}\nfunction tunedModelInfoFromVertex(fromObject) {\n    const toObject = {};\n    const fromBaseModel = getValueByPath(fromObject, [\n        \"labels\",\n        \"google-vertex-llm-tuning-base-model-id\"\n    ]);\n    if (fromBaseModel != null) {\n        setValueByPath(toObject, [\n            \"baseModel\"\n        ], fromBaseModel);\n    }\n    const fromCreateTime = getValueByPath(fromObject, [\n        \"createTime\"\n    ]);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, [\n            \"createTime\"\n        ], fromCreateTime);\n    }\n    const fromUpdateTime = getValueByPath(fromObject, [\n        \"updateTime\"\n    ]);\n    if (fromUpdateTime != null) {\n        setValueByPath(toObject, [\n            \"updateTime\"\n        ], fromUpdateTime);\n    }\n    return toObject;\n}\nfunction checkpointFromVertex(fromObject) {\n    const toObject = {};\n    const fromCheckpointId = getValueByPath(fromObject, [\n        \"checkpointId\"\n    ]);\n    if (fromCheckpointId != null) {\n        setValueByPath(toObject, [\n            \"checkpointId\"\n        ], fromCheckpointId);\n    }\n    const fromEpoch = getValueByPath(fromObject, [\n        \"epoch\"\n    ]);\n    if (fromEpoch != null) {\n        setValueByPath(toObject, [\n            \"epoch\"\n        ], fromEpoch);\n    }\n    const fromStep = getValueByPath(fromObject, [\n        \"step\"\n    ]);\n    if (fromStep != null) {\n        setValueByPath(toObject, [\n            \"step\"\n        ], fromStep);\n    }\n    return toObject;\n}\nfunction modelFromVertex(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (fromDescription != null) {\n        setValueByPath(toObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromVersion = getValueByPath(fromObject, [\n        \"versionId\"\n    ]);\n    if (fromVersion != null) {\n        setValueByPath(toObject, [\n            \"version\"\n        ], fromVersion);\n    }\n    const fromEndpoints = getValueByPath(fromObject, [\n        \"deployedModels\"\n    ]);\n    if (fromEndpoints != null) {\n        let transformedList = fromEndpoints;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return endpointFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"endpoints\"\n        ], transformedList);\n    }\n    const fromLabels = getValueByPath(fromObject, [\n        \"labels\"\n    ]);\n    if (fromLabels != null) {\n        setValueByPath(toObject, [\n            \"labels\"\n        ], fromLabels);\n    }\n    const fromTunedModelInfo = getValueByPath(fromObject, [\n        \"_self\"\n    ]);\n    if (fromTunedModelInfo != null) {\n        setValueByPath(toObject, [\n            \"tunedModelInfo\"\n        ], tunedModelInfoFromVertex(fromTunedModelInfo));\n    }\n    const fromDefaultCheckpointId = getValueByPath(fromObject, [\n        \"defaultCheckpointId\"\n    ]);\n    if (fromDefaultCheckpointId != null) {\n        setValueByPath(toObject, [\n            \"defaultCheckpointId\"\n        ], fromDefaultCheckpointId);\n    }\n    const fromCheckpoints = getValueByPath(fromObject, [\n        \"checkpoints\"\n    ]);\n    if (fromCheckpoints != null) {\n        let transformedList = fromCheckpoints;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return checkpointFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"checkpoints\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction listModelsResponseFromVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromNextPageToken = getValueByPath(fromObject, [\n        \"nextPageToken\"\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, [\n            \"nextPageToken\"\n        ], fromNextPageToken);\n    }\n    const fromModels = getValueByPath(fromObject, [\n        \"_self\"\n    ]);\n    if (fromModels != null) {\n        let transformedList = tExtractModels(fromModels);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return modelFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"models\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction deleteModelResponseFromVertex() {\n    const toObject = {};\n    return toObject;\n}\nfunction countTokensResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromTotalTokens = getValueByPath(fromObject, [\n        \"totalTokens\"\n    ]);\n    if (fromTotalTokens != null) {\n        setValueByPath(toObject, [\n            \"totalTokens\"\n        ], fromTotalTokens);\n    }\n    return toObject;\n}\nfunction computeTokensResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromTokensInfo = getValueByPath(fromObject, [\n        \"tokensInfo\"\n    ]);\n    if (fromTokensInfo != null) {\n        setValueByPath(toObject, [\n            \"tokensInfo\"\n        ], fromTokensInfo);\n    }\n    return toObject;\n}\nfunction videoFromVertex$1(fromObject) {\n    const toObject = {};\n    const fromUri = getValueByPath(fromObject, [\n        \"gcsUri\"\n    ]);\n    if (fromUri != null) {\n        setValueByPath(toObject, [\n            \"uri\"\n        ], fromUri);\n    }\n    const fromVideoBytes = getValueByPath(fromObject, [\n        \"bytesBase64Encoded\"\n    ]);\n    if (fromVideoBytes != null) {\n        setValueByPath(toObject, [\n            \"videoBytes\"\n        ], tBytes(fromVideoBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction generatedVideoFromVertex$1(fromObject) {\n    const toObject = {};\n    const fromVideo = getValueByPath(fromObject, [\n        \"_self\"\n    ]);\n    if (fromVideo != null) {\n        setValueByPath(toObject, [\n            \"video\"\n        ], videoFromVertex$1(fromVideo));\n    }\n    return toObject;\n}\nfunction generateVideosResponseFromVertex$1(fromObject) {\n    const toObject = {};\n    const fromGeneratedVideos = getValueByPath(fromObject, [\n        \"videos\"\n    ]);\n    if (fromGeneratedVideos != null) {\n        let transformedList = fromGeneratedVideos;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return generatedVideoFromVertex$1(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"generatedVideos\"\n        ], transformedList);\n    }\n    const fromRaiMediaFilteredCount = getValueByPath(fromObject, [\n        \"raiMediaFilteredCount\"\n    ]);\n    if (fromRaiMediaFilteredCount != null) {\n        setValueByPath(toObject, [\n            \"raiMediaFilteredCount\"\n        ], fromRaiMediaFilteredCount);\n    }\n    const fromRaiMediaFilteredReasons = getValueByPath(fromObject, [\n        \"raiMediaFilteredReasons\"\n    ]);\n    if (fromRaiMediaFilteredReasons != null) {\n        setValueByPath(toObject, [\n            \"raiMediaFilteredReasons\"\n        ], fromRaiMediaFilteredReasons);\n    }\n    return toObject;\n}\nfunction generateVideosOperationFromVertex$1(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromMetadata = getValueByPath(fromObject, [\n        \"metadata\"\n    ]);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, [\n            \"metadata\"\n        ], fromMetadata);\n    }\n    const fromDone = getValueByPath(fromObject, [\n        \"done\"\n    ]);\n    if (fromDone != null) {\n        setValueByPath(toObject, [\n            \"done\"\n        ], fromDone);\n    }\n    const fromError = getValueByPath(fromObject, [\n        \"error\"\n    ]);\n    if (fromError != null) {\n        setValueByPath(toObject, [\n            \"error\"\n        ], fromError);\n    }\n    const fromResponse = getValueByPath(fromObject, [\n        \"response\"\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, [\n            \"response\"\n        ], generateVideosResponseFromVertex$1(fromResponse));\n    }\n    return toObject;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ const CONTENT_TYPE_HEADER = \"Content-Type\";\nconst SERVER_TIMEOUT_HEADER = \"X-Server-Timeout\";\nconst USER_AGENT_HEADER = \"User-Agent\";\nconst GOOGLE_API_CLIENT_HEADER = \"x-goog-api-client\";\nconst SDK_VERSION = \"1.7.0\"; // x-release-please-version\nconst LIBRARY_LABEL = `google-genai-sdk/${SDK_VERSION}`;\nconst VERTEX_AI_API_DEFAULT_VERSION = \"v1beta1\";\nconst GOOGLE_AI_API_DEFAULT_VERSION = \"v1beta\";\nconst responseLineRE = /^data: (.*)(?:\\n\\n|\\r\\r|\\r\\n\\r\\n)/;\n/**\n * The ApiClient class is used to send requests to the Gemini API or Vertex AI\n * endpoints.\n */ class ApiClient {\n    constructor(opts){\n        var _a, _b;\n        this.clientOptions = Object.assign(Object.assign({}, opts), {\n            project: opts.project,\n            location: opts.location,\n            apiKey: opts.apiKey,\n            vertexai: opts.vertexai\n        });\n        const initHttpOptions = {};\n        if (this.clientOptions.vertexai) {\n            initHttpOptions.apiVersion = (_a = this.clientOptions.apiVersion) !== null && _a !== void 0 ? _a : VERTEX_AI_API_DEFAULT_VERSION;\n            initHttpOptions.baseUrl = this.baseUrlFromProjectLocation();\n            this.normalizeAuthParameters();\n        } else {\n            // Gemini API\n            initHttpOptions.apiVersion = (_b = this.clientOptions.apiVersion) !== null && _b !== void 0 ? _b : GOOGLE_AI_API_DEFAULT_VERSION;\n            initHttpOptions.baseUrl = `https://generativelanguage.googleapis.com/`;\n        }\n        initHttpOptions.headers = this.getDefaultHeaders();\n        this.clientOptions.httpOptions = initHttpOptions;\n        if (opts.httpOptions) {\n            this.clientOptions.httpOptions = this.patchHttpOptions(initHttpOptions, opts.httpOptions);\n        }\n    }\n    /**\n     * Determines the base URL for Vertex AI based on project and location.\n     * Uses the global endpoint if location is 'global' or if project/location\n     * are not specified (implying API key usage).\n     * @private\n     */ baseUrlFromProjectLocation() {\n        if (this.clientOptions.project && this.clientOptions.location && this.clientOptions.location !== \"global\") {\n            // Regional endpoint\n            return `https://${this.clientOptions.location}-aiplatform.googleapis.com/`;\n        }\n        // Global endpoint (covers 'global' location and API key usage)\n        return `https://aiplatform.googleapis.com/`;\n    }\n    /**\n     * Normalizes authentication parameters for Vertex AI.\n     * If project and location are provided, API key is cleared.\n     * If project and location are not provided (implying API key usage),\n     * project and location are cleared.\n     * @private\n     */ normalizeAuthParameters() {\n        if (this.clientOptions.project && this.clientOptions.location) {\n            // Using project/location for auth, clear potential API key\n            this.clientOptions.apiKey = undefined;\n            return;\n        }\n        // Using API key for auth (or no auth provided yet), clear project/location\n        this.clientOptions.project = undefined;\n        this.clientOptions.location = undefined;\n    }\n    isVertexAI() {\n        var _a;\n        return (_a = this.clientOptions.vertexai) !== null && _a !== void 0 ? _a : false;\n    }\n    getProject() {\n        return this.clientOptions.project;\n    }\n    getLocation() {\n        return this.clientOptions.location;\n    }\n    getApiVersion() {\n        if (this.clientOptions.httpOptions && this.clientOptions.httpOptions.apiVersion !== undefined) {\n            return this.clientOptions.httpOptions.apiVersion;\n        }\n        throw new Error(\"API version is not set.\");\n    }\n    getBaseUrl() {\n        if (this.clientOptions.httpOptions && this.clientOptions.httpOptions.baseUrl !== undefined) {\n            return this.clientOptions.httpOptions.baseUrl;\n        }\n        throw new Error(\"Base URL is not set.\");\n    }\n    getRequestUrl() {\n        return this.getRequestUrlInternal(this.clientOptions.httpOptions);\n    }\n    getHeaders() {\n        if (this.clientOptions.httpOptions && this.clientOptions.httpOptions.headers !== undefined) {\n            return this.clientOptions.httpOptions.headers;\n        } else {\n            throw new Error(\"Headers are not set.\");\n        }\n    }\n    getRequestUrlInternal(httpOptions) {\n        if (!httpOptions || httpOptions.baseUrl === undefined || httpOptions.apiVersion === undefined) {\n            throw new Error(\"HTTP options are not correctly set.\");\n        }\n        const baseUrl = httpOptions.baseUrl.endsWith(\"/\") ? httpOptions.baseUrl.slice(0, -1) : httpOptions.baseUrl;\n        const urlElement = [\n            baseUrl\n        ];\n        if (httpOptions.apiVersion && httpOptions.apiVersion !== \"\") {\n            urlElement.push(httpOptions.apiVersion);\n        }\n        return urlElement.join(\"/\");\n    }\n    getBaseResourcePath() {\n        return `projects/${this.clientOptions.project}/locations/${this.clientOptions.location}`;\n    }\n    getApiKey() {\n        return this.clientOptions.apiKey;\n    }\n    getWebsocketBaseUrl() {\n        const baseUrl = this.getBaseUrl();\n        const urlParts = new URL(baseUrl);\n        urlParts.protocol = urlParts.protocol == \"http:\" ? \"ws\" : \"wss\";\n        return urlParts.toString();\n    }\n    setBaseUrl(url) {\n        if (this.clientOptions.httpOptions) {\n            this.clientOptions.httpOptions.baseUrl = url;\n        } else {\n            throw new Error(\"HTTP options are not correctly set.\");\n        }\n    }\n    constructUrl(path, httpOptions, prependProjectLocation) {\n        const urlElement = [\n            this.getRequestUrlInternal(httpOptions)\n        ];\n        if (prependProjectLocation) {\n            urlElement.push(this.getBaseResourcePath());\n        }\n        if (path !== \"\") {\n            urlElement.push(path);\n        }\n        const url = new URL(`${urlElement.join(\"/\")}`);\n        return url;\n    }\n    shouldPrependVertexProjectPath(request) {\n        if (this.clientOptions.apiKey) {\n            return false;\n        }\n        if (!this.clientOptions.vertexai) {\n            return false;\n        }\n        if (request.path.startsWith(\"projects/\")) {\n            // Assume the path already starts with\n            // `projects/<project>/location/<location>`.\n            return false;\n        }\n        if (request.httpMethod === \"GET\" && request.path.startsWith(\"publishers/google/models\")) {\n            // These paths are used by Vertex's models.get and models.list\n            // calls. For base models Vertex does not accept a project/location\n            // prefix (for tuned model the prefix is required).\n            return false;\n        }\n        return true;\n    }\n    async request(request) {\n        let patchedHttpOptions = this.clientOptions.httpOptions;\n        if (request.httpOptions) {\n            patchedHttpOptions = this.patchHttpOptions(this.clientOptions.httpOptions, request.httpOptions);\n        }\n        const prependProjectLocation = this.shouldPrependVertexProjectPath(request);\n        const url = this.constructUrl(request.path, patchedHttpOptions, prependProjectLocation);\n        if (request.queryParams) {\n            for (const [key, value] of Object.entries(request.queryParams)){\n                url.searchParams.append(key, String(value));\n            }\n        }\n        let requestInit = {};\n        if (request.httpMethod === \"GET\") {\n            if (request.body && request.body !== \"{}\") {\n                throw new Error(\"Request body should be empty for GET request, but got non empty request body\");\n            }\n        } else {\n            requestInit.body = request.body;\n        }\n        requestInit = await this.includeExtraHttpOptionsToRequestInit(requestInit, patchedHttpOptions, request.abortSignal);\n        return this.unaryApiCall(url, requestInit, request.httpMethod);\n    }\n    patchHttpOptions(baseHttpOptions, requestHttpOptions) {\n        const patchedHttpOptions = JSON.parse(JSON.stringify(baseHttpOptions));\n        for (const [key, value] of Object.entries(requestHttpOptions)){\n            // Records compile to objects.\n            if (typeof value === \"object\") {\n                // @ts-expect-error TS2345TS7053: Element implicitly has an 'any' type\n                // because expression of type 'string' can't be used to index type\n                // 'HttpOptions'.\n                patchedHttpOptions[key] = Object.assign(Object.assign({}, patchedHttpOptions[key]), value);\n            } else if (value !== undefined) {\n                // @ts-expect-error TS2345TS7053: Element implicitly has an 'any' type\n                // because expression of type 'string' can't be used to index type\n                // 'HttpOptions'.\n                patchedHttpOptions[key] = value;\n            }\n        }\n        return patchedHttpOptions;\n    }\n    async requestStream(request) {\n        let patchedHttpOptions = this.clientOptions.httpOptions;\n        if (request.httpOptions) {\n            patchedHttpOptions = this.patchHttpOptions(this.clientOptions.httpOptions, request.httpOptions);\n        }\n        const prependProjectLocation = this.shouldPrependVertexProjectPath(request);\n        const url = this.constructUrl(request.path, patchedHttpOptions, prependProjectLocation);\n        if (!url.searchParams.has(\"alt\") || url.searchParams.get(\"alt\") !== \"sse\") {\n            url.searchParams.set(\"alt\", \"sse\");\n        }\n        let requestInit = {};\n        requestInit.body = request.body;\n        requestInit = await this.includeExtraHttpOptionsToRequestInit(requestInit, patchedHttpOptions, request.abortSignal);\n        return this.streamApiCall(url, requestInit, request.httpMethod);\n    }\n    async includeExtraHttpOptionsToRequestInit(requestInit, httpOptions, abortSignal) {\n        if (httpOptions && httpOptions.timeout || abortSignal) {\n            const abortController = new AbortController();\n            const signal = abortController.signal;\n            if (httpOptions.timeout && (httpOptions === null || httpOptions === void 0 ? void 0 : httpOptions.timeout) > 0) {\n                setTimeout(()=>abortController.abort(), httpOptions.timeout);\n            }\n            if (abortSignal) {\n                abortSignal.addEventListener(\"abort\", ()=>{\n                    abortController.abort();\n                });\n            }\n            requestInit.signal = signal;\n        }\n        if (httpOptions && httpOptions.extraBody !== null) {\n            includeExtraBodyToRequestInit(requestInit, httpOptions.extraBody);\n        }\n        requestInit.headers = await this.getHeadersInternal(httpOptions);\n        return requestInit;\n    }\n    async unaryApiCall(url, requestInit, httpMethod) {\n        return this.apiCall(url.toString(), Object.assign(Object.assign({}, requestInit), {\n            method: httpMethod\n        })).then(async (response)=>{\n            await throwErrorIfNotOK(response);\n            return new HttpResponse(response);\n        }).catch((e)=>{\n            if (e instanceof Error) {\n                throw e;\n            } else {\n                throw new Error(JSON.stringify(e));\n            }\n        });\n    }\n    async streamApiCall(url, requestInit, httpMethod) {\n        return this.apiCall(url.toString(), Object.assign(Object.assign({}, requestInit), {\n            method: httpMethod\n        })).then(async (response)=>{\n            await throwErrorIfNotOK(response);\n            return this.processStreamResponse(response);\n        }).catch((e)=>{\n            if (e instanceof Error) {\n                throw e;\n            } else {\n                throw new Error(JSON.stringify(e));\n            }\n        });\n    }\n    processStreamResponse(response) {\n        var _a;\n        return __asyncGenerator(this, arguments, function* processStreamResponse_1() {\n            const reader = (_a = response === null || response === void 0 ? void 0 : response.body) === null || _a === void 0 ? void 0 : _a.getReader();\n            const decoder = new TextDecoder(\"utf-8\");\n            if (!reader) {\n                throw new Error(\"Response body is empty\");\n            }\n            try {\n                let buffer = \"\";\n                while(true){\n                    const { done, value } = yield __await(reader.read());\n                    if (done) {\n                        if (buffer.trim().length > 0) {\n                            throw new Error(\"Incomplete JSON segment at the end\");\n                        }\n                        break;\n                    }\n                    const chunkString = decoder.decode(value);\n                    // Parse and throw an error if the chunk contains an error.\n                    try {\n                        const chunkJson = JSON.parse(chunkString);\n                        if (\"error\" in chunkJson) {\n                            const errorJson = JSON.parse(JSON.stringify(chunkJson[\"error\"]));\n                            const status = errorJson[\"status\"];\n                            const code = errorJson[\"code\"];\n                            const errorMessage = `got status: ${status}. ${JSON.stringify(chunkJson)}`;\n                            if (code >= 400 && code < 600) {\n                                const apiError = new ApiError({\n                                    message: errorMessage,\n                                    status: code\n                                });\n                                throw apiError;\n                            }\n                        }\n                    } catch (e) {\n                        const error = e;\n                        if (error.name === \"ApiError\") {\n                            throw e;\n                        }\n                    }\n                    buffer += chunkString;\n                    let match = buffer.match(responseLineRE);\n                    while(match){\n                        const processedChunkString = match[1];\n                        try {\n                            const partialResponse = new Response(processedChunkString, {\n                                headers: response === null || response === void 0 ? void 0 : response.headers,\n                                status: response === null || response === void 0 ? void 0 : response.status,\n                                statusText: response === null || response === void 0 ? void 0 : response.statusText\n                            });\n                            yield yield __await(new HttpResponse(partialResponse));\n                            buffer = buffer.slice(match[0].length);\n                            match = buffer.match(responseLineRE);\n                        } catch (e) {\n                            throw new Error(`exception parsing stream chunk ${processedChunkString}. ${e}`);\n                        }\n                    }\n                }\n            } finally{\n                reader.releaseLock();\n            }\n        });\n    }\n    async apiCall(url, requestInit) {\n        return fetch(url, requestInit).catch((e)=>{\n            throw new Error(`exception ${e} sending request`);\n        });\n    }\n    getDefaultHeaders() {\n        const headers = {};\n        const versionHeaderValue = LIBRARY_LABEL + \" \" + this.clientOptions.userAgentExtra;\n        headers[USER_AGENT_HEADER] = versionHeaderValue;\n        headers[GOOGLE_API_CLIENT_HEADER] = versionHeaderValue;\n        headers[CONTENT_TYPE_HEADER] = \"application/json\";\n        return headers;\n    }\n    async getHeadersInternal(httpOptions) {\n        const headers = new Headers();\n        if (httpOptions && httpOptions.headers) {\n            for (const [key, value] of Object.entries(httpOptions.headers)){\n                headers.append(key, value);\n            }\n            // Append a timeout header if it is set, note that the timeout option is\n            // in milliseconds but the header is in seconds.\n            if (httpOptions.timeout && httpOptions.timeout > 0) {\n                headers.append(SERVER_TIMEOUT_HEADER, String(Math.ceil(httpOptions.timeout / 1000)));\n            }\n        }\n        await this.clientOptions.auth.addAuthHeaders(headers);\n        return headers;\n    }\n    /**\n     * Uploads a file asynchronously using Gemini API only, this is not supported\n     * in Vertex AI.\n     *\n     * @param file The string path to the file to be uploaded or a Blob object.\n     * @param config Optional parameters specified in the `UploadFileConfig`\n     *     interface. @see {@link UploadFileConfig}\n     * @return A promise that resolves to a `File` object.\n     * @throws An error if called on a Vertex AI client.\n     * @throws An error if the `mimeType` is not provided and can not be inferred,\n     */ async uploadFile(file, config) {\n        var _a;\n        const fileToUpload = {};\n        if (config != null) {\n            fileToUpload.mimeType = config.mimeType;\n            fileToUpload.name = config.name;\n            fileToUpload.displayName = config.displayName;\n        }\n        if (fileToUpload.name && !fileToUpload.name.startsWith(\"files/\")) {\n            fileToUpload.name = `files/${fileToUpload.name}`;\n        }\n        const uploader = this.clientOptions.uploader;\n        const fileStat = await uploader.stat(file);\n        fileToUpload.sizeBytes = String(fileStat.size);\n        const mimeType = (_a = config === null || config === void 0 ? void 0 : config.mimeType) !== null && _a !== void 0 ? _a : fileStat.type;\n        if (mimeType === undefined || mimeType === \"\") {\n            throw new Error(\"Can not determine mimeType. Please provide mimeType in the config.\");\n        }\n        fileToUpload.mimeType = mimeType;\n        const uploadUrl = await this.fetchUploadUrl(fileToUpload, config);\n        return uploader.upload(file, uploadUrl, this);\n    }\n    /**\n     * Downloads a file asynchronously to the specified path.\n     *\n     * @params params - The parameters for the download request, see {@link\n     * DownloadFileParameters}\n     */ async downloadFile(params) {\n        const downloader = this.clientOptions.downloader;\n        await downloader.download(params, this);\n    }\n    async fetchUploadUrl(file, config) {\n        var _a;\n        let httpOptions = {};\n        if (config === null || config === void 0 ? void 0 : config.httpOptions) {\n            httpOptions = config.httpOptions;\n        } else {\n            httpOptions = {\n                apiVersion: \"\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    \"X-Goog-Upload-Protocol\": \"resumable\",\n                    \"X-Goog-Upload-Command\": \"start\",\n                    \"X-Goog-Upload-Header-Content-Length\": `${file.sizeBytes}`,\n                    \"X-Goog-Upload-Header-Content-Type\": `${file.mimeType}`\n                }\n            };\n        }\n        const body = {\n            \"file\": file\n        };\n        const httpResponse = await this.request({\n            path: formatMap(\"upload/v1beta/files\", body[\"_url\"]),\n            body: JSON.stringify(body),\n            httpMethod: \"POST\",\n            httpOptions\n        });\n        if (!httpResponse || !(httpResponse === null || httpResponse === void 0 ? void 0 : httpResponse.headers)) {\n            throw new Error(\"Server did not return an HttpResponse or the returned HttpResponse did not have headers.\");\n        }\n        const uploadUrl = (_a = httpResponse === null || httpResponse === void 0 ? void 0 : httpResponse.headers) === null || _a === void 0 ? void 0 : _a[\"x-goog-upload-url\"];\n        if (uploadUrl === undefined) {\n            throw new Error(\"Failed to get upload url. Server did not return the x-google-upload-url in the headers\");\n        }\n        return uploadUrl;\n    }\n}\nasync function throwErrorIfNotOK(response) {\n    var _a;\n    if (response === undefined) {\n        throw new Error(\"response is undefined\");\n    }\n    if (!response.ok) {\n        const status = response.status;\n        let errorBody;\n        if ((_a = response.headers.get(\"content-type\")) === null || _a === void 0 ? void 0 : _a.includes(\"application/json\")) {\n            errorBody = await response.json();\n        } else {\n            errorBody = {\n                error: {\n                    message: await response.text(),\n                    code: response.status,\n                    status: response.statusText\n                }\n            };\n        }\n        const errorMessage = JSON.stringify(errorBody);\n        if (status >= 400 && status < 600) {\n            const apiError = new ApiError({\n                message: errorMessage,\n                status: status\n            });\n            throw apiError;\n        }\n        throw new Error(errorMessage);\n    }\n}\n/**\n * Recursively updates the `requestInit.body` with values from an `extraBody` object.\n *\n * If `requestInit.body` is a string, it's assumed to be JSON and will be parsed.\n * The `extraBody` is then deeply merged into this parsed object.\n * If `requestInit.body` is a Blob, `extraBody` will be ignored, and a warning logged,\n * as merging structured data into an opaque Blob is not supported.\n *\n * The function does not enforce that updated values from `extraBody` have the\n * same type as existing values in `requestInit.body`. Type mismatches during\n * the merge will result in a warning, but the value from `extraBody` will overwrite\n * the original. `extraBody` users are responsible for ensuring `extraBody` has the correct structure.\n *\n * @param requestInit The RequestInit object whose body will be updated.\n * @param extraBody The object containing updates to be merged into `requestInit.body`.\n */ function includeExtraBodyToRequestInit(requestInit, extraBody) {\n    if (!extraBody || Object.keys(extraBody).length === 0) {\n        return;\n    }\n    if (requestInit.body instanceof Blob) {\n        console.warn(\"includeExtraBodyToRequestInit: extraBody provided but current request body is a Blob. extraBody will be ignored as merging is not supported for Blob bodies.\");\n        return;\n    }\n    let currentBodyObject = {};\n    // If adding new type to HttpRequest.body, please check the code below to\n    // see if we need to update the logic.\n    if (typeof requestInit.body === \"string\" && requestInit.body.length > 0) {\n        try {\n            const parsedBody = JSON.parse(requestInit.body);\n            if (typeof parsedBody === \"object\" && parsedBody !== null && !Array.isArray(parsedBody)) {\n                currentBodyObject = parsedBody;\n            } else {\n                console.warn(\"includeExtraBodyToRequestInit: Original request body is valid JSON but not a non-array object. Skip applying extraBody to the request body.\");\n                return;\n            }\n        /*  eslint-disable-next-line @typescript-eslint/no-unused-vars */ } catch (e) {\n            console.warn(\"includeExtraBodyToRequestInit: Original request body is not valid JSON. Skip applying extraBody to the request body.\");\n            return;\n        }\n    }\n    function deepMerge(target, source) {\n        const output = Object.assign({}, target);\n        for(const key in source){\n            if (Object.prototype.hasOwnProperty.call(source, key)) {\n                const sourceValue = source[key];\n                const targetValue = output[key];\n                if (sourceValue && typeof sourceValue === \"object\" && !Array.isArray(sourceValue) && targetValue && typeof targetValue === \"object\" && !Array.isArray(targetValue)) {\n                    output[key] = deepMerge(targetValue, sourceValue);\n                } else {\n                    if (targetValue && sourceValue && typeof targetValue !== typeof sourceValue) {\n                        console.warn(`includeExtraBodyToRequestInit:deepMerge: Type mismatch for key \"${key}\". Original type: ${typeof targetValue}, New type: ${typeof sourceValue}. Overwriting.`);\n                    }\n                    output[key] = sourceValue;\n                }\n            }\n        }\n        return output;\n    }\n    const mergedBody = deepMerge(currentBodyObject, extraBody);\n    requestInit.body = JSON.stringify(mergedBody);\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ // TODO: b/416041229 - Determine how to retrieve the MCP package version.\nconst MCP_LABEL = \"mcp_used/unknown\";\n// Checks whether the list of tools contains any MCP tools.\nfunction hasMcpToolUsage(tools) {\n    for (const tool of tools){\n        if (isMcpCallableTool(tool)) {\n            return true;\n        }\n        if (typeof tool === \"object\" && \"inputSchema\" in tool) {\n            return true;\n        }\n    }\n    return false;\n}\n// Sets the MCP version label in the Google API client header.\nfunction setMcpUsageHeader(headers) {\n    var _a;\n    const existingHeader = (_a = headers[GOOGLE_API_CLIENT_HEADER]) !== null && _a !== void 0 ? _a : \"\";\n    headers[GOOGLE_API_CLIENT_HEADER] = (existingHeader + ` ${MCP_LABEL}`).trimStart();\n}\n// Checks whether the list of tools contains any MCP clients. Will return true\n// if there is at least one MCP client.\nfunction hasMcpClientTools(params) {\n    var _a, _b, _c;\n    return (_c = (_b = (_a = params.config) === null || _a === void 0 ? void 0 : _a.tools) === null || _b === void 0 ? void 0 : _b.some((tool)=>isMcpCallableTool(tool))) !== null && _c !== void 0 ? _c : false;\n}\n// Checks whether the list of tools contains any non-MCP tools. Will return true\n// if there is at least one non-MCP tool.\nfunction hasNonMcpTools(params) {\n    var _a, _b, _c;\n    return (_c = (_b = (_a = params.config) === null || _a === void 0 ? void 0 : _a.tools) === null || _b === void 0 ? void 0 : _b.some((tool)=>!isMcpCallableTool(tool))) !== null && _c !== void 0 ? _c : false;\n}\n// Returns true if the object is a MCP CallableTool, otherwise false.\nfunction isMcpCallableTool(object) {\n    return object !== null && typeof object === \"object\" && object instanceof McpCallableTool;\n}\n// List all tools from the MCP client.\nfunction listAllTools(mcpClient, maxTools = 100) {\n    return __asyncGenerator(this, arguments, function* listAllTools_1() {\n        let cursor = undefined;\n        let numTools = 0;\n        while(numTools < maxTools){\n            const t = yield __await(mcpClient.listTools({\n                cursor\n            }));\n            for (const tool of t.tools){\n                yield yield __await(tool);\n                numTools++;\n            }\n            if (!t.nextCursor) {\n                break;\n            }\n            cursor = t.nextCursor;\n        }\n    });\n}\n/**\n * McpCallableTool can be used for model inference and invoking MCP clients with\n * given function call arguments.\n *\n * @experimental Built-in MCP support is an experimental feature, may change in future\n * versions.\n */ class McpCallableTool {\n    constructor(mcpClients = [], config){\n        this.mcpTools = [];\n        this.functionNameToMcpClient = {};\n        this.mcpClients = mcpClients;\n        this.config = config;\n    }\n    /**\n     * Creates a McpCallableTool.\n     */ static create(mcpClients, config) {\n        return new McpCallableTool(mcpClients, config);\n    }\n    /**\n     * Validates the function names are not duplicate and initialize the function\n     * name to MCP client mapping.\n     *\n     * @throws {Error} if the MCP tools from the MCP clients have duplicate tool\n     *     names.\n     */ async initialize() {\n        var _a, e_1, _b, _c;\n        if (this.mcpTools.length > 0) {\n            return;\n        }\n        const functionMap = {};\n        const mcpTools = [];\n        for (const mcpClient of this.mcpClients){\n            try {\n                for(var _d = true, _e = (e_1 = void 0, __asyncValues(listAllTools(mcpClient))), _f; _f = await _e.next(), _a = _f.done, !_a; _d = true){\n                    _c = _f.value;\n                    _d = false;\n                    const mcpTool = _c;\n                    mcpTools.push(mcpTool);\n                    const mcpToolName = mcpTool.name;\n                    if (functionMap[mcpToolName]) {\n                        throw new Error(`Duplicate function name ${mcpToolName} found in MCP tools. Please ensure function names are unique.`);\n                    }\n                    functionMap[mcpToolName] = mcpClient;\n                }\n            } catch (e_1_1) {\n                e_1 = {\n                    error: e_1_1\n                };\n            } finally{\n                try {\n                    if (!_d && !_a && (_b = _e.return)) await _b.call(_e);\n                } finally{\n                    if (e_1) throw e_1.error;\n                }\n            }\n        }\n        this.mcpTools = mcpTools;\n        this.functionNameToMcpClient = functionMap;\n    }\n    async tool() {\n        await this.initialize();\n        return mcpToolsToGeminiTool(this.mcpTools, this.config);\n    }\n    async callTool(functionCalls) {\n        await this.initialize();\n        const functionCallResponseParts = [];\n        for (const functionCall of functionCalls){\n            if (functionCall.name in this.functionNameToMcpClient) {\n                const mcpClient = this.functionNameToMcpClient[functionCall.name];\n                let requestOptions = undefined;\n                // TODO: b/424238654 - Add support for finer grained timeout control.\n                if (this.config.timeout) {\n                    requestOptions = {\n                        timeout: this.config.timeout\n                    };\n                }\n                const callToolResponse = await mcpClient.callTool({\n                    name: functionCall.name,\n                    arguments: functionCall.args\n                }, // Set the result schema to undefined to allow MCP to rely on the\n                // default schema.\n                undefined, requestOptions);\n                functionCallResponseParts.push({\n                    functionResponse: {\n                        name: functionCall.name,\n                        response: callToolResponse.isError ? {\n                            error: callToolResponse\n                        } : callToolResponse\n                    }\n                });\n            }\n        }\n        return functionCallResponseParts;\n    }\n}\nfunction isMcpClient(client) {\n    return client !== null && typeof client === \"object\" && \"listTools\" in client && typeof client.listTools === \"function\";\n}\n/**\n * Creates a McpCallableTool from MCP clients and an optional config.\n *\n * The callable tool can invoke the MCP clients with given function call\n * arguments. (often for automatic function calling).\n * Use the config to modify tool parameters such as behavior.\n *\n * @experimental Built-in MCP support is an experimental feature, may change in future\n * versions.\n */ function mcpToTool(...args) {\n    if (args.length === 0) {\n        throw new Error(\"No MCP clients provided\");\n    }\n    const maybeConfig = args[args.length - 1];\n    if (isMcpClient(maybeConfig)) {\n        return McpCallableTool.create(args, {});\n    }\n    return McpCallableTool.create(args.slice(0, args.length - 1), maybeConfig);\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ /**\n * Handles incoming messages from the WebSocket.\n *\n * @remarks\n * This function is responsible for parsing incoming messages, transforming them\n * into LiveMusicServerMessage, and then calling the onmessage callback.\n * Note that the first message which is received from the server is a\n * setupComplete message.\n *\n * @param apiClient The ApiClient instance.\n * @param onmessage The user-provided onmessage callback (if any).\n * @param event The MessageEvent from the WebSocket.\n */ async function handleWebSocketMessage$1(apiClient, onmessage, event) {\n    const serverMessage = new LiveMusicServerMessage();\n    let data;\n    if (event.data instanceof Blob) {\n        data = JSON.parse(await event.data.text());\n    } else {\n        data = JSON.parse(event.data);\n    }\n    const response = liveMusicServerMessageFromMldev(data);\n    Object.assign(serverMessage, response);\n    onmessage(serverMessage);\n}\n/**\n   LiveMusic class encapsulates the configuration for live music\n   generation via Lyria Live models.\n\n   @experimental\n  */ class LiveMusic {\n    constructor(apiClient, auth, webSocketFactory){\n        this.apiClient = apiClient;\n        this.auth = auth;\n        this.webSocketFactory = webSocketFactory;\n    }\n    /**\n       Establishes a connection to the specified model and returns a\n       LiveMusicSession object representing that connection.\n  \n       @experimental\n  \n       @remarks\n  \n       @param params - The parameters for establishing a connection to the model.\n       @return A live session.\n  \n       @example\n       ```ts\n       let model = 'models/lyria-realtime-exp';\n       const session = await ai.live.music.connect({\n         model: model,\n         callbacks: {\n           onmessage: (e: MessageEvent) => {\n             console.log('Received message from the server: %s\\n', debug(e.data));\n           },\n           onerror: (e: ErrorEvent) => {\n             console.log('Error occurred: %s\\n', debug(e.error));\n           },\n           onclose: (e: CloseEvent) => {\n             console.log('Connection closed.');\n           },\n         },\n       });\n       ```\n      */ async connect(params) {\n        var _a, _b;\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"Live music is not supported for Vertex AI.\");\n        }\n        console.warn(\"Live music generation is experimental and may change in future versions.\");\n        const websocketBaseUrl = this.apiClient.getWebsocketBaseUrl();\n        const apiVersion = this.apiClient.getApiVersion();\n        const headers = mapToHeaders$1(this.apiClient.getDefaultHeaders());\n        const apiKey = this.apiClient.getApiKey();\n        const url = `${websocketBaseUrl}/ws/google.ai.generativelanguage.${apiVersion}.GenerativeService.BidiGenerateMusic?key=${apiKey}`;\n        let onopenResolve = ()=>{};\n        const onopenPromise = new Promise((resolve)=>{\n            onopenResolve = resolve;\n        });\n        const callbacks = params.callbacks;\n        const onopenAwaitedCallback = function() {\n            onopenResolve({});\n        };\n        const apiClient = this.apiClient;\n        const websocketCallbacks = {\n            onopen: onopenAwaitedCallback,\n            onmessage: (event)=>{\n                void handleWebSocketMessage$1(apiClient, callbacks.onmessage, event);\n            },\n            onerror: (_a = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onerror) !== null && _a !== void 0 ? _a : function(e) {},\n            onclose: (_b = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onclose) !== null && _b !== void 0 ? _b : function(e) {}\n        };\n        const conn = this.webSocketFactory.create(url, headersToMap$1(headers), websocketCallbacks);\n        conn.connect();\n        // Wait for the websocket to open before sending requests.\n        await onopenPromise;\n        const model = tModel(this.apiClient, params.model);\n        const setup = liveMusicClientSetupToMldev({\n            model\n        });\n        const clientMessage = liveMusicClientMessageToMldev({\n            setup\n        });\n        conn.send(JSON.stringify(clientMessage));\n        return new LiveMusicSession(conn, this.apiClient);\n    }\n}\n/**\n   Represents a connection to the API.\n\n   @experimental\n  */ class LiveMusicSession {\n    constructor(conn, apiClient){\n        this.conn = conn;\n        this.apiClient = apiClient;\n    }\n    /**\n      Sets inputs to steer music generation. Updates the session's current\n      weighted prompts.\n  \n      @param params - Contains one property, `weightedPrompts`.\n  \n        - `weightedPrompts` to send to the model; weights are normalized to\n          sum to 1.0.\n  \n      @experimental\n     */ async setWeightedPrompts(params) {\n        if (!params.weightedPrompts || Object.keys(params.weightedPrompts).length === 0) {\n            throw new Error(\"Weighted prompts must be set and contain at least one entry.\");\n        }\n        const setWeightedPromptsParameters = liveMusicSetWeightedPromptsParametersToMldev(params);\n        const clientContent = liveMusicClientContentToMldev(setWeightedPromptsParameters);\n        this.conn.send(JSON.stringify({\n            clientContent\n        }));\n    }\n    /**\n      Sets a configuration to the model. Updates the session's current\n      music generation config.\n  \n      @param params - Contains one property, `musicGenerationConfig`.\n  \n        - `musicGenerationConfig` to set in the model. Passing an empty or\n      undefined config to the model will reset the config to defaults.\n  \n      @experimental\n     */ async setMusicGenerationConfig(params) {\n        if (!params.musicGenerationConfig) {\n            params.musicGenerationConfig = {};\n        }\n        const setConfigParameters = liveMusicSetConfigParametersToMldev(params);\n        const clientMessage = liveMusicClientMessageToMldev(setConfigParameters);\n        this.conn.send(JSON.stringify(clientMessage));\n    }\n    sendPlaybackControl(playbackControl) {\n        const clientMessage = liveMusicClientMessageToMldev({\n            playbackControl\n        });\n        this.conn.send(JSON.stringify(clientMessage));\n    }\n    /**\n     * Start the music stream.\n     *\n     * @experimental\n     */ play() {\n        this.sendPlaybackControl(LiveMusicPlaybackControl.PLAY);\n    }\n    /**\n     * Temporarily halt the music stream. Use `play` to resume from the current\n     * position.\n     *\n     * @experimental\n     */ pause() {\n        this.sendPlaybackControl(LiveMusicPlaybackControl.PAUSE);\n    }\n    /**\n     * Stop the music stream and reset the state. Retains the current prompts\n     * and config.\n     *\n     * @experimental\n     */ stop() {\n        this.sendPlaybackControl(LiveMusicPlaybackControl.STOP);\n    }\n    /**\n     * Resets the context of the music generation without stopping it.\n     * Retains the current prompts and config.\n     *\n     * @experimental\n     */ resetContext() {\n        this.sendPlaybackControl(LiveMusicPlaybackControl.RESET_CONTEXT);\n    }\n    /**\n       Terminates the WebSocket connection.\n  \n       @experimental\n     */ close() {\n        this.conn.close();\n    }\n}\n// Converts an headers object to a \"map\" object as expected by the WebSocket\n// constructor. We use this as the Auth interface works with Headers objects\n// while the WebSocket constructor takes a map.\nfunction headersToMap$1(headers) {\n    const headerMap = {};\n    headers.forEach((value, key)=>{\n        headerMap[key] = value;\n    });\n    return headerMap;\n}\n// Converts a \"map\" object to a headers object. We use this as the Auth\n// interface works with Headers objects while the API client default headers\n// returns a map.\nfunction mapToHeaders$1(map) {\n    const headers = new Headers();\n    for (const [key, value] of Object.entries(map)){\n        headers.append(key, value);\n    }\n    return headers;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ const FUNCTION_RESPONSE_REQUIRES_ID = \"FunctionResponse request must have an `id` field from the response of a ToolCall.FunctionalCalls in Google AI.\";\n/**\n * Handles incoming messages from the WebSocket.\n *\n * @remarks\n * This function is responsible for parsing incoming messages, transforming them\n * into LiveServerMessages, and then calling the onmessage callback. Note that\n * the first message which is received from the server is a setupComplete\n * message.\n *\n * @param apiClient The ApiClient instance.\n * @param onmessage The user-provided onmessage callback (if any).\n * @param event The MessageEvent from the WebSocket.\n */ async function handleWebSocketMessage(apiClient, onmessage, event) {\n    const serverMessage = new LiveServerMessage();\n    let jsonData;\n    if (event.data instanceof Blob) {\n        jsonData = await event.data.text();\n    } else if (event.data instanceof ArrayBuffer) {\n        jsonData = new TextDecoder().decode(event.data);\n    } else {\n        jsonData = event.data;\n    }\n    const data = JSON.parse(jsonData);\n    if (apiClient.isVertexAI()) {\n        const resp = liveServerMessageFromVertex(data);\n        Object.assign(serverMessage, resp);\n    } else {\n        const resp = liveServerMessageFromMldev(data);\n        Object.assign(serverMessage, resp);\n    }\n    onmessage(serverMessage);\n}\n/**\n   Live class encapsulates the configuration for live interaction with the\n   Generative Language API. It embeds ApiClient for general API settings.\n\n   @experimental\n  */ class Live {\n    constructor(apiClient, auth, webSocketFactory){\n        this.apiClient = apiClient;\n        this.auth = auth;\n        this.webSocketFactory = webSocketFactory;\n        this.music = new LiveMusic(this.apiClient, this.auth, this.webSocketFactory);\n    }\n    /**\n       Establishes a connection to the specified model with the given\n       configuration and returns a Session object representing that connection.\n  \n       @experimental Built-in MCP support is an experimental feature, may change in\n       future versions.\n  \n       @remarks\n  \n       @param params - The parameters for establishing a connection to the model.\n       @return A live session.\n  \n       @example\n       ```ts\n       let model: string;\n       if (GOOGLE_GENAI_USE_VERTEXAI) {\n         model = 'gemini-2.0-flash-live-preview-04-09';\n       } else {\n         model = 'gemini-2.0-flash-live-001';\n       }\n       const session = await ai.live.connect({\n         model: model,\n         config: {\n           responseModalities: [Modality.AUDIO],\n         },\n         callbacks: {\n           onopen: () => {\n             console.log('Connected to the socket.');\n           },\n           onmessage: (e: MessageEvent) => {\n             console.log('Received message from the server: %s\\n', debug(e.data));\n           },\n           onerror: (e: ErrorEvent) => {\n             console.log('Error occurred: %s\\n', debug(e.error));\n           },\n           onclose: (e: CloseEvent) => {\n             console.log('Connection closed.');\n           },\n         },\n       });\n       ```\n      */ async connect(params) {\n        var _a, _b, _c, _d, _e, _f;\n        const websocketBaseUrl = this.apiClient.getWebsocketBaseUrl();\n        const apiVersion = this.apiClient.getApiVersion();\n        let url;\n        const defaultHeaders = this.apiClient.getDefaultHeaders();\n        if (params.config && params.config.tools && hasMcpToolUsage(params.config.tools)) {\n            setMcpUsageHeader(defaultHeaders);\n        }\n        const headers = mapToHeaders(defaultHeaders);\n        if (this.apiClient.isVertexAI()) {\n            url = `${websocketBaseUrl}/ws/google.cloud.aiplatform.${apiVersion}.LlmBidiService/BidiGenerateContent`;\n            await this.auth.addAuthHeaders(headers);\n        } else {\n            const apiKey = this.apiClient.getApiKey();\n            let method = \"BidiGenerateContent\";\n            let keyName = \"key\";\n            if (apiKey === null || apiKey === void 0 ? void 0 : apiKey.startsWith(\"auth_tokens/\")) {\n                console.warn(\"Warning: Ephemeral token support is experimental and may change in future versions.\");\n                method = \"BidiGenerateContentConstrained\";\n                keyName = \"access_token\";\n            }\n            url = `${websocketBaseUrl}/ws/google.ai.generativelanguage.${apiVersion}.GenerativeService.${method}?${keyName}=${apiKey}`;\n        }\n        let onopenResolve = ()=>{};\n        const onopenPromise = new Promise((resolve)=>{\n            onopenResolve = resolve;\n        });\n        const callbacks = params.callbacks;\n        const onopenAwaitedCallback = function() {\n            var _a;\n            (_a = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onopen) === null || _a === void 0 ? void 0 : _a.call(callbacks);\n            onopenResolve({});\n        };\n        const apiClient = this.apiClient;\n        const websocketCallbacks = {\n            onopen: onopenAwaitedCallback,\n            onmessage: (event)=>{\n                void handleWebSocketMessage(apiClient, callbacks.onmessage, event);\n            },\n            onerror: (_a = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onerror) !== null && _a !== void 0 ? _a : function(e) {},\n            onclose: (_b = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onclose) !== null && _b !== void 0 ? _b : function(e) {}\n        };\n        const conn = this.webSocketFactory.create(url, headersToMap(headers), websocketCallbacks);\n        conn.connect();\n        // Wait for the websocket to open before sending requests.\n        await onopenPromise;\n        let transformedModel = tModel(this.apiClient, params.model);\n        if (this.apiClient.isVertexAI() && transformedModel.startsWith(\"publishers/\")) {\n            const project = this.apiClient.getProject();\n            const location = this.apiClient.getLocation();\n            transformedModel = `projects/${project}/locations/${location}/` + transformedModel;\n        }\n        let clientMessage = {};\n        if (this.apiClient.isVertexAI() && ((_c = params.config) === null || _c === void 0 ? void 0 : _c.responseModalities) === undefined) {\n            // Set default to AUDIO to align with MLDev API.\n            if (params.config === undefined) {\n                params.config = {\n                    responseModalities: [\n                        Modality.AUDIO\n                    ]\n                };\n            } else {\n                params.config.responseModalities = [\n                    Modality.AUDIO\n                ];\n            }\n        }\n        if ((_d = params.config) === null || _d === void 0 ? void 0 : _d.generationConfig) {\n            // Raise deprecation warning for generationConfig.\n            console.warn(\"Setting `LiveConnectConfig.generation_config` is deprecated, please set the fields on `LiveConnectConfig` directly. This will become an error in a future version (not before Q3 2025).\");\n        }\n        const inputTools = (_f = (_e = params.config) === null || _e === void 0 ? void 0 : _e.tools) !== null && _f !== void 0 ? _f : [];\n        const convertedTools = [];\n        for (const tool of inputTools){\n            if (this.isCallableTool(tool)) {\n                const callableTool = tool;\n                convertedTools.push(await callableTool.tool());\n            } else {\n                convertedTools.push(tool);\n            }\n        }\n        if (convertedTools.length > 0) {\n            params.config.tools = convertedTools;\n        }\n        const liveConnectParameters = {\n            model: transformedModel,\n            config: params.config,\n            callbacks: params.callbacks\n        };\n        if (this.apiClient.isVertexAI()) {\n            clientMessage = liveConnectParametersToVertex(this.apiClient, liveConnectParameters);\n        } else {\n            clientMessage = liveConnectParametersToMldev(this.apiClient, liveConnectParameters);\n        }\n        delete clientMessage[\"config\"];\n        conn.send(JSON.stringify(clientMessage));\n        return new Session(conn, this.apiClient);\n    }\n    // TODO: b/416041229 - Abstract this method to a common place.\n    isCallableTool(tool) {\n        return \"callTool\" in tool && typeof tool.callTool === \"function\";\n    }\n}\nconst defaultLiveSendClientContentParamerters = {\n    turnComplete: true\n};\n/**\n   Represents a connection to the API.\n\n   @experimental\n  */ class Session {\n    constructor(conn, apiClient){\n        this.conn = conn;\n        this.apiClient = apiClient;\n    }\n    tLiveClientContent(apiClient, params) {\n        if (params.turns !== null && params.turns !== undefined) {\n            let contents = [];\n            try {\n                contents = tContents(params.turns);\n                if (apiClient.isVertexAI()) {\n                    contents = contents.map((item)=>contentToVertex(item));\n                } else {\n                    contents = contents.map((item)=>contentToMldev$1(item));\n                }\n            } catch (_a) {\n                throw new Error(`Failed to parse client content \"turns\", type: '${typeof params.turns}'`);\n            }\n            return {\n                clientContent: {\n                    turns: contents,\n                    turnComplete: params.turnComplete\n                }\n            };\n        }\n        return {\n            clientContent: {\n                turnComplete: params.turnComplete\n            }\n        };\n    }\n    tLiveClienttToolResponse(apiClient, params) {\n        let functionResponses = [];\n        if (params.functionResponses == null) {\n            throw new Error(\"functionResponses is required.\");\n        }\n        if (!Array.isArray(params.functionResponses)) {\n            functionResponses = [\n                params.functionResponses\n            ];\n        } else {\n            functionResponses = params.functionResponses;\n        }\n        if (functionResponses.length === 0) {\n            throw new Error(\"functionResponses is required.\");\n        }\n        for (const functionResponse of functionResponses){\n            if (typeof functionResponse !== \"object\" || functionResponse === null || !(\"name\" in functionResponse) || !(\"response\" in functionResponse)) {\n                throw new Error(`Could not parse function response, type '${typeof functionResponse}'.`);\n            }\n            if (!apiClient.isVertexAI() && !(\"id\" in functionResponse)) {\n                throw new Error(FUNCTION_RESPONSE_REQUIRES_ID);\n            }\n        }\n        const clientMessage = {\n            toolResponse: {\n                functionResponses: functionResponses\n            }\n        };\n        return clientMessage;\n    }\n    /**\n      Send a message over the established connection.\n  \n      @param params - Contains two **optional** properties, `turns` and\n          `turnComplete`.\n  \n        - `turns` will be converted to a `Content[]`\n        - `turnComplete: true` [default] indicates that you are done sending\n          content and expect a response. If `turnComplete: false`, the server\n          will wait for additional messages before starting generation.\n  \n      @experimental\n  \n      @remarks\n      There are two ways to send messages to the live API:\n      `sendClientContent` and `sendRealtimeInput`.\n  \n      `sendClientContent` messages are added to the model context **in order**.\n      Having a conversation using `sendClientContent` messages is roughly\n      equivalent to using the `Chat.sendMessageStream`, except that the state of\n      the `chat` history is stored on the API server instead of locally.\n  \n      Because of `sendClientContent`'s order guarantee, the model cannot respons\n      as quickly to `sendClientContent` messages as to `sendRealtimeInput`\n      messages. This makes the biggest difference when sending objects that have\n      significant preprocessing time (typically images).\n  \n      The `sendClientContent` message sends a `Content[]`\n      which has more options than the `Blob` sent by `sendRealtimeInput`.\n  \n      So the main use-cases for `sendClientContent` over `sendRealtimeInput` are:\n  \n      - Sending anything that can't be represented as a `Blob` (text,\n      `sendClientContent({turns=\"Hello?\"}`)).\n      - Managing turns when not using audio input and voice activity detection.\n        (`sendClientContent({turnComplete:true})` or the short form\n      `sendClientContent()`)\n      - Prefilling a conversation context\n        ```\n        sendClientContent({\n            turns: [\n              Content({role:user, parts:...}),\n              Content({role:user, parts:...}),\n              ...\n            ]\n        })\n        ```\n      @experimental\n     */ sendClientContent(params) {\n        params = Object.assign(Object.assign({}, defaultLiveSendClientContentParamerters), params);\n        const clientMessage = this.tLiveClientContent(this.apiClient, params);\n        this.conn.send(JSON.stringify(clientMessage));\n    }\n    /**\n      Send a realtime message over the established connection.\n  \n      @param params - Contains one property, `media`.\n  \n        - `media` will be converted to a `Blob`\n  \n      @experimental\n  \n      @remarks\n      Use `sendRealtimeInput` for realtime audio chunks and video frames (images).\n  \n      With `sendRealtimeInput` the api will respond to audio automatically\n      based on voice activity detection (VAD).\n  \n      `sendRealtimeInput` is optimized for responsivness at the expense of\n      deterministic ordering guarantees. Audio and video tokens are to the\n      context when they become available.\n  \n      Note: The Call signature expects a `Blob` object, but only a subset\n      of audio and image mimetypes are allowed.\n     */ sendRealtimeInput(params) {\n        let clientMessage = {};\n        if (this.apiClient.isVertexAI()) {\n            clientMessage = {\n                \"realtimeInput\": liveSendRealtimeInputParametersToVertex(params)\n            };\n        } else {\n            clientMessage = {\n                \"realtimeInput\": liveSendRealtimeInputParametersToMldev(params)\n            };\n        }\n        this.conn.send(JSON.stringify(clientMessage));\n    }\n    /**\n      Send a function response message over the established connection.\n  \n      @param params - Contains property `functionResponses`.\n  \n        - `functionResponses` will be converted to a `functionResponses[]`\n  \n      @remarks\n      Use `sendFunctionResponse` to reply to `LiveServerToolCall` from the server.\n  \n      Use {@link types.LiveConnectConfig#tools} to configure the callable functions.\n  \n      @experimental\n     */ sendToolResponse(params) {\n        if (params.functionResponses == null) {\n            throw new Error(\"Tool response parameters are required.\");\n        }\n        const clientMessage = this.tLiveClienttToolResponse(this.apiClient, params);\n        this.conn.send(JSON.stringify(clientMessage));\n    }\n    /**\n       Terminates the WebSocket connection.\n  \n       @experimental\n  \n       @example\n       ```ts\n       let model: string;\n       if (GOOGLE_GENAI_USE_VERTEXAI) {\n         model = 'gemini-2.0-flash-live-preview-04-09';\n       } else {\n         model = 'gemini-2.0-flash-live-001';\n       }\n       const session = await ai.live.connect({\n         model: model,\n         config: {\n           responseModalities: [Modality.AUDIO],\n         }\n       });\n  \n       session.close();\n       ```\n     */ close() {\n        this.conn.close();\n    }\n}\n// Converts an headers object to a \"map\" object as expected by the WebSocket\n// constructor. We use this as the Auth interface works with Headers objects\n// while the WebSocket constructor takes a map.\nfunction headersToMap(headers) {\n    const headerMap = {};\n    headers.forEach((value, key)=>{\n        headerMap[key] = value;\n    });\n    return headerMap;\n}\n// Converts a \"map\" object to a headers object. We use this as the Auth\n// interface works with Headers objects while the API client default headers\n// returns a map.\nfunction mapToHeaders(map) {\n    const headers = new Headers();\n    for (const [key, value] of Object.entries(map)){\n        headers.append(key, value);\n    }\n    return headers;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ const DEFAULT_MAX_REMOTE_CALLS = 10;\n/** Returns whether automatic function calling is disabled. */ function shouldDisableAfc(config) {\n    var _a, _b, _c;\n    if ((_a = config === null || config === void 0 ? void 0 : config.automaticFunctionCalling) === null || _a === void 0 ? void 0 : _a.disable) {\n        return true;\n    }\n    let callableToolsPresent = false;\n    for (const tool of (_b = config === null || config === void 0 ? void 0 : config.tools) !== null && _b !== void 0 ? _b : []){\n        if (isCallableTool(tool)) {\n            callableToolsPresent = true;\n            break;\n        }\n    }\n    if (!callableToolsPresent) {\n        return true;\n    }\n    const maxCalls = (_c = config === null || config === void 0 ? void 0 : config.automaticFunctionCalling) === null || _c === void 0 ? void 0 : _c.maximumRemoteCalls;\n    if (maxCalls && (maxCalls < 0 || !Number.isInteger(maxCalls)) || maxCalls == 0) {\n        console.warn(\"Invalid maximumRemoteCalls value provided for automatic function calling. Disabled automatic function calling. Please provide a valid integer value greater than 0. maximumRemoteCalls provided:\", maxCalls);\n        return true;\n    }\n    return false;\n}\nfunction isCallableTool(tool) {\n    return \"callTool\" in tool && typeof tool.callTool === \"function\";\n}\n/**\n * Returns whether to append automatic function calling history to the\n * response.\n */ function shouldAppendAfcHistory(config) {\n    var _a;\n    return !((_a = config === null || config === void 0 ? void 0 : config.automaticFunctionCalling) === null || _a === void 0 ? void 0 : _a.ignoreCallHistory);\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ class Models extends BaseModule {\n    constructor(apiClient){\n        super();\n        this.apiClient = apiClient;\n        /**\n         * Makes an API request to generate content with a given model.\n         *\n         * For the `model` parameter, supported formats for Vertex AI API include:\n         * - The Gemini model ID, for example: 'gemini-2.0-flash'\n         * - The full resource name starts with 'projects/', for example:\n         *  'projects/my-project-id/locations/us-central1/publishers/google/models/gemini-2.0-flash'\n         * - The partial resource name with 'publishers/', for example:\n         *  'publishers/google/models/gemini-2.0-flash' or\n         *  'publishers/meta/models/llama-3.1-405b-instruct-maas'\n         * - `/` separated publisher and model name, for example:\n         * 'google/gemini-2.0-flash' or 'meta/llama-3.1-405b-instruct-maas'\n         *\n         * For the `model` parameter, supported formats for Gemini API include:\n         * - The Gemini model ID, for example: 'gemini-2.0-flash'\n         * - The model name starts with 'models/', for example:\n         *  'models/gemini-2.0-flash'\n         * - For tuned models, the model name starts with 'tunedModels/',\n         * for example:\n         * 'tunedModels/1234567890123456789'\n         *\n         * Some models support multimodal input and output.\n         *\n         * @param params - The parameters for generating content.\n         * @return The response from generating content.\n         *\n         * @example\n         * ```ts\n         * const response = await ai.models.generateContent({\n         *   model: 'gemini-2.0-flash',\n         *   contents: 'why is the sky blue?',\n         *   config: {\n         *     candidateCount: 2,\n         *   }\n         * });\n         * console.log(response);\n         * ```\n         */ this.generateContent = async (params)=>{\n            var _a, _b, _c, _d, _e;\n            const transformedParams = await this.processParamsForMcpUsage(params);\n            if (!hasMcpClientTools(params) || shouldDisableAfc(params.config)) {\n                return await this.generateContentInternal(transformedParams);\n            }\n            if (hasNonMcpTools(params)) {\n                throw new Error(\"Automatic function calling with CallableTools and Tools is not yet supported.\");\n            }\n            let response;\n            let functionResponseContent;\n            const automaticFunctionCallingHistory = tContents(transformedParams.contents);\n            const maxRemoteCalls = (_c = (_b = (_a = transformedParams.config) === null || _a === void 0 ? void 0 : _a.automaticFunctionCalling) === null || _b === void 0 ? void 0 : _b.maximumRemoteCalls) !== null && _c !== void 0 ? _c : DEFAULT_MAX_REMOTE_CALLS;\n            let remoteCalls = 0;\n            while(remoteCalls < maxRemoteCalls){\n                response = await this.generateContentInternal(transformedParams);\n                if (!response.functionCalls || response.functionCalls.length === 0) {\n                    break;\n                }\n                const responseContent = response.candidates[0].content;\n                const functionResponseParts = [];\n                for (const tool of (_e = (_d = params.config) === null || _d === void 0 ? void 0 : _d.tools) !== null && _e !== void 0 ? _e : []){\n                    if (isCallableTool(tool)) {\n                        const callableTool = tool;\n                        const parts = await callableTool.callTool(response.functionCalls);\n                        functionResponseParts.push(...parts);\n                    }\n                }\n                remoteCalls++;\n                functionResponseContent = {\n                    role: \"user\",\n                    parts: functionResponseParts\n                };\n                transformedParams.contents = tContents(transformedParams.contents);\n                transformedParams.contents.push(responseContent);\n                transformedParams.contents.push(functionResponseContent);\n                if (shouldAppendAfcHistory(transformedParams.config)) {\n                    automaticFunctionCallingHistory.push(responseContent);\n                    automaticFunctionCallingHistory.push(functionResponseContent);\n                }\n            }\n            if (shouldAppendAfcHistory(transformedParams.config)) {\n                response.automaticFunctionCallingHistory = automaticFunctionCallingHistory;\n            }\n            return response;\n        };\n        /**\n         * Makes an API request to generate content with a given model and yields the\n         * response in chunks.\n         *\n         * For the `model` parameter, supported formats for Vertex AI API include:\n         * - The Gemini model ID, for example: 'gemini-2.0-flash'\n         * - The full resource name starts with 'projects/', for example:\n         *  'projects/my-project-id/locations/us-central1/publishers/google/models/gemini-2.0-flash'\n         * - The partial resource name with 'publishers/', for example:\n         *  'publishers/google/models/gemini-2.0-flash' or\n         *  'publishers/meta/models/llama-3.1-405b-instruct-maas'\n         * - `/` separated publisher and model name, for example:\n         * 'google/gemini-2.0-flash' or 'meta/llama-3.1-405b-instruct-maas'\n         *\n         * For the `model` parameter, supported formats for Gemini API include:\n         * - The Gemini model ID, for example: 'gemini-2.0-flash'\n         * - The model name starts with 'models/', for example:\n         *  'models/gemini-2.0-flash'\n         * - For tuned models, the model name starts with 'tunedModels/',\n         * for example:\n         *  'tunedModels/1234567890123456789'\n         *\n         * Some models support multimodal input and output.\n         *\n         * @param params - The parameters for generating content with streaming response.\n         * @return The response from generating content.\n         *\n         * @example\n         * ```ts\n         * const response = await ai.models.generateContentStream({\n         *   model: 'gemini-2.0-flash',\n         *   contents: 'why is the sky blue?',\n         *   config: {\n         *     maxOutputTokens: 200,\n         *   }\n         * });\n         * for await (const chunk of response) {\n         *   console.log(chunk);\n         * }\n         * ```\n         */ this.generateContentStream = async (params)=>{\n            if (shouldDisableAfc(params.config)) {\n                const transformedParams = await this.processParamsForMcpUsage(params);\n                return await this.generateContentStreamInternal(transformedParams);\n            } else {\n                return await this.processAfcStream(params);\n            }\n        };\n        /**\n         * Generates an image based on a text description and configuration.\n         *\n         * @param params - The parameters for generating images.\n         * @return The response from the API.\n         *\n         * @example\n         * ```ts\n         * const response = await client.models.generateImages({\n         *  model: 'imagen-3.0-generate-002',\n         *  prompt: 'Robot holding a red skateboard',\n         *  config: {\n         *    numberOfImages: 1,\n         *    includeRaiReason: true,\n         *  },\n         * });\n         * console.log(response?.generatedImages?.[0]?.image?.imageBytes);\n         * ```\n         */ this.generateImages = async (params)=>{\n            return await this.generateImagesInternal(params).then((apiResponse)=>{\n                var _a;\n                let positivePromptSafetyAttributes;\n                const generatedImages = [];\n                if (apiResponse === null || apiResponse === void 0 ? void 0 : apiResponse.generatedImages) {\n                    for (const generatedImage of apiResponse.generatedImages){\n                        if (generatedImage && (generatedImage === null || generatedImage === void 0 ? void 0 : generatedImage.safetyAttributes) && ((_a = generatedImage === null || generatedImage === void 0 ? void 0 : generatedImage.safetyAttributes) === null || _a === void 0 ? void 0 : _a.contentType) === \"Positive Prompt\") {\n                            positivePromptSafetyAttributes = generatedImage === null || generatedImage === void 0 ? void 0 : generatedImage.safetyAttributes;\n                        } else {\n                            generatedImages.push(generatedImage);\n                        }\n                    }\n                }\n                let response;\n                if (positivePromptSafetyAttributes) {\n                    response = {\n                        generatedImages: generatedImages,\n                        positivePromptSafetyAttributes: positivePromptSafetyAttributes\n                    };\n                } else {\n                    response = {\n                        generatedImages: generatedImages\n                    };\n                }\n                return response;\n            });\n        };\n        this.list = async (params)=>{\n            var _a;\n            const defaultConfig = {\n                queryBase: true\n            };\n            const actualConfig = Object.assign(Object.assign({}, defaultConfig), params === null || params === void 0 ? void 0 : params.config);\n            const actualParams = {\n                config: actualConfig\n            };\n            if (this.apiClient.isVertexAI()) {\n                if (!actualParams.config.queryBase) {\n                    if ((_a = actualParams.config) === null || _a === void 0 ? void 0 : _a.filter) {\n                        throw new Error(\"Filtering tuned models list for Vertex AI is not currently supported\");\n                    } else {\n                        actualParams.config.filter = \"labels.tune-type:*\";\n                    }\n                }\n            }\n            return new Pager(PagedItem.PAGED_ITEM_MODELS, (x)=>this.listInternal(x), await this.listInternal(actualParams), actualParams);\n        };\n        /**\n         * Edits an image based on a prompt, list of reference images, and configuration.\n         *\n         * @param params - The parameters for editing an image.\n         * @return The response from the API.\n         *\n         * @example\n         * ```ts\n         * const response = await client.models.editImage({\n         *  model: 'imagen-3.0-capability-001',\n         *  prompt: 'Generate an image containing a mug with the product logo [1] visible on the side of the mug.',\n         *  referenceImages: [subjectReferenceImage]\n         *  config: {\n         *    numberOfImages: 1,\n         *    includeRaiReason: true,\n         *  },\n         * });\n         * console.log(response?.generatedImages?.[0]?.image?.imageBytes);\n         * ```\n         */ this.editImage = async (params)=>{\n            const paramsInternal = {\n                model: params.model,\n                prompt: params.prompt,\n                referenceImages: [],\n                config: params.config\n            };\n            if (params.referenceImages) {\n                if (params.referenceImages) {\n                    paramsInternal.referenceImages = params.referenceImages.map((img)=>img.toReferenceImageAPI());\n                }\n            }\n            return await this.editImageInternal(paramsInternal);\n        };\n        /**\n         * Upscales an image based on an image, upscale factor, and configuration.\n         * Only supported in Vertex AI currently.\n         *\n         * @param params - The parameters for upscaling an image.\n         * @return The response from the API.\n         *\n         * @example\n         * ```ts\n         * const response = await client.models.upscaleImage({\n         *  model: 'imagen-3.0-generate-002',\n         *  image: image,\n         *  upscaleFactor: 'x2',\n         *  config: {\n         *    includeRaiReason: true,\n         *  },\n         * });\n         * console.log(response?.generatedImages?.[0]?.image?.imageBytes);\n         * ```\n         */ this.upscaleImage = async (params)=>{\n            let apiConfig = {\n                numberOfImages: 1,\n                mode: \"upscale\"\n            };\n            if (params.config) {\n                apiConfig = Object.assign(Object.assign({}, apiConfig), params.config);\n            }\n            const apiParams = {\n                model: params.model,\n                image: params.image,\n                upscaleFactor: params.upscaleFactor,\n                config: apiConfig\n            };\n            return await this.upscaleImageInternal(apiParams);\n        };\n    }\n    /**\n     * Transforms the CallableTools in the parameters to be simply Tools, it\n     * copies the params into a new object and replaces the tools, it does not\n     * modify the original params. Also sets the MCP usage header if there are\n     * MCP tools in the parameters.\n     */ async processParamsForMcpUsage(params) {\n        var _a, _b, _c;\n        const tools = (_a = params.config) === null || _a === void 0 ? void 0 : _a.tools;\n        if (!tools) {\n            return params;\n        }\n        const transformedTools = await Promise.all(tools.map(async (tool)=>{\n            if (isCallableTool(tool)) {\n                const callableTool = tool;\n                return await callableTool.tool();\n            }\n            return tool;\n        }));\n        const newParams = {\n            model: params.model,\n            contents: params.contents,\n            config: Object.assign(Object.assign({}, params.config), {\n                tools: transformedTools\n            })\n        };\n        newParams.config.tools = transformedTools;\n        if (params.config && params.config.tools && hasMcpToolUsage(params.config.tools)) {\n            const headers = (_c = (_b = params.config.httpOptions) === null || _b === void 0 ? void 0 : _b.headers) !== null && _c !== void 0 ? _c : {};\n            let newHeaders = Object.assign({}, headers);\n            if (Object.keys(newHeaders).length === 0) {\n                newHeaders = this.apiClient.getDefaultHeaders();\n            }\n            setMcpUsageHeader(newHeaders);\n            newParams.config.httpOptions = Object.assign(Object.assign({}, params.config.httpOptions), {\n                headers: newHeaders\n            });\n        }\n        return newParams;\n    }\n    async initAfcToolsMap(params) {\n        var _a, _b, _c;\n        const afcTools = new Map();\n        for (const tool of (_b = (_a = params.config) === null || _a === void 0 ? void 0 : _a.tools) !== null && _b !== void 0 ? _b : []){\n            if (isCallableTool(tool)) {\n                const callableTool = tool;\n                const toolDeclaration = await callableTool.tool();\n                for (const declaration of (_c = toolDeclaration.functionDeclarations) !== null && _c !== void 0 ? _c : []){\n                    if (!declaration.name) {\n                        throw new Error(\"Function declaration name is required.\");\n                    }\n                    if (afcTools.has(declaration.name)) {\n                        throw new Error(`Duplicate tool declaration name: ${declaration.name}`);\n                    }\n                    afcTools.set(declaration.name, callableTool);\n                }\n            }\n        }\n        return afcTools;\n    }\n    async processAfcStream(params) {\n        var _a, _b, _c;\n        const maxRemoteCalls = (_c = (_b = (_a = params.config) === null || _a === void 0 ? void 0 : _a.automaticFunctionCalling) === null || _b === void 0 ? void 0 : _b.maximumRemoteCalls) !== null && _c !== void 0 ? _c : DEFAULT_MAX_REMOTE_CALLS;\n        let wereFunctionsCalled = false;\n        let remoteCallCount = 0;\n        const afcToolsMap = await this.initAfcToolsMap(params);\n        return function(models, afcTools, params) {\n            var _a, _b;\n            return __asyncGenerator(this, arguments, function*() {\n                var _c, e_1, _d, _e;\n                while(remoteCallCount < maxRemoteCalls){\n                    if (wereFunctionsCalled) {\n                        remoteCallCount++;\n                        wereFunctionsCalled = false;\n                    }\n                    const transformedParams = yield __await(models.processParamsForMcpUsage(params));\n                    const response = yield __await(models.generateContentStreamInternal(transformedParams));\n                    const functionResponses = [];\n                    const responseContents = [];\n                    try {\n                        for(var _f = true, response_1 = (e_1 = void 0, __asyncValues(response)), response_1_1; response_1_1 = yield __await(response_1.next()), _c = response_1_1.done, !_c; _f = true){\n                            _e = response_1_1.value;\n                            _f = false;\n                            const chunk = _e;\n                            yield yield __await(chunk);\n                            if (chunk.candidates && ((_a = chunk.candidates[0]) === null || _a === void 0 ? void 0 : _a.content)) {\n                                responseContents.push(chunk.candidates[0].content);\n                                for (const part of (_b = chunk.candidates[0].content.parts) !== null && _b !== void 0 ? _b : []){\n                                    if (remoteCallCount < maxRemoteCalls && part.functionCall) {\n                                        if (!part.functionCall.name) {\n                                            throw new Error(\"Function call name was not returned by the model.\");\n                                        }\n                                        if (!afcTools.has(part.functionCall.name)) {\n                                            throw new Error(`Automatic function calling was requested, but not all the tools the model used implement the CallableTool interface. Available tools: ${afcTools.keys()}, mising tool: ${part.functionCall.name}`);\n                                        } else {\n                                            const responseParts = yield __await(afcTools.get(part.functionCall.name).callTool([\n                                                part.functionCall\n                                            ]));\n                                            functionResponses.push(...responseParts);\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    } catch (e_1_1) {\n                        e_1 = {\n                            error: e_1_1\n                        };\n                    } finally{\n                        try {\n                            if (!_f && !_c && (_d = response_1.return)) yield __await(_d.call(response_1));\n                        } finally{\n                            if (e_1) throw e_1.error;\n                        }\n                    }\n                    if (functionResponses.length > 0) {\n                        wereFunctionsCalled = true;\n                        const typedResponseChunk = new GenerateContentResponse();\n                        typedResponseChunk.candidates = [\n                            {\n                                content: {\n                                    role: \"user\",\n                                    parts: functionResponses\n                                }\n                            }\n                        ];\n                        yield yield __await(typedResponseChunk);\n                        const newContents = [];\n                        newContents.push(...responseContents);\n                        newContents.push({\n                            role: \"user\",\n                            parts: functionResponses\n                        });\n                        const updatedContents = tContents(params.contents).concat(newContents);\n                        params.contents = updatedContents;\n                    } else {\n                        break;\n                    }\n                }\n            });\n        }(this, afcToolsMap, params);\n    }\n    async generateContentInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = generateContentParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{model}:generateContent\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = generateContentResponseFromVertex(apiResponse);\n                const typedResp = new GenerateContentResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            const body = generateContentParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{model}:generateContent\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = generateContentResponseFromMldev(apiResponse);\n                const typedResp = new GenerateContentResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    async generateContentStreamInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = generateContentParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{model}:streamGenerateContent?alt=sse\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            const apiClient = this.apiClient;\n            response = apiClient.requestStream({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            });\n            return response.then(function(apiResponse) {\n                return __asyncGenerator(this, arguments, function*() {\n                    var _a, e_2, _b, _c;\n                    try {\n                        for(var _d = true, apiResponse_1 = __asyncValues(apiResponse), apiResponse_1_1; apiResponse_1_1 = yield __await(apiResponse_1.next()), _a = apiResponse_1_1.done, !_a; _d = true){\n                            _c = apiResponse_1_1.value;\n                            _d = false;\n                            const chunk = _c;\n                            const resp = generateContentResponseFromVertex((yield __await(chunk.json())));\n                            const typedResp = new GenerateContentResponse();\n                            Object.assign(typedResp, resp);\n                            yield yield __await(typedResp);\n                        }\n                    } catch (e_2_1) {\n                        e_2 = {\n                            error: e_2_1\n                        };\n                    } finally{\n                        try {\n                            if (!_d && !_a && (_b = apiResponse_1.return)) yield __await(_b.call(apiResponse_1));\n                        } finally{\n                            if (e_2) throw e_2.error;\n                        }\n                    }\n                });\n            });\n        } else {\n            const body = generateContentParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{model}:streamGenerateContent?alt=sse\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            const apiClient = this.apiClient;\n            response = apiClient.requestStream({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            });\n            return response.then(function(apiResponse) {\n                return __asyncGenerator(this, arguments, function*() {\n                    var _a, e_3, _b, _c;\n                    try {\n                        for(var _d = true, apiResponse_2 = __asyncValues(apiResponse), apiResponse_2_1; apiResponse_2_1 = yield __await(apiResponse_2.next()), _a = apiResponse_2_1.done, !_a; _d = true){\n                            _c = apiResponse_2_1.value;\n                            _d = false;\n                            const chunk = _c;\n                            const resp = generateContentResponseFromMldev((yield __await(chunk.json())));\n                            const typedResp = new GenerateContentResponse();\n                            Object.assign(typedResp, resp);\n                            yield yield __await(typedResp);\n                        }\n                    } catch (e_3_1) {\n                        e_3 = {\n                            error: e_3_1\n                        };\n                    } finally{\n                        try {\n                            if (!_d && !_a && (_b = apiResponse_2.return)) yield __await(_b.call(apiResponse_2));\n                        } finally{\n                            if (e_3) throw e_3.error;\n                        }\n                    }\n                });\n            });\n        }\n    }\n    /**\n     * Calculates embeddings for the given contents. Only text is supported.\n     *\n     * @param params - The parameters for embedding contents.\n     * @return The response from the API.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.embedContent({\n     *  model: 'text-embedding-004',\n     *  contents: [\n     *    'What is your name?',\n     *    'What is your favorite color?',\n     *  ],\n     *  config: {\n     *    outputDimensionality: 64,\n     *  },\n     * });\n     * console.log(response);\n     * ```\n     */ async embedContent(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = embedContentParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{model}:predict\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = embedContentResponseFromVertex(apiResponse);\n                const typedResp = new EmbedContentResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            const body = embedContentParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{model}:batchEmbedContents\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = embedContentResponseFromMldev(apiResponse);\n                const typedResp = new EmbedContentResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Generates an image based on a text description and configuration.\n     *\n     * @param params - The parameters for generating images.\n     * @return The response from the API.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.generateImages({\n     *  model: 'imagen-3.0-generate-002',\n     *  prompt: 'Robot holding a red skateboard',\n     *  config: {\n     *    numberOfImages: 1,\n     *    includeRaiReason: true,\n     *  },\n     * });\n     * console.log(response?.generatedImages?.[0]?.image?.imageBytes);\n     * ```\n     */ async generateImagesInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = generateImagesParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{model}:predict\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = generateImagesResponseFromVertex(apiResponse);\n                const typedResp = new GenerateImagesResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            const body = generateImagesParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{model}:predict\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = generateImagesResponseFromMldev(apiResponse);\n                const typedResp = new GenerateImagesResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    async editImageInternal(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = editImageParametersInternalToVertex(this.apiClient, params);\n            path = formatMap(\"{model}:predict\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = editImageResponseFromVertex(apiResponse);\n                const typedResp = new EditImageResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            throw new Error(\"This method is only supported by the Vertex AI.\");\n        }\n    }\n    async upscaleImageInternal(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = upscaleImageAPIParametersInternalToVertex(this.apiClient, params);\n            path = formatMap(\"{model}:predict\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = upscaleImageResponseFromVertex(apiResponse);\n                const typedResp = new UpscaleImageResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            throw new Error(\"This method is only supported by the Vertex AI.\");\n        }\n    }\n    /**\n     * Fetches information about a model by name.\n     *\n     * @example\n     * ```ts\n     * const modelInfo = await ai.models.get({model: 'gemini-2.0-flash'});\n     * ```\n     */ async get(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = getModelParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = modelFromVertex(apiResponse);\n                return resp;\n            });\n        } else {\n            const body = getModelParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = modelFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n    async listInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = listModelsParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{models_url}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = listModelsResponseFromVertex(this.apiClient, apiResponse);\n                const typedResp = new ListModelsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            const body = listModelsParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{models_url}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = listModelsResponseFromMldev(this.apiClient, apiResponse);\n                const typedResp = new ListModelsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Updates a tuned model by its name.\n     *\n     * @param params - The parameters for updating the model.\n     * @return The response from the API.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.update({\n     *   model: 'tuned-model-name',\n     *   config: {\n     *     displayName: 'New display name',\n     *     description: 'New description',\n     *   },\n     * });\n     * ```\n     */ async update(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = updateModelParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{model}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"PATCH\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = modelFromVertex(apiResponse);\n                return resp;\n            });\n        } else {\n            const body = updateModelParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"PATCH\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = modelFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n    /**\n     * Deletes a tuned model by its name.\n     *\n     * @param params - The parameters for deleting the model.\n     * @return The response from the API.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.delete({model: 'tuned-model-name'});\n     * ```\n     */ async delete(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = deleteModelParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"DELETE\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then(()=>{\n                const resp = deleteModelResponseFromVertex();\n                const typedResp = new DeleteModelResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            const body = deleteModelParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"DELETE\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then(()=>{\n                const resp = deleteModelResponseFromMldev();\n                const typedResp = new DeleteModelResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Counts the number of tokens in the given contents. Multimodal input is\n     * supported for Gemini models.\n     *\n     * @param params - The parameters for counting tokens.\n     * @return The response from the API.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.countTokens({\n     *  model: 'gemini-2.0-flash',\n     *  contents: 'The quick brown fox jumps over the lazy dog.'\n     * });\n     * console.log(response);\n     * ```\n     */ async countTokens(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = countTokensParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{model}:countTokens\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = countTokensResponseFromVertex(apiResponse);\n                const typedResp = new CountTokensResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            const body = countTokensParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{model}:countTokens\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = countTokensResponseFromMldev(apiResponse);\n                const typedResp = new CountTokensResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Given a list of contents, returns a corresponding TokensInfo containing\n     * the list of tokens and list of token ids.\n     *\n     * This method is not supported by the Gemini Developer API.\n     *\n     * @param params - The parameters for computing tokens.\n     * @return The response from the API.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.computeTokens({\n     *  model: 'gemini-2.0-flash',\n     *  contents: 'What is your name?'\n     * });\n     * console.log(response);\n     * ```\n     */ async computeTokens(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = computeTokensParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{model}:computeTokens\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = computeTokensResponseFromVertex(apiResponse);\n                const typedResp = new ComputeTokensResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            throw new Error(\"This method is only supported by the Vertex AI.\");\n        }\n    }\n    /**\n     *  Generates videos based on a text description and configuration.\n     *\n     * @param params - The parameters for generating videos.\n     * @return A Promise<GenerateVideosOperation> which allows you to track the progress and eventually retrieve the generated videos using the operations.get method.\n     *\n     * @example\n     * ```ts\n     * const operation = await ai.models.generateVideos({\n     *  model: 'veo-2.0-generate-001',\n     *  prompt: 'A neon hologram of a cat driving at top speed',\n     *  config: {\n     *    numberOfVideos: 1\n     * });\n     *\n     * while (!operation.done) {\n     *   await new Promise(resolve => setTimeout(resolve, 10000));\n     *   operation = await ai.operations.getVideosOperation({operation: operation});\n     * }\n     *\n     * console.log(operation.response?.generatedVideos?.[0]?.video?.uri);\n     * ```\n     */ async generateVideos(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = generateVideosParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{model}:predictLongRunning\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = generateVideosOperationFromVertex$1(apiResponse);\n                return resp;\n            });\n        } else {\n            const body = generateVideosParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{model}:predictLongRunning\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = generateVideosOperationFromMldev$1(apiResponse);\n                return resp;\n            });\n        }\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ // Code generated by the Google Gen AI SDK generator DO NOT EDIT.\nfunction getOperationParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromOperationName = getValueByPath(fromObject, [\n        \"operationName\"\n    ]);\n    if (fromOperationName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"operationName\"\n        ], fromOperationName);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], fromConfig);\n    }\n    return toObject;\n}\nfunction getOperationParametersToVertex(fromObject) {\n    const toObject = {};\n    const fromOperationName = getValueByPath(fromObject, [\n        \"operationName\"\n    ]);\n    if (fromOperationName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"operationName\"\n        ], fromOperationName);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], fromConfig);\n    }\n    return toObject;\n}\nfunction fetchPredictOperationParametersToVertex(fromObject) {\n    const toObject = {};\n    const fromOperationName = getValueByPath(fromObject, [\n        \"operationName\"\n    ]);\n    if (fromOperationName != null) {\n        setValueByPath(toObject, [\n            \"operationName\"\n        ], fromOperationName);\n    }\n    const fromResourceName = getValueByPath(fromObject, [\n        \"resourceName\"\n    ]);\n    if (fromResourceName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"resourceName\"\n        ], fromResourceName);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], fromConfig);\n    }\n    return toObject;\n}\nfunction videoFromMldev(fromObject) {\n    const toObject = {};\n    const fromUri = getValueByPath(fromObject, [\n        \"video\",\n        \"uri\"\n    ]);\n    if (fromUri != null) {\n        setValueByPath(toObject, [\n            \"uri\"\n        ], fromUri);\n    }\n    const fromVideoBytes = getValueByPath(fromObject, [\n        \"video\",\n        \"encodedVideo\"\n    ]);\n    if (fromVideoBytes != null) {\n        setValueByPath(toObject, [\n            \"videoBytes\"\n        ], tBytes(fromVideoBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"encoding\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction generatedVideoFromMldev(fromObject) {\n    const toObject = {};\n    const fromVideo = getValueByPath(fromObject, [\n        \"_self\"\n    ]);\n    if (fromVideo != null) {\n        setValueByPath(toObject, [\n            \"video\"\n        ], videoFromMldev(fromVideo));\n    }\n    return toObject;\n}\nfunction generateVideosResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromGeneratedVideos = getValueByPath(fromObject, [\n        \"generatedSamples\"\n    ]);\n    if (fromGeneratedVideos != null) {\n        let transformedList = fromGeneratedVideos;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return generatedVideoFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"generatedVideos\"\n        ], transformedList);\n    }\n    const fromRaiMediaFilteredCount = getValueByPath(fromObject, [\n        \"raiMediaFilteredCount\"\n    ]);\n    if (fromRaiMediaFilteredCount != null) {\n        setValueByPath(toObject, [\n            \"raiMediaFilteredCount\"\n        ], fromRaiMediaFilteredCount);\n    }\n    const fromRaiMediaFilteredReasons = getValueByPath(fromObject, [\n        \"raiMediaFilteredReasons\"\n    ]);\n    if (fromRaiMediaFilteredReasons != null) {\n        setValueByPath(toObject, [\n            \"raiMediaFilteredReasons\"\n        ], fromRaiMediaFilteredReasons);\n    }\n    return toObject;\n}\nfunction generateVideosOperationFromMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromMetadata = getValueByPath(fromObject, [\n        \"metadata\"\n    ]);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, [\n            \"metadata\"\n        ], fromMetadata);\n    }\n    const fromDone = getValueByPath(fromObject, [\n        \"done\"\n    ]);\n    if (fromDone != null) {\n        setValueByPath(toObject, [\n            \"done\"\n        ], fromDone);\n    }\n    const fromError = getValueByPath(fromObject, [\n        \"error\"\n    ]);\n    if (fromError != null) {\n        setValueByPath(toObject, [\n            \"error\"\n        ], fromError);\n    }\n    const fromResponse = getValueByPath(fromObject, [\n        \"response\",\n        \"generateVideoResponse\"\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, [\n            \"response\"\n        ], generateVideosResponseFromMldev(fromResponse));\n    }\n    return toObject;\n}\nfunction videoFromVertex(fromObject) {\n    const toObject = {};\n    const fromUri = getValueByPath(fromObject, [\n        \"gcsUri\"\n    ]);\n    if (fromUri != null) {\n        setValueByPath(toObject, [\n            \"uri\"\n        ], fromUri);\n    }\n    const fromVideoBytes = getValueByPath(fromObject, [\n        \"bytesBase64Encoded\"\n    ]);\n    if (fromVideoBytes != null) {\n        setValueByPath(toObject, [\n            \"videoBytes\"\n        ], tBytes(fromVideoBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction generatedVideoFromVertex(fromObject) {\n    const toObject = {};\n    const fromVideo = getValueByPath(fromObject, [\n        \"_self\"\n    ]);\n    if (fromVideo != null) {\n        setValueByPath(toObject, [\n            \"video\"\n        ], videoFromVertex(fromVideo));\n    }\n    return toObject;\n}\nfunction generateVideosResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromGeneratedVideos = getValueByPath(fromObject, [\n        \"videos\"\n    ]);\n    if (fromGeneratedVideos != null) {\n        let transformedList = fromGeneratedVideos;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return generatedVideoFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"generatedVideos\"\n        ], transformedList);\n    }\n    const fromRaiMediaFilteredCount = getValueByPath(fromObject, [\n        \"raiMediaFilteredCount\"\n    ]);\n    if (fromRaiMediaFilteredCount != null) {\n        setValueByPath(toObject, [\n            \"raiMediaFilteredCount\"\n        ], fromRaiMediaFilteredCount);\n    }\n    const fromRaiMediaFilteredReasons = getValueByPath(fromObject, [\n        \"raiMediaFilteredReasons\"\n    ]);\n    if (fromRaiMediaFilteredReasons != null) {\n        setValueByPath(toObject, [\n            \"raiMediaFilteredReasons\"\n        ], fromRaiMediaFilteredReasons);\n    }\n    return toObject;\n}\nfunction generateVideosOperationFromVertex(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromMetadata = getValueByPath(fromObject, [\n        \"metadata\"\n    ]);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, [\n            \"metadata\"\n        ], fromMetadata);\n    }\n    const fromDone = getValueByPath(fromObject, [\n        \"done\"\n    ]);\n    if (fromDone != null) {\n        setValueByPath(toObject, [\n            \"done\"\n        ], fromDone);\n    }\n    const fromError = getValueByPath(fromObject, [\n        \"error\"\n    ]);\n    if (fromError != null) {\n        setValueByPath(toObject, [\n            \"error\"\n        ], fromError);\n    }\n    const fromResponse = getValueByPath(fromObject, [\n        \"response\"\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, [\n            \"response\"\n        ], generateVideosResponseFromVertex(fromResponse));\n    }\n    return toObject;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ class Operations extends BaseModule {\n    constructor(apiClient){\n        super();\n        this.apiClient = apiClient;\n    }\n    /**\n     * Gets the status of a long-running operation.\n     *\n     * @param parameters The parameters for the get operation request.\n     * @return The updated Operation object, with the latest status or result.\n     */ async getVideosOperation(parameters) {\n        const operation = parameters.operation;\n        const config = parameters.config;\n        if (operation.name === undefined || operation.name === \"\") {\n            throw new Error(\"Operation name is required.\");\n        }\n        if (this.apiClient.isVertexAI()) {\n            const resourceName = operation.name.split(\"/operations/\")[0];\n            let httpOptions = undefined;\n            if (config && \"httpOptions\" in config) {\n                httpOptions = config.httpOptions;\n            }\n            return this.fetchPredictVideosOperationInternal({\n                operationName: operation.name,\n                resourceName: resourceName,\n                config: {\n                    httpOptions: httpOptions\n                }\n            });\n        } else {\n            return this.getVideosOperationInternal({\n                operationName: operation.name,\n                config: config\n            });\n        }\n    }\n    async getVideosOperationInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = getOperationParametersToVertex(params);\n            path = formatMap(\"{operationName}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = generateVideosOperationFromVertex(apiResponse);\n                return resp;\n            });\n        } else {\n            const body = getOperationParametersToMldev(params);\n            path = formatMap(\"{operationName}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = generateVideosOperationFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n    async fetchPredictVideosOperationInternal(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = fetchPredictOperationParametersToVertex(params);\n            path = formatMap(\"{resourceName}:fetchPredictOperation\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = generateVideosOperationFromVertex(apiResponse);\n                return resp;\n            });\n        } else {\n            throw new Error(\"This method is only supported by the Vertex AI.\");\n        }\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ function prebuiltVoiceConfigToMldev(fromObject) {\n    const toObject = {};\n    const fromVoiceName = getValueByPath(fromObject, [\n        \"voiceName\"\n    ]);\n    if (fromVoiceName != null) {\n        setValueByPath(toObject, [\n            \"voiceName\"\n        ], fromVoiceName);\n    }\n    return toObject;\n}\nfunction voiceConfigToMldev(fromObject) {\n    const toObject = {};\n    const fromPrebuiltVoiceConfig = getValueByPath(fromObject, [\n        \"prebuiltVoiceConfig\"\n    ]);\n    if (fromPrebuiltVoiceConfig != null) {\n        setValueByPath(toObject, [\n            \"prebuiltVoiceConfig\"\n        ], prebuiltVoiceConfigToMldev(fromPrebuiltVoiceConfig));\n    }\n    return toObject;\n}\nfunction speakerVoiceConfigToMldev(fromObject) {\n    const toObject = {};\n    const fromSpeaker = getValueByPath(fromObject, [\n        \"speaker\"\n    ]);\n    if (fromSpeaker != null) {\n        setValueByPath(toObject, [\n            \"speaker\"\n        ], fromSpeaker);\n    }\n    const fromVoiceConfig = getValueByPath(fromObject, [\n        \"voiceConfig\"\n    ]);\n    if (fromVoiceConfig != null) {\n        setValueByPath(toObject, [\n            \"voiceConfig\"\n        ], voiceConfigToMldev(fromVoiceConfig));\n    }\n    return toObject;\n}\nfunction multiSpeakerVoiceConfigToMldev(fromObject) {\n    const toObject = {};\n    const fromSpeakerVoiceConfigs = getValueByPath(fromObject, [\n        \"speakerVoiceConfigs\"\n    ]);\n    if (fromSpeakerVoiceConfigs != null) {\n        let transformedList = fromSpeakerVoiceConfigs;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return speakerVoiceConfigToMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"speakerVoiceConfigs\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction speechConfigToMldev(fromObject) {\n    const toObject = {};\n    const fromVoiceConfig = getValueByPath(fromObject, [\n        \"voiceConfig\"\n    ]);\n    if (fromVoiceConfig != null) {\n        setValueByPath(toObject, [\n            \"voiceConfig\"\n        ], voiceConfigToMldev(fromVoiceConfig));\n    }\n    const fromMultiSpeakerVoiceConfig = getValueByPath(fromObject, [\n        \"multiSpeakerVoiceConfig\"\n    ]);\n    if (fromMultiSpeakerVoiceConfig != null) {\n        setValueByPath(toObject, [\n            \"multiSpeakerVoiceConfig\"\n        ], multiSpeakerVoiceConfigToMldev(fromMultiSpeakerVoiceConfig));\n    }\n    const fromLanguageCode = getValueByPath(fromObject, [\n        \"languageCode\"\n    ]);\n    if (fromLanguageCode != null) {\n        setValueByPath(toObject, [\n            \"languageCode\"\n        ], fromLanguageCode);\n    }\n    return toObject;\n}\nfunction videoMetadataToMldev(fromObject) {\n    const toObject = {};\n    const fromFps = getValueByPath(fromObject, [\n        \"fps\"\n    ]);\n    if (fromFps != null) {\n        setValueByPath(toObject, [\n            \"fps\"\n        ], fromFps);\n    }\n    const fromEndOffset = getValueByPath(fromObject, [\n        \"endOffset\"\n    ]);\n    if (fromEndOffset != null) {\n        setValueByPath(toObject, [\n            \"endOffset\"\n        ], fromEndOffset);\n    }\n    const fromStartOffset = getValueByPath(fromObject, [\n        \"startOffset\"\n    ]);\n    if (fromStartOffset != null) {\n        setValueByPath(toObject, [\n            \"startOffset\"\n        ], fromStartOffset);\n    }\n    return toObject;\n}\nfunction blobToMldev(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"displayName\"\n    ]) !== undefined) {\n        throw new Error(\"displayName parameter is not supported in Gemini API.\");\n    }\n    const fromData = getValueByPath(fromObject, [\n        \"data\"\n    ]);\n    if (fromData != null) {\n        setValueByPath(toObject, [\n            \"data\"\n        ], fromData);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction fileDataToMldev(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"displayName\"\n    ]) !== undefined) {\n        throw new Error(\"displayName parameter is not supported in Gemini API.\");\n    }\n    const fromFileUri = getValueByPath(fromObject, [\n        \"fileUri\"\n    ]);\n    if (fromFileUri != null) {\n        setValueByPath(toObject, [\n            \"fileUri\"\n        ], fromFileUri);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction partToMldev(fromObject) {\n    const toObject = {};\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        \"videoMetadata\"\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, [\n            \"videoMetadata\"\n        ], videoMetadataToMldev(fromVideoMetadata));\n    }\n    const fromThought = getValueByPath(fromObject, [\n        \"thought\"\n    ]);\n    if (fromThought != null) {\n        setValueByPath(toObject, [\n            \"thought\"\n        ], fromThought);\n    }\n    const fromInlineData = getValueByPath(fromObject, [\n        \"inlineData\"\n    ]);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, [\n            \"inlineData\"\n        ], blobToMldev(fromInlineData));\n    }\n    const fromFileData = getValueByPath(fromObject, [\n        \"fileData\"\n    ]);\n    if (fromFileData != null) {\n        setValueByPath(toObject, [\n            \"fileData\"\n        ], fileDataToMldev(fromFileData));\n    }\n    const fromThoughtSignature = getValueByPath(fromObject, [\n        \"thoughtSignature\"\n    ]);\n    if (fromThoughtSignature != null) {\n        setValueByPath(toObject, [\n            \"thoughtSignature\"\n        ], fromThoughtSignature);\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        \"codeExecutionResult\"\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, [\n            \"codeExecutionResult\"\n        ], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        \"executableCode\"\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, [\n            \"executableCode\"\n        ], fromExecutableCode);\n    }\n    const fromFunctionCall = getValueByPath(fromObject, [\n        \"functionCall\"\n    ]);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, [\n            \"functionCall\"\n        ], fromFunctionCall);\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        \"functionResponse\"\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, [\n            \"functionResponse\"\n        ], fromFunctionResponse);\n    }\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    return toObject;\n}\nfunction contentToMldev(fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, [\n        \"parts\"\n    ]);\n    if (fromParts != null) {\n        let transformedList = fromParts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return partToMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"parts\"\n        ], transformedList);\n    }\n    const fromRole = getValueByPath(fromObject, [\n        \"role\"\n    ]);\n    if (fromRole != null) {\n        setValueByPath(toObject, [\n            \"role\"\n        ], fromRole);\n    }\n    return toObject;\n}\nfunction functionDeclarationToMldev(fromObject) {\n    const toObject = {};\n    const fromBehavior = getValueByPath(fromObject, [\n        \"behavior\"\n    ]);\n    if (fromBehavior != null) {\n        setValueByPath(toObject, [\n            \"behavior\"\n        ], fromBehavior);\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (fromDescription != null) {\n        setValueByPath(toObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromParameters = getValueByPath(fromObject, [\n        \"parameters\"\n    ]);\n    if (fromParameters != null) {\n        setValueByPath(toObject, [\n            \"parameters\"\n        ], fromParameters);\n    }\n    const fromParametersJsonSchema = getValueByPath(fromObject, [\n        \"parametersJsonSchema\"\n    ]);\n    if (fromParametersJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"parametersJsonSchema\"\n        ], fromParametersJsonSchema);\n    }\n    const fromResponse = getValueByPath(fromObject, [\n        \"response\"\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, [\n            \"response\"\n        ], fromResponse);\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        \"responseJsonSchema\"\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"responseJsonSchema\"\n        ], fromResponseJsonSchema);\n    }\n    return toObject;\n}\nfunction intervalToMldev(fromObject) {\n    const toObject = {};\n    const fromStartTime = getValueByPath(fromObject, [\n        \"startTime\"\n    ]);\n    if (fromStartTime != null) {\n        setValueByPath(toObject, [\n            \"startTime\"\n        ], fromStartTime);\n    }\n    const fromEndTime = getValueByPath(fromObject, [\n        \"endTime\"\n    ]);\n    if (fromEndTime != null) {\n        setValueByPath(toObject, [\n            \"endTime\"\n        ], fromEndTime);\n    }\n    return toObject;\n}\nfunction googleSearchToMldev(fromObject) {\n    const toObject = {};\n    const fromTimeRangeFilter = getValueByPath(fromObject, [\n        \"timeRangeFilter\"\n    ]);\n    if (fromTimeRangeFilter != null) {\n        setValueByPath(toObject, [\n            \"timeRangeFilter\"\n        ], intervalToMldev(fromTimeRangeFilter));\n    }\n    return toObject;\n}\nfunction dynamicRetrievalConfigToMldev(fromObject) {\n    const toObject = {};\n    const fromMode = getValueByPath(fromObject, [\n        \"mode\"\n    ]);\n    if (fromMode != null) {\n        setValueByPath(toObject, [\n            \"mode\"\n        ], fromMode);\n    }\n    const fromDynamicThreshold = getValueByPath(fromObject, [\n        \"dynamicThreshold\"\n    ]);\n    if (fromDynamicThreshold != null) {\n        setValueByPath(toObject, [\n            \"dynamicThreshold\"\n        ], fromDynamicThreshold);\n    }\n    return toObject;\n}\nfunction googleSearchRetrievalToMldev(fromObject) {\n    const toObject = {};\n    const fromDynamicRetrievalConfig = getValueByPath(fromObject, [\n        \"dynamicRetrievalConfig\"\n    ]);\n    if (fromDynamicRetrievalConfig != null) {\n        setValueByPath(toObject, [\n            \"dynamicRetrievalConfig\"\n        ], dynamicRetrievalConfigToMldev(fromDynamicRetrievalConfig));\n    }\n    return toObject;\n}\nfunction urlContextToMldev() {\n    const toObject = {};\n    return toObject;\n}\nfunction toolToMldev(fromObject) {\n    const toObject = {};\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        \"functionDeclarations\"\n    ]);\n    if (fromFunctionDeclarations != null) {\n        let transformedList = fromFunctionDeclarations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return functionDeclarationToMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"functionDeclarations\"\n        ], transformedList);\n    }\n    if (getValueByPath(fromObject, [\n        \"retrieval\"\n    ]) !== undefined) {\n        throw new Error(\"retrieval parameter is not supported in Gemini API.\");\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, [\n        \"googleSearch\"\n    ]);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, [\n            \"googleSearch\"\n        ], googleSearchToMldev(fromGoogleSearch));\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        \"googleSearchRetrieval\"\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, [\n            \"googleSearchRetrieval\"\n        ], googleSearchRetrievalToMldev(fromGoogleSearchRetrieval));\n    }\n    if (getValueByPath(fromObject, [\n        \"enterpriseWebSearch\"\n    ]) !== undefined) {\n        throw new Error(\"enterpriseWebSearch parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"googleMaps\"\n    ]) !== undefined) {\n        throw new Error(\"googleMaps parameter is not supported in Gemini API.\");\n    }\n    const fromUrlContext = getValueByPath(fromObject, [\n        \"urlContext\"\n    ]);\n    if (fromUrlContext != null) {\n        setValueByPath(toObject, [\n            \"urlContext\"\n        ], urlContextToMldev());\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        \"codeExecution\"\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, [\n            \"codeExecution\"\n        ], fromCodeExecution);\n    }\n    return toObject;\n}\nfunction sessionResumptionConfigToMldev(fromObject) {\n    const toObject = {};\n    const fromHandle = getValueByPath(fromObject, [\n        \"handle\"\n    ]);\n    if (fromHandle != null) {\n        setValueByPath(toObject, [\n            \"handle\"\n        ], fromHandle);\n    }\n    if (getValueByPath(fromObject, [\n        \"transparent\"\n    ]) !== undefined) {\n        throw new Error(\"transparent parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction audioTranscriptionConfigToMldev() {\n    const toObject = {};\n    return toObject;\n}\nfunction automaticActivityDetectionToMldev(fromObject) {\n    const toObject = {};\n    const fromDisabled = getValueByPath(fromObject, [\n        \"disabled\"\n    ]);\n    if (fromDisabled != null) {\n        setValueByPath(toObject, [\n            \"disabled\"\n        ], fromDisabled);\n    }\n    const fromStartOfSpeechSensitivity = getValueByPath(fromObject, [\n        \"startOfSpeechSensitivity\"\n    ]);\n    if (fromStartOfSpeechSensitivity != null) {\n        setValueByPath(toObject, [\n            \"startOfSpeechSensitivity\"\n        ], fromStartOfSpeechSensitivity);\n    }\n    const fromEndOfSpeechSensitivity = getValueByPath(fromObject, [\n        \"endOfSpeechSensitivity\"\n    ]);\n    if (fromEndOfSpeechSensitivity != null) {\n        setValueByPath(toObject, [\n            \"endOfSpeechSensitivity\"\n        ], fromEndOfSpeechSensitivity);\n    }\n    const fromPrefixPaddingMs = getValueByPath(fromObject, [\n        \"prefixPaddingMs\"\n    ]);\n    if (fromPrefixPaddingMs != null) {\n        setValueByPath(toObject, [\n            \"prefixPaddingMs\"\n        ], fromPrefixPaddingMs);\n    }\n    const fromSilenceDurationMs = getValueByPath(fromObject, [\n        \"silenceDurationMs\"\n    ]);\n    if (fromSilenceDurationMs != null) {\n        setValueByPath(toObject, [\n            \"silenceDurationMs\"\n        ], fromSilenceDurationMs);\n    }\n    return toObject;\n}\nfunction realtimeInputConfigToMldev(fromObject) {\n    const toObject = {};\n    const fromAutomaticActivityDetection = getValueByPath(fromObject, [\n        \"automaticActivityDetection\"\n    ]);\n    if (fromAutomaticActivityDetection != null) {\n        setValueByPath(toObject, [\n            \"automaticActivityDetection\"\n        ], automaticActivityDetectionToMldev(fromAutomaticActivityDetection));\n    }\n    const fromActivityHandling = getValueByPath(fromObject, [\n        \"activityHandling\"\n    ]);\n    if (fromActivityHandling != null) {\n        setValueByPath(toObject, [\n            \"activityHandling\"\n        ], fromActivityHandling);\n    }\n    const fromTurnCoverage = getValueByPath(fromObject, [\n        \"turnCoverage\"\n    ]);\n    if (fromTurnCoverage != null) {\n        setValueByPath(toObject, [\n            \"turnCoverage\"\n        ], fromTurnCoverage);\n    }\n    return toObject;\n}\nfunction slidingWindowToMldev(fromObject) {\n    const toObject = {};\n    const fromTargetTokens = getValueByPath(fromObject, [\n        \"targetTokens\"\n    ]);\n    if (fromTargetTokens != null) {\n        setValueByPath(toObject, [\n            \"targetTokens\"\n        ], fromTargetTokens);\n    }\n    return toObject;\n}\nfunction contextWindowCompressionConfigToMldev(fromObject) {\n    const toObject = {};\n    const fromTriggerTokens = getValueByPath(fromObject, [\n        \"triggerTokens\"\n    ]);\n    if (fromTriggerTokens != null) {\n        setValueByPath(toObject, [\n            \"triggerTokens\"\n        ], fromTriggerTokens);\n    }\n    const fromSlidingWindow = getValueByPath(fromObject, [\n        \"slidingWindow\"\n    ]);\n    if (fromSlidingWindow != null) {\n        setValueByPath(toObject, [\n            \"slidingWindow\"\n        ], slidingWindowToMldev(fromSlidingWindow));\n    }\n    return toObject;\n}\nfunction proactivityConfigToMldev(fromObject) {\n    const toObject = {};\n    const fromProactiveAudio = getValueByPath(fromObject, [\n        \"proactiveAudio\"\n    ]);\n    if (fromProactiveAudio != null) {\n        setValueByPath(toObject, [\n            \"proactiveAudio\"\n        ], fromProactiveAudio);\n    }\n    return toObject;\n}\nfunction liveConnectConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromGenerationConfig = getValueByPath(fromObject, [\n        \"generationConfig\"\n    ]);\n    if (parentObject !== undefined && fromGenerationConfig != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\"\n        ], fromGenerationConfig);\n    }\n    const fromResponseModalities = getValueByPath(fromObject, [\n        \"responseModalities\"\n    ]);\n    if (parentObject !== undefined && fromResponseModalities != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"responseModalities\"\n        ], fromResponseModalities);\n    }\n    const fromTemperature = getValueByPath(fromObject, [\n        \"temperature\"\n    ]);\n    if (parentObject !== undefined && fromTemperature != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"temperature\"\n        ], fromTemperature);\n    }\n    const fromTopP = getValueByPath(fromObject, [\n        \"topP\"\n    ]);\n    if (parentObject !== undefined && fromTopP != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"topP\"\n        ], fromTopP);\n    }\n    const fromTopK = getValueByPath(fromObject, [\n        \"topK\"\n    ]);\n    if (parentObject !== undefined && fromTopK != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"topK\"\n        ], fromTopK);\n    }\n    const fromMaxOutputTokens = getValueByPath(fromObject, [\n        \"maxOutputTokens\"\n    ]);\n    if (parentObject !== undefined && fromMaxOutputTokens != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"maxOutputTokens\"\n        ], fromMaxOutputTokens);\n    }\n    const fromMediaResolution = getValueByPath(fromObject, [\n        \"mediaResolution\"\n    ]);\n    if (parentObject !== undefined && fromMediaResolution != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"mediaResolution\"\n        ], fromMediaResolution);\n    }\n    const fromSeed = getValueByPath(fromObject, [\n        \"seed\"\n    ]);\n    if (parentObject !== undefined && fromSeed != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"seed\"\n        ], fromSeed);\n    }\n    const fromSpeechConfig = getValueByPath(fromObject, [\n        \"speechConfig\"\n    ]);\n    if (parentObject !== undefined && fromSpeechConfig != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"speechConfig\"\n        ], speechConfigToMldev(tLiveSpeechConfig(fromSpeechConfig)));\n    }\n    const fromEnableAffectiveDialog = getValueByPath(fromObject, [\n        \"enableAffectiveDialog\"\n    ]);\n    if (parentObject !== undefined && fromEnableAffectiveDialog != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"enableAffectiveDialog\"\n        ], fromEnableAffectiveDialog);\n    }\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        \"systemInstruction\"\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"systemInstruction\"\n        ], contentToMldev(tContent(fromSystemInstruction)));\n    }\n    const fromTools = getValueByPath(fromObject, [\n        \"tools\"\n    ]);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = tTools(fromTools);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return toolToMldev(tTool(item));\n            });\n        }\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"tools\"\n        ], transformedList);\n    }\n    const fromSessionResumption = getValueByPath(fromObject, [\n        \"sessionResumption\"\n    ]);\n    if (parentObject !== undefined && fromSessionResumption != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"sessionResumption\"\n        ], sessionResumptionConfigToMldev(fromSessionResumption));\n    }\n    const fromInputAudioTranscription = getValueByPath(fromObject, [\n        \"inputAudioTranscription\"\n    ]);\n    if (parentObject !== undefined && fromInputAudioTranscription != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"inputAudioTranscription\"\n        ], audioTranscriptionConfigToMldev());\n    }\n    const fromOutputAudioTranscription = getValueByPath(fromObject, [\n        \"outputAudioTranscription\"\n    ]);\n    if (parentObject !== undefined && fromOutputAudioTranscription != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"outputAudioTranscription\"\n        ], audioTranscriptionConfigToMldev());\n    }\n    const fromRealtimeInputConfig = getValueByPath(fromObject, [\n        \"realtimeInputConfig\"\n    ]);\n    if (parentObject !== undefined && fromRealtimeInputConfig != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"realtimeInputConfig\"\n        ], realtimeInputConfigToMldev(fromRealtimeInputConfig));\n    }\n    const fromContextWindowCompression = getValueByPath(fromObject, [\n        \"contextWindowCompression\"\n    ]);\n    if (parentObject !== undefined && fromContextWindowCompression != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"contextWindowCompression\"\n        ], contextWindowCompressionConfigToMldev(fromContextWindowCompression));\n    }\n    const fromProactivity = getValueByPath(fromObject, [\n        \"proactivity\"\n    ]);\n    if (parentObject !== undefined && fromProactivity != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"proactivity\"\n        ], proactivityConfigToMldev(fromProactivity));\n    }\n    return toObject;\n}\nfunction liveConnectConstraintsToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"setup\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], liveConnectConfigToMldev(fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction createAuthTokenConfigToMldev(apiClient, fromObject, parentObject) {\n    const toObject = {};\n    const fromExpireTime = getValueByPath(fromObject, [\n        \"expireTime\"\n    ]);\n    if (parentObject !== undefined && fromExpireTime != null) {\n        setValueByPath(parentObject, [\n            \"expireTime\"\n        ], fromExpireTime);\n    }\n    const fromNewSessionExpireTime = getValueByPath(fromObject, [\n        \"newSessionExpireTime\"\n    ]);\n    if (parentObject !== undefined && fromNewSessionExpireTime != null) {\n        setValueByPath(parentObject, [\n            \"newSessionExpireTime\"\n        ], fromNewSessionExpireTime);\n    }\n    const fromUses = getValueByPath(fromObject, [\n        \"uses\"\n    ]);\n    if (parentObject !== undefined && fromUses != null) {\n        setValueByPath(parentObject, [\n            \"uses\"\n        ], fromUses);\n    }\n    const fromLiveConnectConstraints = getValueByPath(fromObject, [\n        \"liveConnectConstraints\"\n    ]);\n    if (parentObject !== undefined && fromLiveConnectConstraints != null) {\n        setValueByPath(parentObject, [\n            \"bidiGenerateContentSetup\"\n        ], liveConnectConstraintsToMldev(apiClient, fromLiveConnectConstraints));\n    }\n    const fromLockAdditionalFields = getValueByPath(fromObject, [\n        \"lockAdditionalFields\"\n    ]);\n    if (parentObject !== undefined && fromLockAdditionalFields != null) {\n        setValueByPath(parentObject, [\n            \"fieldMask\"\n        ], fromLockAdditionalFields);\n    }\n    return toObject;\n}\nfunction createAuthTokenParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], createAuthTokenConfigToMldev(apiClient, fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction authTokenFromMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    return toObject;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ /**\n * Returns a comma-separated list of field masks from a given object.\n *\n * @param setup The object to extract field masks from.\n * @return A comma-separated list of field masks.\n */ function getFieldMasks(setup) {\n    const fields = [];\n    for(const key in setup){\n        if (Object.prototype.hasOwnProperty.call(setup, key)) {\n            const value = setup[key];\n            // 2nd layer, recursively get field masks see TODO(b/418290100)\n            if (typeof value === \"object\" && value != null && Object.keys(value).length > 0) {\n                const field = Object.keys(value).map((kk)=>`${key}.${kk}`);\n                fields.push(...field);\n            } else {\n                fields.push(key); // 1st layer\n            }\n        }\n    }\n    return fields.join(\",\");\n}\n/**\n * Converts bidiGenerateContentSetup.\n * @param requestDict - The request dictionary.\n * @param config - The configuration object.\n * @return - The modified request dictionary.\n */ function convertBidiSetupToTokenSetup(requestDict, config) {\n    // Convert bidiGenerateContentSetup from bidiGenerateContentSetup.setup.\n    let setupForMaskGeneration = null;\n    const bidiGenerateContentSetupValue = requestDict[\"bidiGenerateContentSetup\"];\n    if (typeof bidiGenerateContentSetupValue === \"object\" && bidiGenerateContentSetupValue !== null && \"setup\" in bidiGenerateContentSetupValue) {\n        // Now we know bidiGenerateContentSetupValue is an object and has a 'setup'\n        // property.\n        const innerSetup = bidiGenerateContentSetupValue.setup;\n        if (typeof innerSetup === \"object\" && innerSetup !== null) {\n            // Valid inner setup found.\n            requestDict[\"bidiGenerateContentSetup\"] = innerSetup;\n            setupForMaskGeneration = innerSetup;\n        } else {\n            // `bidiGenerateContentSetupValue.setup` is not a valid object; treat as\n            // if bidiGenerateContentSetup is invalid.\n            delete requestDict[\"bidiGenerateContentSetup\"];\n        }\n    } else if (bidiGenerateContentSetupValue !== undefined) {\n        // `bidiGenerateContentSetup` exists but not in the expected\n        // shape {setup: {...}}; treat as invalid.\n        delete requestDict[\"bidiGenerateContentSetup\"];\n    }\n    const preExistingFieldMask = requestDict[\"fieldMask\"];\n    // Handle mask generation setup.\n    if (setupForMaskGeneration) {\n        const generatedMaskFromBidi = getFieldMasks(setupForMaskGeneration);\n        if (Array.isArray(config === null || config === void 0 ? void 0 : config.lockAdditionalFields) && (config === null || config === void 0 ? void 0 : config.lockAdditionalFields.length) === 0) {\n            // Case 1: lockAdditionalFields is an empty array. Lock only fields from\n            // bidi setup.\n            if (generatedMaskFromBidi) {\n                // Only assign if mask is not empty\n                requestDict[\"fieldMask\"] = generatedMaskFromBidi;\n            } else {\n                delete requestDict[\"fieldMask\"]; // If mask is empty, effectively no\n            // specific fields locked by bidi\n            }\n        } else if ((config === null || config === void 0 ? void 0 : config.lockAdditionalFields) && config.lockAdditionalFields.length > 0 && preExistingFieldMask !== null && Array.isArray(preExistingFieldMask) && preExistingFieldMask.length > 0) {\n            // Case 2: Lock fields from bidi setup + additional fields\n            // (preExistingFieldMask).\n            const generationConfigFields = [\n                \"temperature\",\n                \"topK\",\n                \"topP\",\n                \"maxOutputTokens\",\n                \"responseModalities\",\n                \"seed\",\n                \"speechConfig\"\n            ];\n            let mappedFieldsFromPreExisting = [];\n            if (preExistingFieldMask.length > 0) {\n                mappedFieldsFromPreExisting = preExistingFieldMask.map((field)=>{\n                    if (generationConfigFields.includes(field)) {\n                        return `generationConfig.${field}`;\n                    }\n                    return field; // Keep original field name if not in\n                // generationConfigFields\n                });\n            }\n            const finalMaskParts = [];\n            if (generatedMaskFromBidi) {\n                finalMaskParts.push(generatedMaskFromBidi);\n            }\n            if (mappedFieldsFromPreExisting.length > 0) {\n                finalMaskParts.push(...mappedFieldsFromPreExisting);\n            }\n            if (finalMaskParts.length > 0) {\n                requestDict[\"fieldMask\"] = finalMaskParts.join(\",\");\n            } else {\n                // If no fields from bidi and no valid additional fields from\n                // pre-existing mask.\n                delete requestDict[\"fieldMask\"];\n            }\n        } else {\n            // Case 3: \"Lock all fields\" (meaning, don't send a field_mask, let server\n            // defaults apply or all are mutable). This is hit if:\n            //  - `config.lockAdditionalFields` is undefined.\n            //  - `config.lockAdditionalFields` is non-empty, BUT\n            //  `preExistingFieldMask` is null, not a string, or an empty string.\n            delete requestDict[\"fieldMask\"];\n        }\n    } else {\n        // No valid `bidiGenerateContentSetup` was found or extracted.\n        // \"Lock additional null fields if any\".\n        if (preExistingFieldMask !== null && Array.isArray(preExistingFieldMask) && preExistingFieldMask.length > 0) {\n            // If there's a pre-existing field mask, it's a string, and it's not\n            // empty, then we should lock all fields.\n            requestDict[\"fieldMask\"] = preExistingFieldMask.join(\",\");\n        } else {\n            delete requestDict[\"fieldMask\"];\n        }\n    }\n    return requestDict;\n}\nclass Tokens extends BaseModule {\n    constructor(apiClient){\n        super();\n        this.apiClient = apiClient;\n    }\n    /**\n     * Creates an ephemeral auth token resource.\n     *\n     * @experimental\n     *\n     * @remarks\n     * Ephermeral auth tokens is only supported in the Gemini Developer API.\n     * It can be used for the session connection to the Live constrained API.\n     *\n     * @param params - The parameters for the create request.\n     * @return The created auth token.\n     *\n     * @example\n     * ```ts\n     * // Case 1: If LiveEphemeralParameters is unset, unlock LiveConnectConfig\n     * // when using the token in Live API sessions. Each session connection can\n     * // use a different configuration.\n     * const config: CreateAuthTokenConfig = {\n     *     uses: 3,\n     *     expireTime: '2025-05-01T00:00:00Z',\n     * }\n     * const token = await ai.tokens.create(config);\n     *\n     * // Case 2: If LiveEphemeralParameters is set, lock all fields in\n     * // LiveConnectConfig when using the token in Live API sessions. For\n     * // example, changing `outputAudioTranscription` in the Live API\n     * // connection will be ignored by the API.\n     * const config: CreateAuthTokenConfig =\n     *     uses: 3,\n     *     expireTime: '2025-05-01T00:00:00Z',\n     *     LiveEphemeralParameters: {\n     *        model: 'gemini-2.0-flash-001',\n     *        config: {\n     *           'responseModalities': ['AUDIO'],\n     *           'systemInstruction': 'Always answer in English.',\n     *        }\n     *     }\n     * }\n     * const token = await ai.tokens.create(config);\n     *\n     * // Case 3: If LiveEphemeralParameters is set and lockAdditionalFields is\n     * // set, lock LiveConnectConfig with set and additional fields (e.g.\n     * // responseModalities, systemInstruction, temperature in this example) when\n     * // using the token in Live API sessions.\n     * const config: CreateAuthTokenConfig =\n     *     uses: 3,\n     *     expireTime: '2025-05-01T00:00:00Z',\n     *     LiveEphemeralParameters: {\n     *        model: 'gemini-2.0-flash-001',\n     *        config: {\n     *           'responseModalities': ['AUDIO'],\n     *           'systemInstruction': 'Always answer in English.',\n     *        }\n     *     },\n     *     lockAdditionalFields: ['temperature'],\n     * }\n     * const token = await ai.tokens.create(config);\n     *\n     * // Case 4: If LiveEphemeralParameters is set and lockAdditionalFields is\n     * // empty array, lock LiveConnectConfig with set fields (e.g.\n     * // responseModalities, systemInstruction in this example) when using the\n     * // token in Live API sessions.\n     * const config: CreateAuthTokenConfig =\n     *     uses: 3,\n     *     expireTime: '2025-05-01T00:00:00Z',\n     *     LiveEphemeralParameters: {\n     *        model: 'gemini-2.0-flash-001',\n     *        config: {\n     *           'responseModalities': ['AUDIO'],\n     *           'systemInstruction': 'Always answer in English.',\n     *        }\n     *     },\n     *     lockAdditionalFields: [],\n     * }\n     * const token = await ai.tokens.create(config);\n     * ```\n     */ async create(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"The client.tokens.create method is only supported by the Gemini Developer API.\");\n        } else {\n            const body = createAuthTokenParametersToMldev(this.apiClient, params);\n            path = formatMap(\"auth_tokens\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            const transformedBody = convertBidiSetupToTokenSetup(body, params.config);\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(transformedBody),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = authTokenFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ const GOOGLE_API_KEY_HEADER = \"x-goog-api-key\";\nconst REQUIRED_VERTEX_AI_SCOPE = \"https://www.googleapis.com/auth/cloud-platform\";\nclass NodeAuth {\n    constructor(opts){\n        if (opts.apiKey !== undefined) {\n            this.apiKey = opts.apiKey;\n            return;\n        }\n        const vertexAuthOptions = buildGoogleAuthOptions(opts.googleAuthOptions);\n        this.googleAuth = new google_auth_library__WEBPACK_IMPORTED_MODULE_1__.GoogleAuth(vertexAuthOptions);\n    }\n    async addAuthHeaders(headers) {\n        if (this.apiKey !== undefined) {\n            if (this.apiKey.startsWith(\"auth_tokens/\")) {\n                throw new Error(\"Ephemeral tokens are only supported by the live API.\");\n            }\n            this.addKeyHeader(headers);\n            return;\n        }\n        return this.addGoogleAuthHeaders(headers);\n    }\n    addKeyHeader(headers) {\n        if (headers.get(GOOGLE_API_KEY_HEADER) !== null) {\n            return;\n        }\n        if (this.apiKey === undefined) {\n            // This should never happen, this method is only called\n            // when apiKey is set.\n            throw new Error(\"Trying to set API key header but apiKey is not set\");\n        }\n        headers.append(GOOGLE_API_KEY_HEADER, this.apiKey);\n    }\n    async addGoogleAuthHeaders(headers) {\n        if (this.googleAuth === undefined) {\n            // This should never happen, addGoogleAuthHeaders should only be\n            // called when there is no apiKey set and in these cases googleAuth\n            // is set.\n            throw new Error(\"Trying to set google-auth headers but googleAuth is unset\");\n        }\n        const authHeaders = await this.googleAuth.getRequestHeaders();\n        for(const key in authHeaders){\n            if (headers.get(key) !== null) {\n                continue;\n            }\n            headers.append(key, authHeaders[key]);\n        }\n    }\n}\nfunction buildGoogleAuthOptions(googleAuthOptions) {\n    let authOptions;\n    if (!googleAuthOptions) {\n        authOptions = {\n            scopes: [\n                REQUIRED_VERTEX_AI_SCOPE\n            ]\n        };\n        return authOptions;\n    } else {\n        authOptions = googleAuthOptions;\n        if (!authOptions.scopes) {\n            authOptions.scopes = [\n                REQUIRED_VERTEX_AI_SCOPE\n            ];\n            return authOptions;\n        } else if (typeof authOptions.scopes === \"string\" && authOptions.scopes !== REQUIRED_VERTEX_AI_SCOPE || Array.isArray(authOptions.scopes) && authOptions.scopes.indexOf(REQUIRED_VERTEX_AI_SCOPE) < 0) {\n            throw new Error(`Invalid auth scopes. Scopes must include: ${REQUIRED_VERTEX_AI_SCOPE}`);\n        }\n        return authOptions;\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ class NodeDownloader {\n    async download(params, apiClient) {\n        if (params.downloadPath) {\n            const response = await downloadFile(params, apiClient);\n            if (response instanceof HttpResponse) {\n                const writer = (0,fs__WEBPACK_IMPORTED_MODULE_2__.createWriteStream)(params.downloadPath);\n                node_stream__WEBPACK_IMPORTED_MODULE_3__.Readable.fromWeb(response.responseInternal.body).pipe(writer);\n            } else {\n                (0,fs__WEBPACK_IMPORTED_MODULE_2__.writeFile)(params.downloadPath, response, {\n                    encoding: \"base64\"\n                }, (error)=>{\n                    if (error) {\n                        throw new Error(`Failed to write file to ${params.downloadPath}: ${error}`);\n                    }\n                });\n            }\n        }\n    }\n}\nasync function downloadFile(params, apiClient) {\n    var _a, _b, _c;\n    const name = tFileName(params.file);\n    if (name !== undefined) {\n        return await apiClient.request({\n            path: `files/${name}:download`,\n            httpMethod: \"GET\",\n            queryParams: {\n                \"alt\": \"media\"\n            },\n            httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n            abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n        });\n    } else if (isGeneratedVideo(params.file)) {\n        const videoBytes = (_c = params.file.video) === null || _c === void 0 ? void 0 : _c.videoBytes;\n        if (typeof videoBytes === \"string\") {\n            return videoBytes;\n        } else {\n            throw new Error(\"Failed to download generated video, Uri or videoBytes not found.\");\n        }\n    } else if (isVideo(params.file)) {\n        const videoBytes = params.file.videoBytes;\n        if (typeof videoBytes === \"string\") {\n            return videoBytes;\n        } else {\n            throw new Error(\"Failed to download video, Uri or videoBytes not found.\");\n        }\n    } else {\n        throw new Error(\"Unsupported file type\");\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ class NodeWebSocketFactory {\n    create(url, headers, callbacks) {\n        return new NodeWebSocket(url, headers, callbacks);\n    }\n}\nclass NodeWebSocket {\n    constructor(url, headers, callbacks){\n        this.url = url;\n        this.headers = headers;\n        this.callbacks = callbacks;\n    }\n    connect() {\n        this.ws = new ws__WEBPACK_IMPORTED_MODULE_4__.WebSocket(this.url, {\n            headers: this.headers\n        });\n        this.ws.onopen = this.callbacks.onopen;\n        this.ws.onerror = this.callbacks.onerror;\n        this.ws.onclose = this.callbacks.onclose;\n        this.ws.onmessage = this.callbacks.onmessage;\n    }\n    send(message) {\n        if (this.ws === undefined) {\n            throw new Error(\"WebSocket is not connected\");\n        }\n        this.ws.send(message);\n    }\n    close() {\n        if (this.ws === undefined) {\n            throw new Error(\"WebSocket is not connected\");\n        }\n        this.ws.close();\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ // Code generated by the Google Gen AI SDK generator DO NOT EDIT.\nfunction getTuningJobParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], fromName);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], fromConfig);\n    }\n    return toObject;\n}\nfunction listTuningJobsConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, [\n        \"pageSize\"\n    ]);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageSize\"\n        ], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, [\n        \"pageToken\"\n    ]);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageToken\"\n        ], fromPageToken);\n    }\n    const fromFilter = getValueByPath(fromObject, [\n        \"filter\"\n    ]);\n    if (parentObject !== undefined && fromFilter != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"filter\"\n        ], fromFilter);\n    }\n    return toObject;\n}\nfunction listTuningJobsParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], listTuningJobsConfigToMldev(fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction tuningExampleToMldev(fromObject) {\n    const toObject = {};\n    const fromTextInput = getValueByPath(fromObject, [\n        \"textInput\"\n    ]);\n    if (fromTextInput != null) {\n        setValueByPath(toObject, [\n            \"textInput\"\n        ], fromTextInput);\n    }\n    const fromOutput = getValueByPath(fromObject, [\n        \"output\"\n    ]);\n    if (fromOutput != null) {\n        setValueByPath(toObject, [\n            \"output\"\n        ], fromOutput);\n    }\n    return toObject;\n}\nfunction tuningDatasetToMldev(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"gcsUri\"\n    ]) !== undefined) {\n        throw new Error(\"gcsUri parameter is not supported in Gemini API.\");\n    }\n    const fromExamples = getValueByPath(fromObject, [\n        \"examples\"\n    ]);\n    if (fromExamples != null) {\n        let transformedList = fromExamples;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return tuningExampleToMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"examples\",\n            \"examples\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction createTuningJobConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"validationDataset\"\n    ]) !== undefined) {\n        throw new Error(\"validationDataset parameter is not supported in Gemini API.\");\n    }\n    const fromTunedModelDisplayName = getValueByPath(fromObject, [\n        \"tunedModelDisplayName\"\n    ]);\n    if (parentObject !== undefined && fromTunedModelDisplayName != null) {\n        setValueByPath(parentObject, [\n            \"displayName\"\n        ], fromTunedModelDisplayName);\n    }\n    if (getValueByPath(fromObject, [\n        \"description\"\n    ]) !== undefined) {\n        throw new Error(\"description parameter is not supported in Gemini API.\");\n    }\n    const fromEpochCount = getValueByPath(fromObject, [\n        \"epochCount\"\n    ]);\n    if (parentObject !== undefined && fromEpochCount != null) {\n        setValueByPath(parentObject, [\n            \"tuningTask\",\n            \"hyperparameters\",\n            \"epochCount\"\n        ], fromEpochCount);\n    }\n    const fromLearningRateMultiplier = getValueByPath(fromObject, [\n        \"learningRateMultiplier\"\n    ]);\n    if (fromLearningRateMultiplier != null) {\n        setValueByPath(toObject, [\n            \"tuningTask\",\n            \"hyperparameters\",\n            \"learningRateMultiplier\"\n        ], fromLearningRateMultiplier);\n    }\n    if (getValueByPath(fromObject, [\n        \"exportLastCheckpointOnly\"\n    ]) !== undefined) {\n        throw new Error(\"exportLastCheckpointOnly parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"adapterSize\"\n    ]) !== undefined) {\n        throw new Error(\"adapterSize parameter is not supported in Gemini API.\");\n    }\n    const fromBatchSize = getValueByPath(fromObject, [\n        \"batchSize\"\n    ]);\n    if (parentObject !== undefined && fromBatchSize != null) {\n        setValueByPath(parentObject, [\n            \"tuningTask\",\n            \"hyperparameters\",\n            \"batchSize\"\n        ], fromBatchSize);\n    }\n    const fromLearningRate = getValueByPath(fromObject, [\n        \"learningRate\"\n    ]);\n    if (parentObject !== undefined && fromLearningRate != null) {\n        setValueByPath(parentObject, [\n            \"tuningTask\",\n            \"hyperparameters\",\n            \"learningRate\"\n        ], fromLearningRate);\n    }\n    return toObject;\n}\nfunction createTuningJobParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromBaseModel = getValueByPath(fromObject, [\n        \"baseModel\"\n    ]);\n    if (fromBaseModel != null) {\n        setValueByPath(toObject, [\n            \"baseModel\"\n        ], fromBaseModel);\n    }\n    const fromTrainingDataset = getValueByPath(fromObject, [\n        \"trainingDataset\"\n    ]);\n    if (fromTrainingDataset != null) {\n        setValueByPath(toObject, [\n            \"tuningTask\",\n            \"trainingData\"\n        ], tuningDatasetToMldev(fromTrainingDataset));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], createTuningJobConfigToMldev(fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction getTuningJobParametersToVertex(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], fromName);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], fromConfig);\n    }\n    return toObject;\n}\nfunction listTuningJobsConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, [\n        \"pageSize\"\n    ]);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageSize\"\n        ], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, [\n        \"pageToken\"\n    ]);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageToken\"\n        ], fromPageToken);\n    }\n    const fromFilter = getValueByPath(fromObject, [\n        \"filter\"\n    ]);\n    if (parentObject !== undefined && fromFilter != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"filter\"\n        ], fromFilter);\n    }\n    return toObject;\n}\nfunction listTuningJobsParametersToVertex(fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], listTuningJobsConfigToVertex(fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction tuningDatasetToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromGcsUri = getValueByPath(fromObject, [\n        \"gcsUri\"\n    ]);\n    if (parentObject !== undefined && fromGcsUri != null) {\n        setValueByPath(parentObject, [\n            \"supervisedTuningSpec\",\n            \"trainingDatasetUri\"\n        ], fromGcsUri);\n    }\n    if (getValueByPath(fromObject, [\n        \"examples\"\n    ]) !== undefined) {\n        throw new Error(\"examples parameter is not supported in Vertex AI.\");\n    }\n    return toObject;\n}\nfunction tuningValidationDatasetToVertex(fromObject) {\n    const toObject = {};\n    const fromGcsUri = getValueByPath(fromObject, [\n        \"gcsUri\"\n    ]);\n    if (fromGcsUri != null) {\n        setValueByPath(toObject, [\n            \"validationDatasetUri\"\n        ], fromGcsUri);\n    }\n    return toObject;\n}\nfunction createTuningJobConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromValidationDataset = getValueByPath(fromObject, [\n        \"validationDataset\"\n    ]);\n    if (parentObject !== undefined && fromValidationDataset != null) {\n        setValueByPath(parentObject, [\n            \"supervisedTuningSpec\"\n        ], tuningValidationDatasetToVertex(fromValidationDataset));\n    }\n    const fromTunedModelDisplayName = getValueByPath(fromObject, [\n        \"tunedModelDisplayName\"\n    ]);\n    if (parentObject !== undefined && fromTunedModelDisplayName != null) {\n        setValueByPath(parentObject, [\n            \"tunedModelDisplayName\"\n        ], fromTunedModelDisplayName);\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (parentObject !== undefined && fromDescription != null) {\n        setValueByPath(parentObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromEpochCount = getValueByPath(fromObject, [\n        \"epochCount\"\n    ]);\n    if (parentObject !== undefined && fromEpochCount != null) {\n        setValueByPath(parentObject, [\n            \"supervisedTuningSpec\",\n            \"hyperParameters\",\n            \"epochCount\"\n        ], fromEpochCount);\n    }\n    const fromLearningRateMultiplier = getValueByPath(fromObject, [\n        \"learningRateMultiplier\"\n    ]);\n    if (parentObject !== undefined && fromLearningRateMultiplier != null) {\n        setValueByPath(parentObject, [\n            \"supervisedTuningSpec\",\n            \"hyperParameters\",\n            \"learningRateMultiplier\"\n        ], fromLearningRateMultiplier);\n    }\n    const fromExportLastCheckpointOnly = getValueByPath(fromObject, [\n        \"exportLastCheckpointOnly\"\n    ]);\n    if (parentObject !== undefined && fromExportLastCheckpointOnly != null) {\n        setValueByPath(parentObject, [\n            \"supervisedTuningSpec\",\n            \"exportLastCheckpointOnly\"\n        ], fromExportLastCheckpointOnly);\n    }\n    const fromAdapterSize = getValueByPath(fromObject, [\n        \"adapterSize\"\n    ]);\n    if (parentObject !== undefined && fromAdapterSize != null) {\n        setValueByPath(parentObject, [\n            \"supervisedTuningSpec\",\n            \"hyperParameters\",\n            \"adapterSize\"\n        ], fromAdapterSize);\n    }\n    if (getValueByPath(fromObject, [\n        \"batchSize\"\n    ]) !== undefined) {\n        throw new Error(\"batchSize parameter is not supported in Vertex AI.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"learningRate\"\n    ]) !== undefined) {\n        throw new Error(\"learningRate parameter is not supported in Vertex AI.\");\n    }\n    return toObject;\n}\nfunction createTuningJobParametersToVertex(fromObject) {\n    const toObject = {};\n    const fromBaseModel = getValueByPath(fromObject, [\n        \"baseModel\"\n    ]);\n    if (fromBaseModel != null) {\n        setValueByPath(toObject, [\n            \"baseModel\"\n        ], fromBaseModel);\n    }\n    const fromTrainingDataset = getValueByPath(fromObject, [\n        \"trainingDataset\"\n    ]);\n    if (fromTrainingDataset != null) {\n        setValueByPath(toObject, [\n            \"supervisedTuningSpec\",\n            \"trainingDatasetUri\"\n        ], tuningDatasetToVertex(fromTrainingDataset, toObject));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], createTuningJobConfigToVertex(fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction tunedModelFromMldev(fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"model\"\n        ], fromModel);\n    }\n    const fromEndpoint = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromEndpoint != null) {\n        setValueByPath(toObject, [\n            \"endpoint\"\n        ], fromEndpoint);\n    }\n    return toObject;\n}\nfunction tuningJobFromMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromState = getValueByPath(fromObject, [\n        \"state\"\n    ]);\n    if (fromState != null) {\n        setValueByPath(toObject, [\n            \"state\"\n        ], tTuningJobStatus(fromState));\n    }\n    const fromCreateTime = getValueByPath(fromObject, [\n        \"createTime\"\n    ]);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, [\n            \"createTime\"\n        ], fromCreateTime);\n    }\n    const fromStartTime = getValueByPath(fromObject, [\n        \"tuningTask\",\n        \"startTime\"\n    ]);\n    if (fromStartTime != null) {\n        setValueByPath(toObject, [\n            \"startTime\"\n        ], fromStartTime);\n    }\n    const fromEndTime = getValueByPath(fromObject, [\n        \"tuningTask\",\n        \"completeTime\"\n    ]);\n    if (fromEndTime != null) {\n        setValueByPath(toObject, [\n            \"endTime\"\n        ], fromEndTime);\n    }\n    const fromUpdateTime = getValueByPath(fromObject, [\n        \"updateTime\"\n    ]);\n    if (fromUpdateTime != null) {\n        setValueByPath(toObject, [\n            \"updateTime\"\n        ], fromUpdateTime);\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (fromDescription != null) {\n        setValueByPath(toObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromBaseModel = getValueByPath(fromObject, [\n        \"baseModel\"\n    ]);\n    if (fromBaseModel != null) {\n        setValueByPath(toObject, [\n            \"baseModel\"\n        ], fromBaseModel);\n    }\n    const fromTunedModel = getValueByPath(fromObject, [\n        \"_self\"\n    ]);\n    if (fromTunedModel != null) {\n        setValueByPath(toObject, [\n            \"tunedModel\"\n        ], tunedModelFromMldev(fromTunedModel));\n    }\n    const fromDistillationSpec = getValueByPath(fromObject, [\n        \"distillationSpec\"\n    ]);\n    if (fromDistillationSpec != null) {\n        setValueByPath(toObject, [\n            \"distillationSpec\"\n        ], fromDistillationSpec);\n    }\n    const fromExperiment = getValueByPath(fromObject, [\n        \"experiment\"\n    ]);\n    if (fromExperiment != null) {\n        setValueByPath(toObject, [\n            \"experiment\"\n        ], fromExperiment);\n    }\n    const fromLabels = getValueByPath(fromObject, [\n        \"labels\"\n    ]);\n    if (fromLabels != null) {\n        setValueByPath(toObject, [\n            \"labels\"\n        ], fromLabels);\n    }\n    const fromPipelineJob = getValueByPath(fromObject, [\n        \"pipelineJob\"\n    ]);\n    if (fromPipelineJob != null) {\n        setValueByPath(toObject, [\n            \"pipelineJob\"\n        ], fromPipelineJob);\n    }\n    const fromServiceAccount = getValueByPath(fromObject, [\n        \"serviceAccount\"\n    ]);\n    if (fromServiceAccount != null) {\n        setValueByPath(toObject, [\n            \"serviceAccount\"\n        ], fromServiceAccount);\n    }\n    const fromTunedModelDisplayName = getValueByPath(fromObject, [\n        \"tunedModelDisplayName\"\n    ]);\n    if (fromTunedModelDisplayName != null) {\n        setValueByPath(toObject, [\n            \"tunedModelDisplayName\"\n        ], fromTunedModelDisplayName);\n    }\n    return toObject;\n}\nfunction listTuningJobsResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromNextPageToken = getValueByPath(fromObject, [\n        \"nextPageToken\"\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, [\n            \"nextPageToken\"\n        ], fromNextPageToken);\n    }\n    const fromTuningJobs = getValueByPath(fromObject, [\n        \"tunedModels\"\n    ]);\n    if (fromTuningJobs != null) {\n        let transformedList = fromTuningJobs;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return tuningJobFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"tuningJobs\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction operationFromMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromMetadata = getValueByPath(fromObject, [\n        \"metadata\"\n    ]);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, [\n            \"metadata\"\n        ], fromMetadata);\n    }\n    const fromDone = getValueByPath(fromObject, [\n        \"done\"\n    ]);\n    if (fromDone != null) {\n        setValueByPath(toObject, [\n            \"done\"\n        ], fromDone);\n    }\n    const fromError = getValueByPath(fromObject, [\n        \"error\"\n    ]);\n    if (fromError != null) {\n        setValueByPath(toObject, [\n            \"error\"\n        ], fromError);\n    }\n    return toObject;\n}\nfunction tunedModelCheckpointFromVertex(fromObject) {\n    const toObject = {};\n    const fromCheckpointId = getValueByPath(fromObject, [\n        \"checkpointId\"\n    ]);\n    if (fromCheckpointId != null) {\n        setValueByPath(toObject, [\n            \"checkpointId\"\n        ], fromCheckpointId);\n    }\n    const fromEpoch = getValueByPath(fromObject, [\n        \"epoch\"\n    ]);\n    if (fromEpoch != null) {\n        setValueByPath(toObject, [\n            \"epoch\"\n        ], fromEpoch);\n    }\n    const fromStep = getValueByPath(fromObject, [\n        \"step\"\n    ]);\n    if (fromStep != null) {\n        setValueByPath(toObject, [\n            \"step\"\n        ], fromStep);\n    }\n    const fromEndpoint = getValueByPath(fromObject, [\n        \"endpoint\"\n    ]);\n    if (fromEndpoint != null) {\n        setValueByPath(toObject, [\n            \"endpoint\"\n        ], fromEndpoint);\n    }\n    return toObject;\n}\nfunction tunedModelFromVertex(fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"model\"\n        ], fromModel);\n    }\n    const fromEndpoint = getValueByPath(fromObject, [\n        \"endpoint\"\n    ]);\n    if (fromEndpoint != null) {\n        setValueByPath(toObject, [\n            \"endpoint\"\n        ], fromEndpoint);\n    }\n    const fromCheckpoints = getValueByPath(fromObject, [\n        \"checkpoints\"\n    ]);\n    if (fromCheckpoints != null) {\n        let transformedList = fromCheckpoints;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return tunedModelCheckpointFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"checkpoints\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction tuningJobFromVertex(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromState = getValueByPath(fromObject, [\n        \"state\"\n    ]);\n    if (fromState != null) {\n        setValueByPath(toObject, [\n            \"state\"\n        ], tTuningJobStatus(fromState));\n    }\n    const fromCreateTime = getValueByPath(fromObject, [\n        \"createTime\"\n    ]);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, [\n            \"createTime\"\n        ], fromCreateTime);\n    }\n    const fromStartTime = getValueByPath(fromObject, [\n        \"startTime\"\n    ]);\n    if (fromStartTime != null) {\n        setValueByPath(toObject, [\n            \"startTime\"\n        ], fromStartTime);\n    }\n    const fromEndTime = getValueByPath(fromObject, [\n        \"endTime\"\n    ]);\n    if (fromEndTime != null) {\n        setValueByPath(toObject, [\n            \"endTime\"\n        ], fromEndTime);\n    }\n    const fromUpdateTime = getValueByPath(fromObject, [\n        \"updateTime\"\n    ]);\n    if (fromUpdateTime != null) {\n        setValueByPath(toObject, [\n            \"updateTime\"\n        ], fromUpdateTime);\n    }\n    const fromError = getValueByPath(fromObject, [\n        \"error\"\n    ]);\n    if (fromError != null) {\n        setValueByPath(toObject, [\n            \"error\"\n        ], fromError);\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (fromDescription != null) {\n        setValueByPath(toObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromBaseModel = getValueByPath(fromObject, [\n        \"baseModel\"\n    ]);\n    if (fromBaseModel != null) {\n        setValueByPath(toObject, [\n            \"baseModel\"\n        ], fromBaseModel);\n    }\n    const fromTunedModel = getValueByPath(fromObject, [\n        \"tunedModel\"\n    ]);\n    if (fromTunedModel != null) {\n        setValueByPath(toObject, [\n            \"tunedModel\"\n        ], tunedModelFromVertex(fromTunedModel));\n    }\n    const fromSupervisedTuningSpec = getValueByPath(fromObject, [\n        \"supervisedTuningSpec\"\n    ]);\n    if (fromSupervisedTuningSpec != null) {\n        setValueByPath(toObject, [\n            \"supervisedTuningSpec\"\n        ], fromSupervisedTuningSpec);\n    }\n    const fromTuningDataStats = getValueByPath(fromObject, [\n        \"tuningDataStats\"\n    ]);\n    if (fromTuningDataStats != null) {\n        setValueByPath(toObject, [\n            \"tuningDataStats\"\n        ], fromTuningDataStats);\n    }\n    const fromEncryptionSpec = getValueByPath(fromObject, [\n        \"encryptionSpec\"\n    ]);\n    if (fromEncryptionSpec != null) {\n        setValueByPath(toObject, [\n            \"encryptionSpec\"\n        ], fromEncryptionSpec);\n    }\n    const fromPartnerModelTuningSpec = getValueByPath(fromObject, [\n        \"partnerModelTuningSpec\"\n    ]);\n    if (fromPartnerModelTuningSpec != null) {\n        setValueByPath(toObject, [\n            \"partnerModelTuningSpec\"\n        ], fromPartnerModelTuningSpec);\n    }\n    const fromDistillationSpec = getValueByPath(fromObject, [\n        \"distillationSpec\"\n    ]);\n    if (fromDistillationSpec != null) {\n        setValueByPath(toObject, [\n            \"distillationSpec\"\n        ], fromDistillationSpec);\n    }\n    const fromExperiment = getValueByPath(fromObject, [\n        \"experiment\"\n    ]);\n    if (fromExperiment != null) {\n        setValueByPath(toObject, [\n            \"experiment\"\n        ], fromExperiment);\n    }\n    const fromLabels = getValueByPath(fromObject, [\n        \"labels\"\n    ]);\n    if (fromLabels != null) {\n        setValueByPath(toObject, [\n            \"labels\"\n        ], fromLabels);\n    }\n    const fromPipelineJob = getValueByPath(fromObject, [\n        \"pipelineJob\"\n    ]);\n    if (fromPipelineJob != null) {\n        setValueByPath(toObject, [\n            \"pipelineJob\"\n        ], fromPipelineJob);\n    }\n    const fromServiceAccount = getValueByPath(fromObject, [\n        \"serviceAccount\"\n    ]);\n    if (fromServiceAccount != null) {\n        setValueByPath(toObject, [\n            \"serviceAccount\"\n        ], fromServiceAccount);\n    }\n    const fromTunedModelDisplayName = getValueByPath(fromObject, [\n        \"tunedModelDisplayName\"\n    ]);\n    if (fromTunedModelDisplayName != null) {\n        setValueByPath(toObject, [\n            \"tunedModelDisplayName\"\n        ], fromTunedModelDisplayName);\n    }\n    return toObject;\n}\nfunction listTuningJobsResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromNextPageToken = getValueByPath(fromObject, [\n        \"nextPageToken\"\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, [\n            \"nextPageToken\"\n        ], fromNextPageToken);\n    }\n    const fromTuningJobs = getValueByPath(fromObject, [\n        \"tuningJobs\"\n    ]);\n    if (fromTuningJobs != null) {\n        let transformedList = fromTuningJobs;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return tuningJobFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"tuningJobs\"\n        ], transformedList);\n    }\n    return toObject;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ class Tunings extends BaseModule {\n    constructor(apiClient){\n        super();\n        this.apiClient = apiClient;\n        /**\n         * Gets a TuningJob.\n         *\n         * @param name - The resource name of the tuning job.\n         * @return - A TuningJob object.\n         *\n         * @experimental - The SDK's tuning implementation is experimental, and may\n         * change in future versions.\n         */ this.get = async (params)=>{\n            return await this.getInternal(params);\n        };\n        /**\n         * Lists tuning jobs.\n         *\n         * @param config - The configuration for the list request.\n         * @return - A list of tuning jobs.\n         *\n         * @experimental - The SDK's tuning implementation is experimental, and may\n         * change in future versions.\n         */ this.list = async (params = {})=>{\n            return new Pager(PagedItem.PAGED_ITEM_TUNING_JOBS, (x)=>this.listInternal(x), await this.listInternal(params), params);\n        };\n        /**\n         * Creates a supervised fine-tuning job.\n         *\n         * @param params - The parameters for the tuning job.\n         * @return - A TuningJob operation.\n         *\n         * @experimental - The SDK's tuning implementation is experimental, and may\n         * change in future versions.\n         */ this.tune = async (params)=>{\n            if (this.apiClient.isVertexAI()) {\n                return await this.tuneInternal(params);\n            } else {\n                const operation = await this.tuneMldevInternal(params);\n                let tunedModelName = \"\";\n                if (operation[\"metadata\"] !== undefined && operation[\"metadata\"][\"tunedModel\"] !== undefined) {\n                    tunedModelName = operation[\"metadata\"][\"tunedModel\"];\n                } else if (operation[\"name\"] !== undefined && operation[\"name\"].includes(\"/operations/\")) {\n                    tunedModelName = operation[\"name\"].split(\"/operations/\")[0];\n                }\n                const tuningJob = {\n                    name: tunedModelName,\n                    state: JobState.JOB_STATE_QUEUED\n                };\n                return tuningJob;\n            }\n        };\n    }\n    async getInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = getTuningJobParametersToVertex(params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = tuningJobFromVertex(apiResponse);\n                return resp;\n            });\n        } else {\n            const body = getTuningJobParametersToMldev(params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = tuningJobFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n    async listInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = listTuningJobsParametersToVertex(params);\n            path = formatMap(\"tuningJobs\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = listTuningJobsResponseFromVertex(apiResponse);\n                const typedResp = new ListTuningJobsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            const body = listTuningJobsParametersToMldev(params);\n            path = formatMap(\"tunedModels\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = listTuningJobsResponseFromMldev(apiResponse);\n                const typedResp = new ListTuningJobsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    async tuneInternal(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = createTuningJobParametersToVertex(params);\n            path = formatMap(\"tuningJobs\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = tuningJobFromVertex(apiResponse);\n                return resp;\n            });\n        } else {\n            throw new Error(\"This method is only supported by the Vertex AI.\");\n        }\n    }\n    async tuneMldevInternal(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"This method is only supported by the Gemini Developer API.\");\n        } else {\n            const body = createTuningJobParametersToMldev(params);\n            path = formatMap(\"tunedModels\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = operationFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n}\nconst MAX_CHUNK_SIZE = 1024 * 1024 * 8; // bytes\nconst MAX_RETRY_COUNT = 3;\nconst INITIAL_RETRY_DELAY_MS = 1000;\nconst DELAY_MULTIPLIER = 2;\nconst X_GOOG_UPLOAD_STATUS_HEADER_FIELD = \"x-goog-upload-status\";\nasync function uploadBlob(file, uploadUrl, apiClient) {\n    var _a, _b, _c;\n    let fileSize = 0;\n    let offset = 0;\n    let response = new HttpResponse(new Response());\n    let uploadCommand = \"upload\";\n    fileSize = file.size;\n    while(offset < fileSize){\n        const chunkSize = Math.min(MAX_CHUNK_SIZE, fileSize - offset);\n        const chunk = file.slice(offset, offset + chunkSize);\n        if (offset + chunkSize >= fileSize) {\n            uploadCommand += \", finalize\";\n        }\n        let retryCount = 0;\n        let currentDelayMs = INITIAL_RETRY_DELAY_MS;\n        while(retryCount < MAX_RETRY_COUNT){\n            response = await apiClient.request({\n                path: \"\",\n                body: chunk,\n                httpMethod: \"POST\",\n                httpOptions: {\n                    apiVersion: \"\",\n                    baseUrl: uploadUrl,\n                    headers: {\n                        \"X-Goog-Upload-Command\": uploadCommand,\n                        \"X-Goog-Upload-Offset\": String(offset),\n                        \"Content-Length\": String(chunkSize)\n                    }\n                }\n            });\n            if ((_a = response === null || response === void 0 ? void 0 : response.headers) === null || _a === void 0 ? void 0 : _a[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) {\n                break;\n            }\n            retryCount++;\n            await sleep(currentDelayMs);\n            currentDelayMs = currentDelayMs * DELAY_MULTIPLIER;\n        }\n        offset += chunkSize;\n        // The `x-goog-upload-status` header field can be `active`, `final` and\n        //`cancelled` in resposne.\n        if (((_b = response === null || response === void 0 ? void 0 : response.headers) === null || _b === void 0 ? void 0 : _b[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) !== \"active\") {\n            break;\n        }\n        // TODO(b/401391430) Investigate why the upload status is not finalized\n        // even though all content has been uploaded.\n        if (fileSize <= offset) {\n            throw new Error(\"All content has been uploaded, but the upload status is not finalized.\");\n        }\n    }\n    const responseJson = await (response === null || response === void 0 ? void 0 : response.json());\n    if (((_c = response === null || response === void 0 ? void 0 : response.headers) === null || _c === void 0 ? void 0 : _c[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) !== \"final\") {\n        throw new Error(\"Failed to upload file: Upload status is not finalized.\");\n    }\n    return responseJson[\"file\"];\n}\nasync function getBlobStat(file) {\n    const fileStat = {\n        size: file.size,\n        type: file.type\n    };\n    return fileStat;\n}\nfunction sleep(ms) {\n    return new Promise((resolvePromise)=>setTimeout(resolvePromise, ms));\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ class NodeUploader {\n    async stat(file) {\n        const fileStat = {\n            size: 0,\n            type: undefined\n        };\n        if (typeof file === \"string\") {\n            const originalStat = await fs_promises__WEBPACK_IMPORTED_MODULE_5__.stat(file);\n            fileStat.size = originalStat.size;\n            fileStat.type = this.inferMimeType(file);\n            return fileStat;\n        } else {\n            return await getBlobStat(file);\n        }\n    }\n    async upload(file, uploadUrl, apiClient) {\n        if (typeof file === \"string\") {\n            return await this.uploadFileFromPath(file, uploadUrl, apiClient);\n        } else {\n            return uploadBlob(file, uploadUrl, apiClient);\n        }\n    }\n    /**\n     * Infers the MIME type of a file based on its extension.\n     *\n     * @param filePath The path to the file.\n     * @returns The MIME type of the file, or undefined if it cannot be inferred.\n     */ inferMimeType(filePath) {\n        // Get the file extension.\n        const fileExtension = filePath.slice(filePath.lastIndexOf(\".\") + 1);\n        // Create a map of file extensions to MIME types.\n        const mimeTypes = {\n            \"aac\": \"audio/aac\",\n            \"abw\": \"application/x-abiword\",\n            \"arc\": \"application/x-freearc\",\n            \"avi\": \"video/x-msvideo\",\n            \"azw\": \"application/vnd.amazon.ebook\",\n            \"bin\": \"application/octet-stream\",\n            \"bmp\": \"image/bmp\",\n            \"bz\": \"application/x-bzip\",\n            \"bz2\": \"application/x-bzip2\",\n            \"csh\": \"application/x-csh\",\n            \"css\": \"text/css\",\n            \"csv\": \"text/csv\",\n            \"doc\": \"application/msword\",\n            \"docx\": \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\",\n            \"eot\": \"application/vnd.ms-fontobject\",\n            \"epub\": \"application/epub+zip\",\n            \"gz\": \"application/gzip\",\n            \"gif\": \"image/gif\",\n            \"htm\": \"text/html\",\n            \"html\": \"text/html\",\n            \"ico\": \"image/vnd.microsoft.icon\",\n            \"ics\": \"text/calendar\",\n            \"jar\": \"application/java-archive\",\n            \"jpeg\": \"image/jpeg\",\n            \"jpg\": \"image/jpeg\",\n            \"js\": \"text/javascript\",\n            \"json\": \"application/json\",\n            \"jsonld\": \"application/ld+json\",\n            \"kml\": \"application/vnd.google-earth.kml+xml\",\n            \"kmz\": \"application/vnd.google-earth.kmz+xml\",\n            \"mjs\": \"text/javascript\",\n            \"mp3\": \"audio/mpeg\",\n            \"mp4\": \"video/mp4\",\n            \"mpeg\": \"video/mpeg\",\n            \"mpkg\": \"application/vnd.apple.installer+xml\",\n            \"odt\": \"application/vnd.oasis.opendocument.text\",\n            \"oga\": \"audio/ogg\",\n            \"ogv\": \"video/ogg\",\n            \"ogx\": \"application/ogg\",\n            \"opus\": \"audio/opus\",\n            \"otf\": \"font/otf\",\n            \"png\": \"image/png\",\n            \"pdf\": \"application/pdf\",\n            \"php\": \"application/x-httpd-php\",\n            \"ppt\": \"application/vnd.ms-powerpoint\",\n            \"pptx\": \"application/vnd.openxmlformats-officedocument.presentationml.presentation\",\n            \"rar\": \"application/vnd.rar\",\n            \"rtf\": \"application/rtf\",\n            \"sh\": \"application/x-sh\",\n            \"svg\": \"image/svg+xml\",\n            \"swf\": \"application/x-shockwave-flash\",\n            \"tar\": \"application/x-tar\",\n            \"tif\": \"image/tiff\",\n            \"tiff\": \"image/tiff\",\n            \"ts\": \"video/mp2t\",\n            \"ttf\": \"font/ttf\",\n            \"txt\": \"text/plain\",\n            \"vsd\": \"application/vnd.visio\",\n            \"wav\": \"audio/wav\",\n            \"weba\": \"audio/webm\",\n            \"webm\": \"video/webm\",\n            \"webp\": \"image/webp\",\n            \"woff\": \"font/woff\",\n            \"woff2\": \"font/woff2\",\n            \"xhtml\": \"application/xhtml+xml\",\n            \"xls\": \"application/vnd.ms-excel\",\n            \"xlsx\": \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\",\n            \"xml\": \"application/xml\",\n            \"xul\": \"application/vnd.mozilla.xul+xml\",\n            \"zip\": \"application/zip\",\n            \"3gp\": \"video/3gpp\",\n            \"3g2\": \"video/3gpp2\",\n            \"7z\": \"application/x-7z-compressed\"\n        };\n        // Look up the MIME type based on the file extension.\n        const mimeType = mimeTypes[fileExtension.toLowerCase()];\n        // Return the MIME type.\n        return mimeType;\n    }\n    async uploadFileFromPath(file, uploadUrl, apiClient) {\n        var _a, _b, _c;\n        let fileSize = 0;\n        let offset = 0;\n        let response = new HttpResponse(new Response());\n        let uploadCommand = \"upload\";\n        let fileHandle;\n        try {\n            fileHandle = await fs_promises__WEBPACK_IMPORTED_MODULE_5__.open(file, \"r\");\n            if (!fileHandle) {\n                throw new Error(`Failed to open file`);\n            }\n            fileSize = (await fileHandle.stat()).size;\n            while(offset < fileSize){\n                const chunkSize = Math.min(MAX_CHUNK_SIZE, fileSize - offset);\n                if (offset + chunkSize >= fileSize) {\n                    uploadCommand += \", finalize\";\n                }\n                const buffer = new Uint8Array(chunkSize);\n                const { bytesRead: bytesRead } = await fileHandle.read(buffer, 0, chunkSize, offset);\n                if (bytesRead !== chunkSize) {\n                    throw new Error(`Failed to read ${chunkSize} bytes from file at offset ${offset}. bytes actually read: ${bytesRead}`);\n                }\n                const chunk = new Blob([\n                    buffer\n                ]);\n                let retryCount = 0;\n                let currentDelayMs = INITIAL_RETRY_DELAY_MS;\n                while(retryCount < MAX_RETRY_COUNT){\n                    response = await apiClient.request({\n                        path: \"\",\n                        body: chunk,\n                        httpMethod: \"POST\",\n                        httpOptions: {\n                            apiVersion: \"\",\n                            baseUrl: uploadUrl,\n                            headers: {\n                                \"X-Goog-Upload-Command\": uploadCommand,\n                                \"X-Goog-Upload-Offset\": String(offset),\n                                \"Content-Length\": String(bytesRead)\n                            }\n                        }\n                    });\n                    if ((_a = response === null || response === void 0 ? void 0 : response.headers) === null || _a === void 0 ? void 0 : _a[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) {\n                        break;\n                    }\n                    retryCount++;\n                    await sleep(currentDelayMs);\n                    currentDelayMs = currentDelayMs * DELAY_MULTIPLIER;\n                }\n                offset += bytesRead;\n                // The `x-goog-upload-status` header field can be `active`, `final` and\n                //`cancelled` in resposne.\n                if (((_b = response === null || response === void 0 ? void 0 : response.headers) === null || _b === void 0 ? void 0 : _b[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) !== \"active\") {\n                    break;\n                }\n                if (fileSize <= offset) {\n                    throw new Error(\"All content has been uploaded, but the upload status is not finalized.\");\n                }\n            }\n            const responseJson = await (response === null || response === void 0 ? void 0 : response.json());\n            if (((_c = response === null || response === void 0 ? void 0 : response.headers) === null || _c === void 0 ? void 0 : _c[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) !== \"final\") {\n                throw new Error(\"Failed to upload file: Upload status is not finalized.\");\n            }\n            return responseJson[\"file\"];\n        } finally{\n            // Ensure the file handle is always closed\n            if (fileHandle) {\n                await fileHandle.close();\n            }\n        }\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ const LANGUAGE_LABEL_PREFIX = \"gl-node/\";\n/**\n * The Google GenAI SDK.\n *\n * @remarks\n * Provides access to the GenAI features through either the {@link\n * https://cloud.google.com/vertex-ai/docs/reference/rest | Gemini API} or\n * the {@link https://cloud.google.com/vertex-ai/docs/reference/rest | Vertex AI\n * API}.\n *\n * The {@link GoogleGenAIOptions.vertexai} value determines which of the API\n * services to use.\n *\n * When using the Gemini API, a {@link GoogleGenAIOptions.apiKey} must also be\n * set. When using Vertex AI, both {@link GoogleGenAIOptions.project} and {@link\n * GoogleGenAIOptions.location} must be set, or a {@link\n * GoogleGenAIOptions.apiKey} must be set when using Express Mode.\n *\n * Explicitly passed in values in {@link GoogleGenAIOptions} will always take\n * precedence over environment variables. If both project/location and api_key\n * exist in the environment variables, the project/location will be used.\n *\n * @example\n * Initializing the SDK for using the Gemini API:\n * ```ts\n * import {GoogleGenAI} from '@google/genai';\n * const ai = new GoogleGenAI({apiKey: 'GEMINI_API_KEY'});\n * ```\n *\n * @example\n * Initializing the SDK for using the Vertex AI API:\n * ```ts\n * import {GoogleGenAI} from '@google/genai';\n * const ai = new GoogleGenAI({\n *   vertexai: true,\n *   project: 'PROJECT_ID',\n *   location: 'PROJECT_LOCATION'\n * });\n * ```\n *\n */ class GoogleGenAI {\n    constructor(options){\n        var _a, _b, _c, _d, _e, _f;\n        // Validate explicitly set initializer values.\n        if ((options.project || options.location) && options.apiKey) {\n            throw new Error(\"Project/location and API key are mutually exclusive in the client initializer.\");\n        }\n        this.vertexai = (_b = (_a = options.vertexai) !== null && _a !== void 0 ? _a : getBooleanEnv(\"GOOGLE_GENAI_USE_VERTEXAI\")) !== null && _b !== void 0 ? _b : false;\n        const envApiKey = getApiKeyFromEnv();\n        const envProject = getEnv(\"GOOGLE_CLOUD_PROJECT\");\n        const envLocation = getEnv(\"GOOGLE_CLOUD_LOCATION\");\n        this.apiKey = (_c = options.apiKey) !== null && _c !== void 0 ? _c : envApiKey;\n        this.project = (_d = options.project) !== null && _d !== void 0 ? _d : envProject;\n        this.location = (_e = options.location) !== null && _e !== void 0 ? _e : envLocation;\n        // Handle when to use Vertex AI in express mode (api key)\n        if (options.vertexai) {\n            if ((_f = options.googleAuthOptions) === null || _f === void 0 ? void 0 : _f.credentials) {\n                // Explicit credentials take precedence over implicit api_key.\n                console.debug(\"The user provided Google Cloud credentials will take precedence\" + \" over the API key from the environment variable.\");\n                this.apiKey = undefined;\n            }\n            // Explicit api_key and explicit project/location already handled above.\n            if ((envProject || envLocation) && options.apiKey) {\n                // Explicit api_key takes precedence over implicit project/location.\n                console.debug(\"The user provided Vertex AI API key will take precedence over\" + \" the project/location from the environment variables.\");\n                this.project = undefined;\n                this.location = undefined;\n            } else if ((options.project || options.location) && envApiKey) {\n                // Explicit project/location takes precedence over implicit api_key.\n                console.debug(\"The user provided project/location will take precedence over\" + \" the API key from the environment variables.\");\n                this.apiKey = undefined;\n            } else if ((envProject || envLocation) && envApiKey) {\n                // Implicit project/location takes precedence over implicit api_key.\n                console.debug(\"The project/location from the environment variables will take\" + \" precedence over the API key from the environment variables.\");\n                this.apiKey = undefined;\n            }\n        }\n        const baseUrl = getBaseUrl(options, getEnv(\"GOOGLE_VERTEX_BASE_URL\"), getEnv(\"GOOGLE_GEMINI_BASE_URL\"));\n        if (baseUrl) {\n            if (options.httpOptions) {\n                options.httpOptions.baseUrl = baseUrl;\n            } else {\n                options.httpOptions = {\n                    baseUrl: baseUrl\n                };\n            }\n        }\n        this.apiVersion = options.apiVersion;\n        const auth = new NodeAuth({\n            apiKey: this.apiKey,\n            googleAuthOptions: options.googleAuthOptions\n        });\n        this.apiClient = new ApiClient({\n            auth: auth,\n            project: this.project,\n            location: this.location,\n            apiVersion: this.apiVersion,\n            apiKey: this.apiKey,\n            vertexai: this.vertexai,\n            httpOptions: options.httpOptions,\n            userAgentExtra: LANGUAGE_LABEL_PREFIX + process.version,\n            uploader: new NodeUploader(),\n            downloader: new NodeDownloader()\n        });\n        this.models = new Models(this.apiClient);\n        this.live = new Live(this.apiClient, auth, new NodeWebSocketFactory());\n        this.batches = new Batches(this.apiClient);\n        this.chats = new Chats(this.models, this.apiClient);\n        this.caches = new Caches(this.apiClient);\n        this.files = new Files(this.apiClient);\n        this.operations = new Operations(this.apiClient);\n        this.authTokens = new Tokens(this.apiClient);\n        this.tunings = new Tunings(this.apiClient);\n    }\n}\nfunction getEnv(env) {\n    var _a, _b, _c;\n    return (_c = (_b = (_a = process === null || process === void 0 ? void 0 : process.env) === null || _a === void 0 ? void 0 : _a[env]) === null || _b === void 0 ? void 0 : _b.trim()) !== null && _c !== void 0 ? _c : undefined;\n}\nfunction getBooleanEnv(env) {\n    return stringToBoolean(getEnv(env));\n}\nfunction stringToBoolean(str) {\n    if (str === undefined) {\n        return false;\n    }\n    return str.toLowerCase() === \"true\";\n}\nfunction getApiKeyFromEnv() {\n    const envGoogleApiKey = getEnv(\"GOOGLE_API_KEY\");\n    const envGeminiApiKey = getEnv(\"GEMINI_API_KEY\");\n    if (envGoogleApiKey && envGeminiApiKey) {\n        console.warn(\"Both GOOGLE_API_KEY and GEMINI_API_KEY are set. Using GOOGLE_API_KEY.\");\n    }\n    return envGoogleApiKey || envGeminiApiKey;\n}\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdvb2dsZS9nZW5haS9kaXN0L25vZGUvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBd0I7QUFDeUI7QUFDQztBQUNYO0FBQ1Y7QUFDSztBQUVsQzs7OztDQUlDLEdBQ0QsSUFBSU8sd0JBQXdCQztBQUM1QixJQUFJQyx3QkFBd0JEO0FBQzVCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBbUJDLEdBQ0QsU0FBU0UsbUJBQW1CQyxhQUFhO0lBQ3JDSix3QkFBd0JJLGNBQWNDLFNBQVM7SUFDL0NILHdCQUF3QkUsY0FBY0UsU0FBUztBQUNuRDtBQUNBOztDQUVDLEdBQ0QsU0FBU0M7SUFDTCxPQUFPO1FBQ0hGLFdBQVdMO1FBQ1hNLFdBQVdKO0lBQ2Y7QUFDSjtBQUNBOzs7OztDQUtDLEdBQ0QsU0FBU00sV0FBV0MsT0FBTyxFQUFFQyxvQkFBb0IsRUFBRUMsb0JBQW9CO0lBQ25FLElBQUlDLElBQUlDLElBQUlDO0lBQ1osSUFBSSxDQUFFLEVBQUNGLEtBQUtILFFBQVFNLFdBQVcsTUFBTSxRQUFRSCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdJLE9BQU8sR0FBRztRQUMvRSxNQUFNQyxrQkFBa0JWO1FBQ3hCLElBQUlFLFFBQVFTLFFBQVEsRUFBRTtZQUNsQixPQUFPLENBQUNMLEtBQUtJLGdCQUFnQlgsU0FBUyxNQUFNLFFBQVFPLE9BQU8sS0FBSyxJQUFJQSxLQUFLSDtRQUM3RSxPQUNLO1lBQ0QsT0FBTyxDQUFDSSxLQUFLRyxnQkFBZ0JaLFNBQVMsTUFBTSxRQUFRUyxPQUFPLEtBQUssSUFBSUEsS0FBS0g7UUFDN0U7SUFDSjtJQUNBLE9BQU9GLFFBQVFNLFdBQVcsQ0FBQ0MsT0FBTztBQUN0QztBQUVBOzs7O0NBSUMsR0FDRCxN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QUFDOUI7QUFFdXVELENBQ3Z1RCxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWRkaXQtYW5hbHl6ZXIvLi9ub2RlX21vZHVsZXMvQGdvb2dsZS9nZW5haS9kaXN0L25vZGUvaW5kZXgubWpzPzJkNzgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgeiB9IGZyb20gJ3pvZCc7XG5pbXBvcnQgeyBHb29nbGVBdXRoIH0gZnJvbSAnZ29vZ2xlLWF1dGgtbGlicmFyeSc7XG5pbXBvcnQgeyBjcmVhdGVXcml0ZVN0cmVhbSwgd3JpdGVGaWxlIH0gZnJvbSAnZnMnO1xuaW1wb3J0IHsgUmVhZGFibGUgfSBmcm9tICdub2RlOnN0cmVhbSc7XG5pbXBvcnQgKiBhcyBOb2RlV3MgZnJvbSAnd3MnO1xuaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMvcHJvbWlzZXMnO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5sZXQgX2RlZmF1bHRCYXNlR2VtaW5pVXJsID0gdW5kZWZpbmVkO1xubGV0IF9kZWZhdWx0QmFzZVZlcnRleFVybCA9IHVuZGVmaW5lZDtcbi8qKlxuICogT3ZlcnJpZGVzIHRoZSBiYXNlIFVSTHMgZm9yIHRoZSBHZW1pbmkgQVBJIGFuZCBWZXJ0ZXggQUkgQVBJLlxuICpcbiAqIEByZW1hcmtzIFRoaXMgZnVuY3Rpb24gc2hvdWxkIGJlIGNhbGxlZCBiZWZvcmUgaW5pdGlhbGl6aW5nIHRoZSBTREsuIElmIHRoZVxuICogYmFzZSBVUkxzIGFyZSBzZXQgYWZ0ZXIgaW5pdGlhbGl6aW5nIHRoZSBTREssIHRoZSBiYXNlIFVSTHMgd2lsbCBub3QgYmVcbiAqIHVwZGF0ZWQuIEJhc2UgVVJMcyBwcm92aWRlZCBpbiB0aGUgSHR0cE9wdGlvbnMgd2lsbCBhbHNvIHRha2UgcHJlY2VkZW5jZSBvdmVyXG4gKiBVUkxzIHNldCBoZXJlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHtHb29nbGVHZW5BSSwgc2V0RGVmYXVsdEJhc2VVcmxzfSBmcm9tICdAZ29vZ2xlL2dlbmFpJztcbiAqIC8vIE92ZXJyaWRlIHRoZSBiYXNlIFVSTCBmb3IgdGhlIEdlbWluaSBBUEkuXG4gKiBzZXREZWZhdWx0QmFzZVVybHMoe2dlbWluaVVybDonaHR0cHM6Ly9nZW1pbmkuZ29vZ2xlLmNvbSd9KTtcbiAqXG4gKiAvLyBPdmVycmlkZSB0aGUgYmFzZSBVUkwgZm9yIHRoZSBWZXJ0ZXggQUkgQVBJLlxuICogc2V0RGVmYXVsdEJhc2VVcmxzKHt2ZXJ0ZXhVcmw6ICdodHRwczovL3ZlcnRleGFpLmdvb2dsZWFwaXMuY29tJ30pO1xuICpcbiAqIGNvbnN0IGFpID0gbmV3IEdvb2dsZUdlbkFJKHthcGlLZXk6ICdHRU1JTklfQVBJX0tFWSd9KTtcbiAqIGBgYFxuICovXG5mdW5jdGlvbiBzZXREZWZhdWx0QmFzZVVybHMoYmFzZVVybFBhcmFtcykge1xuICAgIF9kZWZhdWx0QmFzZUdlbWluaVVybCA9IGJhc2VVcmxQYXJhbXMuZ2VtaW5pVXJsO1xuICAgIF9kZWZhdWx0QmFzZVZlcnRleFVybCA9IGJhc2VVcmxQYXJhbXMudmVydGV4VXJsO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBkZWZhdWx0IGJhc2UgVVJMcyBmb3IgdGhlIEdlbWluaSBBUEkgYW5kIFZlcnRleCBBSSBBUEkuXG4gKi9cbmZ1bmN0aW9uIGdldERlZmF1bHRCYXNlVXJscygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBnZW1pbmlVcmw6IF9kZWZhdWx0QmFzZUdlbWluaVVybCxcbiAgICAgICAgdmVydGV4VXJsOiBfZGVmYXVsdEJhc2VWZXJ0ZXhVcmwsXG4gICAgfTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgZGVmYXVsdCBiYXNlIFVSTCBiYXNlZCBvbiB0aGUgZm9sbG93aW5nIHByaW9yaXR5OlxuICogICAxLiBCYXNlIFVSTHMgc2V0IHZpYSBIdHRwT3B0aW9ucy5cbiAqICAgMi4gQmFzZSBVUkxzIHNldCB2aWEgdGhlIGxhdGVzdCBjYWxsIHRvIHNldERlZmF1bHRCYXNlVXJscy5cbiAqICAgMy4gQmFzZSBVUkxzIHNldCB2aWEgZW52aXJvbm1lbnQgdmFyaWFibGVzLlxuICovXG5mdW5jdGlvbiBnZXRCYXNlVXJsKG9wdGlvbnMsIHZlcnRleEJhc2VVcmxGcm9tRW52LCBnZW1pbmlCYXNlVXJsRnJvbUVudikge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIGlmICghKChfYSA9IG9wdGlvbnMuaHR0cE9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5iYXNlVXJsKSkge1xuICAgICAgICBjb25zdCBkZWZhdWx0QmFzZVVybHMgPSBnZXREZWZhdWx0QmFzZVVybHMoKTtcbiAgICAgICAgaWYgKG9wdGlvbnMudmVydGV4YWkpIHtcbiAgICAgICAgICAgIHJldHVybiAoX2IgPSBkZWZhdWx0QmFzZVVybHMudmVydGV4VXJsKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB2ZXJ0ZXhCYXNlVXJsRnJvbUVudjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAoX2MgPSBkZWZhdWx0QmFzZVVybHMuZ2VtaW5pVXJsKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBnZW1pbmlCYXNlVXJsRnJvbUVudjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3B0aW9ucy5odHRwT3B0aW9ucy5iYXNlVXJsO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5jbGFzcyBCYXNlTW9kdWxlIHtcbn1cbmZ1bmN0aW9uIGZvcm1hdE1hcCh0ZW1wbGF0ZVN0cmluZywgdmFsdWVNYXApIHtcbiAgICAvLyBVc2UgYSByZWd1bGFyIGV4cHJlc3Npb24gdG8gZmluZCBhbGwgcGxhY2Vob2xkZXJzIGluIHRoZSB0ZW1wbGF0ZSBzdHJpbmdcbiAgICBjb25zdCByZWdleCA9IC9cXHsoW159XSspXFx9L2c7XG4gICAgLy8gUmVwbGFjZSBlYWNoIHBsYWNlaG9sZGVyIHdpdGggaXRzIGNvcnJlc3BvbmRpbmcgdmFsdWUgZnJvbSB0aGUgdmFsdWVNYXBcbiAgICByZXR1cm4gdGVtcGxhdGVTdHJpbmcucmVwbGFjZShyZWdleCwgKG1hdGNoLCBrZXkpID0+IHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZU1hcCwga2V5KSkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZU1hcFtrZXldO1xuICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgdmFsdWUgdG8gYSBzdHJpbmcgaWYgaXQncyBub3QgYSBzdHJpbmcgYWxyZWFkeVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwgPyBTdHJpbmcodmFsdWUpIDogJyc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBIYW5kbGUgbWlzc2luZyBrZXlzXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEtleSAnJHtrZXl9JyBub3QgZm91bmQgaW4gdmFsdWVNYXAuYCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHNldFZhbHVlQnlQYXRoKGRhdGEsIGtleXMsIHZhbHVlKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgICAgICBpZiAoa2V5LmVuZHNXaXRoKCdbXScpKSB7XG4gICAgICAgICAgICBjb25zdCBrZXlOYW1lID0ga2V5LnNsaWNlKDAsIC0yKTtcbiAgICAgICAgICAgIGlmICghKGtleU5hbWUgaW4gZGF0YSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtrZXlOYW1lXSA9IEFycmF5LmZyb20oeyBsZW5ndGg6IHZhbHVlLmxlbmd0aCB9LCAoKSA9PiAoe30pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVmFsdWUgbXVzdCBiZSBhIGxpc3QgZ2l2ZW4gYW4gYXJyYXkgcGF0aCAke2tleX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhW2tleU5hbWVdKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFycmF5RGF0YSA9IGRhdGFba2V5TmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgYXJyYXlEYXRhLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlbnRyeSA9IGFycmF5RGF0YVtqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFZhbHVlQnlQYXRoKGVudHJ5LCBrZXlzLnNsaWNlKGkgKyAxKSwgdmFsdWVbal0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGQgb2YgYXJyYXlEYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aChkLCBrZXlzLnNsaWNlKGkgKyAxKSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleS5lbmRzV2l0aCgnWzBdJykpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleU5hbWUgPSBrZXkuc2xpY2UoMCwgLTMpO1xuICAgICAgICAgICAgaWYgKCEoa2V5TmFtZSBpbiBkYXRhKSkge1xuICAgICAgICAgICAgICAgIGRhdGFba2V5TmFtZV0gPSBbe31dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXJyYXlEYXRhID0gZGF0YVtrZXlOYW1lXTtcbiAgICAgICAgICAgIHNldFZhbHVlQnlQYXRoKGFycmF5RGF0YVswXSwga2V5cy5zbGljZShpICsgMSksIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRhdGFba2V5XSB8fCB0eXBlb2YgZGF0YVtrZXldICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgZGF0YVtrZXldID0ge307XG4gICAgICAgIH1cbiAgICAgICAgZGF0YSA9IGRhdGFba2V5XTtcbiAgICB9XG4gICAgY29uc3Qga2V5VG9TZXQgPSBrZXlzW2tleXMubGVuZ3RoIC0gMV07XG4gICAgY29uc3QgZXhpc3RpbmdEYXRhID0gZGF0YVtrZXlUb1NldF07XG4gICAgaWYgKGV4aXN0aW5nRGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghdmFsdWUgfHxcbiAgICAgICAgICAgICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIE9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGggPT09IDApKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlID09PSBleGlzdGluZ0RhdGEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGV4aXN0aW5nRGF0YSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIGV4aXN0aW5nRGF0YSAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oZXhpc3RpbmdEYXRhLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBzZXQgdmFsdWUgZm9yIGFuIGV4aXN0aW5nIGtleS4gS2V5OiAke2tleVRvU2V0fWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBkYXRhW2tleVRvU2V0XSA9IHZhbHVlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFZhbHVlQnlQYXRoKGRhdGEsIGtleXMpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAoa2V5cy5sZW5ndGggPT09IDEgJiYga2V5c1swXSA9PT0gJ19zZWxmJykge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGRhdGEgIT09ICdvYmplY3QnIHx8IGRhdGEgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgIGlmIChrZXkuZW5kc1dpdGgoJ1tdJykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlOYW1lID0ga2V5LnNsaWNlKDAsIC0yKTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5TmFtZSBpbiBkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFycmF5RGF0YSA9IGRhdGFba2V5TmFtZV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShhcnJheURhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhcnJheURhdGEubWFwKChkKSA9PiBnZXRWYWx1ZUJ5UGF0aChkLCBrZXlzLnNsaWNlKGkgKyAxKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gZGF0YVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgVHlwZUVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuLyoqIFJlcXVpcmVkLiBPdXRjb21lIG9mIHRoZSBjb2RlIGV4ZWN1dGlvbi4gKi9cbnZhciBPdXRjb21lO1xuKGZ1bmN0aW9uIChPdXRjb21lKSB7XG4gICAgLyoqXG4gICAgICogVW5zcGVjaWZpZWQgc3RhdHVzLiBUaGlzIHZhbHVlIHNob3VsZCBub3QgYmUgdXNlZC5cbiAgICAgKi9cbiAgICBPdXRjb21lW1wiT1VUQ09NRV9VTlNQRUNJRklFRFwiXSA9IFwiT1VUQ09NRV9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIENvZGUgZXhlY3V0aW9uIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHkuXG4gICAgICovXG4gICAgT3V0Y29tZVtcIk9VVENPTUVfT0tcIl0gPSBcIk9VVENPTUVfT0tcIjtcbiAgICAvKipcbiAgICAgKiBDb2RlIGV4ZWN1dGlvbiBmaW5pc2hlZCBidXQgd2l0aCBhIGZhaWx1cmUuIGBzdGRlcnJgIHNob3VsZCBjb250YWluIHRoZSByZWFzb24uXG4gICAgICovXG4gICAgT3V0Y29tZVtcIk9VVENPTUVfRkFJTEVEXCJdID0gXCJPVVRDT01FX0ZBSUxFRFwiO1xuICAgIC8qKlxuICAgICAqIENvZGUgZXhlY3V0aW9uIHJhbiBmb3IgdG9vIGxvbmcsIGFuZCB3YXMgY2FuY2VsbGVkLiBUaGVyZSBtYXkgb3IgbWF5IG5vdCBiZSBhIHBhcnRpYWwgb3V0cHV0IHByZXNlbnQuXG4gICAgICovXG4gICAgT3V0Y29tZVtcIk9VVENPTUVfREVBRExJTkVfRVhDRUVERURcIl0gPSBcIk9VVENPTUVfREVBRExJTkVfRVhDRUVERURcIjtcbn0pKE91dGNvbWUgfHwgKE91dGNvbWUgPSB7fSkpO1xuLyoqIFJlcXVpcmVkLiBQcm9ncmFtbWluZyBsYW5ndWFnZSBvZiB0aGUgYGNvZGVgLiAqL1xudmFyIExhbmd1YWdlO1xuKGZ1bmN0aW9uIChMYW5ndWFnZSkge1xuICAgIC8qKlxuICAgICAqIFVuc3BlY2lmaWVkIGxhbmd1YWdlLiBUaGlzIHZhbHVlIHNob3VsZCBub3QgYmUgdXNlZC5cbiAgICAgKi9cbiAgICBMYW5ndWFnZVtcIkxBTkdVQUdFX1VOU1BFQ0lGSUVEXCJdID0gXCJMQU5HVUFHRV9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIFB5dGhvbiA+PSAzLjEwLCB3aXRoIG51bXB5IGFuZCBzaW1weSBhdmFpbGFibGUuXG4gICAgICovXG4gICAgTGFuZ3VhZ2VbXCJQWVRIT05cIl0gPSBcIlBZVEhPTlwiO1xufSkoTGFuZ3VhZ2UgfHwgKExhbmd1YWdlID0ge30pKTtcbi8qKiBPcHRpb25hbC4gVGhlIHR5cGUgb2YgdGhlIGRhdGEuICovXG52YXIgVHlwZTtcbihmdW5jdGlvbiAoVHlwZSkge1xuICAgIC8qKlxuICAgICAqIE5vdCBzcGVjaWZpZWQsIHNob3VsZCBub3QgYmUgdXNlZC5cbiAgICAgKi9cbiAgICBUeXBlW1wiVFlQRV9VTlNQRUNJRklFRFwiXSA9IFwiVFlQRV9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIE9wZW5BUEkgc3RyaW5nIHR5cGVcbiAgICAgKi9cbiAgICBUeXBlW1wiU1RSSU5HXCJdID0gXCJTVFJJTkdcIjtcbiAgICAvKipcbiAgICAgKiBPcGVuQVBJIG51bWJlciB0eXBlXG4gICAgICovXG4gICAgVHlwZVtcIk5VTUJFUlwiXSA9IFwiTlVNQkVSXCI7XG4gICAgLyoqXG4gICAgICogT3BlbkFQSSBpbnRlZ2VyIHR5cGVcbiAgICAgKi9cbiAgICBUeXBlW1wiSU5URUdFUlwiXSA9IFwiSU5URUdFUlwiO1xuICAgIC8qKlxuICAgICAqIE9wZW5BUEkgYm9vbGVhbiB0eXBlXG4gICAgICovXG4gICAgVHlwZVtcIkJPT0xFQU5cIl0gPSBcIkJPT0xFQU5cIjtcbiAgICAvKipcbiAgICAgKiBPcGVuQVBJIGFycmF5IHR5cGVcbiAgICAgKi9cbiAgICBUeXBlW1wiQVJSQVlcIl0gPSBcIkFSUkFZXCI7XG4gICAgLyoqXG4gICAgICogT3BlbkFQSSBvYmplY3QgdHlwZVxuICAgICAqL1xuICAgIFR5cGVbXCJPQkpFQ1RcIl0gPSBcIk9CSkVDVFwiO1xuICAgIC8qKlxuICAgICAqIE51bGwgdHlwZVxuICAgICAqL1xuICAgIFR5cGVbXCJOVUxMXCJdID0gXCJOVUxMXCI7XG59KShUeXBlIHx8IChUeXBlID0ge30pKTtcbi8qKiBSZXF1aXJlZC4gSGFybSBjYXRlZ29yeS4gKi9cbnZhciBIYXJtQ2F0ZWdvcnk7XG4oZnVuY3Rpb24gKEhhcm1DYXRlZ29yeSkge1xuICAgIC8qKlxuICAgICAqIFRoZSBoYXJtIGNhdGVnb3J5IGlzIHVuc3BlY2lmaWVkLlxuICAgICAqL1xuICAgIEhhcm1DYXRlZ29yeVtcIkhBUk1fQ0FURUdPUllfVU5TUEVDSUZJRURcIl0gPSBcIkhBUk1fQ0FURUdPUllfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgaGFybSBjYXRlZ29yeSBpcyBoYXRlIHNwZWVjaC5cbiAgICAgKi9cbiAgICBIYXJtQ2F0ZWdvcnlbXCJIQVJNX0NBVEVHT1JZX0hBVEVfU1BFRUNIXCJdID0gXCJIQVJNX0NBVEVHT1JZX0hBVEVfU1BFRUNIXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGhhcm0gY2F0ZWdvcnkgaXMgZGFuZ2Vyb3VzIGNvbnRlbnQuXG4gICAgICovXG4gICAgSGFybUNhdGVnb3J5W1wiSEFSTV9DQVRFR09SWV9EQU5HRVJPVVNfQ09OVEVOVFwiXSA9IFwiSEFSTV9DQVRFR09SWV9EQU5HRVJPVVNfQ09OVEVOVFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBoYXJtIGNhdGVnb3J5IGlzIGhhcmFzc21lbnQuXG4gICAgICovXG4gICAgSGFybUNhdGVnb3J5W1wiSEFSTV9DQVRFR09SWV9IQVJBU1NNRU5UXCJdID0gXCJIQVJNX0NBVEVHT1JZX0hBUkFTU01FTlRcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgaGFybSBjYXRlZ29yeSBpcyBzZXh1YWxseSBleHBsaWNpdCBjb250ZW50LlxuICAgICAqL1xuICAgIEhhcm1DYXRlZ29yeVtcIkhBUk1fQ0FURUdPUllfU0VYVUFMTFlfRVhQTElDSVRcIl0gPSBcIkhBUk1fQ0FURUdPUllfU0VYVUFMTFlfRVhQTElDSVRcIjtcbiAgICAvKipcbiAgICAgKiBEZXByZWNhdGVkOiBFbGVjdGlvbiBmaWx0ZXIgaXMgbm90IGxvbmdlciBzdXBwb3J0ZWQuIFRoZSBoYXJtIGNhdGVnb3J5IGlzIGNpdmljIGludGVncml0eS5cbiAgICAgKi9cbiAgICBIYXJtQ2F0ZWdvcnlbXCJIQVJNX0NBVEVHT1JZX0NJVklDX0lOVEVHUklUWVwiXSA9IFwiSEFSTV9DQVRFR09SWV9DSVZJQ19JTlRFR1JJVFlcIjtcbn0pKEhhcm1DYXRlZ29yeSB8fCAoSGFybUNhdGVnb3J5ID0ge30pKTtcbi8qKiBPcHRpb25hbC4gU3BlY2lmeSBpZiB0aGUgdGhyZXNob2xkIGlzIHVzZWQgZm9yIHByb2JhYmlsaXR5IG9yIHNldmVyaXR5IHNjb3JlLiBJZiBub3Qgc3BlY2lmaWVkLCB0aGUgdGhyZXNob2xkIGlzIHVzZWQgZm9yIHByb2JhYmlsaXR5IHNjb3JlLiAqL1xudmFyIEhhcm1CbG9ja01ldGhvZDtcbihmdW5jdGlvbiAoSGFybUJsb2NrTWV0aG9kKSB7XG4gICAgLyoqXG4gICAgICogVGhlIGhhcm0gYmxvY2sgbWV0aG9kIGlzIHVuc3BlY2lmaWVkLlxuICAgICAqL1xuICAgIEhhcm1CbG9ja01ldGhvZFtcIkhBUk1fQkxPQ0tfTUVUSE9EX1VOU1BFQ0lGSUVEXCJdID0gXCJIQVJNX0JMT0NLX01FVEhPRF9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBoYXJtIGJsb2NrIG1ldGhvZCB1c2VzIGJvdGggcHJvYmFiaWxpdHkgYW5kIHNldmVyaXR5IHNjb3Jlcy5cbiAgICAgKi9cbiAgICBIYXJtQmxvY2tNZXRob2RbXCJTRVZFUklUWVwiXSA9IFwiU0VWRVJJVFlcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgaGFybSBibG9jayBtZXRob2QgdXNlcyB0aGUgcHJvYmFiaWxpdHkgc2NvcmUuXG4gICAgICovXG4gICAgSGFybUJsb2NrTWV0aG9kW1wiUFJPQkFCSUxJVFlcIl0gPSBcIlBST0JBQklMSVRZXCI7XG59KShIYXJtQmxvY2tNZXRob2QgfHwgKEhhcm1CbG9ja01ldGhvZCA9IHt9KSk7XG4vKiogUmVxdWlyZWQuIFRoZSBoYXJtIGJsb2NrIHRocmVzaG9sZC4gKi9cbnZhciBIYXJtQmxvY2tUaHJlc2hvbGQ7XG4oZnVuY3Rpb24gKEhhcm1CbG9ja1RocmVzaG9sZCkge1xuICAgIC8qKlxuICAgICAqIFVuc3BlY2lmaWVkIGhhcm0gYmxvY2sgdGhyZXNob2xkLlxuICAgICAqL1xuICAgIEhhcm1CbG9ja1RocmVzaG9sZFtcIkhBUk1fQkxPQ0tfVEhSRVNIT0xEX1VOU1BFQ0lGSUVEXCJdID0gXCJIQVJNX0JMT0NLX1RIUkVTSE9MRF9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIEJsb2NrIGxvdyB0aHJlc2hvbGQgYW5kIGFib3ZlIChpLmUuIGJsb2NrIG1vcmUpLlxuICAgICAqL1xuICAgIEhhcm1CbG9ja1RocmVzaG9sZFtcIkJMT0NLX0xPV19BTkRfQUJPVkVcIl0gPSBcIkJMT0NLX0xPV19BTkRfQUJPVkVcIjtcbiAgICAvKipcbiAgICAgKiBCbG9jayBtZWRpdW0gdGhyZXNob2xkIGFuZCBhYm92ZS5cbiAgICAgKi9cbiAgICBIYXJtQmxvY2tUaHJlc2hvbGRbXCJCTE9DS19NRURJVU1fQU5EX0FCT1ZFXCJdID0gXCJCTE9DS19NRURJVU1fQU5EX0FCT1ZFXCI7XG4gICAgLyoqXG4gICAgICogQmxvY2sgb25seSBoaWdoIHRocmVzaG9sZCAoaS5lLiBibG9jayBsZXNzKS5cbiAgICAgKi9cbiAgICBIYXJtQmxvY2tUaHJlc2hvbGRbXCJCTE9DS19PTkxZX0hJR0hcIl0gPSBcIkJMT0NLX09OTFlfSElHSFwiO1xuICAgIC8qKlxuICAgICAqIEJsb2NrIG5vbmUuXG4gICAgICovXG4gICAgSGFybUJsb2NrVGhyZXNob2xkW1wiQkxPQ0tfTk9ORVwiXSA9IFwiQkxPQ0tfTk9ORVwiO1xuICAgIC8qKlxuICAgICAqIFR1cm4gb2ZmIHRoZSBzYWZldHkgZmlsdGVyLlxuICAgICAqL1xuICAgIEhhcm1CbG9ja1RocmVzaG9sZFtcIk9GRlwiXSA9IFwiT0ZGXCI7XG59KShIYXJtQmxvY2tUaHJlc2hvbGQgfHwgKEhhcm1CbG9ja1RocmVzaG9sZCA9IHt9KSk7XG4vKiogVGhlIG1vZGUgb2YgdGhlIHByZWRpY3RvciB0byBiZSB1c2VkIGluIGR5bmFtaWMgcmV0cmlldmFsLiAqL1xudmFyIE1vZGU7XG4oZnVuY3Rpb24gKE1vZGUpIHtcbiAgICAvKipcbiAgICAgKiBBbHdheXMgdHJpZ2dlciByZXRyaWV2YWwuXG4gICAgICovXG4gICAgTW9kZVtcIk1PREVfVU5TUEVDSUZJRURcIl0gPSBcIk1PREVfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBSdW4gcmV0cmlldmFsIG9ubHkgd2hlbiBzeXN0ZW0gZGVjaWRlcyBpdCBpcyBuZWNlc3NhcnkuXG4gICAgICovXG4gICAgTW9kZVtcIk1PREVfRFlOQU1JQ1wiXSA9IFwiTU9ERV9EWU5BTUlDXCI7XG59KShNb2RlIHx8IChNb2RlID0ge30pKTtcbi8qKiBUeXBlIG9mIGF1dGggc2NoZW1lLiAqL1xudmFyIEF1dGhUeXBlO1xuKGZ1bmN0aW9uIChBdXRoVHlwZSkge1xuICAgIEF1dGhUeXBlW1wiQVVUSF9UWVBFX1VOU1BFQ0lGSUVEXCJdID0gXCJBVVRIX1RZUEVfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBObyBBdXRoLlxuICAgICAqL1xuICAgIEF1dGhUeXBlW1wiTk9fQVVUSFwiXSA9IFwiTk9fQVVUSFwiO1xuICAgIC8qKlxuICAgICAqIEFQSSBLZXkgQXV0aC5cbiAgICAgKi9cbiAgICBBdXRoVHlwZVtcIkFQSV9LRVlfQVVUSFwiXSA9IFwiQVBJX0tFWV9BVVRIXCI7XG4gICAgLyoqXG4gICAgICogSFRUUCBCYXNpYyBBdXRoLlxuICAgICAqL1xuICAgIEF1dGhUeXBlW1wiSFRUUF9CQVNJQ19BVVRIXCJdID0gXCJIVFRQX0JBU0lDX0FVVEhcIjtcbiAgICAvKipcbiAgICAgKiBHb29nbGUgU2VydmljZSBBY2NvdW50IEF1dGguXG4gICAgICovXG4gICAgQXV0aFR5cGVbXCJHT09HTEVfU0VSVklDRV9BQ0NPVU5UX0FVVEhcIl0gPSBcIkdPT0dMRV9TRVJWSUNFX0FDQ09VTlRfQVVUSFwiO1xuICAgIC8qKlxuICAgICAqIE9BdXRoIGF1dGguXG4gICAgICovXG4gICAgQXV0aFR5cGVbXCJPQVVUSFwiXSA9IFwiT0FVVEhcIjtcbiAgICAvKipcbiAgICAgKiBPcGVuSUQgQ29ubmVjdCAoT0lEQykgQXV0aC5cbiAgICAgKi9cbiAgICBBdXRoVHlwZVtcIk9JRENfQVVUSFwiXSA9IFwiT0lEQ19BVVRIXCI7XG59KShBdXRoVHlwZSB8fCAoQXV0aFR5cGUgPSB7fSkpO1xuLyoqIE91dHB1dCBvbmx5LiBUaGUgcmVhc29uIHdoeSB0aGUgbW9kZWwgc3RvcHBlZCBnZW5lcmF0aW5nIHRva2Vucy5cblxuICBJZiBlbXB0eSwgdGhlIG1vZGVsIGhhcyBub3Qgc3RvcHBlZCBnZW5lcmF0aW5nIHRoZSB0b2tlbnMuXG4gICAqL1xudmFyIEZpbmlzaFJlYXNvbjtcbihmdW5jdGlvbiAoRmluaXNoUmVhc29uKSB7XG4gICAgLyoqXG4gICAgICogVGhlIGZpbmlzaCByZWFzb24gaXMgdW5zcGVjaWZpZWQuXG4gICAgICovXG4gICAgRmluaXNoUmVhc29uW1wiRklOSVNIX1JFQVNPTl9VTlNQRUNJRklFRFwiXSA9IFwiRklOSVNIX1JFQVNPTl9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIFRva2VuIGdlbmVyYXRpb24gcmVhY2hlZCBhIG5hdHVyYWwgc3RvcHBpbmcgcG9pbnQgb3IgYSBjb25maWd1cmVkIHN0b3Agc2VxdWVuY2UuXG4gICAgICovXG4gICAgRmluaXNoUmVhc29uW1wiU1RPUFwiXSA9IFwiU1RPUFwiO1xuICAgIC8qKlxuICAgICAqIFRva2VuIGdlbmVyYXRpb24gcmVhY2hlZCB0aGUgY29uZmlndXJlZCBtYXhpbXVtIG91dHB1dCB0b2tlbnMuXG4gICAgICovXG4gICAgRmluaXNoUmVhc29uW1wiTUFYX1RPS0VOU1wiXSA9IFwiTUFYX1RPS0VOU1wiO1xuICAgIC8qKlxuICAgICAqIFRva2VuIGdlbmVyYXRpb24gc3RvcHBlZCBiZWNhdXNlIHRoZSBjb250ZW50IHBvdGVudGlhbGx5IGNvbnRhaW5zIHNhZmV0eSB2aW9sYXRpb25zLiBOT1RFOiBXaGVuIHN0cmVhbWluZywgW2NvbnRlbnRdW10gaXMgZW1wdHkgaWYgY29udGVudCBmaWx0ZXJzIGJsb2NrcyB0aGUgb3V0cHV0LlxuICAgICAqL1xuICAgIEZpbmlzaFJlYXNvbltcIlNBRkVUWVwiXSA9IFwiU0FGRVRZXCI7XG4gICAgLyoqXG4gICAgICogVGhlIHRva2VuIGdlbmVyYXRpb24gc3RvcHBlZCBiZWNhdXNlIG9mIHBvdGVudGlhbCByZWNpdGF0aW9uLlxuICAgICAqL1xuICAgIEZpbmlzaFJlYXNvbltcIlJFQ0lUQVRJT05cIl0gPSBcIlJFQ0lUQVRJT05cIjtcbiAgICAvKipcbiAgICAgKiBUaGUgdG9rZW4gZ2VuZXJhdGlvbiBzdG9wcGVkIGJlY2F1c2Ugb2YgdXNpbmcgYW4gdW5zdXBwb3J0ZWQgbGFuZ3VhZ2UuXG4gICAgICovXG4gICAgRmluaXNoUmVhc29uW1wiTEFOR1VBR0VcIl0gPSBcIkxBTkdVQUdFXCI7XG4gICAgLyoqXG4gICAgICogQWxsIG90aGVyIHJlYXNvbnMgdGhhdCBzdG9wcGVkIHRoZSB0b2tlbiBnZW5lcmF0aW9uLlxuICAgICAqL1xuICAgIEZpbmlzaFJlYXNvbltcIk9USEVSXCJdID0gXCJPVEhFUlwiO1xuICAgIC8qKlxuICAgICAqIFRva2VuIGdlbmVyYXRpb24gc3RvcHBlZCBiZWNhdXNlIHRoZSBjb250ZW50IGNvbnRhaW5zIGZvcmJpZGRlbiB0ZXJtcy5cbiAgICAgKi9cbiAgICBGaW5pc2hSZWFzb25bXCJCTE9DS0xJU1RcIl0gPSBcIkJMT0NLTElTVFwiO1xuICAgIC8qKlxuICAgICAqIFRva2VuIGdlbmVyYXRpb24gc3RvcHBlZCBmb3IgcG90ZW50aWFsbHkgY29udGFpbmluZyBwcm9oaWJpdGVkIGNvbnRlbnQuXG4gICAgICovXG4gICAgRmluaXNoUmVhc29uW1wiUFJPSElCSVRFRF9DT05URU5UXCJdID0gXCJQUk9ISUJJVEVEX0NPTlRFTlRcIjtcbiAgICAvKipcbiAgICAgKiBUb2tlbiBnZW5lcmF0aW9uIHN0b3BwZWQgYmVjYXVzZSB0aGUgY29udGVudCBwb3RlbnRpYWxseSBjb250YWlucyBTZW5zaXRpdmUgUGVyc29uYWxseSBJZGVudGlmaWFibGUgSW5mb3JtYXRpb24gKFNQSUkpLlxuICAgICAqL1xuICAgIEZpbmlzaFJlYXNvbltcIlNQSUlcIl0gPSBcIlNQSUlcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgZnVuY3Rpb24gY2FsbCBnZW5lcmF0ZWQgYnkgdGhlIG1vZGVsIGlzIGludmFsaWQuXG4gICAgICovXG4gICAgRmluaXNoUmVhc29uW1wiTUFMRk9STUVEX0ZVTkNUSU9OX0NBTExcIl0gPSBcIk1BTEZPUk1FRF9GVU5DVElPTl9DQUxMXCI7XG4gICAgLyoqXG4gICAgICogVG9rZW4gZ2VuZXJhdGlvbiBzdG9wcGVkIGJlY2F1c2UgZ2VuZXJhdGVkIGltYWdlcyBoYXZlIHNhZmV0eSB2aW9sYXRpb25zLlxuICAgICAqL1xuICAgIEZpbmlzaFJlYXNvbltcIklNQUdFX1NBRkVUWVwiXSA9IFwiSU1BR0VfU0FGRVRZXCI7XG4gICAgLyoqXG4gICAgICogVGhlIHRvb2wgY2FsbCBnZW5lcmF0ZWQgYnkgdGhlIG1vZGVsIGlzIGludmFsaWQuXG4gICAgICovXG4gICAgRmluaXNoUmVhc29uW1wiVU5FWFBFQ1RFRF9UT09MX0NBTExcIl0gPSBcIlVORVhQRUNURURfVE9PTF9DQUxMXCI7XG59KShGaW5pc2hSZWFzb24gfHwgKEZpbmlzaFJlYXNvbiA9IHt9KSk7XG4vKiogT3V0cHV0IG9ubHkuIEhhcm0gcHJvYmFiaWxpdHkgbGV2ZWxzIGluIHRoZSBjb250ZW50LiAqL1xudmFyIEhhcm1Qcm9iYWJpbGl0eTtcbihmdW5jdGlvbiAoSGFybVByb2JhYmlsaXR5KSB7XG4gICAgLyoqXG4gICAgICogSGFybSBwcm9iYWJpbGl0eSB1bnNwZWNpZmllZC5cbiAgICAgKi9cbiAgICBIYXJtUHJvYmFiaWxpdHlbXCJIQVJNX1BST0JBQklMSVRZX1VOU1BFQ0lGSUVEXCJdID0gXCJIQVJNX1BST0JBQklMSVRZX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogTmVnbGlnaWJsZSBsZXZlbCBvZiBoYXJtLlxuICAgICAqL1xuICAgIEhhcm1Qcm9iYWJpbGl0eVtcIk5FR0xJR0lCTEVcIl0gPSBcIk5FR0xJR0lCTEVcIjtcbiAgICAvKipcbiAgICAgKiBMb3cgbGV2ZWwgb2YgaGFybS5cbiAgICAgKi9cbiAgICBIYXJtUHJvYmFiaWxpdHlbXCJMT1dcIl0gPSBcIkxPV1wiO1xuICAgIC8qKlxuICAgICAqIE1lZGl1bSBsZXZlbCBvZiBoYXJtLlxuICAgICAqL1xuICAgIEhhcm1Qcm9iYWJpbGl0eVtcIk1FRElVTVwiXSA9IFwiTUVESVVNXCI7XG4gICAgLyoqXG4gICAgICogSGlnaCBsZXZlbCBvZiBoYXJtLlxuICAgICAqL1xuICAgIEhhcm1Qcm9iYWJpbGl0eVtcIkhJR0hcIl0gPSBcIkhJR0hcIjtcbn0pKEhhcm1Qcm9iYWJpbGl0eSB8fCAoSGFybVByb2JhYmlsaXR5ID0ge30pKTtcbi8qKiBPdXRwdXQgb25seS4gSGFybSBzZXZlcml0eSBsZXZlbHMgaW4gdGhlIGNvbnRlbnQuICovXG52YXIgSGFybVNldmVyaXR5O1xuKGZ1bmN0aW9uIChIYXJtU2V2ZXJpdHkpIHtcbiAgICAvKipcbiAgICAgKiBIYXJtIHNldmVyaXR5IHVuc3BlY2lmaWVkLlxuICAgICAqL1xuICAgIEhhcm1TZXZlcml0eVtcIkhBUk1fU0VWRVJJVFlfVU5TUEVDSUZJRURcIl0gPSBcIkhBUk1fU0VWRVJJVFlfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBOZWdsaWdpYmxlIGxldmVsIG9mIGhhcm0gc2V2ZXJpdHkuXG4gICAgICovXG4gICAgSGFybVNldmVyaXR5W1wiSEFSTV9TRVZFUklUWV9ORUdMSUdJQkxFXCJdID0gXCJIQVJNX1NFVkVSSVRZX05FR0xJR0lCTEVcIjtcbiAgICAvKipcbiAgICAgKiBMb3cgbGV2ZWwgb2YgaGFybSBzZXZlcml0eS5cbiAgICAgKi9cbiAgICBIYXJtU2V2ZXJpdHlbXCJIQVJNX1NFVkVSSVRZX0xPV1wiXSA9IFwiSEFSTV9TRVZFUklUWV9MT1dcIjtcbiAgICAvKipcbiAgICAgKiBNZWRpdW0gbGV2ZWwgb2YgaGFybSBzZXZlcml0eS5cbiAgICAgKi9cbiAgICBIYXJtU2V2ZXJpdHlbXCJIQVJNX1NFVkVSSVRZX01FRElVTVwiXSA9IFwiSEFSTV9TRVZFUklUWV9NRURJVU1cIjtcbiAgICAvKipcbiAgICAgKiBIaWdoIGxldmVsIG9mIGhhcm0gc2V2ZXJpdHkuXG4gICAgICovXG4gICAgSGFybVNldmVyaXR5W1wiSEFSTV9TRVZFUklUWV9ISUdIXCJdID0gXCJIQVJNX1NFVkVSSVRZX0hJR0hcIjtcbn0pKEhhcm1TZXZlcml0eSB8fCAoSGFybVNldmVyaXR5ID0ge30pKTtcbi8qKiBPdXRwdXQgb25seS4gQmxvY2tlZCByZWFzb24uICovXG52YXIgQmxvY2tlZFJlYXNvbjtcbihmdW5jdGlvbiAoQmxvY2tlZFJlYXNvbikge1xuICAgIC8qKlxuICAgICAqIFVuc3BlY2lmaWVkIGJsb2NrZWQgcmVhc29uLlxuICAgICAqL1xuICAgIEJsb2NrZWRSZWFzb25bXCJCTE9DS0VEX1JFQVNPTl9VTlNQRUNJRklFRFwiXSA9IFwiQkxPQ0tFRF9SRUFTT05fVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBDYW5kaWRhdGVzIGJsb2NrZWQgZHVlIHRvIHNhZmV0eS5cbiAgICAgKi9cbiAgICBCbG9ja2VkUmVhc29uW1wiU0FGRVRZXCJdID0gXCJTQUZFVFlcIjtcbiAgICAvKipcbiAgICAgKiBDYW5kaWRhdGVzIGJsb2NrZWQgZHVlIHRvIG90aGVyIHJlYXNvbi5cbiAgICAgKi9cbiAgICBCbG9ja2VkUmVhc29uW1wiT1RIRVJcIl0gPSBcIk9USEVSXCI7XG4gICAgLyoqXG4gICAgICogQ2FuZGlkYXRlcyBibG9ja2VkIGR1ZSB0byB0aGUgdGVybXMgd2hpY2ggYXJlIGluY2x1ZGVkIGZyb20gdGhlIHRlcm1pbm9sb2d5IGJsb2NrbGlzdC5cbiAgICAgKi9cbiAgICBCbG9ja2VkUmVhc29uW1wiQkxPQ0tMSVNUXCJdID0gXCJCTE9DS0xJU1RcIjtcbiAgICAvKipcbiAgICAgKiBDYW5kaWRhdGVzIGJsb2NrZWQgZHVlIHRvIHByb2hpYml0ZWQgY29udGVudC5cbiAgICAgKi9cbiAgICBCbG9ja2VkUmVhc29uW1wiUFJPSElCSVRFRF9DT05URU5UXCJdID0gXCJQUk9ISUJJVEVEX0NPTlRFTlRcIjtcbn0pKEJsb2NrZWRSZWFzb24gfHwgKEJsb2NrZWRSZWFzb24gPSB7fSkpO1xuLyoqIE91dHB1dCBvbmx5LiBUcmFmZmljIHR5cGUuIFRoaXMgc2hvd3Mgd2hldGhlciBhIHJlcXVlc3QgY29uc3VtZXMgUGF5LUFzLVlvdS1HbyBvciBQcm92aXNpb25lZCBUaHJvdWdocHV0IHF1b3RhLiAqL1xudmFyIFRyYWZmaWNUeXBlO1xuKGZ1bmN0aW9uIChUcmFmZmljVHlwZSkge1xuICAgIC8qKlxuICAgICAqIFVuc3BlY2lmaWVkIHJlcXVlc3QgdHJhZmZpYyB0eXBlLlxuICAgICAqL1xuICAgIFRyYWZmaWNUeXBlW1wiVFJBRkZJQ19UWVBFX1VOU1BFQ0lGSUVEXCJdID0gXCJUUkFGRklDX1RZUEVfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBUeXBlIGZvciBQYXktQXMtWW91LUdvIHRyYWZmaWMuXG4gICAgICovXG4gICAgVHJhZmZpY1R5cGVbXCJPTl9ERU1BTkRcIl0gPSBcIk9OX0RFTUFORFwiO1xuICAgIC8qKlxuICAgICAqIFR5cGUgZm9yIFByb3Zpc2lvbmVkIFRocm91Z2hwdXQgdHJhZmZpYy5cbiAgICAgKi9cbiAgICBUcmFmZmljVHlwZVtcIlBST1ZJU0lPTkVEX1RIUk9VR0hQVVRcIl0gPSBcIlBST1ZJU0lPTkVEX1RIUk9VR0hQVVRcIjtcbn0pKFRyYWZmaWNUeXBlIHx8IChUcmFmZmljVHlwZSA9IHt9KSk7XG4vKiogU2VydmVyIGNvbnRlbnQgbW9kYWxpdGllcy4gKi9cbnZhciBNb2RhbGl0eTtcbihmdW5jdGlvbiAoTW9kYWxpdHkpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgbW9kYWxpdHkgaXMgdW5zcGVjaWZpZWQuXG4gICAgICovXG4gICAgTW9kYWxpdHlbXCJNT0RBTElUWV9VTlNQRUNJRklFRFwiXSA9IFwiTU9EQUxJVFlfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgdGhlIG1vZGVsIHNob3VsZCByZXR1cm4gdGV4dFxuICAgICAqL1xuICAgIE1vZGFsaXR5W1wiVEVYVFwiXSA9IFwiVEVYVFwiO1xuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB0aGUgbW9kZWwgc2hvdWxkIHJldHVybiBpbWFnZXMuXG4gICAgICovXG4gICAgTW9kYWxpdHlbXCJJTUFHRVwiXSA9IFwiSU1BR0VcIjtcbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgdGhlIG1vZGVsIHNob3VsZCByZXR1cm4gYXVkaW8uXG4gICAgICovXG4gICAgTW9kYWxpdHlbXCJBVURJT1wiXSA9IFwiQVVESU9cIjtcbn0pKE1vZGFsaXR5IHx8IChNb2RhbGl0eSA9IHt9KSk7XG4vKiogVGhlIG1lZGlhIHJlc29sdXRpb24gdG8gdXNlLiAqL1xudmFyIE1lZGlhUmVzb2x1dGlvbjtcbihmdW5jdGlvbiAoTWVkaWFSZXNvbHV0aW9uKSB7XG4gICAgLyoqXG4gICAgICogTWVkaWEgcmVzb2x1dGlvbiBoYXMgbm90IGJlZW4gc2V0XG4gICAgICovXG4gICAgTWVkaWFSZXNvbHV0aW9uW1wiTUVESUFfUkVTT0xVVElPTl9VTlNQRUNJRklFRFwiXSA9IFwiTUVESUFfUkVTT0xVVElPTl9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIE1lZGlhIHJlc29sdXRpb24gc2V0IHRvIGxvdyAoNjQgdG9rZW5zKS5cbiAgICAgKi9cbiAgICBNZWRpYVJlc29sdXRpb25bXCJNRURJQV9SRVNPTFVUSU9OX0xPV1wiXSA9IFwiTUVESUFfUkVTT0xVVElPTl9MT1dcIjtcbiAgICAvKipcbiAgICAgKiBNZWRpYSByZXNvbHV0aW9uIHNldCB0byBtZWRpdW0gKDI1NiB0b2tlbnMpLlxuICAgICAqL1xuICAgIE1lZGlhUmVzb2x1dGlvbltcIk1FRElBX1JFU09MVVRJT05fTUVESVVNXCJdID0gXCJNRURJQV9SRVNPTFVUSU9OX01FRElVTVwiO1xuICAgIC8qKlxuICAgICAqIE1lZGlhIHJlc29sdXRpb24gc2V0IHRvIGhpZ2ggKHpvb21lZCByZWZyYW1pbmcgd2l0aCAyNTYgdG9rZW5zKS5cbiAgICAgKi9cbiAgICBNZWRpYVJlc29sdXRpb25bXCJNRURJQV9SRVNPTFVUSU9OX0hJR0hcIl0gPSBcIk1FRElBX1JFU09MVVRJT05fSElHSFwiO1xufSkoTWVkaWFSZXNvbHV0aW9uIHx8IChNZWRpYVJlc29sdXRpb24gPSB7fSkpO1xuLyoqIEpvYiBzdGF0ZS4gKi9cbnZhciBKb2JTdGF0ZTtcbihmdW5jdGlvbiAoSm9iU3RhdGUpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgam9iIHN0YXRlIGlzIHVuc3BlY2lmaWVkLlxuICAgICAqL1xuICAgIEpvYlN0YXRlW1wiSk9CX1NUQVRFX1VOU1BFQ0lGSUVEXCJdID0gXCJKT0JfU1RBVEVfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgam9iIGhhcyBiZWVuIGp1c3QgY3JlYXRlZCBvciByZXN1bWVkIGFuZCBwcm9jZXNzaW5nIGhhcyBub3QgeWV0IGJlZ3VuLlxuICAgICAqL1xuICAgIEpvYlN0YXRlW1wiSk9CX1NUQVRFX1FVRVVFRFwiXSA9IFwiSk9CX1NUQVRFX1FVRVVFRFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBzZXJ2aWNlIGlzIHByZXBhcmluZyB0byBydW4gdGhlIGpvYi5cbiAgICAgKi9cbiAgICBKb2JTdGF0ZVtcIkpPQl9TVEFURV9QRU5ESU5HXCJdID0gXCJKT0JfU1RBVEVfUEVORElOR1wiO1xuICAgIC8qKlxuICAgICAqIFRoZSBqb2IgaXMgaW4gcHJvZ3Jlc3MuXG4gICAgICovXG4gICAgSm9iU3RhdGVbXCJKT0JfU1RBVEVfUlVOTklOR1wiXSA9IFwiSk9CX1NUQVRFX1JVTk5JTkdcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgam9iIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHkuXG4gICAgICovXG4gICAgSm9iU3RhdGVbXCJKT0JfU1RBVEVfU1VDQ0VFREVEXCJdID0gXCJKT0JfU1RBVEVfU1VDQ0VFREVEXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGpvYiBmYWlsZWQuXG4gICAgICovXG4gICAgSm9iU3RhdGVbXCJKT0JfU1RBVEVfRkFJTEVEXCJdID0gXCJKT0JfU1RBVEVfRkFJTEVEXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGpvYiBpcyBiZWluZyBjYW5jZWxsZWQuIEZyb20gdGhpcyBzdGF0ZSB0aGUgam9iIG1heSBvbmx5IGdvIHRvIGVpdGhlciBgSk9CX1NUQVRFX1NVQ0NFRURFRGAsIGBKT0JfU1RBVEVfRkFJTEVEYCBvciBgSk9CX1NUQVRFX0NBTkNFTExFRGAuXG4gICAgICovXG4gICAgSm9iU3RhdGVbXCJKT0JfU1RBVEVfQ0FOQ0VMTElOR1wiXSA9IFwiSk9CX1NUQVRFX0NBTkNFTExJTkdcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgam9iIGhhcyBiZWVuIGNhbmNlbGxlZC5cbiAgICAgKi9cbiAgICBKb2JTdGF0ZVtcIkpPQl9TVEFURV9DQU5DRUxMRURcIl0gPSBcIkpPQl9TVEFURV9DQU5DRUxMRURcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgam9iIGhhcyBiZWVuIHN0b3BwZWQsIGFuZCBjYW4gYmUgcmVzdW1lZC5cbiAgICAgKi9cbiAgICBKb2JTdGF0ZVtcIkpPQl9TVEFURV9QQVVTRURcIl0gPSBcIkpPQl9TVEFURV9QQVVTRURcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgam9iIGhhcyBleHBpcmVkLlxuICAgICAqL1xuICAgIEpvYlN0YXRlW1wiSk9CX1NUQVRFX0VYUElSRURcIl0gPSBcIkpPQl9TVEFURV9FWFBJUkVEXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGpvYiBpcyBiZWluZyB1cGRhdGVkLiBPbmx5IGpvYnMgaW4gdGhlIGBKT0JfU1RBVEVfUlVOTklOR2Agc3RhdGUgY2FuIGJlIHVwZGF0ZWQuIEFmdGVyIHVwZGF0aW5nLCB0aGUgam9iIGdvZXMgYmFjayB0byB0aGUgYEpPQl9TVEFURV9SVU5OSU5HYCBzdGF0ZS5cbiAgICAgKi9cbiAgICBKb2JTdGF0ZVtcIkpPQl9TVEFURV9VUERBVElOR1wiXSA9IFwiSk9CX1NUQVRFX1VQREFUSU5HXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGpvYiBpcyBwYXJ0aWFsbHkgc3VjY2VlZGVkLCBzb21lIHJlc3VsdHMgbWF5IGJlIG1pc3NpbmcgZHVlIHRvIGVycm9ycy5cbiAgICAgKi9cbiAgICBKb2JTdGF0ZVtcIkpPQl9TVEFURV9QQVJUSUFMTFlfU1VDQ0VFREVEXCJdID0gXCJKT0JfU1RBVEVfUEFSVElBTExZX1NVQ0NFRURFRFwiO1xufSkoSm9iU3RhdGUgfHwgKEpvYlN0YXRlID0ge30pKTtcbi8qKiBPcHRpb25hbC4gQWRhcHRlciBzaXplIGZvciB0dW5pbmcuICovXG52YXIgQWRhcHRlclNpemU7XG4oZnVuY3Rpb24gKEFkYXB0ZXJTaXplKSB7XG4gICAgLyoqXG4gICAgICogQWRhcHRlciBzaXplIGlzIHVuc3BlY2lmaWVkLlxuICAgICAqL1xuICAgIEFkYXB0ZXJTaXplW1wiQURBUFRFUl9TSVpFX1VOU1BFQ0lGSUVEXCJdID0gXCJBREFQVEVSX1NJWkVfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBBZGFwdGVyIHNpemUgMS5cbiAgICAgKi9cbiAgICBBZGFwdGVyU2l6ZVtcIkFEQVBURVJfU0laRV9PTkVcIl0gPSBcIkFEQVBURVJfU0laRV9PTkVcIjtcbiAgICAvKipcbiAgICAgKiBBZGFwdGVyIHNpemUgMi5cbiAgICAgKi9cbiAgICBBZGFwdGVyU2l6ZVtcIkFEQVBURVJfU0laRV9UV09cIl0gPSBcIkFEQVBURVJfU0laRV9UV09cIjtcbiAgICAvKipcbiAgICAgKiBBZGFwdGVyIHNpemUgNC5cbiAgICAgKi9cbiAgICBBZGFwdGVyU2l6ZVtcIkFEQVBURVJfU0laRV9GT1VSXCJdID0gXCJBREFQVEVSX1NJWkVfRk9VUlwiO1xuICAgIC8qKlxuICAgICAqIEFkYXB0ZXIgc2l6ZSA4LlxuICAgICAqL1xuICAgIEFkYXB0ZXJTaXplW1wiQURBUFRFUl9TSVpFX0VJR0hUXCJdID0gXCJBREFQVEVSX1NJWkVfRUlHSFRcIjtcbiAgICAvKipcbiAgICAgKiBBZGFwdGVyIHNpemUgMTYuXG4gICAgICovXG4gICAgQWRhcHRlclNpemVbXCJBREFQVEVSX1NJWkVfU0lYVEVFTlwiXSA9IFwiQURBUFRFUl9TSVpFX1NJWFRFRU5cIjtcbiAgICAvKipcbiAgICAgKiBBZGFwdGVyIHNpemUgMzIuXG4gICAgICovXG4gICAgQWRhcHRlclNpemVbXCJBREFQVEVSX1NJWkVfVEhJUlRZX1RXT1wiXSA9IFwiQURBUFRFUl9TSVpFX1RISVJUWV9UV09cIjtcbn0pKEFkYXB0ZXJTaXplIHx8IChBZGFwdGVyU2l6ZSA9IHt9KSk7XG4vKiogT3B0aW9ucyBmb3IgZmVhdHVyZSBzZWxlY3Rpb24gcHJlZmVyZW5jZS4gKi9cbnZhciBGZWF0dXJlU2VsZWN0aW9uUHJlZmVyZW5jZTtcbihmdW5jdGlvbiAoRmVhdHVyZVNlbGVjdGlvblByZWZlcmVuY2UpIHtcbiAgICBGZWF0dXJlU2VsZWN0aW9uUHJlZmVyZW5jZVtcIkZFQVRVUkVfU0VMRUNUSU9OX1BSRUZFUkVOQ0VfVU5TUEVDSUZJRURcIl0gPSBcIkZFQVRVUkVfU0VMRUNUSU9OX1BSRUZFUkVOQ0VfVU5TUEVDSUZJRURcIjtcbiAgICBGZWF0dXJlU2VsZWN0aW9uUHJlZmVyZW5jZVtcIlBSSU9SSVRJWkVfUVVBTElUWVwiXSA9IFwiUFJJT1JJVElaRV9RVUFMSVRZXCI7XG4gICAgRmVhdHVyZVNlbGVjdGlvblByZWZlcmVuY2VbXCJCQUxBTkNFRFwiXSA9IFwiQkFMQU5DRURcIjtcbiAgICBGZWF0dXJlU2VsZWN0aW9uUHJlZmVyZW5jZVtcIlBSSU9SSVRJWkVfQ09TVFwiXSA9IFwiUFJJT1JJVElaRV9DT1NUXCI7XG59KShGZWF0dXJlU2VsZWN0aW9uUHJlZmVyZW5jZSB8fCAoRmVhdHVyZVNlbGVjdGlvblByZWZlcmVuY2UgPSB7fSkpO1xuLyoqIERlZmluZXMgdGhlIGZ1bmN0aW9uIGJlaGF2aW9yLiBEZWZhdWx0cyB0byBgQkxPQ0tJTkdgLiAqL1xudmFyIEJlaGF2aW9yO1xuKGZ1bmN0aW9uIChCZWhhdmlvcikge1xuICAgIC8qKlxuICAgICAqIFRoaXMgdmFsdWUgaXMgdW51c2VkLlxuICAgICAqL1xuICAgIEJlaGF2aW9yW1wiVU5TUEVDSUZJRURcIl0gPSBcIlVOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogSWYgc2V0LCB0aGUgc3lzdGVtIHdpbGwgd2FpdCB0byByZWNlaXZlIHRoZSBmdW5jdGlvbiByZXNwb25zZSBiZWZvcmUgY29udGludWluZyB0aGUgY29udmVyc2F0aW9uLlxuICAgICAqL1xuICAgIEJlaGF2aW9yW1wiQkxPQ0tJTkdcIl0gPSBcIkJMT0NLSU5HXCI7XG4gICAgLyoqXG4gICAgICogSWYgc2V0LCB0aGUgc3lzdGVtIHdpbGwgbm90IHdhaXQgdG8gcmVjZWl2ZSB0aGUgZnVuY3Rpb24gcmVzcG9uc2UuIEluc3RlYWQsIGl0IHdpbGwgYXR0ZW1wdCB0byBoYW5kbGUgZnVuY3Rpb24gcmVzcG9uc2VzIGFzIHRoZXkgYmVjb21lIGF2YWlsYWJsZSB3aGlsZSBtYWludGFpbmluZyB0aGUgY29udmVyc2F0aW9uIGJldHdlZW4gdGhlIHVzZXIgYW5kIHRoZSBtb2RlbC5cbiAgICAgKi9cbiAgICBCZWhhdmlvcltcIk5PTl9CTE9DS0lOR1wiXSA9IFwiTk9OX0JMT0NLSU5HXCI7XG59KShCZWhhdmlvciB8fCAoQmVoYXZpb3IgPSB7fSkpO1xuLyoqIENvbmZpZyBmb3IgdGhlIGR5bmFtaWMgcmV0cmlldmFsIGNvbmZpZyBtb2RlLiAqL1xudmFyIER5bmFtaWNSZXRyaWV2YWxDb25maWdNb2RlO1xuKGZ1bmN0aW9uIChEeW5hbWljUmV0cmlldmFsQ29uZmlnTW9kZSkge1xuICAgIC8qKlxuICAgICAqIEFsd2F5cyB0cmlnZ2VyIHJldHJpZXZhbC5cbiAgICAgKi9cbiAgICBEeW5hbWljUmV0cmlldmFsQ29uZmlnTW9kZVtcIk1PREVfVU5TUEVDSUZJRURcIl0gPSBcIk1PREVfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBSdW4gcmV0cmlldmFsIG9ubHkgd2hlbiBzeXN0ZW0gZGVjaWRlcyBpdCBpcyBuZWNlc3NhcnkuXG4gICAgICovXG4gICAgRHluYW1pY1JldHJpZXZhbENvbmZpZ01vZGVbXCJNT0RFX0RZTkFNSUNcIl0gPSBcIk1PREVfRFlOQU1JQ1wiO1xufSkoRHluYW1pY1JldHJpZXZhbENvbmZpZ01vZGUgfHwgKER5bmFtaWNSZXRyaWV2YWxDb25maWdNb2RlID0ge30pKTtcbi8qKiBDb25maWcgZm9yIHRoZSBmdW5jdGlvbiBjYWxsaW5nIGNvbmZpZyBtb2RlLiAqL1xudmFyIEZ1bmN0aW9uQ2FsbGluZ0NvbmZpZ01vZGU7XG4oZnVuY3Rpb24gKEZ1bmN0aW9uQ2FsbGluZ0NvbmZpZ01vZGUpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgZnVuY3Rpb24gY2FsbGluZyBjb25maWcgbW9kZSBpcyB1bnNwZWNpZmllZC4gU2hvdWxkIG5vdCBiZSB1c2VkLlxuICAgICAqL1xuICAgIEZ1bmN0aW9uQ2FsbGluZ0NvbmZpZ01vZGVbXCJNT0RFX1VOU1BFQ0lGSUVEXCJdID0gXCJNT0RFX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBtb2RlbCBiZWhhdmlvciwgbW9kZWwgZGVjaWRlcyB0byBwcmVkaWN0IGVpdGhlciBmdW5jdGlvbiBjYWxscyBvciBuYXR1cmFsIGxhbmd1YWdlIHJlc3BvbnNlLlxuICAgICAqL1xuICAgIEZ1bmN0aW9uQ2FsbGluZ0NvbmZpZ01vZGVbXCJBVVRPXCJdID0gXCJBVVRPXCI7XG4gICAgLyoqXG4gICAgICogTW9kZWwgaXMgY29uc3RyYWluZWQgdG8gYWx3YXlzIHByZWRpY3RpbmcgZnVuY3Rpb24gY2FsbHMgb25seS4gSWYgXCJhbGxvd2VkX2Z1bmN0aW9uX25hbWVzXCIgYXJlIHNldCwgdGhlIHByZWRpY3RlZCBmdW5jdGlvbiBjYWxscyB3aWxsIGJlIGxpbWl0ZWQgdG8gYW55IG9uZSBvZiBcImFsbG93ZWRfZnVuY3Rpb25fbmFtZXNcIiwgZWxzZSB0aGUgcHJlZGljdGVkIGZ1bmN0aW9uIGNhbGxzIHdpbGwgYmUgYW55IG9uZSBvZiB0aGUgcHJvdmlkZWQgXCJmdW5jdGlvbl9kZWNsYXJhdGlvbnNcIi5cbiAgICAgKi9cbiAgICBGdW5jdGlvbkNhbGxpbmdDb25maWdNb2RlW1wiQU5ZXCJdID0gXCJBTllcIjtcbiAgICAvKipcbiAgICAgKiBNb2RlbCB3aWxsIG5vdCBwcmVkaWN0IGFueSBmdW5jdGlvbiBjYWxscy4gTW9kZWwgYmVoYXZpb3IgaXMgc2FtZSBhcyB3aGVuIG5vdCBwYXNzaW5nIGFueSBmdW5jdGlvbiBkZWNsYXJhdGlvbnMuXG4gICAgICovXG4gICAgRnVuY3Rpb25DYWxsaW5nQ29uZmlnTW9kZVtcIk5PTkVcIl0gPSBcIk5PTkVcIjtcbn0pKEZ1bmN0aW9uQ2FsbGluZ0NvbmZpZ01vZGUgfHwgKEZ1bmN0aW9uQ2FsbGluZ0NvbmZpZ01vZGUgPSB7fSkpO1xuLyoqIFN0YXR1cyBvZiB0aGUgdXJsIHJldHJpZXZhbC4gKi9cbnZhciBVcmxSZXRyaWV2YWxTdGF0dXM7XG4oZnVuY3Rpb24gKFVybFJldHJpZXZhbFN0YXR1cykge1xuICAgIC8qKlxuICAgICAqIERlZmF1bHQgdmFsdWUuIFRoaXMgdmFsdWUgaXMgdW51c2VkXG4gICAgICovXG4gICAgVXJsUmV0cmlldmFsU3RhdHVzW1wiVVJMX1JFVFJJRVZBTF9TVEFUVVNfVU5TUEVDSUZJRURcIl0gPSBcIlVSTF9SRVRSSUVWQUxfU1RBVFVTX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogVXJsIHJldHJpZXZhbCBpcyBzdWNjZXNzZnVsLlxuICAgICAqL1xuICAgIFVybFJldHJpZXZhbFN0YXR1c1tcIlVSTF9SRVRSSUVWQUxfU1RBVFVTX1NVQ0NFU1NcIl0gPSBcIlVSTF9SRVRSSUVWQUxfU1RBVFVTX1NVQ0NFU1NcIjtcbiAgICAvKipcbiAgICAgKiBVcmwgcmV0cmlldmFsIGlzIGZhaWxlZCBkdWUgdG8gZXJyb3IuXG4gICAgICovXG4gICAgVXJsUmV0cmlldmFsU3RhdHVzW1wiVVJMX1JFVFJJRVZBTF9TVEFUVVNfRVJST1JcIl0gPSBcIlVSTF9SRVRSSUVWQUxfU1RBVFVTX0VSUk9SXCI7XG59KShVcmxSZXRyaWV2YWxTdGF0dXMgfHwgKFVybFJldHJpZXZhbFN0YXR1cyA9IHt9KSk7XG4vKiogRW51bSB0aGF0IGNvbnRyb2xzIHRoZSBzYWZldHkgZmlsdGVyIGxldmVsIGZvciBvYmplY3Rpb25hYmxlIGNvbnRlbnQuICovXG52YXIgU2FmZXR5RmlsdGVyTGV2ZWw7XG4oZnVuY3Rpb24gKFNhZmV0eUZpbHRlckxldmVsKSB7XG4gICAgU2FmZXR5RmlsdGVyTGV2ZWxbXCJCTE9DS19MT1dfQU5EX0FCT1ZFXCJdID0gXCJCTE9DS19MT1dfQU5EX0FCT1ZFXCI7XG4gICAgU2FmZXR5RmlsdGVyTGV2ZWxbXCJCTE9DS19NRURJVU1fQU5EX0FCT1ZFXCJdID0gXCJCTE9DS19NRURJVU1fQU5EX0FCT1ZFXCI7XG4gICAgU2FmZXR5RmlsdGVyTGV2ZWxbXCJCTE9DS19PTkxZX0hJR0hcIl0gPSBcIkJMT0NLX09OTFlfSElHSFwiO1xuICAgIFNhZmV0eUZpbHRlckxldmVsW1wiQkxPQ0tfTk9ORVwiXSA9IFwiQkxPQ0tfTk9ORVwiO1xufSkoU2FmZXR5RmlsdGVyTGV2ZWwgfHwgKFNhZmV0eUZpbHRlckxldmVsID0ge30pKTtcbi8qKiBFbnVtIHRoYXQgY29udHJvbHMgdGhlIGdlbmVyYXRpb24gb2YgcGVvcGxlLiAqL1xudmFyIFBlcnNvbkdlbmVyYXRpb247XG4oZnVuY3Rpb24gKFBlcnNvbkdlbmVyYXRpb24pIHtcbiAgICAvKipcbiAgICAgKiBCbG9jayBnZW5lcmF0aW9uIG9mIGltYWdlcyBvZiBwZW9wbGUuXG4gICAgICovXG4gICAgUGVyc29uR2VuZXJhdGlvbltcIkRPTlRfQUxMT1dcIl0gPSBcIkRPTlRfQUxMT1dcIjtcbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBpbWFnZXMgb2YgYWR1bHRzLCBidXQgbm90IGNoaWxkcmVuLlxuICAgICAqL1xuICAgIFBlcnNvbkdlbmVyYXRpb25bXCJBTExPV19BRFVMVFwiXSA9IFwiQUxMT1dfQURVTFRcIjtcbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBpbWFnZXMgdGhhdCBpbmNsdWRlIGFkdWx0cyBhbmQgY2hpbGRyZW4uXG4gICAgICovXG4gICAgUGVyc29uR2VuZXJhdGlvbltcIkFMTE9XX0FMTFwiXSA9IFwiQUxMT1dfQUxMXCI7XG59KShQZXJzb25HZW5lcmF0aW9uIHx8IChQZXJzb25HZW5lcmF0aW9uID0ge30pKTtcbi8qKiBFbnVtIHRoYXQgc3BlY2lmaWVzIHRoZSBsYW5ndWFnZSBvZiB0aGUgdGV4dCBpbiB0aGUgcHJvbXB0LiAqL1xudmFyIEltYWdlUHJvbXB0TGFuZ3VhZ2U7XG4oZnVuY3Rpb24gKEltYWdlUHJvbXB0TGFuZ3VhZ2UpIHtcbiAgICBJbWFnZVByb21wdExhbmd1YWdlW1wiYXV0b1wiXSA9IFwiYXV0b1wiO1xuICAgIEltYWdlUHJvbXB0TGFuZ3VhZ2VbXCJlblwiXSA9IFwiZW5cIjtcbiAgICBJbWFnZVByb21wdExhbmd1YWdlW1wiamFcIl0gPSBcImphXCI7XG4gICAgSW1hZ2VQcm9tcHRMYW5ndWFnZVtcImtvXCJdID0gXCJrb1wiO1xuICAgIEltYWdlUHJvbXB0TGFuZ3VhZ2VbXCJoaVwiXSA9IFwiaGlcIjtcbn0pKEltYWdlUHJvbXB0TGFuZ3VhZ2UgfHwgKEltYWdlUHJvbXB0TGFuZ3VhZ2UgPSB7fSkpO1xuLyoqIEVudW0gcmVwcmVzZW50aW5nIHRoZSBtYXNrIG1vZGUgb2YgYSBtYXNrIHJlZmVyZW5jZSBpbWFnZS4gKi9cbnZhciBNYXNrUmVmZXJlbmNlTW9kZTtcbihmdW5jdGlvbiAoTWFza1JlZmVyZW5jZU1vZGUpIHtcbiAgICBNYXNrUmVmZXJlbmNlTW9kZVtcIk1BU0tfTU9ERV9ERUZBVUxUXCJdID0gXCJNQVNLX01PREVfREVGQVVMVFwiO1xuICAgIE1hc2tSZWZlcmVuY2VNb2RlW1wiTUFTS19NT0RFX1VTRVJfUFJPVklERURcIl0gPSBcIk1BU0tfTU9ERV9VU0VSX1BST1ZJREVEXCI7XG4gICAgTWFza1JlZmVyZW5jZU1vZGVbXCJNQVNLX01PREVfQkFDS0dST1VORFwiXSA9IFwiTUFTS19NT0RFX0JBQ0tHUk9VTkRcIjtcbiAgICBNYXNrUmVmZXJlbmNlTW9kZVtcIk1BU0tfTU9ERV9GT1JFR1JPVU5EXCJdID0gXCJNQVNLX01PREVfRk9SRUdST1VORFwiO1xuICAgIE1hc2tSZWZlcmVuY2VNb2RlW1wiTUFTS19NT0RFX1NFTUFOVElDXCJdID0gXCJNQVNLX01PREVfU0VNQU5USUNcIjtcbn0pKE1hc2tSZWZlcmVuY2VNb2RlIHx8IChNYXNrUmVmZXJlbmNlTW9kZSA9IHt9KSk7XG4vKiogRW51bSByZXByZXNlbnRpbmcgdGhlIGNvbnRyb2wgdHlwZSBvZiBhIGNvbnRyb2wgcmVmZXJlbmNlIGltYWdlLiAqL1xudmFyIENvbnRyb2xSZWZlcmVuY2VUeXBlO1xuKGZ1bmN0aW9uIChDb250cm9sUmVmZXJlbmNlVHlwZSkge1xuICAgIENvbnRyb2xSZWZlcmVuY2VUeXBlW1wiQ09OVFJPTF9UWVBFX0RFRkFVTFRcIl0gPSBcIkNPTlRST0xfVFlQRV9ERUZBVUxUXCI7XG4gICAgQ29udHJvbFJlZmVyZW5jZVR5cGVbXCJDT05UUk9MX1RZUEVfQ0FOTllcIl0gPSBcIkNPTlRST0xfVFlQRV9DQU5OWVwiO1xuICAgIENvbnRyb2xSZWZlcmVuY2VUeXBlW1wiQ09OVFJPTF9UWVBFX1NDUklCQkxFXCJdID0gXCJDT05UUk9MX1RZUEVfU0NSSUJCTEVcIjtcbiAgICBDb250cm9sUmVmZXJlbmNlVHlwZVtcIkNPTlRST0xfVFlQRV9GQUNFX01FU0hcIl0gPSBcIkNPTlRST0xfVFlQRV9GQUNFX01FU0hcIjtcbn0pKENvbnRyb2xSZWZlcmVuY2VUeXBlIHx8IChDb250cm9sUmVmZXJlbmNlVHlwZSA9IHt9KSk7XG4vKiogRW51bSByZXByZXNlbnRpbmcgdGhlIHN1YmplY3QgdHlwZSBvZiBhIHN1YmplY3QgcmVmZXJlbmNlIGltYWdlLiAqL1xudmFyIFN1YmplY3RSZWZlcmVuY2VUeXBlO1xuKGZ1bmN0aW9uIChTdWJqZWN0UmVmZXJlbmNlVHlwZSkge1xuICAgIFN1YmplY3RSZWZlcmVuY2VUeXBlW1wiU1VCSkVDVF9UWVBFX0RFRkFVTFRcIl0gPSBcIlNVQkpFQ1RfVFlQRV9ERUZBVUxUXCI7XG4gICAgU3ViamVjdFJlZmVyZW5jZVR5cGVbXCJTVUJKRUNUX1RZUEVfUEVSU09OXCJdID0gXCJTVUJKRUNUX1RZUEVfUEVSU09OXCI7XG4gICAgU3ViamVjdFJlZmVyZW5jZVR5cGVbXCJTVUJKRUNUX1RZUEVfQU5JTUFMXCJdID0gXCJTVUJKRUNUX1RZUEVfQU5JTUFMXCI7XG4gICAgU3ViamVjdFJlZmVyZW5jZVR5cGVbXCJTVUJKRUNUX1RZUEVfUFJPRFVDVFwiXSA9IFwiU1VCSkVDVF9UWVBFX1BST0RVQ1RcIjtcbn0pKFN1YmplY3RSZWZlcmVuY2VUeXBlIHx8IChTdWJqZWN0UmVmZXJlbmNlVHlwZSA9IHt9KSk7XG4vKiogRW51bSByZXByZXNlbnRpbmcgdGhlIEltYWdlbiAzIEVkaXQgbW9kZS4gKi9cbnZhciBFZGl0TW9kZTtcbihmdW5jdGlvbiAoRWRpdE1vZGUpIHtcbiAgICBFZGl0TW9kZVtcIkVESVRfTU9ERV9ERUZBVUxUXCJdID0gXCJFRElUX01PREVfREVGQVVMVFwiO1xuICAgIEVkaXRNb2RlW1wiRURJVF9NT0RFX0lOUEFJTlRfUkVNT1ZBTFwiXSA9IFwiRURJVF9NT0RFX0lOUEFJTlRfUkVNT1ZBTFwiO1xuICAgIEVkaXRNb2RlW1wiRURJVF9NT0RFX0lOUEFJTlRfSU5TRVJUSU9OXCJdID0gXCJFRElUX01PREVfSU5QQUlOVF9JTlNFUlRJT05cIjtcbiAgICBFZGl0TW9kZVtcIkVESVRfTU9ERV9PVVRQQUlOVFwiXSA9IFwiRURJVF9NT0RFX09VVFBBSU5UXCI7XG4gICAgRWRpdE1vZGVbXCJFRElUX01PREVfQ09OVFJPTExFRF9FRElUSU5HXCJdID0gXCJFRElUX01PREVfQ09OVFJPTExFRF9FRElUSU5HXCI7XG4gICAgRWRpdE1vZGVbXCJFRElUX01PREVfU1RZTEVcIl0gPSBcIkVESVRfTU9ERV9TVFlMRVwiO1xuICAgIEVkaXRNb2RlW1wiRURJVF9NT0RFX0JHU1dBUFwiXSA9IFwiRURJVF9NT0RFX0JHU1dBUFwiO1xuICAgIEVkaXRNb2RlW1wiRURJVF9NT0RFX1BST0RVQ1RfSU1BR0VcIl0gPSBcIkVESVRfTU9ERV9QUk9EVUNUX0lNQUdFXCI7XG59KShFZGl0TW9kZSB8fCAoRWRpdE1vZGUgPSB7fSkpO1xuLyoqIEVudW0gdGhhdCBjb250cm9scyB0aGUgY29tcHJlc3Npb24gcXVhbGl0eSBvZiB0aGUgZ2VuZXJhdGVkIHZpZGVvcy4gKi9cbnZhciBWaWRlb0NvbXByZXNzaW9uUXVhbGl0eTtcbihmdW5jdGlvbiAoVmlkZW9Db21wcmVzc2lvblF1YWxpdHkpIHtcbiAgICAvKipcbiAgICAgKiBPcHRpbWl6ZWQgdmlkZW8gY29tcHJlc3Npb24gcXVhbGl0eS4gVGhpcyB3aWxsIHByb2R1Y2UgdmlkZW9zXG4gICAgICAgIHdpdGggYSBjb21wcmVzc2VkLCBzbWFsbGVyIGZpbGUgc2l6ZS5cbiAgICAgKi9cbiAgICBWaWRlb0NvbXByZXNzaW9uUXVhbGl0eVtcIk9QVElNSVpFRFwiXSA9IFwiT1BUSU1JWkVEXCI7XG4gICAgLyoqXG4gICAgICogTG9zc2xlc3MgdmlkZW8gY29tcHJlc3Npb24gcXVhbGl0eS4gVGhpcyB3aWxsIHByb2R1Y2UgdmlkZW9zXG4gICAgICAgIHdpdGggYSBsYXJnZXIgZmlsZSBzaXplLlxuICAgICAqL1xuICAgIFZpZGVvQ29tcHJlc3Npb25RdWFsaXR5W1wiTE9TU0xFU1NcIl0gPSBcIkxPU1NMRVNTXCI7XG59KShWaWRlb0NvbXByZXNzaW9uUXVhbGl0eSB8fCAoVmlkZW9Db21wcmVzc2lvblF1YWxpdHkgPSB7fSkpO1xuLyoqIFN0YXRlIGZvciB0aGUgbGlmZWN5Y2xlIG9mIGEgRmlsZS4gKi9cbnZhciBGaWxlU3RhdGU7XG4oZnVuY3Rpb24gKEZpbGVTdGF0ZSkge1xuICAgIEZpbGVTdGF0ZVtcIlNUQVRFX1VOU1BFQ0lGSUVEXCJdID0gXCJTVEFURV9VTlNQRUNJRklFRFwiO1xuICAgIEZpbGVTdGF0ZVtcIlBST0NFU1NJTkdcIl0gPSBcIlBST0NFU1NJTkdcIjtcbiAgICBGaWxlU3RhdGVbXCJBQ1RJVkVcIl0gPSBcIkFDVElWRVwiO1xuICAgIEZpbGVTdGF0ZVtcIkZBSUxFRFwiXSA9IFwiRkFJTEVEXCI7XG59KShGaWxlU3RhdGUgfHwgKEZpbGVTdGF0ZSA9IHt9KSk7XG4vKiogU291cmNlIG9mIHRoZSBGaWxlLiAqL1xudmFyIEZpbGVTb3VyY2U7XG4oZnVuY3Rpb24gKEZpbGVTb3VyY2UpIHtcbiAgICBGaWxlU291cmNlW1wiU09VUkNFX1VOU1BFQ0lGSUVEXCJdID0gXCJTT1VSQ0VfVU5TUEVDSUZJRURcIjtcbiAgICBGaWxlU291cmNlW1wiVVBMT0FERURcIl0gPSBcIlVQTE9BREVEXCI7XG4gICAgRmlsZVNvdXJjZVtcIkdFTkVSQVRFRFwiXSA9IFwiR0VORVJBVEVEXCI7XG59KShGaWxlU291cmNlIHx8IChGaWxlU291cmNlID0ge30pKTtcbi8qKiBTZXJ2ZXIgY29udGVudCBtb2RhbGl0aWVzLiAqL1xudmFyIE1lZGlhTW9kYWxpdHk7XG4oZnVuY3Rpb24gKE1lZGlhTW9kYWxpdHkpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgbW9kYWxpdHkgaXMgdW5zcGVjaWZpZWQuXG4gICAgICovXG4gICAgTWVkaWFNb2RhbGl0eVtcIk1PREFMSVRZX1VOU1BFQ0lGSUVEXCJdID0gXCJNT0RBTElUWV9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIFBsYWluIHRleHQuXG4gICAgICovXG4gICAgTWVkaWFNb2RhbGl0eVtcIlRFWFRcIl0gPSBcIlRFWFRcIjtcbiAgICAvKipcbiAgICAgKiBJbWFnZXMuXG4gICAgICovXG4gICAgTWVkaWFNb2RhbGl0eVtcIklNQUdFXCJdID0gXCJJTUFHRVwiO1xuICAgIC8qKlxuICAgICAqIFZpZGVvLlxuICAgICAqL1xuICAgIE1lZGlhTW9kYWxpdHlbXCJWSURFT1wiXSA9IFwiVklERU9cIjtcbiAgICAvKipcbiAgICAgKiBBdWRpby5cbiAgICAgKi9cbiAgICBNZWRpYU1vZGFsaXR5W1wiQVVESU9cIl0gPSBcIkFVRElPXCI7XG4gICAgLyoqXG4gICAgICogRG9jdW1lbnQsIGUuZy4gUERGLlxuICAgICAqL1xuICAgIE1lZGlhTW9kYWxpdHlbXCJET0NVTUVOVFwiXSA9IFwiRE9DVU1FTlRcIjtcbn0pKE1lZGlhTW9kYWxpdHkgfHwgKE1lZGlhTW9kYWxpdHkgPSB7fSkpO1xuLyoqIFN0YXJ0IG9mIHNwZWVjaCBzZW5zaXRpdml0eS4gKi9cbnZhciBTdGFydFNlbnNpdGl2aXR5O1xuKGZ1bmN0aW9uIChTdGFydFNlbnNpdGl2aXR5KSB7XG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgaXMgU1RBUlRfU0VOU0lUSVZJVFlfTE9XLlxuICAgICAqL1xuICAgIFN0YXJ0U2Vuc2l0aXZpdHlbXCJTVEFSVF9TRU5TSVRJVklUWV9VTlNQRUNJRklFRFwiXSA9IFwiU1RBUlRfU0VOU0lUSVZJVFlfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBBdXRvbWF0aWMgZGV0ZWN0aW9uIHdpbGwgZGV0ZWN0IHRoZSBzdGFydCBvZiBzcGVlY2ggbW9yZSBvZnRlbi5cbiAgICAgKi9cbiAgICBTdGFydFNlbnNpdGl2aXR5W1wiU1RBUlRfU0VOU0lUSVZJVFlfSElHSFwiXSA9IFwiU1RBUlRfU0VOU0lUSVZJVFlfSElHSFwiO1xuICAgIC8qKlxuICAgICAqIEF1dG9tYXRpYyBkZXRlY3Rpb24gd2lsbCBkZXRlY3QgdGhlIHN0YXJ0IG9mIHNwZWVjaCBsZXNzIG9mdGVuLlxuICAgICAqL1xuICAgIFN0YXJ0U2Vuc2l0aXZpdHlbXCJTVEFSVF9TRU5TSVRJVklUWV9MT1dcIl0gPSBcIlNUQVJUX1NFTlNJVElWSVRZX0xPV1wiO1xufSkoU3RhcnRTZW5zaXRpdml0eSB8fCAoU3RhcnRTZW5zaXRpdml0eSA9IHt9KSk7XG4vKiogRW5kIG9mIHNwZWVjaCBzZW5zaXRpdml0eS4gKi9cbnZhciBFbmRTZW5zaXRpdml0eTtcbihmdW5jdGlvbiAoRW5kU2Vuc2l0aXZpdHkpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBpcyBFTkRfU0VOU0lUSVZJVFlfTE9XLlxuICAgICAqL1xuICAgIEVuZFNlbnNpdGl2aXR5W1wiRU5EX1NFTlNJVElWSVRZX1VOU1BFQ0lGSUVEXCJdID0gXCJFTkRfU0VOU0lUSVZJVFlfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBBdXRvbWF0aWMgZGV0ZWN0aW9uIGVuZHMgc3BlZWNoIG1vcmUgb2Z0ZW4uXG4gICAgICovXG4gICAgRW5kU2Vuc2l0aXZpdHlbXCJFTkRfU0VOU0lUSVZJVFlfSElHSFwiXSA9IFwiRU5EX1NFTlNJVElWSVRZX0hJR0hcIjtcbiAgICAvKipcbiAgICAgKiBBdXRvbWF0aWMgZGV0ZWN0aW9uIGVuZHMgc3BlZWNoIGxlc3Mgb2Z0ZW4uXG4gICAgICovXG4gICAgRW5kU2Vuc2l0aXZpdHlbXCJFTkRfU0VOU0lUSVZJVFlfTE9XXCJdID0gXCJFTkRfU0VOU0lUSVZJVFlfTE9XXCI7XG59KShFbmRTZW5zaXRpdml0eSB8fCAoRW5kU2Vuc2l0aXZpdHkgPSB7fSkpO1xuLyoqIFRoZSBkaWZmZXJlbnQgd2F5cyBvZiBoYW5kbGluZyB1c2VyIGFjdGl2aXR5LiAqL1xudmFyIEFjdGl2aXR5SGFuZGxpbmc7XG4oZnVuY3Rpb24gKEFjdGl2aXR5SGFuZGxpbmcpIHtcbiAgICAvKipcbiAgICAgKiBJZiB1bnNwZWNpZmllZCwgdGhlIGRlZmF1bHQgYmVoYXZpb3IgaXMgYFNUQVJUX09GX0FDVElWSVRZX0lOVEVSUlVQVFNgLlxuICAgICAqL1xuICAgIEFjdGl2aXR5SGFuZGxpbmdbXCJBQ1RJVklUWV9IQU5ETElOR19VTlNQRUNJRklFRFwiXSA9IFwiQUNUSVZJVFlfSEFORExJTkdfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCBzdGFydCBvZiBhY3Rpdml0eSB3aWxsIGludGVycnVwdCB0aGUgbW9kZWwncyByZXNwb25zZSAoYWxzbyBjYWxsZWQgXCJiYXJnZSBpblwiKS4gVGhlIG1vZGVsJ3MgY3VycmVudCByZXNwb25zZSB3aWxsIGJlIGN1dC1vZmYgaW4gdGhlIG1vbWVudCBvZiB0aGUgaW50ZXJydXB0aW9uLiBUaGlzIGlzIHRoZSBkZWZhdWx0IGJlaGF2aW9yLlxuICAgICAqL1xuICAgIEFjdGl2aXR5SGFuZGxpbmdbXCJTVEFSVF9PRl9BQ1RJVklUWV9JTlRFUlJVUFRTXCJdID0gXCJTVEFSVF9PRl9BQ1RJVklUWV9JTlRFUlJVUFRTXCI7XG4gICAgLyoqXG4gICAgICogVGhlIG1vZGVsJ3MgcmVzcG9uc2Ugd2lsbCBub3QgYmUgaW50ZXJydXB0ZWQuXG4gICAgICovXG4gICAgQWN0aXZpdHlIYW5kbGluZ1tcIk5PX0lOVEVSUlVQVElPTlwiXSA9IFwiTk9fSU5URVJSVVBUSU9OXCI7XG59KShBY3Rpdml0eUhhbmRsaW5nIHx8IChBY3Rpdml0eUhhbmRsaW5nID0ge30pKTtcbi8qKiBPcHRpb25zIGFib3V0IHdoaWNoIGlucHV0IGlzIGluY2x1ZGVkIGluIHRoZSB1c2VyJ3MgdHVybi4gKi9cbnZhciBUdXJuQ292ZXJhZ2U7XG4oZnVuY3Rpb24gKFR1cm5Db3ZlcmFnZSkge1xuICAgIC8qKlxuICAgICAqIElmIHVuc3BlY2lmaWVkLCB0aGUgZGVmYXVsdCBiZWhhdmlvciBpcyBgVFVSTl9JTkNMVURFU19PTkxZX0FDVElWSVRZYC5cbiAgICAgKi9cbiAgICBUdXJuQ292ZXJhZ2VbXCJUVVJOX0NPVkVSQUdFX1VOU1BFQ0lGSUVEXCJdID0gXCJUVVJOX0NPVkVSQUdFX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogVGhlIHVzZXJzIHR1cm4gb25seSBpbmNsdWRlcyBhY3Rpdml0eSBzaW5jZSB0aGUgbGFzdCB0dXJuLCBleGNsdWRpbmcgaW5hY3Rpdml0eSAoZS5nLiBzaWxlbmNlIG9uIHRoZSBhdWRpbyBzdHJlYW0pLiBUaGlzIGlzIHRoZSBkZWZhdWx0IGJlaGF2aW9yLlxuICAgICAqL1xuICAgIFR1cm5Db3ZlcmFnZVtcIlRVUk5fSU5DTFVERVNfT05MWV9BQ1RJVklUWVwiXSA9IFwiVFVSTl9JTkNMVURFU19PTkxZX0FDVElWSVRZXCI7XG4gICAgLyoqXG4gICAgICogVGhlIHVzZXJzIHR1cm4gaW5jbHVkZXMgYWxsIHJlYWx0aW1lIGlucHV0IHNpbmNlIHRoZSBsYXN0IHR1cm4sIGluY2x1ZGluZyBpbmFjdGl2aXR5IChlLmcuIHNpbGVuY2Ugb24gdGhlIGF1ZGlvIHN0cmVhbSkuXG4gICAgICovXG4gICAgVHVybkNvdmVyYWdlW1wiVFVSTl9JTkNMVURFU19BTExfSU5QVVRcIl0gPSBcIlRVUk5fSU5DTFVERVNfQUxMX0lOUFVUXCI7XG59KShUdXJuQ292ZXJhZ2UgfHwgKFR1cm5Db3ZlcmFnZSA9IHt9KSk7XG4vKiogU3BlY2lmaWVzIGhvdyB0aGUgcmVzcG9uc2Ugc2hvdWxkIGJlIHNjaGVkdWxlZCBpbiB0aGUgY29udmVyc2F0aW9uLiAqL1xudmFyIEZ1bmN0aW9uUmVzcG9uc2VTY2hlZHVsaW5nO1xuKGZ1bmN0aW9uIChGdW5jdGlvblJlc3BvbnNlU2NoZWR1bGluZykge1xuICAgIC8qKlxuICAgICAqIFRoaXMgdmFsdWUgaXMgdW51c2VkLlxuICAgICAqL1xuICAgIEZ1bmN0aW9uUmVzcG9uc2VTY2hlZHVsaW5nW1wiU0NIRURVTElOR19VTlNQRUNJRklFRFwiXSA9IFwiU0NIRURVTElOR19VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIE9ubHkgYWRkIHRoZSByZXN1bHQgdG8gdGhlIGNvbnZlcnNhdGlvbiBjb250ZXh0LCBkbyBub3QgaW50ZXJydXB0IG9yIHRyaWdnZXIgZ2VuZXJhdGlvbi5cbiAgICAgKi9cbiAgICBGdW5jdGlvblJlc3BvbnNlU2NoZWR1bGluZ1tcIlNJTEVOVFwiXSA9IFwiU0lMRU5UXCI7XG4gICAgLyoqXG4gICAgICogQWRkIHRoZSByZXN1bHQgdG8gdGhlIGNvbnZlcnNhdGlvbiBjb250ZXh0LCBhbmQgcHJvbXB0IHRvIGdlbmVyYXRlIG91dHB1dCB3aXRob3V0IGludGVycnVwdGluZyBvbmdvaW5nIGdlbmVyYXRpb24uXG4gICAgICovXG4gICAgRnVuY3Rpb25SZXNwb25zZVNjaGVkdWxpbmdbXCJXSEVOX0lETEVcIl0gPSBcIldIRU5fSURMRVwiO1xuICAgIC8qKlxuICAgICAqIEFkZCB0aGUgcmVzdWx0IHRvIHRoZSBjb252ZXJzYXRpb24gY29udGV4dCwgaW50ZXJydXB0IG9uZ29pbmcgZ2VuZXJhdGlvbiBhbmQgcHJvbXB0IHRvIGdlbmVyYXRlIG91dHB1dC5cbiAgICAgKi9cbiAgICBGdW5jdGlvblJlc3BvbnNlU2NoZWR1bGluZ1tcIklOVEVSUlVQVFwiXSA9IFwiSU5URVJSVVBUXCI7XG59KShGdW5jdGlvblJlc3BvbnNlU2NoZWR1bGluZyB8fCAoRnVuY3Rpb25SZXNwb25zZVNjaGVkdWxpbmcgPSB7fSkpO1xuLyoqIFNjYWxlIG9mIHRoZSBnZW5lcmF0ZWQgbXVzaWMuICovXG52YXIgU2NhbGU7XG4oZnVuY3Rpb24gKFNjYWxlKSB7XG4gICAgLyoqXG4gICAgICogRGVmYXVsdCB2YWx1ZS4gVGhpcyB2YWx1ZSBpcyB1bnVzZWQuXG4gICAgICovXG4gICAgU2NhbGVbXCJTQ0FMRV9VTlNQRUNJRklFRFwiXSA9IFwiU0NBTEVfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBDIG1ham9yIG9yIEEgbWlub3IuXG4gICAgICovXG4gICAgU2NhbGVbXCJDX01BSk9SX0FfTUlOT1JcIl0gPSBcIkNfTUFKT1JfQV9NSU5PUlwiO1xuICAgIC8qKlxuICAgICAqIERiIG1ham9yIG9yIEJiIG1pbm9yLlxuICAgICAqL1xuICAgIFNjYWxlW1wiRF9GTEFUX01BSk9SX0JfRkxBVF9NSU5PUlwiXSA9IFwiRF9GTEFUX01BSk9SX0JfRkxBVF9NSU5PUlwiO1xuICAgIC8qKlxuICAgICAqIEQgbWFqb3Igb3IgQiBtaW5vci5cbiAgICAgKi9cbiAgICBTY2FsZVtcIkRfTUFKT1JfQl9NSU5PUlwiXSA9IFwiRF9NQUpPUl9CX01JTk9SXCI7XG4gICAgLyoqXG4gICAgICogRWIgbWFqb3Igb3IgQyBtaW5vclxuICAgICAqL1xuICAgIFNjYWxlW1wiRV9GTEFUX01BSk9SX0NfTUlOT1JcIl0gPSBcIkVfRkxBVF9NQUpPUl9DX01JTk9SXCI7XG4gICAgLyoqXG4gICAgICogRSBtYWpvciBvciBEYiBtaW5vci5cbiAgICAgKi9cbiAgICBTY2FsZVtcIkVfTUFKT1JfRF9GTEFUX01JTk9SXCJdID0gXCJFX01BSk9SX0RfRkxBVF9NSU5PUlwiO1xuICAgIC8qKlxuICAgICAqIEYgbWFqb3Igb3IgRCBtaW5vci5cbiAgICAgKi9cbiAgICBTY2FsZVtcIkZfTUFKT1JfRF9NSU5PUlwiXSA9IFwiRl9NQUpPUl9EX01JTk9SXCI7XG4gICAgLyoqXG4gICAgICogR2IgbWFqb3Igb3IgRWIgbWlub3IuXG4gICAgICovXG4gICAgU2NhbGVbXCJHX0ZMQVRfTUFKT1JfRV9GTEFUX01JTk9SXCJdID0gXCJHX0ZMQVRfTUFKT1JfRV9GTEFUX01JTk9SXCI7XG4gICAgLyoqXG4gICAgICogRyBtYWpvciBvciBFIG1pbm9yLlxuICAgICAqL1xuICAgIFNjYWxlW1wiR19NQUpPUl9FX01JTk9SXCJdID0gXCJHX01BSk9SX0VfTUlOT1JcIjtcbiAgICAvKipcbiAgICAgKiBBYiBtYWpvciBvciBGIG1pbm9yLlxuICAgICAqL1xuICAgIFNjYWxlW1wiQV9GTEFUX01BSk9SX0ZfTUlOT1JcIl0gPSBcIkFfRkxBVF9NQUpPUl9GX01JTk9SXCI7XG4gICAgLyoqXG4gICAgICogQSBtYWpvciBvciBHYiBtaW5vci5cbiAgICAgKi9cbiAgICBTY2FsZVtcIkFfTUFKT1JfR19GTEFUX01JTk9SXCJdID0gXCJBX01BSk9SX0dfRkxBVF9NSU5PUlwiO1xuICAgIC8qKlxuICAgICAqIEJiIG1ham9yIG9yIEcgbWlub3IuXG4gICAgICovXG4gICAgU2NhbGVbXCJCX0ZMQVRfTUFKT1JfR19NSU5PUlwiXSA9IFwiQl9GTEFUX01BSk9SX0dfTUlOT1JcIjtcbiAgICAvKipcbiAgICAgKiBCIG1ham9yIG9yIEFiIG1pbm9yLlxuICAgICAqL1xuICAgIFNjYWxlW1wiQl9NQUpPUl9BX0ZMQVRfTUlOT1JcIl0gPSBcIkJfTUFKT1JfQV9GTEFUX01JTk9SXCI7XG59KShTY2FsZSB8fCAoU2NhbGUgPSB7fSkpO1xuLyoqIFRoZSBwbGF5YmFjayBjb250cm9sIHNpZ25hbCB0byBhcHBseSB0byB0aGUgbXVzaWMgZ2VuZXJhdGlvbi4gKi9cbnZhciBMaXZlTXVzaWNQbGF5YmFja0NvbnRyb2w7XG4oZnVuY3Rpb24gKExpdmVNdXNpY1BsYXliYWNrQ29udHJvbCkge1xuICAgIC8qKlxuICAgICAqIFRoaXMgdmFsdWUgaXMgdW51c2VkLlxuICAgICAqL1xuICAgIExpdmVNdXNpY1BsYXliYWNrQ29udHJvbFtcIlBMQVlCQUNLX0NPTlRST0xfVU5TUEVDSUZJRURcIl0gPSBcIlBMQVlCQUNLX0NPTlRST0xfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBTdGFydCBnZW5lcmF0aW5nIHRoZSBtdXNpYy5cbiAgICAgKi9cbiAgICBMaXZlTXVzaWNQbGF5YmFja0NvbnRyb2xbXCJQTEFZXCJdID0gXCJQTEFZXCI7XG4gICAgLyoqXG4gICAgICogSG9sZCB0aGUgbXVzaWMgZ2VuZXJhdGlvbi4gVXNlIFBMQVkgdG8gcmVzdW1lIGZyb20gdGhlIGN1cnJlbnQgcG9zaXRpb24uXG4gICAgICovXG4gICAgTGl2ZU11c2ljUGxheWJhY2tDb250cm9sW1wiUEFVU0VcIl0gPSBcIlBBVVNFXCI7XG4gICAgLyoqXG4gICAgICogU3RvcCB0aGUgbXVzaWMgZ2VuZXJhdGlvbiBhbmQgcmVzZXQgdGhlIGNvbnRleHQgKHByb21wdHMgcmV0YWluZWQpLlxuICAgICAgICBVc2UgUExBWSB0byByZXN0YXJ0IHRoZSBtdXNpYyBnZW5lcmF0aW9uLlxuICAgICAqL1xuICAgIExpdmVNdXNpY1BsYXliYWNrQ29udHJvbFtcIlNUT1BcIl0gPSBcIlNUT1BcIjtcbiAgICAvKipcbiAgICAgKiBSZXNldCB0aGUgY29udGV4dCBvZiB0aGUgbXVzaWMgZ2VuZXJhdGlvbiB3aXRob3V0IHN0b3BwaW5nIGl0LlxuICAgICAgICBSZXRhaW5zIHRoZSBjdXJyZW50IHByb21wdHMgYW5kIGNvbmZpZy5cbiAgICAgKi9cbiAgICBMaXZlTXVzaWNQbGF5YmFja0NvbnRyb2xbXCJSRVNFVF9DT05URVhUXCJdID0gXCJSRVNFVF9DT05URVhUXCI7XG59KShMaXZlTXVzaWNQbGF5YmFja0NvbnRyb2wgfHwgKExpdmVNdXNpY1BsYXliYWNrQ29udHJvbCA9IHt9KSk7XG4vKiogQSBmdW5jdGlvbiByZXNwb25zZS4gKi9cbmNsYXNzIEZ1bmN0aW9uUmVzcG9uc2Uge1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgYFBhcnRgIG9iamVjdCBmcm9tIGEgYFVSSWAgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBjcmVhdGVQYXJ0RnJvbVVyaSh1cmksIG1pbWVUeXBlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZmlsZURhdGE6IHtcbiAgICAgICAgICAgIGZpbGVVcmk6IHVyaSxcbiAgICAgICAgICAgIG1pbWVUeXBlOiBtaW1lVHlwZSxcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgYFBhcnRgIG9iamVjdCBmcm9tIGEgYHRleHRgIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUGFydEZyb21UZXh0KHRleHQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgIH07XG59XG4vKipcbiAqIENyZWF0ZXMgYSBgUGFydGAgb2JqZWN0IGZyb20gYSBgRnVuY3Rpb25DYWxsYCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVBhcnRGcm9tRnVuY3Rpb25DYWxsKG5hbWUsIGFyZ3MpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBmdW5jdGlvbkNhbGw6IHtcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICBhcmdzOiBhcmdzLFxuICAgICAgICB9LFxuICAgIH07XG59XG4vKipcbiAqIENyZWF0ZXMgYSBgUGFydGAgb2JqZWN0IGZyb20gYSBgRnVuY3Rpb25SZXNwb25zZWAgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBjcmVhdGVQYXJ0RnJvbUZ1bmN0aW9uUmVzcG9uc2UoaWQsIG5hbWUsIHJlc3BvbnNlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZnVuY3Rpb25SZXNwb25zZToge1xuICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgIHJlc3BvbnNlOiByZXNwb25zZSxcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgYFBhcnRgIG9iamVjdCBmcm9tIGEgYGJhc2U2NGAgZW5jb2RlZCBgc3RyaW5nYC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUGFydEZyb21CYXNlNjQoZGF0YSwgbWltZVR5cGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBpbmxpbmVEYXRhOiB7XG4gICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgbWltZVR5cGU6IG1pbWVUeXBlLFxuICAgICAgICB9LFxuICAgIH07XG59XG4vKipcbiAqIENyZWF0ZXMgYSBgUGFydGAgb2JqZWN0IGZyb20gdGhlIGBvdXRjb21lYCBhbmQgYG91dHB1dGAgb2YgYSBgQ29kZUV4ZWN1dGlvblJlc3VsdGAgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBjcmVhdGVQYXJ0RnJvbUNvZGVFeGVjdXRpb25SZXN1bHQob3V0Y29tZSwgb3V0cHV0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29kZUV4ZWN1dGlvblJlc3VsdDoge1xuICAgICAgICAgICAgb3V0Y29tZTogb3V0Y29tZSxcbiAgICAgICAgICAgIG91dHB1dDogb3V0cHV0LFxuICAgICAgICB9LFxuICAgIH07XG59XG4vKipcbiAqIENyZWF0ZXMgYSBgUGFydGAgb2JqZWN0IGZyb20gdGhlIGBjb2RlYCBhbmQgYGxhbmd1YWdlYCBvZiBhbiBgRXhlY3V0YWJsZUNvZGVgIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUGFydEZyb21FeGVjdXRhYmxlQ29kZShjb2RlLCBsYW5ndWFnZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGV4ZWN1dGFibGVDb2RlOiB7XG4gICAgICAgICAgICBjb2RlOiBjb2RlLFxuICAgICAgICAgICAgbGFuZ3VhZ2U6IGxhbmd1YWdlLFxuICAgICAgICB9LFxuICAgIH07XG59XG5mdW5jdGlvbiBfaXNQYXJ0KG9iaikge1xuICAgIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiBvYmogIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICgnZmlsZURhdGEnIGluIG9iaiB8fFxuICAgICAgICAgICAgJ3RleHQnIGluIG9iaiB8fFxuICAgICAgICAgICAgJ2Z1bmN0aW9uQ2FsbCcgaW4gb2JqIHx8XG4gICAgICAgICAgICAnZnVuY3Rpb25SZXNwb25zZScgaW4gb2JqIHx8XG4gICAgICAgICAgICAnaW5saW5lRGF0YScgaW4gb2JqIHx8XG4gICAgICAgICAgICAndmlkZW9NZXRhZGF0YScgaW4gb2JqIHx8XG4gICAgICAgICAgICAnY29kZUV4ZWN1dGlvblJlc3VsdCcgaW4gb2JqIHx8XG4gICAgICAgICAgICAnZXhlY3V0YWJsZUNvZGUnIGluIG9iaik7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIF90b1BhcnRzKHBhcnRPclN0cmluZykge1xuICAgIGNvbnN0IHBhcnRzID0gW107XG4gICAgaWYgKHR5cGVvZiBwYXJ0T3JTdHJpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHBhcnRzLnB1c2goY3JlYXRlUGFydEZyb21UZXh0KHBhcnRPclN0cmluZykpO1xuICAgIH1cbiAgICBlbHNlIGlmIChfaXNQYXJ0KHBhcnRPclN0cmluZykpIHtcbiAgICAgICAgcGFydHMucHVzaChwYXJ0T3JTdHJpbmcpO1xuICAgIH1cbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHBhcnRPclN0cmluZykpIHtcbiAgICAgICAgaWYgKHBhcnRPclN0cmluZy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncGFydE9yU3RyaW5nIGNhbm5vdCBiZSBhbiBlbXB0eSBhcnJheScpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgcGFydCBvZiBwYXJ0T3JTdHJpbmcpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKGNyZWF0ZVBhcnRGcm9tVGV4dChwYXJ0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChfaXNQYXJ0KHBhcnQpKSB7XG4gICAgICAgICAgICAgICAgcGFydHMucHVzaChwYXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZWxlbWVudCBpbiBQYXJ0VW5pb24gbXVzdCBiZSBhIFBhcnQgb2JqZWN0IG9yIHN0cmluZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhcnRPclN0cmluZyBtdXN0IGJlIGEgUGFydCBvYmplY3QsIHN0cmluZywgb3IgYXJyYXknKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnRzO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgYENvbnRlbnRgIG9iamVjdCB3aXRoIGEgdXNlciByb2xlIGZyb20gYSBgUGFydExpc3RVbmlvbmAgb2JqZWN0IG9yIGBzdHJpbmdgLlxuICovXG5mdW5jdGlvbiBjcmVhdGVVc2VyQ29udGVudChwYXJ0T3JTdHJpbmcpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICByb2xlOiAndXNlcicsXG4gICAgICAgIHBhcnRzOiBfdG9QYXJ0cyhwYXJ0T3JTdHJpbmcpLFxuICAgIH07XG59XG4vKipcbiAqIENyZWF0ZXMgYSBgQ29udGVudGAgb2JqZWN0IHdpdGggYSBtb2RlbCByb2xlIGZyb20gYSBgUGFydExpc3RVbmlvbmAgb2JqZWN0IG9yIGBzdHJpbmdgLlxuICovXG5mdW5jdGlvbiBjcmVhdGVNb2RlbENvbnRlbnQocGFydE9yU3RyaW5nKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcm9sZTogJ21vZGVsJyxcbiAgICAgICAgcGFydHM6IF90b1BhcnRzKHBhcnRPclN0cmluZyksXG4gICAgfTtcbn1cbi8qKiBBIHdyYXBwZXIgY2xhc3MgZm9yIHRoZSBodHRwIHJlc3BvbnNlLiAqL1xuY2xhc3MgSHR0cFJlc3BvbnNlIHtcbiAgICBjb25zdHJ1Y3RvcihyZXNwb25zZSkge1xuICAgICAgICAvLyBQcm9jZXNzIHRoZSBoZWFkZXJzLlxuICAgICAgICBjb25zdCBoZWFkZXJzID0ge307XG4gICAgICAgIGZvciAoY29uc3QgcGFpciBvZiByZXNwb25zZS5oZWFkZXJzLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgaGVhZGVyc1twYWlyWzBdXSA9IHBhaXJbMV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oZWFkZXJzID0gaGVhZGVycztcbiAgICAgICAgLy8gS2VlcCB0aGUgb3JpZ2luYWwgcmVzcG9uc2UuXG4gICAgICAgIHRoaXMucmVzcG9uc2VJbnRlcm5hbCA9IHJlc3BvbnNlO1xuICAgIH1cbiAgICBqc29uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNwb25zZUludGVybmFsLmpzb24oKTtcbiAgICB9XG59XG4vKiogQ29udGVudCBmaWx0ZXIgcmVzdWx0cyBmb3IgYSBwcm9tcHQgc2VudCBpbiB0aGUgcmVxdWVzdC4gKi9cbmNsYXNzIEdlbmVyYXRlQ29udGVudFJlc3BvbnNlUHJvbXB0RmVlZGJhY2sge1xufVxuLyoqIFVzYWdlIG1ldGFkYXRhIGFib3V0IHJlc3BvbnNlKHMpLiAqL1xuY2xhc3MgR2VuZXJhdGVDb250ZW50UmVzcG9uc2VVc2FnZU1ldGFkYXRhIHtcbn1cbi8qKiBSZXNwb25zZSBtZXNzYWdlIGZvciBQcmVkaWN0aW9uU2VydmljZS5HZW5lcmF0ZUNvbnRlbnQuICovXG5jbGFzcyBHZW5lcmF0ZUNvbnRlbnRSZXNwb25zZSB7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY29uY2F0ZW5hdGlvbiBvZiBhbGwgdGV4dCBwYXJ0cyBmcm9tIHRoZSBmaXJzdCBjYW5kaWRhdGUgaW4gdGhlIHJlc3BvbnNlLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBJZiB0aGVyZSBhcmUgbXVsdGlwbGUgY2FuZGlkYXRlcyBpbiB0aGUgcmVzcG9uc2UsIHRoZSB0ZXh0IGZyb20gdGhlIGZpcnN0XG4gICAgICogb25lIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAgICogSWYgdGhlcmUgYXJlIG5vbi10ZXh0IHBhcnRzIGluIHRoZSByZXNwb25zZSwgdGhlIGNvbmNhdGVuYXRpb24gb2YgYWxsIHRleHRcbiAgICAgKiBwYXJ0cyB3aWxsIGJlIHJldHVybmVkLCBhbmQgYSB3YXJuaW5nIHdpbGwgYmUgbG9nZ2VkLlxuICAgICAqIElmIHRoZXJlIGFyZSB0aG91Z2h0IHBhcnRzIGluIHRoZSByZXNwb25zZSwgdGhlIGNvbmNhdGVuYXRpb24gb2YgYWxsIHRleHRcbiAgICAgKiBwYXJ0cyBleGNsdWRpbmcgdGhlIHRob3VnaHQgcGFydHMgd2lsbCBiZSByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFpLm1vZGVscy5nZW5lcmF0ZUNvbnRlbnQoe1xuICAgICAqICAgbW9kZWw6ICdnZW1pbmktMi4wLWZsYXNoJyxcbiAgICAgKiAgIGNvbnRlbnRzOlxuICAgICAqICAgICAnV2h5IGlzIHRoZSBza3kgYmx1ZT8nLFxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogY29uc29sZS5kZWJ1ZyhyZXNwb25zZS50ZXh0KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBnZXQgdGV4dCgpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaDtcbiAgICAgICAgaWYgKCgoX2QgPSAoX2MgPSAoX2IgPSAoX2EgPSB0aGlzLmNhbmRpZGF0ZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVswXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNvbnRlbnQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5wYXJ0cykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmxlbmd0aCkgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2FuZGlkYXRlcyAmJiB0aGlzLmNhbmRpZGF0ZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCd0aGVyZSBhcmUgbXVsdGlwbGUgY2FuZGlkYXRlcyBpbiB0aGUgcmVzcG9uc2UsIHJldHVybmluZyB0ZXh0IGZyb20gdGhlIGZpcnN0IG9uZS4nKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdGV4dCA9ICcnO1xuICAgICAgICBsZXQgYW55VGV4dFBhcnRUZXh0ID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IG5vblRleHRQYXJ0cyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgKF9oID0gKF9nID0gKF9mID0gKF9lID0gdGhpcy5jYW5kaWRhdGVzKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2VbMF0pID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5jb250ZW50KSA9PT0gbnVsbCB8fCBfZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2cucGFydHMpICE9PSBudWxsICYmIF9oICE9PSB2b2lkIDAgPyBfaCA6IFtdKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtmaWVsZE5hbWUsIGZpZWxkVmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHBhcnQpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkTmFtZSAhPT0gJ3RleHQnICYmXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkTmFtZSAhPT0gJ3Rob3VnaHQnICYmXG4gICAgICAgICAgICAgICAgICAgIChmaWVsZFZhbHVlICE9PSBudWxsIHx8IGZpZWxkVmFsdWUgIT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9uVGV4dFBhcnRzLnB1c2goZmllbGROYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHBhcnQudGV4dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHBhcnQudGhvdWdodCA9PT0gJ2Jvb2xlYW4nICYmIHBhcnQudGhvdWdodCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYW55VGV4dFBhcnRUZXh0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0ZXh0ICs9IHBhcnQudGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobm9uVGV4dFBhcnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgdGhlcmUgYXJlIG5vbi10ZXh0IHBhcnRzICR7bm9uVGV4dFBhcnRzfSBpbiB0aGUgcmVzcG9uc2UsIHJldHVybmluZyBjb25jYXRlbmF0aW9uIG9mIGFsbCB0ZXh0IHBhcnRzLiBQbGVhc2UgcmVmZXIgdG8gdGhlIG5vbiB0ZXh0IHBhcnRzIGZvciBhIGZ1bGwgcmVzcG9uc2UgZnJvbSBtb2RlbC5gKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBwYXJ0LnRleHQgPT09ICcnIGlzIGRpZmZlcmVudCBmcm9tIHBhcnQudGV4dCBpcyBudWxsXG4gICAgICAgIHJldHVybiBhbnlUZXh0UGFydFRleHQgPyB0ZXh0IDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjb25jYXRlbmF0aW9uIG9mIGFsbCBpbmxpbmUgZGF0YSBwYXJ0cyBmcm9tIHRoZSBmaXJzdCBjYW5kaWRhdGVcbiAgICAgKiBpbiB0aGUgcmVzcG9uc2UuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIElmIHRoZXJlIGFyZSBtdWx0aXBsZSBjYW5kaWRhdGVzIGluIHRoZSByZXNwb25zZSwgdGhlIGlubGluZSBkYXRhIGZyb20gdGhlXG4gICAgICogZmlyc3Qgb25lIHdpbGwgYmUgcmV0dXJuZWQuIElmIHRoZXJlIGFyZSBub24taW5saW5lIGRhdGEgcGFydHMgaW4gdGhlXG4gICAgICogcmVzcG9uc2UsIHRoZSBjb25jYXRlbmF0aW9uIG9mIGFsbCBpbmxpbmUgZGF0YSBwYXJ0cyB3aWxsIGJlIHJldHVybmVkLCBhbmRcbiAgICAgKiBhIHdhcm5pbmcgd2lsbCBiZSBsb2dnZWQuXG4gICAgICovXG4gICAgZ2V0IGRhdGEoKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2g7XG4gICAgICAgIGlmICgoKF9kID0gKF9jID0gKF9iID0gKF9hID0gdGhpcy5jYW5kaWRhdGVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbMF0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jb250ZW50KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MucGFydHMpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5sZW5ndGgpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNhbmRpZGF0ZXMgJiYgdGhpcy5jYW5kaWRhdGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybigndGhlcmUgYXJlIG11bHRpcGxlIGNhbmRpZGF0ZXMgaW4gdGhlIHJlc3BvbnNlLCByZXR1cm5pbmcgZGF0YSBmcm9tIHRoZSBmaXJzdCBvbmUuJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRhdGEgPSAnJztcbiAgICAgICAgY29uc3Qgbm9uRGF0YVBhcnRzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcGFydCBvZiAoX2ggPSAoX2cgPSAoX2YgPSAoX2UgPSB0aGlzLmNhbmRpZGF0ZXMpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZVswXSkgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLmNvbnRlbnQpID09PSBudWxsIHx8IF9nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZy5wYXJ0cykgIT09IG51bGwgJiYgX2ggIT09IHZvaWQgMCA/IF9oIDogW10pIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2ZpZWxkTmFtZSwgZmllbGRWYWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocGFydCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmllbGROYW1lICE9PSAnaW5saW5lRGF0YScgJiZcbiAgICAgICAgICAgICAgICAgICAgKGZpZWxkVmFsdWUgIT09IG51bGwgfHwgZmllbGRWYWx1ZSAhPT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgICAgICAgICBub25EYXRhUGFydHMucHVzaChmaWVsZE5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJ0LmlubGluZURhdGEgJiYgdHlwZW9mIHBhcnQuaW5saW5lRGF0YS5kYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGRhdGEgKz0gYXRvYihwYXJ0LmlubGluZURhdGEuZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vbkRhdGFQYXJ0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYHRoZXJlIGFyZSBub24tZGF0YSBwYXJ0cyAke25vbkRhdGFQYXJ0c30gaW4gdGhlIHJlc3BvbnNlLCByZXR1cm5pbmcgY29uY2F0ZW5hdGlvbiBvZiBhbGwgZGF0YSBwYXJ0cy4gUGxlYXNlIHJlZmVyIHRvIHRoZSBub24gZGF0YSBwYXJ0cyBmb3IgYSBmdWxsIHJlc3BvbnNlIGZyb20gbW9kZWwuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGEubGVuZ3RoID4gMCA/IGJ0b2EoZGF0YSkgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGZ1bmN0aW9uIGNhbGxzIGZyb20gdGhlIGZpcnN0IGNhbmRpZGF0ZSBpbiB0aGUgcmVzcG9uc2UuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIElmIHRoZXJlIGFyZSBtdWx0aXBsZSBjYW5kaWRhdGVzIGluIHRoZSByZXNwb25zZSwgdGhlIGZ1bmN0aW9uIGNhbGxzIGZyb21cbiAgICAgKiB0aGUgZmlyc3Qgb25lIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAgICogSWYgdGhlcmUgYXJlIG5vIGZ1bmN0aW9uIGNhbGxzIGluIHRoZSByZXNwb25zZSwgdW5kZWZpbmVkIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgY29udHJvbExpZ2h0RnVuY3Rpb25EZWNsYXJhdGlvbjogRnVuY3Rpb25EZWNsYXJhdGlvbiA9IHtcbiAgICAgKiAgIG5hbWU6ICdjb250cm9sTGlnaHQnLFxuICAgICAqICAgcGFyYW1ldGVyczoge1xuICAgICAqICAgdHlwZTogVHlwZS5PQkpFQ1QsXG4gICAgICogICBkZXNjcmlwdGlvbjogJ1NldCB0aGUgYnJpZ2h0bmVzcyBhbmQgY29sb3IgdGVtcGVyYXR1cmUgb2YgYSByb29tIGxpZ2h0LicsXG4gICAgICogICBwcm9wZXJ0aWVzOiB7XG4gICAgICogICAgIGJyaWdodG5lc3M6IHtcbiAgICAgKiAgICAgICB0eXBlOiBUeXBlLk5VTUJFUixcbiAgICAgKiAgICAgICBkZXNjcmlwdGlvbjpcbiAgICAgKiAgICAgICAgICdMaWdodCBsZXZlbCBmcm9tIDAgdG8gMTAwLiBaZXJvIGlzIG9mZiBhbmQgMTAwIGlzIGZ1bGwgYnJpZ2h0bmVzcy4nLFxuICAgICAqICAgICB9LFxuICAgICAqICAgICBjb2xvclRlbXBlcmF0dXJlOiB7XG4gICAgICogICAgICAgdHlwZTogVHlwZS5TVFJJTkcsXG4gICAgICogICAgICAgZGVzY3JpcHRpb246XG4gICAgICogICAgICAgICAnQ29sb3IgdGVtcGVyYXR1cmUgb2YgdGhlIGxpZ2h0IGZpeHR1cmUgd2hpY2ggY2FuIGJlIGBkYXlsaWdodGAsIGBjb29sYCBvciBgd2FybWAuJyxcbiAgICAgKiAgICAgfSxcbiAgICAgKiAgIH0sXG4gICAgICogICByZXF1aXJlZDogWydicmlnaHRuZXNzJywgJ2NvbG9yVGVtcGVyYXR1cmUnXSxcbiAgICAgKiAgfTtcbiAgICAgKiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhaS5tb2RlbHMuZ2VuZXJhdGVDb250ZW50KHtcbiAgICAgKiAgICAgbW9kZWw6ICdnZW1pbmktMi4wLWZsYXNoJyxcbiAgICAgKiAgICAgY29udGVudHM6ICdEaW0gdGhlIGxpZ2h0cyBzbyB0aGUgcm9vbSBmZWVscyBjb3p5IGFuZCB3YXJtLicsXG4gICAgICogICAgIGNvbmZpZzoge1xuICAgICAqICAgICAgIHRvb2xzOiBbe2Z1bmN0aW9uRGVjbGFyYXRpb25zOiBbY29udHJvbExpZ2h0RnVuY3Rpb25EZWNsYXJhdGlvbl19XSxcbiAgICAgKiAgICAgICB0b29sQ29uZmlnOiB7XG4gICAgICogICAgICAgICBmdW5jdGlvbkNhbGxpbmdDb25maWc6IHtcbiAgICAgKiAgICAgICAgICAgbW9kZTogRnVuY3Rpb25DYWxsaW5nQ29uZmlnTW9kZS5BTlksXG4gICAgICogICAgICAgICAgIGFsbG93ZWRGdW5jdGlvbk5hbWVzOiBbJ2NvbnRyb2xMaWdodCddLFxuICAgICAqICAgICAgICAgfSxcbiAgICAgKiAgICAgICB9LFxuICAgICAqICAgICB9LFxuICAgICAqICAgfSk7XG4gICAgICogIGNvbnNvbGUuZGVidWcoSlNPTi5zdHJpbmdpZnkocmVzcG9uc2UuZnVuY3Rpb25DYWxscykpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGdldCBmdW5jdGlvbkNhbGxzKCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oO1xuICAgICAgICBpZiAoKChfZCA9IChfYyA9IChfYiA9IChfYSA9IHRoaXMuY2FuZGlkYXRlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWzBdKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY29udGVudCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnBhcnRzKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QubGVuZ3RoKSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jYW5kaWRhdGVzICYmIHRoaXMuY2FuZGlkYXRlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ3RoZXJlIGFyZSBtdWx0aXBsZSBjYW5kaWRhdGVzIGluIHRoZSByZXNwb25zZSwgcmV0dXJuaW5nIGZ1bmN0aW9uIGNhbGxzIGZyb20gdGhlIGZpcnN0IG9uZS4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmdW5jdGlvbkNhbGxzID0gKF9oID0gKF9nID0gKF9mID0gKF9lID0gdGhpcy5jYW5kaWRhdGVzKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2VbMF0pID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5jb250ZW50KSA9PT0gbnVsbCB8fCBfZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2cucGFydHMpID09PSBudWxsIHx8IF9oID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaC5maWx0ZXIoKHBhcnQpID0+IHBhcnQuZnVuY3Rpb25DYWxsKS5tYXAoKHBhcnQpID0+IHBhcnQuZnVuY3Rpb25DYWxsKS5maWx0ZXIoKGZ1bmN0aW9uQ2FsbCkgPT4gZnVuY3Rpb25DYWxsICE9PSB1bmRlZmluZWQpO1xuICAgICAgICBpZiAoKGZ1bmN0aW9uQ2FsbHMgPT09IG51bGwgfHwgZnVuY3Rpb25DYWxscyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZnVuY3Rpb25DYWxscy5sZW5ndGgpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbkNhbGxzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBleGVjdXRhYmxlIGNvZGUgZnJvbSB0aGUgZmlyc3QgY2FuZGlkYXRlIGluIHRoZSByZXNwb25zZS5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogSWYgdGhlcmUgYXJlIG11bHRpcGxlIGNhbmRpZGF0ZXMgaW4gdGhlIHJlc3BvbnNlLCB0aGUgZXhlY3V0YWJsZSBjb2RlIGZyb21cbiAgICAgKiB0aGUgZmlyc3Qgb25lIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAgICogSWYgdGhlcmUgYXJlIG5vIGV4ZWN1dGFibGUgY29kZSBpbiB0aGUgcmVzcG9uc2UsIHVuZGVmaW5lZCB3aWxsIGJlXG4gICAgICogcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhaS5tb2RlbHMuZ2VuZXJhdGVDb250ZW50KHtcbiAgICAgKiAgIG1vZGVsOiAnZ2VtaW5pLTIuMC1mbGFzaCcsXG4gICAgICogICBjb250ZW50czpcbiAgICAgKiAgICAgJ1doYXQgaXMgdGhlIHN1bSBvZiB0aGUgZmlyc3QgNTAgcHJpbWUgbnVtYmVycz8gR2VuZXJhdGUgYW5kIHJ1biBjb2RlIGZvciB0aGUgY2FsY3VsYXRpb24sIGFuZCBtYWtlIHN1cmUgeW91IGdldCBhbGwgNTAuJ1xuICAgICAqICAgY29uZmlnOiB7XG4gICAgICogICAgIHRvb2xzOiBbe2NvZGVFeGVjdXRpb246IHt9fV0sXG4gICAgICogICB9LFxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogY29uc29sZS5kZWJ1ZyhyZXNwb25zZS5leGVjdXRhYmxlQ29kZSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZ2V0IGV4ZWN1dGFibGVDb2RlKCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfajtcbiAgICAgICAgaWYgKCgoX2QgPSAoX2MgPSAoX2IgPSAoX2EgPSB0aGlzLmNhbmRpZGF0ZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVswXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNvbnRlbnQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5wYXJ0cykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmxlbmd0aCkgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2FuZGlkYXRlcyAmJiB0aGlzLmNhbmRpZGF0ZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCd0aGVyZSBhcmUgbXVsdGlwbGUgY2FuZGlkYXRlcyBpbiB0aGUgcmVzcG9uc2UsIHJldHVybmluZyBleGVjdXRhYmxlIGNvZGUgZnJvbSB0aGUgZmlyc3Qgb25lLicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV4ZWN1dGFibGVDb2RlID0gKF9oID0gKF9nID0gKF9mID0gKF9lID0gdGhpcy5jYW5kaWRhdGVzKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2VbMF0pID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5jb250ZW50KSA9PT0gbnVsbCB8fCBfZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2cucGFydHMpID09PSBudWxsIHx8IF9oID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaC5maWx0ZXIoKHBhcnQpID0+IHBhcnQuZXhlY3V0YWJsZUNvZGUpLm1hcCgocGFydCkgPT4gcGFydC5leGVjdXRhYmxlQ29kZSkuZmlsdGVyKChleGVjdXRhYmxlQ29kZSkgPT4gZXhlY3V0YWJsZUNvZGUgIT09IHVuZGVmaW5lZCk7XG4gICAgICAgIGlmICgoZXhlY3V0YWJsZUNvZGUgPT09IG51bGwgfHwgZXhlY3V0YWJsZUNvZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGV4ZWN1dGFibGVDb2RlLmxlbmd0aCkgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChfaiA9IGV4ZWN1dGFibGVDb2RlID09PSBudWxsIHx8IGV4ZWN1dGFibGVDb2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBleGVjdXRhYmxlQ29kZVswXSkgPT09IG51bGwgfHwgX2ogPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9qLmNvZGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGZpcnN0IGNvZGUgZXhlY3V0aW9uIHJlc3VsdCBmcm9tIHRoZSBmaXJzdCBjYW5kaWRhdGUgaW4gdGhlIHJlc3BvbnNlLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBJZiB0aGVyZSBhcmUgbXVsdGlwbGUgY2FuZGlkYXRlcyBpbiB0aGUgcmVzcG9uc2UsIHRoZSBjb2RlIGV4ZWN1dGlvbiByZXN1bHQgZnJvbVxuICAgICAqIHRoZSBmaXJzdCBvbmUgd2lsbCBiZSByZXR1cm5lZC5cbiAgICAgKiBJZiB0aGVyZSBhcmUgbm8gY29kZSBleGVjdXRpb24gcmVzdWx0IGluIHRoZSByZXNwb25zZSwgdW5kZWZpbmVkIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhaS5tb2RlbHMuZ2VuZXJhdGVDb250ZW50KHtcbiAgICAgKiAgIG1vZGVsOiAnZ2VtaW5pLTIuMC1mbGFzaCcsXG4gICAgICogICBjb250ZW50czpcbiAgICAgKiAgICAgJ1doYXQgaXMgdGhlIHN1bSBvZiB0aGUgZmlyc3QgNTAgcHJpbWUgbnVtYmVycz8gR2VuZXJhdGUgYW5kIHJ1biBjb2RlIGZvciB0aGUgY2FsY3VsYXRpb24sIGFuZCBtYWtlIHN1cmUgeW91IGdldCBhbGwgNTAuJ1xuICAgICAqICAgY29uZmlnOiB7XG4gICAgICogICAgIHRvb2xzOiBbe2NvZGVFeGVjdXRpb246IHt9fV0sXG4gICAgICogICB9LFxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogY29uc29sZS5kZWJ1ZyhyZXNwb25zZS5jb2RlRXhlY3V0aW9uUmVzdWx0KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBnZXQgY29kZUV4ZWN1dGlvblJlc3VsdCgpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaCwgX2o7XG4gICAgICAgIGlmICgoKF9kID0gKF9jID0gKF9iID0gKF9hID0gdGhpcy5jYW5kaWRhdGVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbMF0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jb250ZW50KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MucGFydHMpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5sZW5ndGgpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNhbmRpZGF0ZXMgJiYgdGhpcy5jYW5kaWRhdGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybigndGhlcmUgYXJlIG11bHRpcGxlIGNhbmRpZGF0ZXMgaW4gdGhlIHJlc3BvbnNlLCByZXR1cm5pbmcgY29kZSBleGVjdXRpb24gcmVzdWx0IGZyb20gdGhlIGZpcnN0IG9uZS4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb2RlRXhlY3V0aW9uUmVzdWx0ID0gKF9oID0gKF9nID0gKF9mID0gKF9lID0gdGhpcy5jYW5kaWRhdGVzKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2VbMF0pID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5jb250ZW50KSA9PT0gbnVsbCB8fCBfZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2cucGFydHMpID09PSBudWxsIHx8IF9oID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaC5maWx0ZXIoKHBhcnQpID0+IHBhcnQuY29kZUV4ZWN1dGlvblJlc3VsdCkubWFwKChwYXJ0KSA9PiBwYXJ0LmNvZGVFeGVjdXRpb25SZXN1bHQpLmZpbHRlcigoY29kZUV4ZWN1dGlvblJlc3VsdCkgPT4gY29kZUV4ZWN1dGlvblJlc3VsdCAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgaWYgKChjb2RlRXhlY3V0aW9uUmVzdWx0ID09PSBudWxsIHx8IGNvZGVFeGVjdXRpb25SZXN1bHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvZGVFeGVjdXRpb25SZXN1bHQubGVuZ3RoKSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKF9qID0gY29kZUV4ZWN1dGlvblJlc3VsdCA9PT0gbnVsbCB8fCBjb2RlRXhlY3V0aW9uUmVzdWx0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb2RlRXhlY3V0aW9uUmVzdWx0WzBdKSA9PT0gbnVsbCB8fCBfaiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2oub3V0cHV0O1xuICAgIH1cbn1cbi8qKiBSZXNwb25zZSBmb3IgdGhlIGVtYmVkX2NvbnRlbnQgbWV0aG9kLiAqL1xuY2xhc3MgRW1iZWRDb250ZW50UmVzcG9uc2Uge1xufVxuLyoqIFRoZSBvdXRwdXQgaW1hZ2VzIHJlc3BvbnNlLiAqL1xuY2xhc3MgR2VuZXJhdGVJbWFnZXNSZXNwb25zZSB7XG59XG4vKiogUmVzcG9uc2UgZm9yIHRoZSByZXF1ZXN0IHRvIGVkaXQgYW4gaW1hZ2UuICovXG5jbGFzcyBFZGl0SW1hZ2VSZXNwb25zZSB7XG59XG5jbGFzcyBVcHNjYWxlSW1hZ2VSZXNwb25zZSB7XG59XG5jbGFzcyBMaXN0TW9kZWxzUmVzcG9uc2Uge1xufVxuY2xhc3MgRGVsZXRlTW9kZWxSZXNwb25zZSB7XG59XG4vKiogUmVzcG9uc2UgZm9yIGNvdW50aW5nIHRva2Vucy4gKi9cbmNsYXNzIENvdW50VG9rZW5zUmVzcG9uc2Uge1xufVxuLyoqIFJlc3BvbnNlIGZvciBjb21wdXRpbmcgdG9rZW5zLiAqL1xuY2xhc3MgQ29tcHV0ZVRva2Vuc1Jlc3BvbnNlIHtcbn1cbi8qKiBSZXNwb25zZSB3aXRoIGdlbmVyYXRlZCB2aWRlb3MuICovXG5jbGFzcyBHZW5lcmF0ZVZpZGVvc1Jlc3BvbnNlIHtcbn1cbi8qKiBSZXNwb25zZSBmb3IgdGhlIGxpc3QgdHVuaW5nIGpvYnMgbWV0aG9kLiAqL1xuY2xhc3MgTGlzdFR1bmluZ0pvYnNSZXNwb25zZSB7XG59XG4vKiogRW1wdHkgcmVzcG9uc2UgZm9yIGNhY2hlcy5kZWxldGUgbWV0aG9kLiAqL1xuY2xhc3MgRGVsZXRlQ2FjaGVkQ29udGVudFJlc3BvbnNlIHtcbn1cbmNsYXNzIExpc3RDYWNoZWRDb250ZW50c1Jlc3BvbnNlIHtcbn1cbi8qKiBSZXNwb25zZSBmb3IgdGhlIGxpc3QgZmlsZXMgbWV0aG9kLiAqL1xuY2xhc3MgTGlzdEZpbGVzUmVzcG9uc2Uge1xufVxuLyoqIFJlc3BvbnNlIGZvciB0aGUgY3JlYXRlIGZpbGUgbWV0aG9kLiAqL1xuY2xhc3MgQ3JlYXRlRmlsZVJlc3BvbnNlIHtcbn1cbi8qKiBSZXNwb25zZSBmb3IgdGhlIGRlbGV0ZSBmaWxlIG1ldGhvZC4gKi9cbmNsYXNzIERlbGV0ZUZpbGVSZXNwb25zZSB7XG59XG4vKiogQ29uZmlnIGZvciBgaW5saW5lZF9yZXNwb25zZXNgIHBhcmFtZXRlci4gKi9cbmNsYXNzIElubGluZWRSZXNwb25zZSB7XG59XG4vKiogQ29uZmlnIGZvciBiYXRjaGVzLmxpc3QgcmV0dXJuIHZhbHVlLiAqL1xuY2xhc3MgTGlzdEJhdGNoSm9ic1Jlc3BvbnNlIHtcbn1cbi8qKiBSZXByZXNlbnRzIGEgc2luZ2xlIHJlc3BvbnNlIGluIGEgcmVwbGF5LiAqL1xuY2xhc3MgUmVwbGF5UmVzcG9uc2Uge1xufVxuLyoqIEEgcmF3IHJlZmVyZW5jZSBpbWFnZS5cblxuICBBIHJhdyByZWZlcmVuY2UgaW1hZ2UgcmVwcmVzZW50cyB0aGUgYmFzZSBpbWFnZSB0byBlZGl0LCBwcm92aWRlZCBieSB0aGUgdXNlci5cbiAgSXQgY2FuIG9wdGlvbmFsbHkgYmUgcHJvdmlkZWQgaW4gYWRkaXRpb24gdG8gYSBtYXNrIHJlZmVyZW5jZSBpbWFnZSBvclxuICBhIHN0eWxlIHJlZmVyZW5jZSBpbWFnZS5cbiAgICovXG5jbGFzcyBSYXdSZWZlcmVuY2VJbWFnZSB7XG4gICAgLyoqIEludGVybmFsIG1ldGhvZCB0byBjb252ZXJ0IHRvIFJlZmVyZW5jZUltYWdlQVBJSW50ZXJuYWwuICovXG4gICAgdG9SZWZlcmVuY2VJbWFnZUFQSSgpIHtcbiAgICAgICAgY29uc3QgcmVmZXJlbmNlSW1hZ2VBUEkgPSB7XG4gICAgICAgICAgICByZWZlcmVuY2VUeXBlOiAnUkVGRVJFTkNFX1RZUEVfUkFXJyxcbiAgICAgICAgICAgIHJlZmVyZW5jZUltYWdlOiB0aGlzLnJlZmVyZW5jZUltYWdlLFxuICAgICAgICAgICAgcmVmZXJlbmNlSWQ6IHRoaXMucmVmZXJlbmNlSWQsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByZWZlcmVuY2VJbWFnZUFQSTtcbiAgICB9XG59XG4vKiogQSBtYXNrIHJlZmVyZW5jZSBpbWFnZS5cblxuICBUaGlzIGVuY2Fwc3VsYXRlcyBlaXRoZXIgYSBtYXNrIGltYWdlIHByb3ZpZGVkIGJ5IHRoZSB1c2VyIGFuZCBjb25maWdzIGZvclxuICB0aGUgdXNlciBwcm92aWRlZCBtYXNrLCBvciBvbmx5IGNvbmZpZyBwYXJhbWV0ZXJzIGZvciB0aGUgbW9kZWwgdG8gZ2VuZXJhdGVcbiAgYSBtYXNrLlxuXG4gIEEgbWFzayBpbWFnZSBpcyBhbiBpbWFnZSB3aG9zZSBub24temVybyB2YWx1ZXMgaW5kaWNhdGUgd2hlcmUgdG8gZWRpdCB0aGUgYmFzZVxuICBpbWFnZS4gSWYgdGhlIHVzZXIgcHJvdmlkZXMgYSBtYXNrIGltYWdlLCB0aGUgbWFzayBtdXN0IGJlIGluIHRoZSBzYW1lXG4gIGRpbWVuc2lvbnMgYXMgdGhlIHJhdyBpbWFnZS5cbiAgICovXG5jbGFzcyBNYXNrUmVmZXJlbmNlSW1hZ2Uge1xuICAgIC8qKiBJbnRlcm5hbCBtZXRob2QgdG8gY29udmVydCB0byBSZWZlcmVuY2VJbWFnZUFQSUludGVybmFsLiAqL1xuICAgIHRvUmVmZXJlbmNlSW1hZ2VBUEkoKSB7XG4gICAgICAgIGNvbnN0IHJlZmVyZW5jZUltYWdlQVBJID0ge1xuICAgICAgICAgICAgcmVmZXJlbmNlVHlwZTogJ1JFRkVSRU5DRV9UWVBFX01BU0snLFxuICAgICAgICAgICAgcmVmZXJlbmNlSW1hZ2U6IHRoaXMucmVmZXJlbmNlSW1hZ2UsXG4gICAgICAgICAgICByZWZlcmVuY2VJZDogdGhpcy5yZWZlcmVuY2VJZCxcbiAgICAgICAgICAgIG1hc2tJbWFnZUNvbmZpZzogdGhpcy5jb25maWcsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByZWZlcmVuY2VJbWFnZUFQSTtcbiAgICB9XG59XG4vKiogQSBjb250cm9sIHJlZmVyZW5jZSBpbWFnZS5cblxuICBUaGUgaW1hZ2Ugb2YgdGhlIGNvbnRyb2wgcmVmZXJlbmNlIGltYWdlIGlzIGVpdGhlciBhIGNvbnRyb2wgaW1hZ2UgcHJvdmlkZWRcbiAgYnkgdGhlIHVzZXIsIG9yIGEgcmVndWxhciBpbWFnZSB3aGljaCB0aGUgYmFja2VuZCB3aWxsIHVzZSB0byBnZW5lcmF0ZSBhXG4gIGNvbnRyb2wgaW1hZ2Ugb2YuIEluIHRoZSBjYXNlIG9mIHRoZSBsYXR0ZXIsIHRoZVxuICBlbmFibGVfY29udHJvbF9pbWFnZV9jb21wdXRhdGlvbiBmaWVsZCBpbiB0aGUgY29uZmlnIHNob3VsZCBiZSBzZXQgdG8gVHJ1ZS5cblxuICBBIGNvbnRyb2wgaW1hZ2UgaXMgYW4gaW1hZ2UgdGhhdCByZXByZXNlbnRzIGEgc2tldGNoIGltYWdlIG9mIGFyZWFzIGZvciB0aGVcbiAgbW9kZWwgdG8gZmlsbCBpbiBiYXNlZCBvbiB0aGUgcHJvbXB0LlxuICAgKi9cbmNsYXNzIENvbnRyb2xSZWZlcmVuY2VJbWFnZSB7XG4gICAgLyoqIEludGVybmFsIG1ldGhvZCB0byBjb252ZXJ0IHRvIFJlZmVyZW5jZUltYWdlQVBJSW50ZXJuYWwuICovXG4gICAgdG9SZWZlcmVuY2VJbWFnZUFQSSgpIHtcbiAgICAgICAgY29uc3QgcmVmZXJlbmNlSW1hZ2VBUEkgPSB7XG4gICAgICAgICAgICByZWZlcmVuY2VUeXBlOiAnUkVGRVJFTkNFX1RZUEVfQ09OVFJPTCcsXG4gICAgICAgICAgICByZWZlcmVuY2VJbWFnZTogdGhpcy5yZWZlcmVuY2VJbWFnZSxcbiAgICAgICAgICAgIHJlZmVyZW5jZUlkOiB0aGlzLnJlZmVyZW5jZUlkLFxuICAgICAgICAgICAgY29udHJvbEltYWdlQ29uZmlnOiB0aGlzLmNvbmZpZyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJlZmVyZW5jZUltYWdlQVBJO1xuICAgIH1cbn1cbi8qKiBBIHN0eWxlIHJlZmVyZW5jZSBpbWFnZS5cblxuICBUaGlzIGVuY2Fwc3VsYXRlcyBhIHN0eWxlIHJlZmVyZW5jZSBpbWFnZSBwcm92aWRlZCBieSB0aGUgdXNlciwgYW5kXG4gIGFkZGl0aW9uYWxseSBvcHRpb25hbCBjb25maWcgcGFyYW1ldGVycyBmb3IgdGhlIHN0eWxlIHJlZmVyZW5jZSBpbWFnZS5cblxuICBBIHJhdyByZWZlcmVuY2UgaW1hZ2UgY2FuIGFsc28gYmUgcHJvdmlkZWQgYXMgYSBkZXN0aW5hdGlvbiBmb3IgdGhlIHN0eWxlIHRvXG4gIGJlIGFwcGxpZWQgdG8uXG4gICAqL1xuY2xhc3MgU3R5bGVSZWZlcmVuY2VJbWFnZSB7XG4gICAgLyoqIEludGVybmFsIG1ldGhvZCB0byBjb252ZXJ0IHRvIFJlZmVyZW5jZUltYWdlQVBJSW50ZXJuYWwuICovXG4gICAgdG9SZWZlcmVuY2VJbWFnZUFQSSgpIHtcbiAgICAgICAgY29uc3QgcmVmZXJlbmNlSW1hZ2VBUEkgPSB7XG4gICAgICAgICAgICByZWZlcmVuY2VUeXBlOiAnUkVGRVJFTkNFX1RZUEVfU1RZTEUnLFxuICAgICAgICAgICAgcmVmZXJlbmNlSW1hZ2U6IHRoaXMucmVmZXJlbmNlSW1hZ2UsXG4gICAgICAgICAgICByZWZlcmVuY2VJZDogdGhpcy5yZWZlcmVuY2VJZCxcbiAgICAgICAgICAgIHN0eWxlSW1hZ2VDb25maWc6IHRoaXMuY29uZmlnLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcmVmZXJlbmNlSW1hZ2VBUEk7XG4gICAgfVxufVxuLyoqIEEgc3ViamVjdCByZWZlcmVuY2UgaW1hZ2UuXG5cbiAgVGhpcyBlbmNhcHN1bGF0ZXMgYSBzdWJqZWN0IHJlZmVyZW5jZSBpbWFnZSBwcm92aWRlZCBieSB0aGUgdXNlciwgYW5kXG4gIGFkZGl0aW9uYWxseSBvcHRpb25hbCBjb25maWcgcGFyYW1ldGVycyBmb3IgdGhlIHN1YmplY3QgcmVmZXJlbmNlIGltYWdlLlxuXG4gIEEgcmF3IHJlZmVyZW5jZSBpbWFnZSBjYW4gYWxzbyBiZSBwcm92aWRlZCBhcyBhIGRlc3RpbmF0aW9uIGZvciB0aGUgc3ViamVjdCB0b1xuICBiZSBhcHBsaWVkIHRvLlxuICAgKi9cbmNsYXNzIFN1YmplY3RSZWZlcmVuY2VJbWFnZSB7XG4gICAgLyogSW50ZXJuYWwgbWV0aG9kIHRvIGNvbnZlcnQgdG8gUmVmZXJlbmNlSW1hZ2VBUElJbnRlcm5hbC4gKi9cbiAgICB0b1JlZmVyZW5jZUltYWdlQVBJKCkge1xuICAgICAgICBjb25zdCByZWZlcmVuY2VJbWFnZUFQSSA9IHtcbiAgICAgICAgICAgIHJlZmVyZW5jZVR5cGU6ICdSRUZFUkVOQ0VfVFlQRV9TVUJKRUNUJyxcbiAgICAgICAgICAgIHJlZmVyZW5jZUltYWdlOiB0aGlzLnJlZmVyZW5jZUltYWdlLFxuICAgICAgICAgICAgcmVmZXJlbmNlSWQ6IHRoaXMucmVmZXJlbmNlSWQsXG4gICAgICAgICAgICBzdWJqZWN0SW1hZ2VDb25maWc6IHRoaXMuY29uZmlnLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcmVmZXJlbmNlSW1hZ2VBUEk7XG4gICAgfVxufVxuLyoqIFJlc3BvbnNlIG1lc3NhZ2UgZm9yIEFQSSBjYWxsLiAqL1xuY2xhc3MgTGl2ZVNlcnZlck1lc3NhZ2Uge1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNvbmNhdGVuYXRpb24gb2YgYWxsIHRleHQgcGFydHMgZnJvbSB0aGUgc2VydmVyIGNvbnRlbnQgaWYgcHJlc2VudC5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogSWYgdGhlcmUgYXJlIG5vbi10ZXh0IHBhcnRzIGluIHRoZSByZXNwb25zZSwgdGhlIGNvbmNhdGVuYXRpb24gb2YgYWxsIHRleHRcbiAgICAgKiBwYXJ0cyB3aWxsIGJlIHJldHVybmVkLCBhbmQgYSB3YXJuaW5nIHdpbGwgYmUgbG9nZ2VkLlxuICAgICAqL1xuICAgIGdldCB0ZXh0KCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgbGV0IHRleHQgPSAnJztcbiAgICAgICAgbGV0IGFueVRleHRQYXJ0Rm91bmQgPSBmYWxzZTtcbiAgICAgICAgY29uc3Qgbm9uVGV4dFBhcnRzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcGFydCBvZiAoX2MgPSAoX2IgPSAoX2EgPSB0aGlzLnNlcnZlckNvbnRlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tb2RlbFR1cm4pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5wYXJ0cykgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogW10pIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2ZpZWxkTmFtZSwgZmllbGRWYWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocGFydCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmllbGROYW1lICE9PSAndGV4dCcgJiZcbiAgICAgICAgICAgICAgICAgICAgZmllbGROYW1lICE9PSAndGhvdWdodCcgJiZcbiAgICAgICAgICAgICAgICAgICAgZmllbGRWYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBub25UZXh0UGFydHMucHVzaChmaWVsZE5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGFydC50ZXh0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcGFydC50aG91Z2h0ID09PSAnYm9vbGVhbicgJiYgcGFydC50aG91Z2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhbnlUZXh0UGFydEZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0ZXh0ICs9IHBhcnQudGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobm9uVGV4dFBhcnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgdGhlcmUgYXJlIG5vbi10ZXh0IHBhcnRzICR7bm9uVGV4dFBhcnRzfSBpbiB0aGUgcmVzcG9uc2UsIHJldHVybmluZyBjb25jYXRlbmF0aW9uIG9mIGFsbCB0ZXh0IHBhcnRzLiBQbGVhc2UgcmVmZXIgdG8gdGhlIG5vbiB0ZXh0IHBhcnRzIGZvciBhIGZ1bGwgcmVzcG9uc2UgZnJvbSBtb2RlbC5gKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBwYXJ0LnRleHQgPT09ICcnIGlzIGRpZmZlcmVudCBmcm9tIHBhcnQudGV4dCBpcyBudWxsXG4gICAgICAgIHJldHVybiBhbnlUZXh0UGFydEZvdW5kID8gdGV4dCA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY29uY2F0ZW5hdGlvbiBvZiBhbGwgaW5saW5lIGRhdGEgcGFydHMgZnJvbSB0aGUgc2VydmVyIGNvbnRlbnQgaWYgcHJlc2VudC5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogSWYgdGhlcmUgYXJlIG5vbi1pbmxpbmUgZGF0YSBwYXJ0cyBpbiB0aGVcbiAgICAgKiByZXNwb25zZSwgdGhlIGNvbmNhdGVuYXRpb24gb2YgYWxsIGlubGluZSBkYXRhIHBhcnRzIHdpbGwgYmUgcmV0dXJuZWQsIGFuZFxuICAgICAqIGEgd2FybmluZyB3aWxsIGJlIGxvZ2dlZC5cbiAgICAgKi9cbiAgICBnZXQgZGF0YSgpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGxldCBkYXRhID0gJyc7XG4gICAgICAgIGNvbnN0IG5vbkRhdGFQYXJ0cyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgKF9jID0gKF9iID0gKF9hID0gdGhpcy5zZXJ2ZXJDb250ZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubW9kZWxUdXJuKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucGFydHMpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IFtdKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtmaWVsZE5hbWUsIGZpZWxkVmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHBhcnQpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkTmFtZSAhPT0gJ2lubGluZURhdGEnICYmIGZpZWxkVmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9uRGF0YVBhcnRzLnB1c2goZmllbGROYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFydC5pbmxpbmVEYXRhICYmIHR5cGVvZiBwYXJ0LmlubGluZURhdGEuZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBkYXRhICs9IGF0b2IocGFydC5pbmxpbmVEYXRhLmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChub25EYXRhUGFydHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGB0aGVyZSBhcmUgbm9uLWRhdGEgcGFydHMgJHtub25EYXRhUGFydHN9IGluIHRoZSByZXNwb25zZSwgcmV0dXJuaW5nIGNvbmNhdGVuYXRpb24gb2YgYWxsIGRhdGEgcGFydHMuIFBsZWFzZSByZWZlciB0byB0aGUgbm9uIGRhdGEgcGFydHMgZm9yIGEgZnVsbCByZXNwb25zZSBmcm9tIG1vZGVsLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhLmxlbmd0aCA+IDAgPyBidG9hKGRhdGEpIDogdW5kZWZpbmVkO1xuICAgIH1cbn1cbi8qKiBDbGllbnQgZ2VuZXJhdGVkIHJlc3BvbnNlIHRvIGEgYFRvb2xDYWxsYCByZWNlaXZlZCBmcm9tIHRoZSBzZXJ2ZXIuXG5cbiAgSW5kaXZpZHVhbCBgRnVuY3Rpb25SZXNwb25zZWAgb2JqZWN0cyBhcmUgbWF0Y2hlZCB0byB0aGUgcmVzcGVjdGl2ZVxuICBgRnVuY3Rpb25DYWxsYCBvYmplY3RzIGJ5IHRoZSBgaWRgIGZpZWxkLlxuXG4gIE5vdGUgdGhhdCBpbiB0aGUgdW5hcnkgYW5kIHNlcnZlci1zdHJlYW1pbmcgR2VuZXJhdGVDb250ZW50IEFQSXMgZnVuY3Rpb25cbiAgY2FsbGluZyBoYXBwZW5zIGJ5IGV4Y2hhbmdpbmcgdGhlIGBDb250ZW50YCBwYXJ0cywgd2hpbGUgaW4gdGhlIGJpZGlcbiAgR2VuZXJhdGVDb250ZW50IEFQSXMgZnVuY3Rpb24gY2FsbGluZyBoYXBwZW5zIG92ZXIgdGhpcyBkZWRpY2F0ZWQgc2V0IG9mXG4gIG1lc3NhZ2VzLlxuICAgKi9cbmNsYXNzIExpdmVDbGllbnRUb29sUmVzcG9uc2Uge1xufVxuLyoqIFBhcmFtZXRlcnMgZm9yIHNlbmRpbmcgdG9vbCByZXNwb25zZXMgdG8gdGhlIGxpdmUgQVBJLiAqL1xuY2xhc3MgTGl2ZVNlbmRUb29sUmVzcG9uc2VQYXJhbWV0ZXJzIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLyoqIFRvb2wgcmVzcG9uc2VzIHRvIHNlbmQgdG8gdGhlIHNlc3Npb24uICovXG4gICAgICAgIHRoaXMuZnVuY3Rpb25SZXNwb25zZXMgPSBbXTtcbiAgICB9XG59XG4vKiogUmVzcG9uc2UgbWVzc2FnZSBmb3IgdGhlIExpdmVNdXNpY0NsaWVudE1lc3NhZ2UgY2FsbC4gKi9cbmNsYXNzIExpdmVNdXNpY1NlcnZlck1lc3NhZ2Uge1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGZpcnN0IGF1ZGlvIGNodW5rIGZyb20gdGhlIHNlcnZlciBjb250ZW50LCBpZiBwcmVzZW50LlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBJZiB0aGVyZSBhcmUgbm8gYXVkaW8gY2h1bmtzIGluIHRoZSByZXNwb25zZSwgdW5kZWZpbmVkIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAgICovXG4gICAgZ2V0IGF1ZGlvQ2h1bmsoKSB7XG4gICAgICAgIGlmICh0aGlzLnNlcnZlckNvbnRlbnQgJiZcbiAgICAgICAgICAgIHRoaXMuc2VydmVyQ29udGVudC5hdWRpb0NodW5rcyAmJlxuICAgICAgICAgICAgdGhpcy5zZXJ2ZXJDb250ZW50LmF1ZGlvQ2h1bmtzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlcnZlckNvbnRlbnQuYXVkaW9DaHVua3NbMF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmZ1bmN0aW9uIHRNb2RlbChhcGlDbGllbnQsIG1vZGVsKSB7XG4gICAgaWYgKCFtb2RlbCB8fCB0eXBlb2YgbW9kZWwgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbW9kZWwgaXMgcmVxdWlyZWQgYW5kIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICB9XG4gICAgaWYgKGFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgaWYgKG1vZGVsLnN0YXJ0c1dpdGgoJ3B1Ymxpc2hlcnMvJykgfHxcbiAgICAgICAgICAgIG1vZGVsLnN0YXJ0c1dpdGgoJ3Byb2plY3RzLycpIHx8XG4gICAgICAgICAgICBtb2RlbC5zdGFydHNXaXRoKCdtb2RlbHMvJykpIHtcbiAgICAgICAgICAgIHJldHVybiBtb2RlbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtb2RlbC5pbmRleE9mKCcvJykgPj0gMCkge1xuICAgICAgICAgICAgY29uc3QgcGFydHMgPSBtb2RlbC5zcGxpdCgnLycsIDIpO1xuICAgICAgICAgICAgcmV0dXJuIGBwdWJsaXNoZXJzLyR7cGFydHNbMF19L21vZGVscy8ke3BhcnRzWzFdfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYHB1Ymxpc2hlcnMvZ29vZ2xlL21vZGVscy8ke21vZGVsfWA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChtb2RlbC5zdGFydHNXaXRoKCdtb2RlbHMvJykgfHwgbW9kZWwuc3RhcnRzV2l0aCgndHVuZWRNb2RlbHMvJykpIHtcbiAgICAgICAgICAgIHJldHVybiBtb2RlbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBgbW9kZWxzLyR7bW9kZWx9YDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHRDYWNoZXNNb2RlbChhcGlDbGllbnQsIG1vZGVsKSB7XG4gICAgY29uc3QgdHJhbnNmb3JtZWRNb2RlbCA9IHRNb2RlbChhcGlDbGllbnQsIG1vZGVsKTtcbiAgICBpZiAoIXRyYW5zZm9ybWVkTW9kZWwpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBpZiAodHJhbnNmb3JtZWRNb2RlbC5zdGFydHNXaXRoKCdwdWJsaXNoZXJzLycpICYmIGFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgLy8gdmVydGV4IGNhY2hlcyBvbmx5IHN1cHBvcnQgbW9kZWwgbmFtZSBzdGFydCB3aXRoIHByb2plY3RzLlxuICAgICAgICByZXR1cm4gYHByb2plY3RzLyR7YXBpQ2xpZW50LmdldFByb2plY3QoKX0vbG9jYXRpb25zLyR7YXBpQ2xpZW50LmdldExvY2F0aW9uKCl9LyR7dHJhbnNmb3JtZWRNb2RlbH1gO1xuICAgIH1cbiAgICBlbHNlIGlmICh0cmFuc2Zvcm1lZE1vZGVsLnN0YXJ0c1dpdGgoJ21vZGVscy8nKSAmJiBhcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgIHJldHVybiBgcHJvamVjdHMvJHthcGlDbGllbnQuZ2V0UHJvamVjdCgpfS9sb2NhdGlvbnMvJHthcGlDbGllbnQuZ2V0TG9jYXRpb24oKX0vcHVibGlzaGVycy9nb29nbGUvJHt0cmFuc2Zvcm1lZE1vZGVsfWA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtZWRNb2RlbDtcbiAgICB9XG59XG5mdW5jdGlvbiB0QmxvYnMoYmxvYnMpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShibG9icykpIHtcbiAgICAgICAgcmV0dXJuIGJsb2JzLm1hcCgoYmxvYikgPT4gdEJsb2IoYmxvYikpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFt0QmxvYihibG9icyldO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRCbG9iKGJsb2IpIHtcbiAgICBpZiAodHlwZW9mIGJsb2IgPT09ICdvYmplY3QnICYmIGJsb2IgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGJsb2I7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IHBhcnNlIGlucHV0IGFzIEJsb2IuIFVuc3VwcG9ydGVkIGJsb2IgdHlwZTogJHt0eXBlb2YgYmxvYn1gKTtcbn1cbmZ1bmN0aW9uIHRJbWFnZUJsb2IoYmxvYikge1xuICAgIGNvbnN0IHRyYW5zZm9ybWVkQmxvYiA9IHRCbG9iKGJsb2IpO1xuICAgIGlmICh0cmFuc2Zvcm1lZEJsb2IubWltZVR5cGUgJiZcbiAgICAgICAgdHJhbnNmb3JtZWRCbG9iLm1pbWVUeXBlLnN0YXJ0c1dpdGgoJ2ltYWdlLycpKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lZEJsb2I7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgbWltZSB0eXBlOiAke3RyYW5zZm9ybWVkQmxvYi5taW1lVHlwZX1gKTtcbn1cbmZ1bmN0aW9uIHRBdWRpb0Jsb2IoYmxvYikge1xuICAgIGNvbnN0IHRyYW5zZm9ybWVkQmxvYiA9IHRCbG9iKGJsb2IpO1xuICAgIGlmICh0cmFuc2Zvcm1lZEJsb2IubWltZVR5cGUgJiZcbiAgICAgICAgdHJhbnNmb3JtZWRCbG9iLm1pbWVUeXBlLnN0YXJ0c1dpdGgoJ2F1ZGlvLycpKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lZEJsb2I7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgbWltZSB0eXBlOiAke3RyYW5zZm9ybWVkQmxvYi5taW1lVHlwZX1gKTtcbn1cbmZ1bmN0aW9uIHRQYXJ0KG9yaWdpbikge1xuICAgIGlmIChvcmlnaW4gPT09IG51bGwgfHwgb3JpZ2luID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXJ0VW5pb24gaXMgcmVxdWlyZWQnKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcmlnaW4gPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBvcmlnaW47XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3JpZ2luID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4geyB0ZXh0OiBvcmlnaW4gfTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBwYXJ0IHR5cGU6ICR7dHlwZW9mIG9yaWdpbn1gKTtcbn1cbmZ1bmN0aW9uIHRQYXJ0cyhvcmlnaW4pIHtcbiAgICBpZiAob3JpZ2luID09PSBudWxsIHx8XG4gICAgICAgIG9yaWdpbiA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgIChBcnJheS5pc0FycmF5KG9yaWdpbikgJiYgb3JpZ2luLmxlbmd0aCA9PT0gMCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXJ0TGlzdFVuaW9uIGlzIHJlcXVpcmVkJyk7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KG9yaWdpbikpIHtcbiAgICAgICAgcmV0dXJuIG9yaWdpbi5tYXAoKGl0ZW0pID0+IHRQYXJ0KGl0ZW0pKTtcbiAgICB9XG4gICAgcmV0dXJuIFt0UGFydChvcmlnaW4pXTtcbn1cbmZ1bmN0aW9uIF9pc0NvbnRlbnQob3JpZ2luKSB7XG4gICAgcmV0dXJuIChvcmlnaW4gIT09IG51bGwgJiZcbiAgICAgICAgb3JpZ2luICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgdHlwZW9mIG9yaWdpbiA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgJ3BhcnRzJyBpbiBvcmlnaW4gJiZcbiAgICAgICAgQXJyYXkuaXNBcnJheShvcmlnaW4ucGFydHMpKTtcbn1cbmZ1bmN0aW9uIF9pc0Z1bmN0aW9uQ2FsbFBhcnQob3JpZ2luKSB7XG4gICAgcmV0dXJuIChvcmlnaW4gIT09IG51bGwgJiZcbiAgICAgICAgb3JpZ2luICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgdHlwZW9mIG9yaWdpbiA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgJ2Z1bmN0aW9uQ2FsbCcgaW4gb3JpZ2luKTtcbn1cbmZ1bmN0aW9uIF9pc0Z1bmN0aW9uUmVzcG9uc2VQYXJ0KG9yaWdpbikge1xuICAgIHJldHVybiAob3JpZ2luICE9PSBudWxsICYmXG4gICAgICAgIG9yaWdpbiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIHR5cGVvZiBvcmlnaW4gPT09ICdvYmplY3QnICYmXG4gICAgICAgICdmdW5jdGlvblJlc3BvbnNlJyBpbiBvcmlnaW4pO1xufVxuZnVuY3Rpb24gdENvbnRlbnQob3JpZ2luKSB7XG4gICAgaWYgKG9yaWdpbiA9PT0gbnVsbCB8fCBvcmlnaW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbnRlbnRVbmlvbiBpcyByZXF1aXJlZCcpO1xuICAgIH1cbiAgICBpZiAoX2lzQ29udGVudChvcmlnaW4pKSB7XG4gICAgICAgIC8vIF9pc0NvbnRlbnQgaXMgYSB1dGlsaXR5IGZ1bmN0aW9uIHRoYXQgY2hlY2tzIGlmIHRoZVxuICAgICAgICAvLyBvcmlnaW4gaXMgYSBDb250ZW50LlxuICAgICAgICByZXR1cm4gb3JpZ2luO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICByb2xlOiAndXNlcicsXG4gICAgICAgIHBhcnRzOiB0UGFydHMob3JpZ2luKSxcbiAgICB9O1xufVxuZnVuY3Rpb24gdENvbnRlbnRzRm9yRW1iZWQoYXBpQ2xpZW50LCBvcmlnaW4pIHtcbiAgICBpZiAoIW9yaWdpbikge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGlmIChhcGlDbGllbnQuaXNWZXJ0ZXhBSSgpICYmIEFycmF5LmlzQXJyYXkob3JpZ2luKSkge1xuICAgICAgICByZXR1cm4gb3JpZ2luLmZsYXRNYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSB0Q29udGVudChpdGVtKTtcbiAgICAgICAgICAgIGlmIChjb250ZW50LnBhcnRzICYmXG4gICAgICAgICAgICAgICAgY29udGVudC5wYXJ0cy5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICAgICAgY29udGVudC5wYXJ0c1swXS50ZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2NvbnRlbnQucGFydHNbMF0udGV4dF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChhcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSB0Q29udGVudChvcmlnaW4pO1xuICAgICAgICBpZiAoY29udGVudC5wYXJ0cyAmJlxuICAgICAgICAgICAgY29udGVudC5wYXJ0cy5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICBjb250ZW50LnBhcnRzWzBdLnRleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIFtjb250ZW50LnBhcnRzWzBdLnRleHRdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3JpZ2luKSkge1xuICAgICAgICByZXR1cm4gb3JpZ2luLm1hcCgoaXRlbSkgPT4gdENvbnRlbnQoaXRlbSkpO1xuICAgIH1cbiAgICByZXR1cm4gW3RDb250ZW50KG9yaWdpbildO1xufVxuZnVuY3Rpb24gdENvbnRlbnRzKG9yaWdpbikge1xuICAgIGlmIChvcmlnaW4gPT09IG51bGwgfHxcbiAgICAgICAgb3JpZ2luID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgKEFycmF5LmlzQXJyYXkob3JpZ2luKSAmJiBvcmlnaW4ubGVuZ3RoID09PSAwKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbnRlbnRzIGFyZSByZXF1aXJlZCcpO1xuICAgIH1cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkob3JpZ2luKSkge1xuICAgICAgICAvLyBJZiBpdCdzIG5vdCBhbiBhcnJheSwgaXQncyBhIHNpbmdsZSBjb250ZW50IG9yIGEgc2luZ2xlIFBhcnRVbmlvbi5cbiAgICAgICAgaWYgKF9pc0Z1bmN0aW9uQ2FsbFBhcnQob3JpZ2luKSB8fCBfaXNGdW5jdGlvblJlc3BvbnNlUGFydChvcmlnaW4pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RvIHNwZWNpZnkgZnVuY3Rpb25DYWxsIG9yIGZ1bmN0aW9uUmVzcG9uc2UgcGFydHMsIHBsZWFzZSB3cmFwIHRoZW0gaW4gYSBDb250ZW50IG9iamVjdCwgc3BlY2lmeWluZyB0aGUgcm9sZSBmb3IgdGhlbScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbdENvbnRlbnQob3JpZ2luKV07XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGNvbnN0IGFjY3VtdWxhdGVkUGFydHMgPSBbXTtcbiAgICBjb25zdCBpc0NvbnRlbnRBcnJheSA9IF9pc0NvbnRlbnQob3JpZ2luWzBdKTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2Ygb3JpZ2luKSB7XG4gICAgICAgIGNvbnN0IGlzQ29udGVudCA9IF9pc0NvbnRlbnQoaXRlbSk7XG4gICAgICAgIGlmIChpc0NvbnRlbnQgIT0gaXNDb250ZW50QXJyYXkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWl4aW5nIENvbnRlbnQgYW5kIFBhcnRzIGlzIG5vdCBzdXBwb3J0ZWQsIHBsZWFzZSBncm91cCB0aGUgcGFydHMgaW50byBhIHRoZSBhcHByb3ByaWF0ZSBDb250ZW50IG9iamVjdHMgYW5kIHNwZWNpZnkgdGhlIHJvbGVzIGZvciB0aGVtJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQ29udGVudCkge1xuICAgICAgICAgICAgLy8gYGlzQ29udGVudGAgY29udGFpbnMgdGhlIHJlc3VsdCBvZiBfaXNDb250ZW50LCB3aGljaCBpcyBhIHV0aWxpdHlcbiAgICAgICAgICAgIC8vIGZ1bmN0aW9uIHRoYXQgY2hlY2tzIGlmIHRoZSBpdGVtIGlzIGEgQ29udGVudC5cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKF9pc0Z1bmN0aW9uQ2FsbFBhcnQoaXRlbSkgfHwgX2lzRnVuY3Rpb25SZXNwb25zZVBhcnQoaXRlbSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVG8gc3BlY2lmeSBmdW5jdGlvbkNhbGwgb3IgZnVuY3Rpb25SZXNwb25zZSBwYXJ0cywgcGxlYXNlIHdyYXAgdGhlbSwgYW5kIGFueSBvdGhlciBwYXJ0cywgaW4gQ29udGVudCBvYmplY3RzIGFzIGFwcHJvcHJpYXRlLCBzcGVjaWZ5aW5nIHRoZSByb2xlIGZvciB0aGVtJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhY2N1bXVsYXRlZFBhcnRzLnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFpc0NvbnRlbnRBcnJheSkge1xuICAgICAgICByZXN1bHQucHVzaCh7IHJvbGU6ICd1c2VyJywgcGFydHM6IHRQYXJ0cyhhY2N1bXVsYXRlZFBhcnRzKSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIFRoZSBmaWVsZHMgdGhhdCBhcmUgc3VwcG9ydGVkIGJ5IEpTT05TY2hlbWEuIE11c3QgYmUga2VwdCBpbiBzeW5jIHdpdGggdGhlXG4vLyBKU09OU2NoZW1hIGludGVyZmFjZSBhYm92ZS5cbmNvbnN0IHN1cHBvcnRlZEpzb25TY2hlbWFGaWVsZHMgPSBuZXcgU2V0KFtcbiAgICAndHlwZScsXG4gICAgJ2Zvcm1hdCcsXG4gICAgJ3RpdGxlJyxcbiAgICAnZGVzY3JpcHRpb24nLFxuICAgICdkZWZhdWx0JyxcbiAgICAnaXRlbXMnLFxuICAgICdtaW5JdGVtcycsXG4gICAgJ21heEl0ZW1zJyxcbiAgICAnZW51bScsXG4gICAgJ3Byb3BlcnRpZXMnLFxuICAgICdyZXF1aXJlZCcsXG4gICAgJ21pblByb3BlcnRpZXMnLFxuICAgICdtYXhQcm9wZXJ0aWVzJyxcbiAgICAnbWluaW11bScsXG4gICAgJ21heGltdW0nLFxuICAgICdtaW5MZW5ndGgnLFxuICAgICdtYXhMZW5ndGgnLFxuICAgICdwYXR0ZXJuJyxcbiAgICAnYW55T2YnLFxuICAgICdwcm9wZXJ0eU9yZGVyaW5nJyxcbl0pO1xuY29uc3QganNvblNjaGVtYVR5cGVWYWxpZGF0b3IgPSB6LmVudW0oW1xuICAgICdzdHJpbmcnLFxuICAgICdudW1iZXInLFxuICAgICdpbnRlZ2VyJyxcbiAgICAnb2JqZWN0JyxcbiAgICAnYXJyYXknLFxuICAgICdib29sZWFuJyxcbiAgICAnbnVsbCcsXG5dKTtcbi8vIEhhbmRsZXMgYWxsIHR5cGVzIGFuZCBhcnJheXMgb2YgYWxsIHR5cGVzLlxuY29uc3Qgc2NoZW1hVHlwZVVuaW9uID0gei51bmlvbihbXG4gICAganNvblNjaGVtYVR5cGVWYWxpZGF0b3IsXG4gICAgei5hcnJheShqc29uU2NoZW1hVHlwZVZhbGlkYXRvciksXG5dKTtcbi8qKlxuICogQ3JlYXRlcyBhIHpvZCB2YWxpZGF0b3IgZm9yIEpTT05TY2hlbWEuXG4gKlxuICogQHBhcmFtIHN0cmljdE1vZGUgV2hldGhlciB0byBlbmFibGUgc3RyaWN0IG1vZGUsIGRlZmF1bHQgdG8gdHJ1ZS4gV2hlblxuICogc3RyaWN0IG1vZGUgaXMgZW5hYmxlZCwgdGhlIHpvZCB2YWxpZGF0b3Igd2lsbCB0aHJvdyBlcnJvciBpZiB0aGVyZVxuICogYXJlIHVucmVjb2duaXplZCBmaWVsZHMgaW4gdGhlIGlucHV0IGRhdGEuIElmIHN0cmljdCBtb2RlIGlzXG4gKiBkaXNhYmxlZCwgdGhlIHpvZCB2YWxpZGF0b3Igd2lsbCBpZ25vcmUgdGhlIHVucmVjb2duaXplZCBmaWVsZHMsIG9ubHlcbiAqIHBvcHVsYXRlIHRoZSBmaWVsZHMgdGhhdCBhcmUgbGlzdGVkIGluIHRoZSBKU09OU2NoZW1hLiBSZWdhcmRsZXNzIG9mXG4gKiB0aGUgbW9kZSB0aGUgdHlwZSBtaXNtYXRjaCB3aWxsIGFsd2F5cyByZXN1bHQgaW4gYW4gZXJyb3IsIGZvciBleGFtcGxlXG4gKiBpdGVtcyBmaWVsZCBzaG91bGQgYmUgYSBzaW5nbGUgSlNPTlNjaGVtYSwgYnV0IGZvciB0dXBsZSB0eXBlIGl0IHdvdWxkXG4gKiBiZSBhbiBhcnJheSBvZiBKU09OU2NoZW1hLCB0aGlzIHdpbGwgYWx3YXlzIHJlc3VsdCBpbiBhbiBlcnJvci5cbiAqIEByZXR1cm4gVGhlIHpvZCB2YWxpZGF0b3IgZm9yIEpTT05TY2hlbWEuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUpzb25TY2hlbWFWYWxpZGF0b3Ioc3RyaWN0TW9kZSA9IHRydWUpIHtcbiAgICBjb25zdCBqc29uU2NoZW1hVmFsaWRhdG9yID0gei5sYXp5KCgpID0+IHtcbiAgICAgICAgLy8gRGVmaW5lIHRoZSBiYXNlIG9iamVjdCBzaGFwZSAqaW5zaWRlKiB0aGUgei5sYXp5IGNhbGxiYWNrXG4gICAgICAgIGNvbnN0IGJhc2VTaGFwZSA9IHoub2JqZWN0KHtcbiAgICAgICAgICAgIC8vIC0tLSBUeXBlIC0tLVxuICAgICAgICAgICAgdHlwZTogc2NoZW1hVHlwZVVuaW9uLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAvLyAtLS0gQW5ub3RhdGlvbnMgLS0tXG4gICAgICAgICAgICBmb3JtYXQ6IHouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgICAgICAgICAgIHRpdGxlOiB6LnN0cmluZygpLm9wdGlvbmFsKCksXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgZGVmYXVsdDogei51bmtub3duKCkub3B0aW9uYWwoKSxcbiAgICAgICAgICAgIC8vIC0tLSBBcnJheSBWYWxpZGF0aW9ucyAtLS1cbiAgICAgICAgICAgIGl0ZW1zOiBqc29uU2NoZW1hVmFsaWRhdG9yLm9wdGlvbmFsKCksXG4gICAgICAgICAgICBtaW5JdGVtczogei5jb2VyY2Uuc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgICAgICAgICAgIG1heEl0ZW1zOiB6LmNvZXJjZS5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgLy8gLS0tIEdlbmVyaWMgVmFsaWRhdGlvbnMgLS0tXG4gICAgICAgICAgICBlbnVtOiB6LmFycmF5KHoudW5rbm93bigpKS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgLy8gLS0tIE9iamVjdCBWYWxpZGF0aW9ucyAtLS1cbiAgICAgICAgICAgIHByb3BlcnRpZXM6IHoucmVjb3JkKHouc3RyaW5nKCksIGpzb25TY2hlbWFWYWxpZGF0b3IpLm9wdGlvbmFsKCksXG4gICAgICAgICAgICByZXF1aXJlZDogei5hcnJheSh6LnN0cmluZygpKS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgbWluUHJvcGVydGllczogei5jb2VyY2Uuc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgICAgICAgICAgIG1heFByb3BlcnRpZXM6IHouY29lcmNlLnN0cmluZygpLm9wdGlvbmFsKCksXG4gICAgICAgICAgICBwcm9wZXJ0eU9yZGVyaW5nOiB6LmFycmF5KHouc3RyaW5nKCkpLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAvLyAtLS0gTnVtZXJpYyBWYWxpZGF0aW9ucyAtLS1cbiAgICAgICAgICAgIG1pbmltdW06IHoubnVtYmVyKCkub3B0aW9uYWwoKSxcbiAgICAgICAgICAgIG1heGltdW06IHoubnVtYmVyKCkub3B0aW9uYWwoKSxcbiAgICAgICAgICAgIC8vIC0tLSBTdHJpbmcgVmFsaWRhdGlvbnMgLS0tXG4gICAgICAgICAgICBtaW5MZW5ndGg6IHouY29lcmNlLnN0cmluZygpLm9wdGlvbmFsKCksXG4gICAgICAgICAgICBtYXhMZW5ndGg6IHouY29lcmNlLnN0cmluZygpLm9wdGlvbmFsKCksXG4gICAgICAgICAgICBwYXR0ZXJuOiB6LnN0cmluZygpLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAvLyAtLS0gU2NoZW1hIENvbXBvc2l0aW9uIC0tLVxuICAgICAgICAgICAgYW55T2Y6IHouYXJyYXkoanNvblNjaGVtYVZhbGlkYXRvcikub3B0aW9uYWwoKSxcbiAgICAgICAgICAgIC8vIC0tLSBBZGRpdGlvbmFsIFByb3BlcnRpZXMgLS0tIFRoaXMgZmllbGQgaXMgbm90IGluY2x1ZGVkIGluIHRoZVxuICAgICAgICAgICAgLy8gSlNPTlNjaGVtYSwgd2lsbCBub3QgYmUgY29tbXVuaWNhdGVkIHRvIHRoZSBtb2RlbCwgaXQgaXMgaGVyZSBwdXJlbHlcbiAgICAgICAgICAgIC8vIGZvciBlbmFibGluZyB0aGUgem9kIHZhbGlkYXRpb24gc3RyaWN0IG1vZGUuXG4gICAgICAgICAgICBhZGRpdGlvbmFsUHJvcGVydGllczogei5ib29sZWFuKCkub3B0aW9uYWwoKSxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIENvbmRpdGlvbmFsbHkgYXBwbHkgLnN0cmljdCgpIGJhc2VkIG9uIHRoZSBmbGFnXG4gICAgICAgIHJldHVybiBzdHJpY3RNb2RlID8gYmFzZVNoYXBlLnN0cmljdCgpIDogYmFzZVNoYXBlO1xuICAgIH0pO1xuICAgIHJldHVybiBqc29uU2NoZW1hVmFsaWRhdG9yO1xufVxuLypcbkhhbmRsZSB0eXBlIGZpZWxkOlxuVGhlIHJlc3VsdGVkIHR5cGUgZmllbGQgaW4gSlNPTlNjaGVtYSBmb3JtIHpvZF90b19qc29uX3NjaGVtYSBjYW4gYmUgZWl0aGVyXG5hbiBhcnJheSBjb25zaXN0IG9mIHByaW1pdGl2ZSB0eXBlcyBvciBhIHNpbmdsZSBwcmltaXRpdmUgdHlwZS5cblRoaXMgaXMgZHVlIHRvIHRoZSBvcHRpbWl6YXRpb24gb2Ygem9kX3RvX2pzb25fc2NoZW1hLCB3aGVuIHRoZSB0eXBlcyBpbiB0aGVcbnVuaW9uIGFyZSBwcmltaXRpdmUgdHlwZXMgd2l0aG91dCBhbnkgYWRkaXRpb25hbCBzcGVjaWZpY2F0aW9ucyxcbnpvZF90b19qc29uX3NjaGVtYSB3aWxsIHNxdWFzaCB0aGUgdHlwZXMgaW50byBhbiBhcnJheSBpbnN0ZWFkIG9mIHB1dCB0aGVtXG5pbiBhbnlPZiBmaWVsZHMuIE90aGVyd2lzZSwgaXQgd2lsbCBwdXQgdGhlIHR5cGVzIGluIGFueU9mIGZpZWxkcy5cblNlZSB0aGUgZm9sbG93aW5nIGxpbmsgZm9yIG1vcmUgZGV0YWlsczpcbmh0dHBzOi8vZ2l0aHViLmNvbS96b2Rqcy96b2QtdG8tanNvbi1zY2hlbWEvYmxvYi9tYWluL3NyYy9pbmRleC50cyNMMTAxXG5UaGUgbG9naWMgaGVyZSBpcyB0cnlpbmcgdG8gdW5kbyB0aGF0IG9wdGltaXphdGlvbiwgZmxhdHRlbmluZyB0aGUgYXJyYXkgb2ZcbnR5cGVzIHRvIGFueU9mIGZpZWxkcy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgZmllbGRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fX19fX19fX19fX19fX19fX19fX19fX19fX1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgLyAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXFxuICAgICAgICAgICAgICAgICAgICAgICAgIC8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXG4gICAgICAgICAgICAgICAgICAgICAgIEFycmF5ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVHlwZS4qXG4gICAgICAgICAgICAgICAgLyAgICAgICAgICAgICAgICAgIFxcICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgICBJbmNsdWRlIG51bGwuICAgICAgICAgICAgICBOb3QgaW5jbHVkZWQgbnVsbCAgICAgdHlwZSA9IFR5cGUuKi5cbiAgICAgIFtudWxsLCBUeXBlLiosIFR5cGUuKl0gICAgIG11bHRpcGxlIHR5cGVzLlxuICAgICAgW251bGwsIFR5cGUuKl0gICAgICAgICAgICAgW1R5cGUuKiwgVHlwZS4qXVxuICAgICAgICAgICAgLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcbiAgICAgIHJlbW92ZSBudWxsICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXFxuICAgICAgYWRkIG51bGxhYmxlID0gdHJ1ZSAgICAgICAgICAgICAgICAgICAgICBcXFxuICAgICAgIC8gICAgICAgICAgICAgICAgICAgIFxcICAgICAgICAgICAgICAgICAgIFxcXG4gICAgW1R5cGUuKl0gICAgICAgICAgIFtUeXBlLiosIFR5cGUuKl0gICAgICAgICAgXFxcbiBvbmx5IG9uZSB0eXBlIGxlZnQgICAgIG11bHRpcGxlIHR5cGVzIGxlZnQgICAgICAgXFxcbiBhZGQgdHlwZSA9IFR5cGUuKi4gICAgICAgICAgIFxcICAgICAgICAgICAgICAgICAgL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcICAgICAgICAgICAgICAgIC9cbiAgICAgICAgICAgICAgICAgICAgICAgICBub3QgcG9wdWxhdGUgdGhlIHR5cGUgZmllbGQgaW4gZmluYWwgcmVzdWx0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBhbmQgbWFrZSB0aGUgdHlwZXMgaW50byBhbnlPZiBmaWVsZHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYW55T2Y6W3t0eXBlOiAnVHlwZS4qJ30sIHt0eXBlOiAnVHlwZS4qJ31dO1xuKi9cbmZ1bmN0aW9uIGZsYXR0ZW5UeXBlQXJyYXlUb0FueU9mKHR5cGVMaXN0LCByZXN1bHRpbmdTY2hlbWEpIHtcbiAgICBpZiAodHlwZUxpc3QuaW5jbHVkZXMoJ251bGwnKSkge1xuICAgICAgICByZXN1bHRpbmdTY2hlbWFbJ251bGxhYmxlJ10gPSB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBsaXN0V2l0aG91dE51bGwgPSB0eXBlTGlzdC5maWx0ZXIoKHR5cGUpID0+IHR5cGUgIT09ICdudWxsJyk7XG4gICAgaWYgKGxpc3RXaXRob3V0TnVsbC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmVzdWx0aW5nU2NoZW1hWyd0eXBlJ10gPSBPYmplY3QudmFsdWVzKFR5cGUpLmluY2x1ZGVzKGxpc3RXaXRob3V0TnVsbFswXS50b1VwcGVyQ2FzZSgpKVxuICAgICAgICAgICAgPyBsaXN0V2l0aG91dE51bGxbMF0udG9VcHBlckNhc2UoKVxuICAgICAgICAgICAgOiBUeXBlLlRZUEVfVU5TUEVDSUZJRUQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXN1bHRpbmdTY2hlbWFbJ2FueU9mJ10gPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBpIG9mIGxpc3RXaXRob3V0TnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0aW5nU2NoZW1hWydhbnlPZiddLnB1c2goe1xuICAgICAgICAgICAgICAgICd0eXBlJzogT2JqZWN0LnZhbHVlcyhUeXBlKS5pbmNsdWRlcyhpLnRvVXBwZXJDYXNlKCkpXG4gICAgICAgICAgICAgICAgICAgID8gaS50b1VwcGVyQ2FzZSgpXG4gICAgICAgICAgICAgICAgICAgIDogVHlwZS5UWVBFX1VOU1BFQ0lGSUVELFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBwcm9jZXNzSnNvblNjaGVtYShfanNvblNjaGVtYSkge1xuICAgIGNvbnN0IGdlbkFJU2NoZW1hID0ge307XG4gICAgY29uc3Qgc2NoZW1hRmllbGROYW1lcyA9IFsnaXRlbXMnXTtcbiAgICBjb25zdCBsaXN0U2NoZW1hRmllbGROYW1lcyA9IFsnYW55T2YnXTtcbiAgICBjb25zdCBkaWN0U2NoZW1hRmllbGROYW1lcyA9IFsncHJvcGVydGllcyddO1xuICAgIGlmIChfanNvblNjaGVtYVsndHlwZSddICYmIF9qc29uU2NoZW1hWydhbnlPZiddKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndHlwZSBhbmQgYW55T2YgY2Fubm90IGJlIGJvdGggcG9wdWxhdGVkLicpO1xuICAgIH1cbiAgICAvKlxuICAgIFRoaXMgaXMgdG8gaGFuZGxlIHRoZSBudWxsYWJsZSBhcnJheSBvciBvYmplY3QuIFRoZSBfanNvblNjaGVtYSB3aWxsXG4gICAgYmUgaW4gdGhlIGZvcm1hdCBvZiB7YW55T2Y6IFt7dHlwZTogJ251bGwnfSwge3R5cGU6ICdvYmplY3QnfV19LiBUaGVcbiAgICBsb2dpYyBpcyB0byBjaGVjayBpZiBhbnlPZiBoYXMgMiBlbGVtZW50cyBhbmQgb25lIG9mIHRoZSBlbGVtZW50IGlzIG51bGwsXG4gICAgaWYgc28sIHRoZSBhbnlPZiBmaWVsZCBpcyB1bm5lY2Vzc2FyeSwgc28gd2UgbmVlZCB0byBnZXQgcmlkIG9mIHRoZSBhbnlPZlxuICAgIGZpZWxkIGFuZCBtYWtlIHRoZSBzY2hlbWEgbnVsbGFibGUuIFRoZW4gdXNlIHRoZSBvdGhlciBlbGVtZW50IGFzIHRoZSBuZXdcbiAgICBfanNvblNjaGVtYSBmb3IgcHJvY2Vzc2luZy4gVGhpcyBpcyBiZWNhdXNlIHRoZSBiYWNrZW5kIGRvZXNuJ3QgaGF2ZSBhIG51bGxcbiAgICB0eXBlLlxuICAgIFRoaXMgaGFzIHRvIGJlIGNoZWNrZWQgYmVmb3JlIHdlIHByb2Nlc3MgYW55IG90aGVyIGZpZWxkcy5cbiAgICBGb3IgZXhhbXBsZTpcbiAgICAgIGNvbnN0IG9iamVjdE51bGxhYmxlID0gei5vYmplY3Qoe1xuICAgICAgICBudWxsYWJsZUFycmF5OiB6LmFycmF5KHouc3RyaW5nKCkpLm51bGxhYmxlKCksXG4gICAgICB9KTtcbiAgICBXaWxsIGhhdmUgdGhlIHJhdyBfanNvblNjaGVtYSBhczpcbiAgICB7XG4gICAgICB0eXBlOiAnT0JKRUNUJyxcbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICBudWxsYWJsZUFycmF5OiB7XG4gICAgICAgICAgICAgYW55T2Y6IFtcbiAgICAgICAgICAgICAgICB7dHlwZTogJ251bGwnfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiAnYXJyYXknLFxuICAgICAgICAgICAgICAgICAgaXRlbXM6IHt0eXBlOiAnc3RyaW5nJ30sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcmVxdWlyZWQ6IFsgJ251bGxhYmxlQXJyYXknIF0sXG4gICAgfVxuICAgIFdpbGwgcmVzdWx0IGluIGZvbGxvd2luZyBzY2hlbWEgY29tcGF0aWJsZSB3aXRoIEdlbWluaSBBUEk6XG4gICAgICB7XG4gICAgICAgIHR5cGU6ICdPQkpFQ1QnLFxuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgIG51bGxhYmxlQXJyYXk6IHtcbiAgICAgICAgICAgICAgbnVsbGFibGU6IHRydWUsXG4gICAgICAgICAgICAgIHR5cGU6ICdBUlJBWScsXG4gICAgICAgICAgICAgIGl0ZW1zOiB7dHlwZTogJ3N0cmluZyd9LFxuICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJlcXVpcmVkOiBbICdudWxsYWJsZUFycmF5JyBdLFxuICAgICAgfVxuICAgICovXG4gICAgY29uc3QgaW5jb21pbmdBbnlPZiA9IF9qc29uU2NoZW1hWydhbnlPZiddO1xuICAgIGlmIChpbmNvbWluZ0FueU9mICE9IG51bGwgJiYgaW5jb21pbmdBbnlPZi5sZW5ndGggPT0gMikge1xuICAgICAgICBpZiAoaW5jb21pbmdBbnlPZlswXVsndHlwZSddID09PSAnbnVsbCcpIHtcbiAgICAgICAgICAgIGdlbkFJU2NoZW1hWydudWxsYWJsZSddID0gdHJ1ZTtcbiAgICAgICAgICAgIF9qc29uU2NoZW1hID0gaW5jb21pbmdBbnlPZlsxXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbmNvbWluZ0FueU9mWzFdWyd0eXBlJ10gPT09ICdudWxsJykge1xuICAgICAgICAgICAgZ2VuQUlTY2hlbWFbJ251bGxhYmxlJ10gPSB0cnVlO1xuICAgICAgICAgICAgX2pzb25TY2hlbWEgPSBpbmNvbWluZ0FueU9mWzBdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChfanNvblNjaGVtYVsndHlwZSddIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgZmxhdHRlblR5cGVBcnJheVRvQW55T2YoX2pzb25TY2hlbWFbJ3R5cGUnXSwgZ2VuQUlTY2hlbWEpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtmaWVsZE5hbWUsIGZpZWxkVmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKF9qc29uU2NoZW1hKSkge1xuICAgICAgICAvLyBTa2lwIGlmIHRoZSBmaWVsZHZhbHVlIGlzIHVuZGVmaW5lZCBvciBudWxsLlxuICAgICAgICBpZiAoZmllbGRWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmllbGROYW1lID09ICd0eXBlJykge1xuICAgICAgICAgICAgaWYgKGZpZWxkVmFsdWUgPT09ICdudWxsJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndHlwZTogbnVsbCBjYW4gbm90IGJlIHRoZSBvbmx5IHBvc3NpYmxlIHR5cGUgZm9yIHRoZSBmaWVsZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaWVsZFZhbHVlIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSBoYXZlIGFscmVhZHkgaGFuZGxlZCB0aGUgdHlwZSBmaWVsZCB3aXRoIGFycmF5IG9mIHR5cGVzIGluIHRoZVxuICAgICAgICAgICAgICAgIC8vIGJlZ2lubmluZyBvZiB0aGlzIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2VuQUlTY2hlbWFbJ3R5cGUnXSA9IE9iamVjdC52YWx1ZXMoVHlwZSkuaW5jbHVkZXMoZmllbGRWYWx1ZS50b1VwcGVyQ2FzZSgpKVxuICAgICAgICAgICAgICAgID8gZmllbGRWYWx1ZS50b1VwcGVyQ2FzZSgpXG4gICAgICAgICAgICAgICAgOiBUeXBlLlRZUEVfVU5TUEVDSUZJRUQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2NoZW1hRmllbGROYW1lcy5pbmNsdWRlcyhmaWVsZE5hbWUpKSB7XG4gICAgICAgICAgICBnZW5BSVNjaGVtYVtmaWVsZE5hbWVdID1cbiAgICAgICAgICAgICAgICBwcm9jZXNzSnNvblNjaGVtYShmaWVsZFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsaXN0U2NoZW1hRmllbGROYW1lcy5pbmNsdWRlcyhmaWVsZE5hbWUpKSB7XG4gICAgICAgICAgICBjb25zdCBsaXN0U2NoZW1hRmllbGRWYWx1ZSA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGZpZWxkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbVsndHlwZSddID09ICdudWxsJykge1xuICAgICAgICAgICAgICAgICAgICBnZW5BSVNjaGVtYVsnbnVsbGFibGUnXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsaXN0U2NoZW1hRmllbGRWYWx1ZS5wdXNoKHByb2Nlc3NKc29uU2NoZW1hKGl0ZW0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdlbkFJU2NoZW1hW2ZpZWxkTmFtZV0gPVxuICAgICAgICAgICAgICAgIGxpc3RTY2hlbWFGaWVsZFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRpY3RTY2hlbWFGaWVsZE5hbWVzLmluY2x1ZGVzKGZpZWxkTmFtZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGRpY3RTY2hlbWFGaWVsZFZhbHVlID0ge307XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhmaWVsZFZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGRpY3RTY2hlbWFGaWVsZFZhbHVlW2tleV0gPSBwcm9jZXNzSnNvblNjaGVtYSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnZW5BSVNjaGVtYVtmaWVsZE5hbWVdID1cbiAgICAgICAgICAgICAgICBkaWN0U2NoZW1hRmllbGRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGFkZGl0aW9uYWxQcm9wZXJ0aWVzIGlzIG5vdCBpbmNsdWRlZCBpbiBKU09OU2NoZW1hLCBza2lwcGluZyBpdC5cbiAgICAgICAgICAgIGlmIChmaWVsZE5hbWUgPT09ICdhZGRpdGlvbmFsUHJvcGVydGllcycpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdlbkFJU2NoZW1hW2ZpZWxkTmFtZV0gPSBmaWVsZFZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBnZW5BSVNjaGVtYTtcbn1cbi8vIHdlIHRha2UgdGhlIHVua25vd24gaW4gdGhlIHNjaGVtYSBmaWVsZCBiZWNhdXNlIHdlIHdhbnQgZW5hYmxlIHVzZXIgdG8gcGFzc1xuLy8gdGhlIG91dHB1dCBvZiBtYWpvciBzY2hlbWEgZGVjbGFyYXRpb24gdG9vbHMgd2l0aG91dCBjYXN0aW5nLiBUb29scyBzdWNoIGFzXG4vLyB6b2RUb0pzb25TY2hlbWEsIHR5cGVib3gsIHpvZFRvSnNvblNjaGVtYSBmdW5jdGlvbiBjYW4gcmV0dXJuIEpzb25TY2hlbWE3VHlwZVxuLy8gb3Igb2JqZWN0LCBzZWUgZGV0YWlscyBpblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL1N0ZWZhblRlcmRlbGwvem9kLXRvLWpzb24tc2NoZW1hL2Jsb2IvNzA1MjVlZmU1NTVjZDIyNjY5MWUwOTNkMTcxMzcwYTNiMTA5MjFkMS9zcmMvem9kVG9Kc29uU2NoZW1hLnRzI0w3XG4vLyB0eXBlYm94IGNhbiByZXR1cm4gdW5rbm93biwgc2VlIGRldGFpbHMgaW5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5jbGFpcnp4ODEvdHlwZWJveC9ibG9iLzVhNTQzMTQzOWY3ZDVjYTZiNDk0ZDBkMThmYmZkN2IxYTM1NmQ2N2Mvc3JjL3R5cGUvY3JlYXRlL3R5cGUudHMjTDM1XG5mdW5jdGlvbiB0U2NoZW1hKHNjaGVtYSkge1xuICAgIGlmIChPYmplY3Qua2V5cyhzY2hlbWEpLmluY2x1ZGVzKCckc2NoZW1hJykpIHtcbiAgICAgICAgZGVsZXRlIHNjaGVtYVsnJHNjaGVtYSddO1xuICAgICAgICBjb25zdCB2YWxpZGF0ZWRKc29uU2NoZW1hID0gY3JlYXRlSnNvblNjaGVtYVZhbGlkYXRvcigpLnBhcnNlKHNjaGVtYSk7XG4gICAgICAgIHJldHVybiBwcm9jZXNzSnNvblNjaGVtYSh2YWxpZGF0ZWRKc29uU2NoZW1hKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBwcm9jZXNzSnNvblNjaGVtYShzY2hlbWEpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRTcGVlY2hDb25maWcoc3BlZWNoQ29uZmlnKSB7XG4gICAgaWYgKHR5cGVvZiBzcGVlY2hDb25maWcgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBzcGVlY2hDb25maWc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBzcGVlY2hDb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2b2ljZUNvbmZpZzoge1xuICAgICAgICAgICAgICAgIHByZWJ1aWx0Vm9pY2VDb25maWc6IHtcbiAgICAgICAgICAgICAgICAgICAgdm9pY2VOYW1lOiBzcGVlY2hDb25maWcsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHNwZWVjaENvbmZpZyB0eXBlOiAke3R5cGVvZiBzcGVlY2hDb25maWd9YCk7XG4gICAgfVxufVxuZnVuY3Rpb24gdExpdmVTcGVlY2hDb25maWcoc3BlZWNoQ29uZmlnKSB7XG4gICAgaWYgKCdtdWx0aVNwZWFrZXJWb2ljZUNvbmZpZycgaW4gc3BlZWNoQ29uZmlnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbXVsdGlTcGVha2VyVm9pY2VDb25maWcgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGUgbGl2ZSBBUEkuJyk7XG4gICAgfVxuICAgIHJldHVybiBzcGVlY2hDb25maWc7XG59XG5mdW5jdGlvbiB0VG9vbCh0b29sKSB7XG4gICAgaWYgKHRvb2wuZnVuY3Rpb25EZWNsYXJhdGlvbnMpIHtcbiAgICAgICAgZm9yIChjb25zdCBmdW5jdGlvbkRlY2xhcmF0aW9uIG9mIHRvb2wuZnVuY3Rpb25EZWNsYXJhdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChmdW5jdGlvbkRlY2xhcmF0aW9uLnBhcmFtZXRlcnMpIHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbkRlY2xhcmF0aW9uLnBhcmFtZXRlcnMgPSB0U2NoZW1hKGZ1bmN0aW9uRGVjbGFyYXRpb24ucGFyYW1ldGVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZnVuY3Rpb25EZWNsYXJhdGlvbi5yZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uRGVjbGFyYXRpb24ucmVzcG9uc2UgPSB0U2NoZW1hKGZ1bmN0aW9uRGVjbGFyYXRpb24ucmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0b29sO1xufVxuZnVuY3Rpb24gdFRvb2xzKHRvb2xzKSB7XG4gICAgLy8gQ2hlY2sgaWYgdGhlIGluY29taW5nIHR5cGUgaXMgZGVmaW5lZC5cbiAgICBpZiAodG9vbHMgPT09IHVuZGVmaW5lZCB8fCB0b29scyA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Rvb2xzIGlzIHJlcXVpcmVkJyk7XG4gICAgfVxuICAgIGlmICghQXJyYXkuaXNBcnJheSh0b29scykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0b29scyBpcyByZXF1aXJlZCBhbmQgbXVzdCBiZSBhbiBhcnJheSBvZiBUb29scycpO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHRvb2wgb2YgdG9vbHMpIHtcbiAgICAgICAgcmVzdWx0LnB1c2godG9vbCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIFByZXBlbmRzIHJlc291cmNlIG5hbWUgd2l0aCBwcm9qZWN0LCBsb2NhdGlvbiwgcmVzb3VyY2VfcHJlZml4IGlmIG5lZWRlZC5cbiAqXG4gKiBAcGFyYW0gY2xpZW50IFRoZSBBUEkgY2xpZW50LlxuICogQHBhcmFtIHJlc291cmNlTmFtZSBUaGUgcmVzb3VyY2UgbmFtZS5cbiAqIEBwYXJhbSByZXNvdXJjZVByZWZpeCBUaGUgcmVzb3VyY2UgcHJlZml4LlxuICogQHBhcmFtIHNwbGl0c0FmdGVyUHJlZml4IFRoZSBudW1iZXIgb2Ygc3BsaXRzIGFmdGVyIHRoZSBwcmVmaXguXG4gKiBAcmV0dXJucyBUaGUgY29tcGxldGVkIHJlc291cmNlIG5hbWUuXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogYGBgXG4gKiByZXNvdXJjZV9uYW1lID0gJzEyMydcbiAqIHJlc291cmNlX3ByZWZpeCA9ICdjYWNoZWRDb250ZW50cydcbiAqIHNwbGl0c19hZnRlcl9wcmVmaXggPSAxXG4gKiBjbGllbnQudmVydGV4YWkgPSBUcnVlXG4gKiBjbGllbnQucHJvamVjdCA9ICdiYXInXG4gKiBjbGllbnQubG9jYXRpb24gPSAndXMtd2VzdDEnXG4gKiBfcmVzb3VyY2VfbmFtZShjbGllbnQsIHJlc291cmNlX25hbWUsIHJlc291cmNlX3ByZWZpeCwgc3BsaXRzX2FmdGVyX3ByZWZpeClcbiAqIHJldHVybnM6ICdwcm9qZWN0cy9iYXIvbG9jYXRpb25zL3VzLXdlc3QxL2NhY2hlZENvbnRlbnRzLzEyMydcbiAqIGBgYFxuICpcbiAqIGBgYFxuICogcmVzb3VyY2VfbmFtZSA9ICdwcm9qZWN0cy9mb28vbG9jYXRpb25zL3VzLWNlbnRyYWwxL2NhY2hlZENvbnRlbnRzLzEyMydcbiAqIHJlc291cmNlX3ByZWZpeCA9ICdjYWNoZWRDb250ZW50cydcbiAqIHNwbGl0c19hZnRlcl9wcmVmaXggPSAxXG4gKiBjbGllbnQudmVydGV4YWkgPSBUcnVlXG4gKiBjbGllbnQucHJvamVjdCA9ICdiYXInXG4gKiBjbGllbnQubG9jYXRpb24gPSAndXMtd2VzdDEnXG4gKiBfcmVzb3VyY2VfbmFtZShjbGllbnQsIHJlc291cmNlX25hbWUsIHJlc291cmNlX3ByZWZpeCwgc3BsaXRzX2FmdGVyX3ByZWZpeClcbiAqIHJldHVybnM6ICdwcm9qZWN0cy9mb28vbG9jYXRpb25zL3VzLWNlbnRyYWwxL2NhY2hlZENvbnRlbnRzLzEyMydcbiAqIGBgYFxuICpcbiAqIGBgYFxuICogcmVzb3VyY2VfbmFtZSA9ICcxMjMnXG4gKiByZXNvdXJjZV9wcmVmaXggPSAnY2FjaGVkQ29udGVudHMnXG4gKiBzcGxpdHNfYWZ0ZXJfcHJlZml4ID0gMVxuICogY2xpZW50LnZlcnRleGFpID0gRmFsc2VcbiAqIF9yZXNvdXJjZV9uYW1lKGNsaWVudCwgcmVzb3VyY2VfbmFtZSwgcmVzb3VyY2VfcHJlZml4LCBzcGxpdHNfYWZ0ZXJfcHJlZml4KVxuICogcmV0dXJucyAnY2FjaGVkQ29udGVudHMvMTIzJ1xuICogYGBgXG4gKlxuICogYGBgXG4gKiByZXNvdXJjZV9uYW1lID0gJ3NvbWUvd3JvbmcvY2FjaGVkQ29udGVudHMvcmVzb3VyY2UvbmFtZS8xMjMnXG4gKiByZXNvdXJjZV9wcmVmaXggPSAnY2FjaGVkQ29udGVudHMnXG4gKiBzcGxpdHNfYWZ0ZXJfcHJlZml4ID0gMVxuICogY2xpZW50LnZlcnRleGFpID0gRmFsc2VcbiAqICMgY2xpZW50LnZlcnRleGFpID0gVHJ1ZVxuICogX3Jlc291cmNlX25hbWUoY2xpZW50LCByZXNvdXJjZV9uYW1lLCByZXNvdXJjZV9wcmVmaXgsIHNwbGl0c19hZnRlcl9wcmVmaXgpXG4gKiAtPiAnc29tZS93cm9uZy9yZXNvdXJjZS9uYW1lLzEyMydcbiAqIGBgYFxuICovXG5mdW5jdGlvbiByZXNvdXJjZU5hbWUoY2xpZW50LCByZXNvdXJjZU5hbWUsIHJlc291cmNlUHJlZml4LCBzcGxpdHNBZnRlclByZWZpeCA9IDEpIHtcbiAgICBjb25zdCBzaG91bGRBcHBlbmRQcmVmaXggPSAhcmVzb3VyY2VOYW1lLnN0YXJ0c1dpdGgoYCR7cmVzb3VyY2VQcmVmaXh9L2ApICYmXG4gICAgICAgIHJlc291cmNlTmFtZS5zcGxpdCgnLycpLmxlbmd0aCA9PT0gc3BsaXRzQWZ0ZXJQcmVmaXg7XG4gICAgaWYgKGNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgaWYgKHJlc291cmNlTmFtZS5zdGFydHNXaXRoKCdwcm9qZWN0cy8nKSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc291cmNlTmFtZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZXNvdXJjZU5hbWUuc3RhcnRzV2l0aCgnbG9jYXRpb25zLycpKSB7XG4gICAgICAgICAgICByZXR1cm4gYHByb2plY3RzLyR7Y2xpZW50LmdldFByb2plY3QoKX0vJHtyZXNvdXJjZU5hbWV9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZXNvdXJjZU5hbWUuc3RhcnRzV2l0aChgJHtyZXNvdXJjZVByZWZpeH0vYCkpIHtcbiAgICAgICAgICAgIHJldHVybiBgcHJvamVjdHMvJHtjbGllbnQuZ2V0UHJvamVjdCgpfS9sb2NhdGlvbnMvJHtjbGllbnQuZ2V0TG9jYXRpb24oKX0vJHtyZXNvdXJjZU5hbWV9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzaG91bGRBcHBlbmRQcmVmaXgpIHtcbiAgICAgICAgICAgIHJldHVybiBgcHJvamVjdHMvJHtjbGllbnQuZ2V0UHJvamVjdCgpfS9sb2NhdGlvbnMvJHtjbGllbnQuZ2V0TG9jYXRpb24oKX0vJHtyZXNvdXJjZVByZWZpeH0vJHtyZXNvdXJjZU5hbWV9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiByZXNvdXJjZU5hbWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNob3VsZEFwcGVuZFByZWZpeCkge1xuICAgICAgICByZXR1cm4gYCR7cmVzb3VyY2VQcmVmaXh9LyR7cmVzb3VyY2VOYW1lfWA7XG4gICAgfVxuICAgIHJldHVybiByZXNvdXJjZU5hbWU7XG59XG5mdW5jdGlvbiB0Q2FjaGVkQ29udGVudE5hbWUoYXBpQ2xpZW50LCBuYW1lKSB7XG4gICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25hbWUgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzb3VyY2VOYW1lKGFwaUNsaWVudCwgbmFtZSwgJ2NhY2hlZENvbnRlbnRzJyk7XG59XG5mdW5jdGlvbiB0VHVuaW5nSm9iU3RhdHVzKHN0YXR1cykge1xuICAgIHN3aXRjaCAoc3RhdHVzKSB7XG4gICAgICAgIGNhc2UgJ1NUQVRFX1VOU1BFQ0lGSUVEJzpcbiAgICAgICAgICAgIHJldHVybiAnSk9CX1NUQVRFX1VOU1BFQ0lGSUVEJztcbiAgICAgICAgY2FzZSAnQ1JFQVRJTkcnOlxuICAgICAgICAgICAgcmV0dXJuICdKT0JfU1RBVEVfUlVOTklORyc7XG4gICAgICAgIGNhc2UgJ0FDVElWRSc6XG4gICAgICAgICAgICByZXR1cm4gJ0pPQl9TVEFURV9TVUNDRUVERUQnO1xuICAgICAgICBjYXNlICdGQUlMRUQnOlxuICAgICAgICAgICAgcmV0dXJuICdKT0JfU1RBVEVfRkFJTEVEJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBzdGF0dXM7XG4gICAgfVxufVxuZnVuY3Rpb24gdEJ5dGVzKGZyb21JbWFnZUJ5dGVzKSB7XG4gICAgaWYgKHR5cGVvZiBmcm9tSW1hZ2VCeXRlcyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmcm9tSW1hZ2VCeXRlcyBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgfVxuICAgIC8vIFRPRE8oYi8zODkxMzM5MTQpOiBSZW1vdmUgZHVtbXkgYnl0ZXMgY29udmVydGVyLlxuICAgIHJldHVybiBmcm9tSW1hZ2VCeXRlcztcbn1cbmZ1bmN0aW9uIF9pc0ZpbGUob3JpZ2luKSB7XG4gICAgcmV0dXJuIChvcmlnaW4gIT09IG51bGwgJiZcbiAgICAgICAgb3JpZ2luICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgdHlwZW9mIG9yaWdpbiA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgJ25hbWUnIGluIG9yaWdpbik7XG59XG5mdW5jdGlvbiBpc0dlbmVyYXRlZFZpZGVvKG9yaWdpbikge1xuICAgIHJldHVybiAob3JpZ2luICE9PSBudWxsICYmXG4gICAgICAgIG9yaWdpbiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIHR5cGVvZiBvcmlnaW4gPT09ICdvYmplY3QnICYmXG4gICAgICAgICd2aWRlbycgaW4gb3JpZ2luKTtcbn1cbmZ1bmN0aW9uIGlzVmlkZW8ob3JpZ2luKSB7XG4gICAgcmV0dXJuIChvcmlnaW4gIT09IG51bGwgJiZcbiAgICAgICAgb3JpZ2luICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgdHlwZW9mIG9yaWdpbiA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgJ3VyaScgaW4gb3JpZ2luKTtcbn1cbmZ1bmN0aW9uIHRGaWxlTmFtZShmcm9tTmFtZSkge1xuICAgIHZhciBfYTtcbiAgICBsZXQgbmFtZTtcbiAgICBpZiAoX2lzRmlsZShmcm9tTmFtZSkpIHtcbiAgICAgICAgbmFtZSA9IGZyb21OYW1lLm5hbWU7XG4gICAgfVxuICAgIGlmIChpc1ZpZGVvKGZyb21OYW1lKSkge1xuICAgICAgICBuYW1lID0gZnJvbU5hbWUudXJpO1xuICAgICAgICBpZiAobmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChpc0dlbmVyYXRlZFZpZGVvKGZyb21OYW1lKSkge1xuICAgICAgICBuYW1lID0gKF9hID0gZnJvbU5hbWUudmlkZW8pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS51cmk7XG4gICAgICAgIGlmIChuYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBmcm9tTmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgbmFtZSA9IGZyb21OYW1lO1xuICAgIH1cbiAgICBpZiAobmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGV4dHJhY3QgZmlsZSBuYW1lIGZyb20gdGhlIHByb3ZpZGVkIGlucHV0LicpO1xuICAgIH1cbiAgICBpZiAobmFtZS5zdGFydHNXaXRoKCdodHRwczovLycpKSB7XG4gICAgICAgIGNvbnN0IHN1ZmZpeCA9IG5hbWUuc3BsaXQoJ2ZpbGVzLycpWzFdO1xuICAgICAgICBjb25zdCBtYXRjaCA9IHN1ZmZpeC5tYXRjaCgvW2EtejAtOV0rLyk7XG4gICAgICAgIGlmIChtYXRjaCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZXh0cmFjdCBmaWxlIG5hbWUgZnJvbSBVUkkgJHtuYW1lfWApO1xuICAgICAgICB9XG4gICAgICAgIG5hbWUgPSBtYXRjaFswXTtcbiAgICB9XG4gICAgZWxzZSBpZiAobmFtZS5zdGFydHNXaXRoKCdmaWxlcy8nKSkge1xuICAgICAgICBuYW1lID0gbmFtZS5zcGxpdCgnZmlsZXMvJylbMV07XG4gICAgfVxuICAgIHJldHVybiBuYW1lO1xufVxuZnVuY3Rpb24gdE1vZGVsc1VybChhcGlDbGllbnQsIGJhc2VNb2RlbHMpIHtcbiAgICBsZXQgcmVzO1xuICAgIGlmIChhcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgIHJlcyA9IGJhc2VNb2RlbHMgPyAncHVibGlzaGVycy9nb29nbGUvbW9kZWxzJyA6ICdtb2RlbHMnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmVzID0gYmFzZU1vZGVscyA/ICdtb2RlbHMnIDogJ3R1bmVkTW9kZWxzJztcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIHRFeHRyYWN0TW9kZWxzKHJlc3BvbnNlKSB7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgWydtb2RlbHMnLCAndHVuZWRNb2RlbHMnLCAncHVibGlzaGVyTW9kZWxzJ10pIHtcbiAgICAgICAgaWYgKGhhc0ZpZWxkKHJlc3BvbnNlLCBrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2Vba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW107XG59XG5mdW5jdGlvbiBoYXNGaWVsZChkYXRhLCBmaWVsZE5hbWUpIHtcbiAgICByZXR1cm4gZGF0YSAhPT0gbnVsbCAmJiB0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcgJiYgZmllbGROYW1lIGluIGRhdGE7XG59XG5mdW5jdGlvbiBtY3BUb0dlbWluaVRvb2wobWNwVG9vbCwgY29uZmlnID0ge30pIHtcbiAgICBjb25zdCBtY3BUb29sU2NoZW1hID0gbWNwVG9vbDtcbiAgICBjb25zdCBmdW5jdGlvbkRlY2xhcmF0aW9uID0ge1xuICAgICAgICBuYW1lOiBtY3BUb29sU2NoZW1hWyduYW1lJ10sXG4gICAgICAgIGRlc2NyaXB0aW9uOiBtY3BUb29sU2NoZW1hWydkZXNjcmlwdGlvbiddLFxuICAgICAgICBwYXJhbWV0ZXJzOiBwcm9jZXNzSnNvblNjaGVtYShmaWx0ZXJUb0pzb25TY2hlbWEobWNwVG9vbFNjaGVtYVsnaW5wdXRTY2hlbWEnXSkpLFxuICAgIH07XG4gICAgaWYgKGNvbmZpZy5iZWhhdmlvcikge1xuICAgICAgICBmdW5jdGlvbkRlY2xhcmF0aW9uWydiZWhhdmlvciddID0gY29uZmlnLmJlaGF2aW9yO1xuICAgIH1cbiAgICBjb25zdCBnZW1pbmlUb29sID0ge1xuICAgICAgICBmdW5jdGlvbkRlY2xhcmF0aW9uczogW1xuICAgICAgICAgICAgZnVuY3Rpb25EZWNsYXJhdGlvbixcbiAgICAgICAgXSxcbiAgICB9O1xuICAgIHJldHVybiBnZW1pbmlUb29sO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIGxpc3Qgb2YgTUNQIHRvb2xzIHRvIGEgc2luZ2xlIEdlbWluaSB0b29sIHdpdGggYSBsaXN0IG9mIGZ1bmN0aW9uXG4gKiBkZWNsYXJhdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIG1jcFRvb2xzVG9HZW1pbmlUb29sKG1jcFRvb2xzLCBjb25maWcgPSB7fSkge1xuICAgIGNvbnN0IGZ1bmN0aW9uRGVjbGFyYXRpb25zID0gW107XG4gICAgY29uc3QgdG9vbE5hbWVzID0gbmV3IFNldCgpO1xuICAgIGZvciAoY29uc3QgbWNwVG9vbCBvZiBtY3BUb29scykge1xuICAgICAgICBjb25zdCBtY3BUb29sTmFtZSA9IG1jcFRvb2wubmFtZTtcbiAgICAgICAgaWYgKHRvb2xOYW1lcy5oYXMobWNwVG9vbE5hbWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYER1cGxpY2F0ZSBmdW5jdGlvbiBuYW1lICR7bWNwVG9vbE5hbWV9IGZvdW5kIGluIE1DUCB0b29scy4gUGxlYXNlIGVuc3VyZSBmdW5jdGlvbiBuYW1lcyBhcmUgdW5pcXVlLmApO1xuICAgICAgICB9XG4gICAgICAgIHRvb2xOYW1lcy5hZGQobWNwVG9vbE5hbWUpO1xuICAgICAgICBjb25zdCBnZW1pbmlUb29sID0gbWNwVG9HZW1pbmlUb29sKG1jcFRvb2wsIGNvbmZpZyk7XG4gICAgICAgIGlmIChnZW1pbmlUb29sLmZ1bmN0aW9uRGVjbGFyYXRpb25zKSB7XG4gICAgICAgICAgICBmdW5jdGlvbkRlY2xhcmF0aW9ucy5wdXNoKC4uLmdlbWluaVRvb2wuZnVuY3Rpb25EZWNsYXJhdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IGZ1bmN0aW9uRGVjbGFyYXRpb25zOiBmdW5jdGlvbkRlY2xhcmF0aW9ucyB9O1xufVxuLy8gRmlsdGVycyB0aGUgbGlzdCBzY2hlbWEgZmllbGQgdG8gb25seSBpbmNsdWRlIGZpZWxkcyB0aGF0IGFyZSBzdXBwb3J0ZWQgYnlcbi8vIEpTT05TY2hlbWEuXG5mdW5jdGlvbiBmaWx0ZXJMaXN0U2NoZW1hRmllbGQoZmllbGRWYWx1ZSkge1xuICAgIGNvbnN0IGxpc3RTY2hlbWFGaWVsZFZhbHVlID0gW107XG4gICAgZm9yIChjb25zdCBsaXN0RmllbGRWYWx1ZSBvZiBmaWVsZFZhbHVlKSB7XG4gICAgICAgIGxpc3RTY2hlbWFGaWVsZFZhbHVlLnB1c2goZmlsdGVyVG9Kc29uU2NoZW1hKGxpc3RGaWVsZFZhbHVlKSk7XG4gICAgfVxuICAgIHJldHVybiBsaXN0U2NoZW1hRmllbGRWYWx1ZTtcbn1cbi8vIEZpbHRlcnMgdGhlIGRpY3Qgc2NoZW1hIGZpZWxkIHRvIG9ubHkgaW5jbHVkZSBmaWVsZHMgdGhhdCBhcmUgc3VwcG9ydGVkIGJ5XG4vLyBKU09OU2NoZW1hLlxuZnVuY3Rpb24gZmlsdGVyRGljdFNjaGVtYUZpZWxkKGZpZWxkVmFsdWUpIHtcbiAgICBjb25zdCBkaWN0U2NoZW1hRmllbGRWYWx1ZSA9IHt9O1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGZpZWxkVmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlUmVjb3JkID0gdmFsdWU7XG4gICAgICAgIGRpY3RTY2hlbWFGaWVsZFZhbHVlW2tleV0gPSBmaWx0ZXJUb0pzb25TY2hlbWEodmFsdWVSZWNvcmQpO1xuICAgIH1cbiAgICByZXR1cm4gZGljdFNjaGVtYUZpZWxkVmFsdWU7XG59XG4vLyBGaWx0ZXJzIHRoZSBzY2hlbWEgdG8gb25seSBpbmNsdWRlIGZpZWxkcyB0aGF0IGFyZSBzdXBwb3J0ZWQgYnkgSlNPTlNjaGVtYS5cbmZ1bmN0aW9uIGZpbHRlclRvSnNvblNjaGVtYShzY2hlbWEpIHtcbiAgICBjb25zdCBzY2hlbWFGaWVsZE5hbWVzID0gbmV3IFNldChbJ2l0ZW1zJ10pOyAvLyAnYWRkaXRpb25hbF9wcm9wZXJ0aWVzJyB0byBjb21lXG4gICAgY29uc3QgbGlzdFNjaGVtYUZpZWxkTmFtZXMgPSBuZXcgU2V0KFsnYW55T2YnXSk7IC8vICdvbmVfb2YnLCAnYWxsX29mJywgJ25vdCcgdG8gY29tZVxuICAgIGNvbnN0IGRpY3RTY2hlbWFGaWVsZE5hbWVzID0gbmV3IFNldChbJ3Byb3BlcnRpZXMnXSk7IC8vICdkZWZzJyB0byBjb21lXG4gICAgY29uc3QgZmlsdGVyZWRTY2hlbWEgPSB7fTtcbiAgICBmb3IgKGNvbnN0IFtmaWVsZE5hbWUsIGZpZWxkVmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHNjaGVtYSkpIHtcbiAgICAgICAgaWYgKHNjaGVtYUZpZWxkTmFtZXMuaGFzKGZpZWxkTmFtZSkpIHtcbiAgICAgICAgICAgIGZpbHRlcmVkU2NoZW1hW2ZpZWxkTmFtZV0gPSBmaWx0ZXJUb0pzb25TY2hlbWEoZmllbGRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGlzdFNjaGVtYUZpZWxkTmFtZXMuaGFzKGZpZWxkTmFtZSkpIHtcbiAgICAgICAgICAgIGZpbHRlcmVkU2NoZW1hW2ZpZWxkTmFtZV0gPSBmaWx0ZXJMaXN0U2NoZW1hRmllbGQoZmllbGRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGljdFNjaGVtYUZpZWxkTmFtZXMuaGFzKGZpZWxkTmFtZSkpIHtcbiAgICAgICAgICAgIGZpbHRlcmVkU2NoZW1hW2ZpZWxkTmFtZV0gPSBmaWx0ZXJEaWN0U2NoZW1hRmllbGQoZmllbGRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZmllbGROYW1lID09PSAndHlwZScpIHtcbiAgICAgICAgICAgIGNvbnN0IHR5cGVWYWx1ZSA9IGZpZWxkVmFsdWUudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgIGZpbHRlcmVkU2NoZW1hW2ZpZWxkTmFtZV0gPSBPYmplY3QudmFsdWVzKFR5cGUpLmluY2x1ZGVzKHR5cGVWYWx1ZSlcbiAgICAgICAgICAgICAgICA/IHR5cGVWYWx1ZVxuICAgICAgICAgICAgICAgIDogVHlwZS5UWVBFX1VOU1BFQ0lGSUVEO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN1cHBvcnRlZEpzb25TY2hlbWFGaWVsZHMuaGFzKGZpZWxkTmFtZSkpIHtcbiAgICAgICAgICAgIGZpbHRlcmVkU2NoZW1hW2ZpZWxkTmFtZV0gPSBmaWVsZFZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmaWx0ZXJlZFNjaGVtYTtcbn1cbi8vIFRyYW5zZm9ybXMgYSBzb3VyY2UgaW5wdXQgaW50byBhIEJhdGNoSm9iU291cmNlIG9iamVjdCB3aXRoIHZhbGlkYXRpb24uXG5mdW5jdGlvbiB0QmF0Y2hKb2JTb3VyY2UoYXBpQ2xpZW50LCBzcmMpIHtcbiAgICBpZiAodHlwZW9mIHNyYyAhPT0gJ3N0cmluZycgJiYgIUFycmF5LmlzQXJyYXkoc3JjKSkge1xuICAgICAgICBpZiAoYXBpQ2xpZW50ICYmIGFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGlmIChzcmMuZ2NzVXJpICYmIHNyYy5iaWdxdWVyeVVyaSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT25seSBvbmUgb2YgYGdjc1VyaWAgb3IgYGJpZ3F1ZXJ5VXJpYCBjYW4gYmUgc2V0LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIXNyYy5nY3NVcmkgJiYgIXNyYy5iaWdxdWVyeVVyaSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT25lIG9mIGBnY3NVcmlgIG9yIGBiaWdxdWVyeVVyaWAgbXVzdCBiZSBzZXQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBMb2dpYyBmb3Igbm9uLVZlcnRleCBBSSBjbGllbnQgKGlubGluZWRfcmVxdWVzdHMsIGZpbGVfbmFtZSlcbiAgICAgICAgICAgIGlmIChzcmMuaW5saW5lZFJlcXVlc3RzICYmIHNyYy5maWxlTmFtZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT25seSBvbmUgb2YgYGlubGluZWRSZXF1ZXN0c2Agb3IgYGZpbGVOYW1lYCBjYW4gYmUgc2V0LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIXNyYy5pbmxpbmVkUmVxdWVzdHMgJiYgIXNyYy5maWxlTmFtZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT25lIG9mIGBpbmxpbmVkUmVxdWVzdHNgIG9yIGBmaWxlTmFtZWAgbXVzdCBiZSBzZXQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNyYztcbiAgICB9XG4gICAgLy8gSWYgc3JjIGlzIGFuIGFycmF5IChsaXN0IGluIFB5dGhvbilcbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHNyYykpIHtcbiAgICAgICAgcmV0dXJuIHsgaW5saW5lZFJlcXVlc3RzOiBzcmMgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHNyYyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHNyYy5zdGFydHNXaXRoKCdnczovLycpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGZvcm1hdDogJ2pzb25sJyxcbiAgICAgICAgICAgICAgICBnY3NVcmk6IFtzcmNdLCAvLyBHQ1MgVVJJIGlzIGV4cGVjdGVkIGFzIGFuIGFycmF5XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNyYy5zdGFydHNXaXRoKCdicTovLycpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGZvcm1hdDogJ2JpZ3F1ZXJ5JyxcbiAgICAgICAgICAgICAgICBiaWdxdWVyeVVyaTogc3JjLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzcmMuc3RhcnRzV2l0aCgnZmlsZXMvJykpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZmlsZU5hbWU6IHNyYyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBzb3VyY2U6ICR7c3JjfWApO1xufVxuZnVuY3Rpb24gdEJhdGNoSm9iRGVzdGluYXRpb24oZGVzdCkge1xuICAgIGNvbnN0IGRlc3RTdHJpbmcgPSBkZXN0O1xuICAgIGlmIChkZXN0U3RyaW5nLnN0YXJ0c1dpdGgoJ2dzOi8vJykpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZvcm1hdDogJ2pzb25sJyxcbiAgICAgICAgICAgIGdjc1VyaTogZGVzdFN0cmluZyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGVzdFN0cmluZy5zdGFydHNXaXRoKCdicTovLycpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmb3JtYXQ6ICdiaWdxdWVyeScsXG4gICAgICAgICAgICBiaWdxdWVyeVVyaTogZGVzdFN0cmluZyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZGVzdGluYXRpb246ICR7ZGVzdFN0cmluZ31gKTtcbiAgICB9XG59XG5mdW5jdGlvbiB0QmF0Y2hKb2JOYW1lKGFwaUNsaWVudCwgbmFtZSkge1xuICAgIGNvbnN0IG5hbWVTdHJpbmcgPSBuYW1lO1xuICAgIGlmICghYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICBjb25zdCBtbGRldlBhdHRlcm4gPSAvYmF0Y2hlc1xcL1teL10rJC87XG4gICAgICAgIGlmIChtbGRldlBhdHRlcm4udGVzdChuYW1lU3RyaW5nKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5hbWVTdHJpbmcuc3BsaXQoJy8nKS5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBiYXRjaCBqb2IgbmFtZTogJHtuYW1lU3RyaW5nfS5gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB2ZXJ0ZXhQYXR0ZXJuID0gL15wcm9qZWN0c1xcL1teL10rXFwvbG9jYXRpb25zXFwvW14vXStcXC9iYXRjaFByZWRpY3Rpb25Kb2JzXFwvW14vXSskLztcbiAgICBpZiAodmVydGV4UGF0dGVybi50ZXN0KG5hbWVTdHJpbmcpKSB7XG4gICAgICAgIHJldHVybiBuYW1lU3RyaW5nLnNwbGl0KCcvJykucG9wKCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKC9eXFxkKyQvLnRlc3QobmFtZVN0cmluZykpIHtcbiAgICAgICAgcmV0dXJuIG5hbWVTdHJpbmc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgYmF0Y2ggam9iIG5hbWU6ICR7bmFtZVN0cmluZ30uYCk7XG4gICAgfVxufVxuZnVuY3Rpb24gdEpvYlN0YXRlKHN0YXRlKSB7XG4gICAgY29uc3Qgc3RhdGVTdHJpbmcgPSBzdGF0ZTtcbiAgICBpZiAoc3RhdGVTdHJpbmcgPT09ICdCQVRDSF9TVEFURV9VTlNQRUNJRklFRCcpIHtcbiAgICAgICAgcmV0dXJuICdKT0JfU1RBVEVfVU5TUEVDSUZJRUQnO1xuICAgIH1cbiAgICBlbHNlIGlmIChzdGF0ZVN0cmluZyA9PT0gJ0JBVENIX1NUQVRFX1BFTkRJTkcnKSB7XG4gICAgICAgIHJldHVybiAnSk9CX1NUQVRFX1BFTkRJTkcnO1xuICAgIH1cbiAgICBlbHNlIGlmIChzdGF0ZVN0cmluZyA9PT0gJ0JBVENIX1NUQVRFX1NVQ0NFRURFRCcpIHtcbiAgICAgICAgcmV0dXJuICdKT0JfU1RBVEVfU1VDQ0VFREVEJztcbiAgICB9XG4gICAgZWxzZSBpZiAoc3RhdGVTdHJpbmcgPT09ICdCQVRDSF9TVEFURV9GQUlMRUQnKSB7XG4gICAgICAgIHJldHVybiAnSk9CX1NUQVRFX0ZBSUxFRCc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHN0YXRlU3RyaW5nID09PSAnQkFUQ0hfU1RBVEVfQ0FOQ0VMTEVEJykge1xuICAgICAgICByZXR1cm4gJ0pPQl9TVEFURV9DQU5DRUxMRUQnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlU3RyaW5nO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuZnVuY3Rpb24gdmlkZW9NZXRhZGF0YVRvTWxkZXYkNChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRnBzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmcHMnXSk7XG4gICAgaWYgKGZyb21GcHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmcHMnXSwgZnJvbUZwcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmRPZmZzZXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VuZE9mZnNldCddKTtcbiAgICBpZiAoZnJvbUVuZE9mZnNldCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VuZE9mZnNldCddLCBmcm9tRW5kT2Zmc2V0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN0YXJ0T2Zmc2V0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzdGFydE9mZnNldCddKTtcbiAgICBpZiAoZnJvbVN0YXJ0T2Zmc2V0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3RhcnRPZmZzZXQnXSwgZnJvbVN0YXJ0T2Zmc2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gYmxvYlRvTWxkZXYkNChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZGlzcGxheU5hbWUgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2RhdGEnXSk7XG4gICAgaWYgKGZyb21EYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGF0YSddLCBmcm9tRGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZpbGVEYXRhVG9NbGRldiQ0KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaXNwbGF5TmFtZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsZVVyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZVVyaSddKTtcbiAgICBpZiAoZnJvbUZpbGVVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWxlVXJpJ10sIGZyb21GaWxlVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gcGFydFRvTWxkZXYkNChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVmlkZW9NZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ZpZGVvTWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVmlkZW9NZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZpZGVvTWV0YWRhdGEnXSwgdmlkZW9NZXRhZGF0YVRvTWxkZXYkNChmcm9tVmlkZW9NZXRhZGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhvdWdodCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGhvdWdodCddKTtcbiAgICBpZiAoZnJvbVRob3VnaHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aG91Z2h0J10sIGZyb21UaG91Z2h0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUlubGluZURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2lubGluZURhdGEnXSk7XG4gICAgaWYgKGZyb21JbmxpbmVEYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5saW5lRGF0YSddLCBibG9iVG9NbGRldiQ0KGZyb21JbmxpbmVEYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWxlRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZURhdGEnXSk7XG4gICAgaWYgKGZyb21GaWxlRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVEYXRhJ10sIGZpbGVEYXRhVG9NbGRldiQ0KGZyb21GaWxlRGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhvdWdodFNpZ25hdHVyZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Rob3VnaHRTaWduYXR1cmUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVGhvdWdodFNpZ25hdHVyZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rob3VnaHRTaWduYXR1cmUnXSwgZnJvbVRob3VnaHRTaWduYXR1cmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NvZGVFeGVjdXRpb25SZXN1bHQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvZGVFeGVjdXRpb25SZXN1bHQnXSwgZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXhlY3V0YWJsZUNvZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdleGVjdXRhYmxlQ29kZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FeGVjdXRhYmxlQ29kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2V4ZWN1dGFibGVDb2RlJ10sIGZyb21FeGVjdXRhYmxlQ29kZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GdW5jdGlvbkNhbGwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Z1bmN0aW9uQ2FsbCddKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uQ2FsbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uQ2FsbCddLCBmcm9tRnVuY3Rpb25DYWxsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvblJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvblJlc3BvbnNlJ10sIGZyb21GdW5jdGlvblJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRleHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RleHQnXSk7XG4gICAgaWYgKGZyb21UZXh0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGV4dCddLCBmcm9tVGV4dCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNvbnRlbnRUb01sZGV2JDQoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVBhcnRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYXJ0cyddKTtcbiAgICBpZiAoZnJvbVBhcnRzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21QYXJ0cztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0VG9NbGRldiQ0KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncGFydHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJvbGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3JvbGUnXSk7XG4gICAgaWYgKGZyb21Sb2xlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncm9sZSddLCBmcm9tUm9sZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHNjaGVtYVRvTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQW55T2YgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2FueU9mJ10pO1xuICAgIGlmIChmcm9tQW55T2YgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhbnlPZiddLCBmcm9tQW55T2YpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGVmYXVsdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGVmYXVsdCddKTtcbiAgICBpZiAoZnJvbURlZmF1bHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkZWZhdWx0J10sIGZyb21EZWZhdWx0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURlc2NyaXB0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkZXNjcmlwdGlvbiddKTtcbiAgICBpZiAoZnJvbURlc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGVzY3JpcHRpb24nXSwgZnJvbURlc2NyaXB0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVudW0gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VudW0nXSk7XG4gICAgaWYgKGZyb21FbnVtICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW51bSddLCBmcm9tRW51bSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FeGFtcGxlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydleGFtcGxlJ10pO1xuICAgIGlmIChmcm9tRXhhbXBsZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2V4YW1wbGUnXSwgZnJvbUV4YW1wbGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRm9ybWF0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmb3JtYXQnXSk7XG4gICAgaWYgKGZyb21Gb3JtYXQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmb3JtYXQnXSwgZnJvbUZvcm1hdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JdGVtcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaXRlbXMnXSk7XG4gICAgaWYgKGZyb21JdGVtcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2l0ZW1zJ10sIGZyb21JdGVtcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NYXhJdGVtcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWF4SXRlbXMnXSk7XG4gICAgaWYgKGZyb21NYXhJdGVtcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21heEl0ZW1zJ10sIGZyb21NYXhJdGVtcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NYXhMZW5ndGggPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21heExlbmd0aCddKTtcbiAgICBpZiAoZnJvbU1heExlbmd0aCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21heExlbmd0aCddLCBmcm9tTWF4TGVuZ3RoKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1heFByb3BlcnRpZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtYXhQcm9wZXJ0aWVzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU1heFByb3BlcnRpZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtYXhQcm9wZXJ0aWVzJ10sIGZyb21NYXhQcm9wZXJ0aWVzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1heGltdW0gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21heGltdW0nXSk7XG4gICAgaWYgKGZyb21NYXhpbXVtICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWF4aW11bSddLCBmcm9tTWF4aW11bSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW5JdGVtcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWluSXRlbXMnXSk7XG4gICAgaWYgKGZyb21NaW5JdGVtcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbkl0ZW1zJ10sIGZyb21NaW5JdGVtcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW5MZW5ndGggPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbkxlbmd0aCddKTtcbiAgICBpZiAoZnJvbU1pbkxlbmd0aCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbkxlbmd0aCddLCBmcm9tTWluTGVuZ3RoKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pblByb3BlcnRpZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtaW5Qcm9wZXJ0aWVzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU1pblByb3BlcnRpZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW5Qcm9wZXJ0aWVzJ10sIGZyb21NaW5Qcm9wZXJ0aWVzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbmltdW0gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbmltdW0nXSk7XG4gICAgaWYgKGZyb21NaW5pbXVtICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWluaW11bSddLCBmcm9tTWluaW11bSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OdWxsYWJsZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbnVsbGFibGUnXSk7XG4gICAgaWYgKGZyb21OdWxsYWJsZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ251bGxhYmxlJ10sIGZyb21OdWxsYWJsZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QYXR0ZXJuID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYXR0ZXJuJ10pO1xuICAgIGlmIChmcm9tUGF0dGVybiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BhdHRlcm4nXSwgZnJvbVBhdHRlcm4pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJvcGVydGllcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncHJvcGVydGllcyddKTtcbiAgICBpZiAoZnJvbVByb3BlcnRpZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcm9wZXJ0aWVzJ10sIGZyb21Qcm9wZXJ0aWVzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVByb3BlcnR5T3JkZXJpbmcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcm9wZXJ0eU9yZGVyaW5nJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVByb3BlcnR5T3JkZXJpbmcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcm9wZXJ0eU9yZGVyaW5nJ10sIGZyb21Qcm9wZXJ0eU9yZGVyaW5nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlcXVpcmVkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXF1aXJlZCddKTtcbiAgICBpZiAoZnJvbVJlcXVpcmVkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVxdWlyZWQnXSwgZnJvbVJlcXVpcmVkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRpdGxlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0aXRsZSddKTtcbiAgICBpZiAoZnJvbVRpdGxlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGl0bGUnXSwgZnJvbVRpdGxlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3R5cGUnXSk7XG4gICAgaWYgKGZyb21UeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndHlwZSddLCBmcm9tVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHNhZmV0eVNldHRpbmdUb01sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWV0aG9kJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtZXRob2QgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNhdGVnb3J5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjYXRlZ29yeSddKTtcbiAgICBpZiAoZnJvbUNhdGVnb3J5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2F0ZWdvcnknXSwgZnJvbUNhdGVnb3J5KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRocmVzaG9sZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGhyZXNob2xkJ10pO1xuICAgIGlmIChmcm9tVGhyZXNob2xkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhyZXNob2xkJ10sIGZyb21UaHJlc2hvbGQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBmdW5jdGlvbkRlY2xhcmF0aW9uVG9NbGRldiQ0KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21CZWhhdmlvciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYmVoYXZpb3InXSk7XG4gICAgaWYgKGZyb21CZWhhdmlvciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2JlaGF2aW9yJ10sIGZyb21CZWhhdmlvcik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EZXNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGVzY3JpcHRpb24nXSk7XG4gICAgaWYgKGZyb21EZXNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10sIGZyb21EZXNjcmlwdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGFyYW1ldGVycyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFyYW1ldGVycyddKTtcbiAgICBpZiAoZnJvbVBhcmFtZXRlcnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJhbWV0ZXJzJ10sIGZyb21QYXJhbWV0ZXJzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhcmFtZXRlcnNKc29uU2NoZW1hID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncGFyYW1ldGVyc0pzb25TY2hlbWEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUGFyYW1ldGVyc0pzb25TY2hlbWEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJhbWV0ZXJzSnNvblNjaGVtYSddLCBmcm9tUGFyYW1ldGVyc0pzb25TY2hlbWEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Jlc3BvbnNlJ10pO1xuICAgIGlmIChmcm9tUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZSddLCBmcm9tUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VKc29uU2NoZW1hID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VKc29uU2NoZW1hJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlSnNvblNjaGVtYSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlSnNvblNjaGVtYSddLCBmcm9tUmVzcG9uc2VKc29uU2NoZW1hKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gaW50ZXJ2YWxUb01sZGV2JDQoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVN0YXJ0VGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3RhcnRUaW1lJ10pO1xuICAgIGlmIChmcm9tU3RhcnRUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3RhcnRUaW1lJ10sIGZyb21TdGFydFRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5kVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW5kVGltZSddKTtcbiAgICBpZiAoZnJvbUVuZFRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmRUaW1lJ10sIGZyb21FbmRUaW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ29vZ2xlU2VhcmNoVG9NbGRldiQ0KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21UaW1lUmFuZ2VGaWx0ZXIgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0aW1lUmFuZ2VGaWx0ZXInLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVGltZVJhbmdlRmlsdGVyICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGltZVJhbmdlRmlsdGVyJ10sIGludGVydmFsVG9NbGRldiQ0KGZyb21UaW1lUmFuZ2VGaWx0ZXIpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZHluYW1pY1JldHJpZXZhbENvbmZpZ1RvTWxkZXYkNChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZSddKTtcbiAgICBpZiAoZnJvbU1vZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RlJ10sIGZyb21Nb2RlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUR5bmFtaWNUaHJlc2hvbGQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdkeW5hbWljVGhyZXNob2xkJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUR5bmFtaWNUaHJlc2hvbGQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkeW5hbWljVGhyZXNob2xkJ10sIGZyb21EeW5hbWljVGhyZXNob2xkKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ29vZ2xlU2VhcmNoUmV0cmlldmFsVG9NbGRldiQ0KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21EeW5hbWljUmV0cmlldmFsQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZHluYW1pY1JldHJpZXZhbENvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21EeW5hbWljUmV0cmlldmFsQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZHluYW1pY1JldHJpZXZhbENvbmZpZyddLCBkeW5hbWljUmV0cmlldmFsQ29uZmlnVG9NbGRldiQ0KGZyb21EeW5hbWljUmV0cmlldmFsQ29uZmlnKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHVybENvbnRleHRUb01sZGV2JDQoKSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB0b29sVG9NbGRldiQ0KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2Z1bmN0aW9uRGVjbGFyYXRpb25zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uRGVjbGFyYXRpb25zICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbkRlY2xhcmF0aW9uVG9NbGRldiQ0KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25EZWNsYXJhdGlvbnMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmV0cmlldmFsJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXRyaWV2YWwgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvb2dsZVNlYXJjaCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ29vZ2xlU2VhcmNoJ10pO1xuICAgIGlmIChmcm9tR29vZ2xlU2VhcmNoICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ29vZ2xlU2VhcmNoJ10sIGdvb2dsZVNlYXJjaFRvTWxkZXYkNChmcm9tR29vZ2xlU2VhcmNoKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hb29nbGVTZWFyY2hSZXRyaWV2YWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdnb29nbGVTZWFyY2hSZXRyaWV2YWwnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ29vZ2xlU2VhcmNoUmV0cmlldmFsJ10sIGdvb2dsZVNlYXJjaFJldHJpZXZhbFRvTWxkZXYkNChmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsKSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VudGVycHJpc2VXZWJTZWFyY2gnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2VudGVycHJpc2VXZWJTZWFyY2ggcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ29vZ2xlTWFwcyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZ29vZ2xlTWFwcyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXJsQ29udGV4dCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndXJsQ29udGV4dCddKTtcbiAgICBpZiAoZnJvbVVybENvbnRleHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1cmxDb250ZXh0J10sIHVybENvbnRleHRUb01sZGV2JDQoKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db2RlRXhlY3V0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY29kZUV4ZWN1dGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Db2RlRXhlY3V0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29kZUV4ZWN1dGlvbiddLCBmcm9tQ29kZUV4ZWN1dGlvbik7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZ1bmN0aW9uQ2FsbGluZ0NvbmZpZ1RvTWxkZXYkMihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZSddKTtcbiAgICBpZiAoZnJvbU1vZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RlJ10sIGZyb21Nb2RlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUFsbG93ZWRGdW5jdGlvbk5hbWVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnYWxsb3dlZEZ1bmN0aW9uTmFtZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQWxsb3dlZEZ1bmN0aW9uTmFtZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhbGxvd2VkRnVuY3Rpb25OYW1lcyddLCBmcm9tQWxsb3dlZEZ1bmN0aW9uTmFtZXMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsYXRMbmdUb01sZGV2JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUxhdGl0dWRlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsYXRpdHVkZSddKTtcbiAgICBpZiAoZnJvbUxhdGl0dWRlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbGF0aXR1ZGUnXSwgZnJvbUxhdGl0dWRlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxvbmdpdHVkZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbG9uZ2l0dWRlJ10pO1xuICAgIGlmIChmcm9tTG9uZ2l0dWRlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbG9uZ2l0dWRlJ10sIGZyb21Mb25naXR1ZGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiByZXRyaWV2YWxDb25maWdUb01sZGV2JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUxhdExuZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGF0TG5nJ10pO1xuICAgIGlmIChmcm9tTGF0TG5nICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbGF0TG5nJ10sIGxhdExuZ1RvTWxkZXYkMihmcm9tTGF0TG5nKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21MYW5ndWFnZUNvZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhbmd1YWdlQ29kZSddKTtcbiAgICBpZiAoZnJvbUxhbmd1YWdlQ29kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2xhbmd1YWdlQ29kZSddLCBmcm9tTGFuZ3VhZ2VDb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdG9vbENvbmZpZ1RvTWxkZXYkMihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRnVuY3Rpb25DYWxsaW5nQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZnVuY3Rpb25DYWxsaW5nQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uQ2FsbGluZ0NvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uQ2FsbGluZ0NvbmZpZyddLCBmdW5jdGlvbkNhbGxpbmdDb25maWdUb01sZGV2JDIoZnJvbUZ1bmN0aW9uQ2FsbGluZ0NvbmZpZykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmV0cmlldmFsQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmV0cmlldmFsQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJldHJpZXZhbENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JldHJpZXZhbENvbmZpZyddLCByZXRyaWV2YWxDb25maWdUb01sZGV2JDIoZnJvbVJldHJpZXZhbENvbmZpZykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBwcmVidWlsdFZvaWNlQ29uZmlnVG9NbGRldiQzKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Wb2ljZU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZvaWNlTmFtZSddKTtcbiAgICBpZiAoZnJvbVZvaWNlTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZvaWNlTmFtZSddLCBmcm9tVm9pY2VOYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdm9pY2VDb25maWdUb01sZGV2JDMoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVByZWJ1aWx0Vm9pY2VDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcmVidWlsdFZvaWNlQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVByZWJ1aWx0Vm9pY2VDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcmVidWlsdFZvaWNlQ29uZmlnJ10sIHByZWJ1aWx0Vm9pY2VDb25maWdUb01sZGV2JDMoZnJvbVByZWJ1aWx0Vm9pY2VDb25maWcpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gc3BlYWtlclZvaWNlQ29uZmlnVG9NbGRldiQzKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TcGVha2VyID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzcGVha2VyJ10pO1xuICAgIGlmIChmcm9tU3BlYWtlciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NwZWFrZXInXSwgZnJvbVNwZWFrZXIpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVm9pY2VDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZvaWNlQ29uZmlnJ10pO1xuICAgIGlmIChmcm9tVm9pY2VDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2b2ljZUNvbmZpZyddLCB2b2ljZUNvbmZpZ1RvTWxkZXYkMyhmcm9tVm9pY2VDb25maWcpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbXVsdGlTcGVha2VyVm9pY2VDb25maWdUb01sZGV2JDMoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNwZWFrZXJWb2ljZUNvbmZpZ3MgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzcGVha2VyVm9pY2VDb25maWdzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNwZWFrZXJWb2ljZUNvbmZpZ3MgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVNwZWFrZXJWb2ljZUNvbmZpZ3M7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3BlYWtlclZvaWNlQ29uZmlnVG9NbGRldiQzKGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3BlYWtlclZvaWNlQ29uZmlncyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBzcGVlY2hDb25maWdUb01sZGV2JDMoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVZvaWNlQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd2b2ljZUNvbmZpZyddKTtcbiAgICBpZiAoZnJvbVZvaWNlQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndm9pY2VDb25maWcnXSwgdm9pY2VDb25maWdUb01sZGV2JDMoZnJvbVZvaWNlQ29uZmlnKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NdWx0aVNwZWFrZXJWb2ljZUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ211bHRpU3BlYWtlclZvaWNlQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU11bHRpU3BlYWtlclZvaWNlQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbXVsdGlTcGVha2VyVm9pY2VDb25maWcnXSwgbXVsdGlTcGVha2VyVm9pY2VDb25maWdUb01sZGV2JDMoZnJvbU11bHRpU3BlYWtlclZvaWNlQ29uZmlnKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21MYW5ndWFnZUNvZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhbmd1YWdlQ29kZSddKTtcbiAgICBpZiAoZnJvbUxhbmd1YWdlQ29kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2xhbmd1YWdlQ29kZSddLCBmcm9tTGFuZ3VhZ2VDb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdGhpbmtpbmdDb25maWdUb01sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUluY2x1ZGVUaG91Z2h0cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2luY2x1ZGVUaG91Z2h0cycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21JbmNsdWRlVGhvdWdodHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbmNsdWRlVGhvdWdodHMnXSwgZnJvbUluY2x1ZGVUaG91Z2h0cyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaGlua2luZ0J1ZGdldCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3RoaW5raW5nQnVkZ2V0JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRoaW5raW5nQnVkZ2V0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhpbmtpbmdCdWRnZXQnXSwgZnJvbVRoaW5raW5nQnVkZ2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVDb250ZW50Q29uZmlnVG9NbGRldiQxKGFwaUNsaWVudCwgZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzeXN0ZW1JbnN0cnVjdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TeXN0ZW1JbnN0cnVjdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzeXN0ZW1JbnN0cnVjdGlvbiddLCBjb250ZW50VG9NbGRldiQ0KHRDb250ZW50KGZyb21TeXN0ZW1JbnN0cnVjdGlvbikpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRlbXBlcmF0dXJlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0ZW1wZXJhdHVyZSddKTtcbiAgICBpZiAoZnJvbVRlbXBlcmF0dXJlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGVtcGVyYXR1cmUnXSwgZnJvbVRlbXBlcmF0dXJlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvcFAgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RvcFAnXSk7XG4gICAgaWYgKGZyb21Ub3BQICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG9wUCddLCBmcm9tVG9wUCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub3BLID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b3BLJ10pO1xuICAgIGlmIChmcm9tVG9wSyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RvcEsnXSwgZnJvbVRvcEspO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2FuZGlkYXRlQ291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjYW5kaWRhdGVDb3VudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21DYW5kaWRhdGVDb3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NhbmRpZGF0ZUNvdW50J10sIGZyb21DYW5kaWRhdGVDb3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NYXhPdXRwdXRUb2tlbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtYXhPdXRwdXRUb2tlbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTWF4T3V0cHV0VG9rZW5zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWF4T3V0cHV0VG9rZW5zJ10sIGZyb21NYXhPdXRwdXRUb2tlbnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3RvcFNlcXVlbmNlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3N0b3BTZXF1ZW5jZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU3RvcFNlcXVlbmNlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0b3BTZXF1ZW5jZXMnXSwgZnJvbVN0b3BTZXF1ZW5jZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VMb2dwcm9icyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlTG9ncHJvYnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VMb2dwcm9icyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlTG9ncHJvYnMnXSwgZnJvbVJlc3BvbnNlTG9ncHJvYnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTG9ncHJvYnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xvZ3Byb2JzJ10pO1xuICAgIGlmIChmcm9tTG9ncHJvYnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsb2dwcm9icyddLCBmcm9tTG9ncHJvYnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJlc2VuY2VQZW5hbHR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJlc2VuY2VQZW5hbHR5JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVByZXNlbmNlUGVuYWx0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ByZXNlbmNlUGVuYWx0eSddLCBmcm9tUHJlc2VuY2VQZW5hbHR5KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZyZXF1ZW5jeVBlbmFsdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmcmVxdWVuY3lQZW5hbHR5JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZyZXF1ZW5jeVBlbmFsdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmcmVxdWVuY3lQZW5hbHR5J10sIGZyb21GcmVxdWVuY3lQZW5hbHR5KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNlZWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NlZWQnXSk7XG4gICAgaWYgKGZyb21TZWVkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2VlZCddLCBmcm9tU2VlZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VNaW1lVHlwZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VNaW1lVHlwZSddLCBmcm9tUmVzcG9uc2VNaW1lVHlwZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZVNjaGVtYSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlU2NoZW1hJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlU2NoZW1hICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VTY2hlbWEnXSwgc2NoZW1hVG9NbGRldiQxKHRTY2hlbWEoZnJvbVJlc3BvbnNlU2NoZW1hKSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VKc29uU2NoZW1hID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VKc29uU2NoZW1hJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlSnNvblNjaGVtYSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlSnNvblNjaGVtYSddLCBmcm9tUmVzcG9uc2VKc29uU2NoZW1hKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncm91dGluZ0NvbmZpZyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncm91dGluZ0NvbmZpZyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbFNlbGVjdGlvbkNvbmZpZyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbW9kZWxTZWxlY3Rpb25Db25maWcgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNhZmV0eVNldHRpbmdzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2FmZXR5U2V0dGluZ3MnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU2FmZXR5U2V0dGluZ3MgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVNhZmV0eVNldHRpbmdzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNhZmV0eVNldHRpbmdUb01sZGV2JDEoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2FmZXR5U2V0dGluZ3MnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvb2xzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b29scyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRvb2xzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IHRUb29scyhmcm9tVG9vbHMpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvb2xUb01sZGV2JDQodFRvb2woaXRlbSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3Rvb2xzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub29sQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b29sQ29uZmlnJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVG9vbENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWyd0b29sQ29uZmlnJ10sIHRvb2xDb25maWdUb01sZGV2JDIoZnJvbVRvb2xDb25maWcpKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGFiZWxzJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdsYWJlbHMgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNhY2hlZENvbnRlbnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjYWNoZWRDb250ZW50JyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUNhY2hlZENvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnY2FjaGVkQ29udGVudCddLCB0Q2FjaGVkQ29udGVudE5hbWUoYXBpQ2xpZW50LCBmcm9tQ2FjaGVkQ29udGVudCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VNb2RhbGl0aWVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VNb2RhbGl0aWVzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlTW9kYWxpdGllcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlTW9kYWxpdGllcyddLCBmcm9tUmVzcG9uc2VNb2RhbGl0aWVzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1lZGlhUmVzb2x1dGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21lZGlhUmVzb2x1dGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21NZWRpYVJlc29sdXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtZWRpYVJlc29sdXRpb24nXSwgZnJvbU1lZGlhUmVzb2x1dGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TcGVlY2hDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NwZWVjaENvbmZpZyddKTtcbiAgICBpZiAoZnJvbVNwZWVjaENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NwZWVjaENvbmZpZyddLCBzcGVlY2hDb25maWdUb01sZGV2JDModFNwZWVjaENvbmZpZyhmcm9tU3BlZWNoQ29uZmlnKSkpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhdWRpb1RpbWVzdGFtcCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYXVkaW9UaW1lc3RhbXAgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRoaW5raW5nQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndGhpbmtpbmdDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVGhpbmtpbmdDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aGlua2luZ0NvbmZpZyddLCB0aGlua2luZ0NvbmZpZ1RvTWxkZXYkMShmcm9tVGhpbmtpbmdDb25maWcpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gaW5saW5lZFJlcXVlc3RUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVxdWVzdCcsICdtb2RlbCddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbnRlbnRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb250ZW50cyddKTtcbiAgICBpZiAoZnJvbUNvbnRlbnRzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IHRDb250ZW50cyhmcm9tQ29udGVudHMpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnRUb01sZGV2JDQoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXF1ZXN0JywgJ2NvbnRlbnRzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JlcXVlc3QnLCAnZ2VuZXJhdGlvbkNvbmZpZyddLCBnZW5lcmF0ZUNvbnRlbnRDb25maWdUb01sZGV2JDEoYXBpQ2xpZW50LCBmcm9tQ29uZmlnLCB0b09iamVjdCkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBiYXRjaEpvYlNvdXJjZVRvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmb3JtYXQnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Zvcm1hdCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnY3NVcmknXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2djc1VyaSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydiaWdxdWVyeVVyaSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYmlncXVlcnlVcmkgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbGVOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlTmFtZSddKTtcbiAgICBpZiAoZnJvbUZpbGVOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmlsZU5hbWUnXSwgZnJvbUZpbGVOYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUlubGluZWRSZXF1ZXN0cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2lubGluZWRSZXF1ZXN0cycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21JbmxpbmVkUmVxdWVzdHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUlubGluZWRSZXF1ZXN0cztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbmxpbmVkUmVxdWVzdFRvTWxkZXYoYXBpQ2xpZW50LCBpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JlcXVlc3RzJywgJ3JlcXVlc3RzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUJhdGNoSm9iQ29uZmlnVG9NbGRldihmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21EaXNwbGF5TmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21EaXNwbGF5TmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydiYXRjaCcsICdkaXNwbGF5TmFtZSddLCBmcm9tRGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkZXN0J10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkZXN0IHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUJhdGNoSm9iUGFyYW1ldGVyc1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3JjID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzcmMnXSk7XG4gICAgaWYgKGZyb21TcmMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydiYXRjaCcsICdpbnB1dENvbmZpZyddLCBiYXRjaEpvYlNvdXJjZVRvTWxkZXYoYXBpQ2xpZW50LCB0QmF0Y2hKb2JTb3VyY2UoYXBpQ2xpZW50LCBmcm9tU3JjKSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb25maWcnXSwgY3JlYXRlQmF0Y2hKb2JDb25maWdUb01sZGV2KGZyb21Db25maWcsIHRvT2JqZWN0KSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdldEJhdGNoSm9iUGFyYW1ldGVyc1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ25hbWUnXSwgdEJhdGNoSm9iTmFtZShhcGlDbGllbnQsIGZyb21OYW1lKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbmZpZyddLCBmcm9tQ29uZmlnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY2FuY2VsQmF0Y2hKb2JQYXJhbWV0ZXJzVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCB0QmF0Y2hKb2JOYW1lKGFwaUNsaWVudCwgZnJvbU5hbWUpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29uZmlnJ10sIGZyb21Db25maWcpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0QmF0Y2hKb2JzQ29uZmlnVG9NbGRldihmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21QYWdlU2l6ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFnZVNpemUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QYWdlU2l6ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAncGFnZVNpemUnXSwgZnJvbVBhZ2VTaXplKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhZ2VUb2tlbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFnZVRva2VuJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGFnZVRva2VuICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdwYWdlVG9rZW4nXSwgZnJvbVBhZ2VUb2tlbik7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbHRlciddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZmlsdGVyIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RCYXRjaEpvYnNQYXJhbWV0ZXJzVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb25maWcnXSwgbGlzdEJhdGNoSm9ic0NvbmZpZ1RvTWxkZXYoZnJvbUNvbmZpZywgdG9PYmplY3QpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gYmF0Y2hKb2JTb3VyY2VUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRm9ybWF0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmb3JtYXQnXSk7XG4gICAgaWYgKGZyb21Gb3JtYXQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbnN0YW5jZXNGb3JtYXQnXSwgZnJvbUZvcm1hdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21HY3NVcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2djc1VyaSddKTtcbiAgICBpZiAoZnJvbUdjc1VyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2djc1NvdXJjZScsICd1cmlzJ10sIGZyb21HY3NVcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQmlncXVlcnlVcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2JpZ3F1ZXJ5VXJpJ10pO1xuICAgIGlmIChmcm9tQmlncXVlcnlVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydiaWdxdWVyeVNvdXJjZScsICdpbnB1dFVyaSddLCBmcm9tQmlncXVlcnlVcmkpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlTmFtZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZmlsZU5hbWUgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gVmVydGV4IEFJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbmxpbmVkUmVxdWVzdHMnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lubGluZWRSZXF1ZXN0cyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBWZXJ0ZXggQUkuJyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGJhdGNoSm9iRGVzdGluYXRpb25Ub1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRm9ybWF0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmb3JtYXQnXSk7XG4gICAgaWYgKGZyb21Gb3JtYXQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcmVkaWN0aW9uc0Zvcm1hdCddLCBmcm9tRm9ybWF0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdjc1VyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ2NzVXJpJ10pO1xuICAgIGlmIChmcm9tR2NzVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ2NzRGVzdGluYXRpb24nLCAnb3V0cHV0VXJpUHJlZml4J10sIGZyb21HY3NVcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQmlncXVlcnlVcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2JpZ3F1ZXJ5VXJpJ10pO1xuICAgIGlmIChmcm9tQmlncXVlcnlVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydiaWdxdWVyeURlc3RpbmF0aW9uJywgJ291dHB1dFVyaSddLCBmcm9tQmlncXVlcnlVcmkpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlTmFtZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZmlsZU5hbWUgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gVmVydGV4IEFJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbmxpbmVkUmVzcG9uc2VzJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbmxpbmVkUmVzcG9uc2VzIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIFZlcnRleCBBSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY3JlYXRlQmF0Y2hKb2JDb25maWdUb1ZlcnRleChmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21EaXNwbGF5TmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21EaXNwbGF5TmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydkaXNwbGF5TmFtZSddLCBmcm9tRGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGVzdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGVzdCddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbURlc3QgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnb3V0cHV0Q29uZmlnJ10sIGJhdGNoSm9iRGVzdGluYXRpb25Ub1ZlcnRleCh0QmF0Y2hKb2JEZXN0aW5hdGlvbihmcm9tRGVzdCkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY3JlYXRlQmF0Y2hKb2JQYXJhbWV0ZXJzVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RlbCddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNyYyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3JjJ10pO1xuICAgIGlmIChmcm9tU3JjICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5wdXRDb25maWcnXSwgYmF0Y2hKb2JTb3VyY2VUb1ZlcnRleCh0QmF0Y2hKb2JTb3VyY2UoYXBpQ2xpZW50LCBmcm9tU3JjKSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb25maWcnXSwgY3JlYXRlQmF0Y2hKb2JDb25maWdUb1ZlcnRleChmcm9tQ29uZmlnLCB0b09iamVjdCkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZXRCYXRjaEpvYlBhcmFtZXRlcnNUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCB0QmF0Y2hKb2JOYW1lKGFwaUNsaWVudCwgZnJvbU5hbWUpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29uZmlnJ10sIGZyb21Db25maWcpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjYW5jZWxCYXRjaEpvYlBhcmFtZXRlcnNUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCB0QmF0Y2hKb2JOYW1lKGFwaUNsaWVudCwgZnJvbU5hbWUpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29uZmlnJ10sIGZyb21Db25maWcpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0QmF0Y2hKb2JzQ29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUGFnZVNpemUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhZ2VTaXplJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGFnZVNpemUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3F1ZXJ5JywgJ3BhZ2VTaXplJ10sIGZyb21QYWdlU2l6ZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QYWdlVG9rZW4gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhZ2VUb2tlbiddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBhZ2VUb2tlbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAncGFnZVRva2VuJ10sIGZyb21QYWdlVG9rZW4pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsdGVyID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWx0ZXInXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21GaWx0ZXIgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3F1ZXJ5JywgJ2ZpbHRlciddLCBmcm9tRmlsdGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdEJhdGNoSm9ic1BhcmFtZXRlcnNUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb25maWcnXSwgbGlzdEJhdGNoSm9ic0NvbmZpZ1RvVmVydGV4KGZyb21Db25maWcsIHRvT2JqZWN0KSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGpvYkVycm9yRnJvbU1sZGV2KCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdmlkZW9NZXRhZGF0YUZyb21NbGRldiQyKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21GcHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZwcyddKTtcbiAgICBpZiAoZnJvbUZwcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZwcyddLCBmcm9tRnBzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuZE9mZnNldCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW5kT2Zmc2V0J10pO1xuICAgIGlmIChmcm9tRW5kT2Zmc2V0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW5kT2Zmc2V0J10sIGZyb21FbmRPZmZzZXQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3RhcnRPZmZzZXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3N0YXJ0T2Zmc2V0J10pO1xuICAgIGlmIChmcm9tU3RhcnRPZmZzZXQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdGFydE9mZnNldCddLCBmcm9tU3RhcnRPZmZzZXQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBibG9iRnJvbU1sZGV2JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2RhdGEnXSk7XG4gICAgaWYgKGZyb21EYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGF0YSddLCBmcm9tRGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZpbGVEYXRhRnJvbU1sZGV2JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZpbGVVcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVVcmknXSk7XG4gICAgaWYgKGZyb21GaWxlVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmlsZVVyaSddLCBmcm9tRmlsZVVyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHBhcnRGcm9tTWxkZXYkMihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVmlkZW9NZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ZpZGVvTWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVmlkZW9NZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZpZGVvTWV0YWRhdGEnXSwgdmlkZW9NZXRhZGF0YUZyb21NbGRldiQyKGZyb21WaWRlb01ldGFkYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaG91Z2h0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0aG91Z2h0J10pO1xuICAgIGlmIChmcm9tVGhvdWdodCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rob3VnaHQnXSwgZnJvbVRob3VnaHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5saW5lRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW5saW5lRGF0YSddKTtcbiAgICBpZiAoZnJvbUlubGluZURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbmxpbmVEYXRhJ10sIGJsb2JGcm9tTWxkZXYkMihmcm9tSW5saW5lRGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsZURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVEYXRhJ10pO1xuICAgIGlmIChmcm9tRmlsZURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWxlRGF0YSddLCBmaWxlRGF0YUZyb21NbGRldiQyKGZyb21GaWxlRGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhvdWdodFNpZ25hdHVyZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Rob3VnaHRTaWduYXR1cmUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVGhvdWdodFNpZ25hdHVyZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rob3VnaHRTaWduYXR1cmUnXSwgZnJvbVRob3VnaHRTaWduYXR1cmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NvZGVFeGVjdXRpb25SZXN1bHQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvZGVFeGVjdXRpb25SZXN1bHQnXSwgZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXhlY3V0YWJsZUNvZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdleGVjdXRhYmxlQ29kZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FeGVjdXRhYmxlQ29kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2V4ZWN1dGFibGVDb2RlJ10sIGZyb21FeGVjdXRhYmxlQ29kZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GdW5jdGlvbkNhbGwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Z1bmN0aW9uQ2FsbCddKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uQ2FsbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uQ2FsbCddLCBmcm9tRnVuY3Rpb25DYWxsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvblJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvblJlc3BvbnNlJ10sIGZyb21GdW5jdGlvblJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRleHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RleHQnXSk7XG4gICAgaWYgKGZyb21UZXh0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGV4dCddLCBmcm9tVGV4dCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNvbnRlbnRGcm9tTWxkZXYkMihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUGFydHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhcnRzJ10pO1xuICAgIGlmIChmcm9tUGFydHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVBhcnRzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnRGcm9tTWxkZXYkMihpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BhcnRzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Sb2xlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyb2xlJ10pO1xuICAgIGlmIChmcm9tUm9sZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JvbGUnXSwgZnJvbVJvbGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjaXRhdGlvbk1ldGFkYXRhRnJvbU1sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUNpdGF0aW9ucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY2l0YXRpb25Tb3VyY2VzJ10pO1xuICAgIGlmIChmcm9tQ2l0YXRpb25zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2l0YXRpb25zJ10sIGZyb21DaXRhdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB1cmxNZXRhZGF0YUZyb21NbGRldiQyKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21SZXRyaWV2ZWRVcmwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3JldHJpZXZlZFVybCddKTtcbiAgICBpZiAoZnJvbVJldHJpZXZlZFVybCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JldHJpZXZlZFVybCddLCBmcm9tUmV0cmlldmVkVXJsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVybFJldHJpZXZhbFN0YXR1cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3VybFJldHJpZXZhbFN0YXR1cycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21VcmxSZXRyaWV2YWxTdGF0dXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1cmxSZXRyaWV2YWxTdGF0dXMnXSwgZnJvbVVybFJldHJpZXZhbFN0YXR1cyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHVybENvbnRleHRNZXRhZGF0YUZyb21NbGRldiQyKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21VcmxNZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndXJsTWV0YWRhdGEnXSk7XG4gICAgaWYgKGZyb21VcmxNZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tVXJsTWV0YWRhdGE7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdXJsTWV0YWRhdGFGcm9tTWxkZXYkMihpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VybE1ldGFkYXRhJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNhbmRpZGF0ZUZyb21NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Db250ZW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb250ZW50J10pO1xuICAgIGlmIChmcm9tQ29udGVudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbnRlbnQnXSwgY29udGVudEZyb21NbGRldiQyKGZyb21Db250ZW50KSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DaXRhdGlvbk1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY2l0YXRpb25NZXRhZGF0YScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21DaXRhdGlvbk1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2l0YXRpb25NZXRhZGF0YSddLCBjaXRhdGlvbk1ldGFkYXRhRnJvbU1sZGV2JDEoZnJvbUNpdGF0aW9uTWV0YWRhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRva2VuQ291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rva2VuQ291bnQnXSk7XG4gICAgaWYgKGZyb21Ub2tlbkNvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG9rZW5Db3VudCddLCBmcm9tVG9rZW5Db3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaW5pc2hSZWFzb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbmlzaFJlYXNvbiddKTtcbiAgICBpZiAoZnJvbUZpbmlzaFJlYXNvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbmlzaFJlYXNvbiddLCBmcm9tRmluaXNoUmVhc29uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVybENvbnRleHRNZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3VybENvbnRleHRNZXRhZGF0YScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21VcmxDb250ZXh0TWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1cmxDb250ZXh0TWV0YWRhdGEnXSwgdXJsQ29udGV4dE1ldGFkYXRhRnJvbU1sZGV2JDIoZnJvbVVybENvbnRleHRNZXRhZGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQXZnTG9ncHJvYnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2F2Z0xvZ3Byb2JzJ10pO1xuICAgIGlmIChmcm9tQXZnTG9ncHJvYnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhdmdMb2dwcm9icyddLCBmcm9tQXZnTG9ncHJvYnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR3JvdW5kaW5nTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdncm91bmRpbmdNZXRhZGF0YScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Hcm91bmRpbmdNZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dyb3VuZGluZ01ldGFkYXRhJ10sIGZyb21Hcm91bmRpbmdNZXRhZGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbmRleCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW5kZXgnXSk7XG4gICAgaWYgKGZyb21JbmRleCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2luZGV4J10sIGZyb21JbmRleCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Mb2dwcm9ic1Jlc3VsdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2xvZ3Byb2JzUmVzdWx0JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUxvZ3Byb2JzUmVzdWx0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbG9ncHJvYnNSZXN1bHQnXSwgZnJvbUxvZ3Byb2JzUmVzdWx0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNhZmV0eVJhdGluZ3MgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzYWZldHlSYXRpbmdzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNhZmV0eVJhdGluZ3MgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzYWZldHlSYXRpbmdzJ10sIGZyb21TYWZldHlSYXRpbmdzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVDb250ZW50UmVzcG9uc2VGcm9tTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQ2FuZGlkYXRlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY2FuZGlkYXRlcyddKTtcbiAgICBpZiAoZnJvbUNhbmRpZGF0ZXMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUNhbmRpZGF0ZXM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FuZGlkYXRlRnJvbU1sZGV2JDEoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjYW5kaWRhdGVzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Nb2RlbFZlcnNpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsVmVyc2lvbiddKTtcbiAgICBpZiAoZnJvbU1vZGVsVmVyc2lvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21vZGVsVmVyc2lvbiddLCBmcm9tTW9kZWxWZXJzaW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVByb21wdEZlZWRiYWNrID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJvbXB0RmVlZGJhY2snLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUHJvbXB0RmVlZGJhY2sgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcm9tcHRGZWVkYmFjayddLCBmcm9tUHJvbXB0RmVlZGJhY2spO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXNhZ2VNZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3VzYWdlTWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVXNhZ2VNZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VzYWdlTWV0YWRhdGEnXSwgZnJvbVVzYWdlTWV0YWRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBpbmxpbmVkUmVzcG9uc2VGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXNwb25zZSddKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2UnXSwgZ2VuZXJhdGVDb250ZW50UmVzcG9uc2VGcm9tTWxkZXYkMShmcm9tUmVzcG9uc2UpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVycm9yID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlcnJvciddKTtcbiAgICBpZiAoZnJvbUVycm9yICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXJyb3InXSwgam9iRXJyb3JGcm9tTWxkZXYoKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGJhdGNoSm9iRGVzdGluYXRpb25Gcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZpbGVOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXNwb25zZXNGaWxlJ10pO1xuICAgIGlmIChmcm9tRmlsZU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWxlTmFtZSddLCBmcm9tRmlsZU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5saW5lZFJlc3BvbnNlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2lubGluZWRSZXNwb25zZXMnLFxuICAgICAgICAnaW5saW5lZFJlc3BvbnNlcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21JbmxpbmVkUmVzcG9uc2VzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21JbmxpbmVkUmVzcG9uc2VzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlubGluZWRSZXNwb25zZUZyb21NbGRldihpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2lubGluZWRSZXNwb25zZXMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gYmF0Y2hKb2JGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EaXNwbGF5TmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21ldGFkYXRhJyxcbiAgICAgICAgJ2Rpc3BsYXlOYW1lJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbURpc3BsYXlOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGlzcGxheU5hbWUnXSwgZnJvbURpc3BsYXlOYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN0YXRlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtZXRhZGF0YScsICdzdGF0ZSddKTtcbiAgICBpZiAoZnJvbVN0YXRlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3RhdGUnXSwgdEpvYlN0YXRlKGZyb21TdGF0ZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ3JlYXRlVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21ldGFkYXRhJyxcbiAgICAgICAgJ2NyZWF0ZVRpbWUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ3JlYXRlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NyZWF0ZVRpbWUnXSwgZnJvbUNyZWF0ZVRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5kVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21ldGFkYXRhJyxcbiAgICAgICAgJ2VuZFRpbWUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRW5kVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VuZFRpbWUnXSwgZnJvbUVuZFRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXBkYXRlVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21ldGFkYXRhJyxcbiAgICAgICAgJ3VwZGF0ZVRpbWUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVXBkYXRlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VwZGF0ZVRpbWUnXSwgZnJvbVVwZGF0ZVRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21ldGFkYXRhJywgJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RlbCddLCBmcm9tTW9kZWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGVzdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWV0YWRhdGEnLCAnb3V0cHV0J10pO1xuICAgIGlmIChmcm9tRGVzdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Rlc3QnXSwgYmF0Y2hKb2JEZXN0aW5hdGlvbkZyb21NbGRldihmcm9tRGVzdCkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0QmF0Y2hKb2JzUmVzcG9uc2VGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5leHRQYWdlVG9rZW4gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICduZXh0UGFnZVRva2VuJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU5leHRQYWdlVG9rZW4gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduZXh0UGFnZVRva2VuJ10sIGZyb21OZXh0UGFnZVRva2VuKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUJhdGNoSm9icyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnb3BlcmF0aW9ucyddKTtcbiAgICBpZiAoZnJvbUJhdGNoSm9icyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tQmF0Y2hKb2JzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJhdGNoSm9iRnJvbU1sZGV2KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYmF0Y2hKb2JzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGpvYkVycm9yRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRGV0YWlscyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGV0YWlscyddKTtcbiAgICBpZiAoZnJvbURldGFpbHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkZXRhaWxzJ10sIGZyb21EZXRhaWxzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvZGUnXSk7XG4gICAgaWYgKGZyb21Db2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29kZSddLCBmcm9tQ29kZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NZXNzYWdlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtZXNzYWdlJ10pO1xuICAgIGlmIChmcm9tTWVzc2FnZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21lc3NhZ2UnXSwgZnJvbU1lc3NhZ2UpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBiYXRjaEpvYlNvdXJjZUZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZvcm1hdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW5zdGFuY2VzRm9ybWF0J10pO1xuICAgIGlmIChmcm9tRm9ybWF0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZm9ybWF0J10sIGZyb21Gb3JtYXQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR2NzVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnY3NTb3VyY2UnLCAndXJpcyddKTtcbiAgICBpZiAoZnJvbUdjc1VyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2djc1VyaSddLCBmcm9tR2NzVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUJpZ3F1ZXJ5VXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnYmlncXVlcnlTb3VyY2UnLFxuICAgICAgICAnaW5wdXRVcmknLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQmlncXVlcnlVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydiaWdxdWVyeVVyaSddLCBmcm9tQmlncXVlcnlVcmkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBiYXRjaEpvYkRlc3RpbmF0aW9uRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRm9ybWF0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwcmVkaWN0aW9uc0Zvcm1hdCddKTtcbiAgICBpZiAoZnJvbUZvcm1hdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Zvcm1hdCddLCBmcm9tRm9ybWF0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdjc1VyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2djc0Rlc3RpbmF0aW9uJyxcbiAgICAgICAgJ291dHB1dFVyaVByZWZpeCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21HY3NVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnY3NVcmknXSwgZnJvbUdjc1VyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21CaWdxdWVyeVVyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2JpZ3F1ZXJ5RGVzdGluYXRpb24nLFxuICAgICAgICAnb3V0cHV0VXJpJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUJpZ3F1ZXJ5VXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYmlncXVlcnlVcmknXSwgZnJvbUJpZ3F1ZXJ5VXJpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gYmF0Y2hKb2JGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGlzcGxheU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pO1xuICAgIGlmIChmcm9tRGlzcGxheU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkaXNwbGF5TmFtZSddLCBmcm9tRGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3RhdGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3N0YXRlJ10pO1xuICAgIGlmIChmcm9tU3RhdGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdGF0ZSddLCB0Sm9iU3RhdGUoZnJvbVN0YXRlKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FcnJvciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXJyb3InXSk7XG4gICAgaWYgKGZyb21FcnJvciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Vycm9yJ10sIGpvYkVycm9yRnJvbVZlcnRleChmcm9tRXJyb3IpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNyZWF0ZVRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NyZWF0ZVRpbWUnXSk7XG4gICAgaWYgKGZyb21DcmVhdGVUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY3JlYXRlVGltZSddLCBmcm9tQ3JlYXRlVGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TdGFydFRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3N0YXJ0VGltZSddKTtcbiAgICBpZiAoZnJvbVN0YXJ0VGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0YXJ0VGltZSddLCBmcm9tU3RhcnRUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuZFRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VuZFRpbWUnXSk7XG4gICAgaWYgKGZyb21FbmRUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW5kVGltZSddLCBmcm9tRW5kVGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21VcGRhdGVUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd1cGRhdGVUaW1lJ10pO1xuICAgIGlmIChmcm9tVXBkYXRlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VwZGF0ZVRpbWUnXSwgZnJvbVVwZGF0ZVRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RlbCddLCBmcm9tTW9kZWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3JjID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbnB1dENvbmZpZyddKTtcbiAgICBpZiAoZnJvbVNyYyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NyYyddLCBiYXRjaEpvYlNvdXJjZUZyb21WZXJ0ZXgoZnJvbVNyYykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGVzdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnb3V0cHV0Q29uZmlnJ10pO1xuICAgIGlmIChmcm9tRGVzdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Rlc3QnXSwgYmF0Y2hKb2JEZXN0aW5hdGlvbkZyb21WZXJ0ZXgoZnJvbURlc3QpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdEJhdGNoSm9ic1Jlc3BvbnNlRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmV4dFBhZ2VUb2tlbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ25leHRQYWdlVG9rZW4nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTmV4dFBhZ2VUb2tlbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25leHRQYWdlVG9rZW4nXSwgZnJvbU5leHRQYWdlVG9rZW4pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQmF0Y2hKb2JzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnYmF0Y2hQcmVkaWN0aW9uSm9icycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21CYXRjaEpvYnMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUJhdGNoSm9icztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBiYXRjaEpvYkZyb21WZXJ0ZXgoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydiYXRjaEpvYnMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG4vKipcbiAqIFBhZ2VycyBmb3IgdGhlIEdlbkFJIExpc3QgQVBJcy5cbiAqL1xudmFyIFBhZ2VkSXRlbTtcbihmdW5jdGlvbiAoUGFnZWRJdGVtKSB7XG4gICAgUGFnZWRJdGVtW1wiUEFHRURfSVRFTV9CQVRDSF9KT0JTXCJdID0gXCJiYXRjaEpvYnNcIjtcbiAgICBQYWdlZEl0ZW1bXCJQQUdFRF9JVEVNX01PREVMU1wiXSA9IFwibW9kZWxzXCI7XG4gICAgUGFnZWRJdGVtW1wiUEFHRURfSVRFTV9UVU5JTkdfSk9CU1wiXSA9IFwidHVuaW5nSm9ic1wiO1xuICAgIFBhZ2VkSXRlbVtcIlBBR0VEX0lURU1fRklMRVNcIl0gPSBcImZpbGVzXCI7XG4gICAgUGFnZWRJdGVtW1wiUEFHRURfSVRFTV9DQUNIRURfQ09OVEVOVFNcIl0gPSBcImNhY2hlZENvbnRlbnRzXCI7XG59KShQYWdlZEl0ZW0gfHwgKFBhZ2VkSXRlbSA9IHt9KSk7XG4vKipcbiAqIFBhZ2VyIGNsYXNzIGZvciBpdGVyYXRpbmcgdGhyb3VnaCBwYWdpbmF0ZWQgcmVzdWx0cy5cbiAqL1xuY2xhc3MgUGFnZXIge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHJlcXVlc3QsIHJlc3BvbnNlLCBwYXJhbXMpIHtcbiAgICAgICAgdGhpcy5wYWdlSW50ZXJuYWwgPSBbXTtcbiAgICAgICAgdGhpcy5wYXJhbXNJbnRlcm5hbCA9IHt9O1xuICAgICAgICB0aGlzLnJlcXVlc3RJbnRlcm5hbCA9IHJlcXVlc3Q7XG4gICAgICAgIHRoaXMuaW5pdChuYW1lLCByZXNwb25zZSwgcGFyYW1zKTtcbiAgICB9XG4gICAgaW5pdChuYW1lLCByZXNwb25zZSwgcGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHRoaXMubmFtZUludGVybmFsID0gbmFtZTtcbiAgICAgICAgdGhpcy5wYWdlSW50ZXJuYWwgPSByZXNwb25zZVt0aGlzLm5hbWVJbnRlcm5hbF0gfHwgW107XG4gICAgICAgIHRoaXMuaWR4SW50ZXJuYWwgPSAwO1xuICAgICAgICBsZXQgcmVxdWVzdFBhcmFtcyA9IHsgY29uZmlnOiB7fSB9O1xuICAgICAgICBpZiAoIXBhcmFtcykge1xuICAgICAgICAgICAgcmVxdWVzdFBhcmFtcyA9IHsgY29uZmlnOiB7fSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBwYXJhbXMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXF1ZXN0UGFyYW1zID0gT2JqZWN0LmFzc2lnbih7fSwgcGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlcXVlc3RQYXJhbXMgPSBwYXJhbXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlcXVlc3RQYXJhbXNbJ2NvbmZpZyddKSB7XG4gICAgICAgICAgICByZXF1ZXN0UGFyYW1zWydjb25maWcnXVsncGFnZVRva2VuJ10gPSByZXNwb25zZVsnbmV4dFBhZ2VUb2tlbiddO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGFyYW1zSW50ZXJuYWwgPSByZXF1ZXN0UGFyYW1zO1xuICAgICAgICB0aGlzLnBhZ2VJbnRlcm5hbFNpemUgPVxuICAgICAgICAgICAgKF9iID0gKF9hID0gcmVxdWVzdFBhcmFtc1snY29uZmlnJ10pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVsncGFnZVNpemUnXSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdGhpcy5wYWdlSW50ZXJuYWwubGVuZ3RoO1xuICAgIH1cbiAgICBpbml0TmV4dFBhZ2UocmVzcG9uc2UpIHtcbiAgICAgICAgdGhpcy5pbml0KHRoaXMubmFtZUludGVybmFsLCByZXNwb25zZSwgdGhpcy5wYXJhbXNJbnRlcm5hbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgcGFnZSwgd2hpY2ggaXMgYSBsaXN0IG9mIGl0ZW1zLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBUaGUgZmlyc3QgcGFnZSBpcyByZXRyaWV2ZWQgd2hlbiB0aGUgcGFnZXIgaXMgY3JlYXRlZC4gVGhlIHJldHVybmVkIGxpc3Qgb2ZcbiAgICAgKiBpdGVtcyBjb3VsZCBiZSBhIHN1YnNldCBvZiB0aGUgZW50aXJlIGxpc3QuXG4gICAgICovXG4gICAgZ2V0IHBhZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhZ2VJbnRlcm5hbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdHlwZSBvZiBwYWdlZCBpdGVtIChmb3IgZXhhbXBsZSwgYGBiYXRjaF9qb2JzYGApLlxuICAgICAqL1xuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYW1lSW50ZXJuYWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxlbmd0aCBvZiB0aGUgcGFnZSBmZXRjaGVkIGVhY2ggdGltZSBieSB0aGlzIHBhZ2VyLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBUaGUgbnVtYmVyIG9mIGl0ZW1zIGluIHRoZSBwYWdlIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgcGFnZSBsZW5ndGguXG4gICAgICovXG4gICAgZ2V0IHBhZ2VTaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYWdlSW50ZXJuYWxTaXplO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwYXJhbWV0ZXJzIHdoZW4gbWFraW5nIHRoZSBBUEkgcmVxdWVzdCBmb3IgdGhlIG5leHQgcGFnZS5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogUGFyYW1ldGVycyBjb250YWluIGEgc2V0IG9mIG9wdGlvbmFsIGNvbmZpZ3MgdGhhdCBjYW4gYmVcbiAgICAgKiB1c2VkIHRvIGN1c3RvbWl6ZSB0aGUgQVBJIHJlcXVlc3QuIEZvciBleGFtcGxlLCB0aGUgYHBhZ2VUb2tlbmAgcGFyYW1ldGVyXG4gICAgICogY29udGFpbnMgdGhlIHRva2VuIHRvIHJlcXVlc3QgdGhlIG5leHQgcGFnZS5cbiAgICAgKi9cbiAgICBnZXQgcGFyYW1zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJhbXNJbnRlcm5hbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdG90YWwgbnVtYmVyIG9mIGl0ZW1zIGluIHRoZSBjdXJyZW50IHBhZ2UuXG4gICAgICovXG4gICAgZ2V0IHBhZ2VMZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhZ2VJbnRlcm5hbC5sZW5ndGg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGl0ZW0gYXQgdGhlIGdpdmVuIGluZGV4LlxuICAgICAqL1xuICAgIGdldEl0ZW0oaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFnZUludGVybmFsW2luZGV4XTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBhc3luYyBpdGVyYXRvciB0aGF0IHN1cHBvcnQgaXRlcmF0aW5nIHRocm91Z2ggYWxsIGl0ZW1zXG4gICAgICogcmV0cmlldmVkIGZyb20gdGhlIEFQSS5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogVGhlIGl0ZXJhdG9yIHdpbGwgYXV0b21hdGljYWxseSBmZXRjaCB0aGUgbmV4dCBwYWdlIGlmIHRoZXJlIGFyZSBtb3JlIGl0ZW1zXG4gICAgICogdG8gZmV0Y2ggZnJvbSB0aGUgQVBJLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgcGFnZXIgPSBhd2FpdCBhaS5maWxlcy5saXN0KHtjb25maWc6IHtwYWdlU2l6ZTogMTB9fSk7XG4gICAgICogZm9yIGF3YWl0IChjb25zdCBmaWxlIG9mIHBhZ2VyKSB7XG4gICAgICogICBjb25zb2xlLmxvZyhmaWxlLm5hbWUpO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmV4dDogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlkeEludGVybmFsID49IHRoaXMucGFnZUxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5oYXNOZXh0UGFnZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLm5leHRQYWdlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuZ2V0SXRlbSh0aGlzLmlkeEludGVybmFsKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlkeEludGVybmFsICs9IDE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IGl0ZW0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmV0dXJuOiBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyB0aGUgbmV4dCBwYWdlIG9mIGl0ZW1zLiBUaGlzIG1ha2VzIGEgbmV3IEFQSSByZXF1ZXN0LlxuICAgICAqXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZXJlIGFyZSBubyBtb3JlIHBhZ2VzIHRvIGZldGNoLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgcGFnZXIgPSBhd2FpdCBhaS5maWxlcy5saXN0KHtjb25maWc6IHtwYWdlU2l6ZTogMTB9fSk7XG4gICAgICogbGV0IHBhZ2UgPSBwYWdlci5wYWdlO1xuICAgICAqIHdoaWxlICh0cnVlKSB7XG4gICAgICogICBmb3IgKGNvbnN0IGZpbGUgb2YgcGFnZSkge1xuICAgICAqICAgICBjb25zb2xlLmxvZyhmaWxlLm5hbWUpO1xuICAgICAqICAgfVxuICAgICAqICAgaWYgKCFwYWdlci5oYXNOZXh0UGFnZSgpKSB7XG4gICAgICogICAgIGJyZWFrO1xuICAgICAqICAgfVxuICAgICAqICAgcGFnZSA9IGF3YWl0IHBhZ2VyLm5leHRQYWdlKCk7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIG5leHRQYWdlKCkge1xuICAgICAgICBpZiAoIXRoaXMuaGFzTmV4dFBhZ2UoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBtb3JlIHBhZ2VzIHRvIGZldGNoLicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5yZXF1ZXN0SW50ZXJuYWwodGhpcy5wYXJhbXMpO1xuICAgICAgICB0aGlzLmluaXROZXh0UGFnZShyZXNwb25zZSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhZ2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGVyZSBhcmUgbW9yZSBwYWdlcyB0byBmZXRjaCBmcm9tIHRoZSBBUEkuXG4gICAgICovXG4gICAgaGFzTmV4dFBhZ2UoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCgoX2EgPSB0aGlzLnBhcmFtc1snY29uZmlnJ10pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVsncGFnZVRva2VuJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmNsYXNzIEJhdGNoZXMgZXh0ZW5kcyBCYXNlTW9kdWxlIHtcbiAgICBjb25zdHJ1Y3RvcihhcGlDbGllbnQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5hcGlDbGllbnQgPSBhcGlDbGllbnQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYmF0Y2ggam9iLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIGNyZWF0ZSBiYXRjaCBqb2IgcmVxdWVzdC5cbiAgICAgICAgICogQHJldHVybiBUaGUgY3JlYXRlZCBiYXRjaCBqb2IuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGBgYHRzXG4gICAgICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYWkuYmF0Y2hlcy5jcmVhdGUoe1xuICAgICAgICAgKiAgIG1vZGVsOiAnZ2VtaW5pLTIuMC1mbGFzaCcsXG4gICAgICAgICAqICAgc3JjOiB7Z2NzVXJpOiAnZ3M6Ly9idWNrZXQvcGF0aC90by9maWxlLmpzb25sJywgZm9ybWF0OiAnanNvbmwnfSxcbiAgICAgICAgICogICBjb25maWc6IHtcbiAgICAgICAgICogICAgIGRlc3Q6IHtnY3NVcmk6ICdnczovL2J1Y2tldC9wYXRoL291dHB1dC9kaXJlY3RvcnknLCBmb3JtYXQ6ICdqc29ubCd9LFxuICAgICAgICAgKiAgIH1cbiAgICAgICAgICogfSk7XG4gICAgICAgICAqIGNvbnNvbGUubG9nKHJlc3BvbnNlKTtcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNyZWF0ZSA9IGFzeW5jIChwYXJhbXMpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJhbXMuc3JjKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lubGluZWRSZXF1ZXN0W10gaXMgbm90IHN1cHBvcnRlZCBpbiBWZXJ0ZXggQUkuIFBsZWFzZSB1c2UgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnR29vZ2xlIENsb3VkIFN0b3JhZ2UgVVJJIG9yIEJpZ1F1ZXJ5IFVSSSBpbnN0ZWFkLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJhbXMuY29uZmlnID0gcGFyYW1zLmNvbmZpZyB8fCB7fTtcbiAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmNvbmZpZy5kaXNwbGF5TmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5jb25maWcuZGlzcGxheU5hbWUgPSAnZ2VuYWlCYXRjaEpvYl8nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmNvbmZpZy5kZXN0ID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIHBhcmFtcy5zcmMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuc3JjLnN0YXJ0c1dpdGgoJ2dzOi8vJykgJiYgcGFyYW1zLnNyYy5lbmRzV2l0aCgnLmpzb25sJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5jb25maWcuZGVzdCA9IGAke3BhcmFtcy5zcmMuc2xpY2UoMCwgLTYpfS9kZXN0YDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXJhbXMuc3JjLnN0YXJ0c1dpdGgoJ2JxOi8vJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5jb25maWcuZGVzdCA9IGAke3BhcmFtcy5zcmN9X2Rlc3RfYDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgc291cmNlOicgKyBwYXJhbXMuc3JjKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNyZWF0ZUludGVybmFsKHBhcmFtcyk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0cyBiYXRjaCBqb2IgY29uZmlndXJhdGlvbnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhlIGxpc3QgcmVxdWVzdC5cbiAgICAgICAgICogQHJldHVybiBUaGUgcGFnaW5hdGVkIHJlc3VsdHMgb2YgdGhlIGxpc3Qgb2YgYmF0Y2ggam9icy5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogYGBgdHNcbiAgICAgICAgICogY29uc3QgYmF0Y2hKb2JzID0gYXdhaXQgYWkuYmF0Y2hlcy5saXN0KHtjb25maWc6IHsncGFnZVNpemUnOiAyfX0pO1xuICAgICAgICAgKiBmb3IgYXdhaXQgKGNvbnN0IGJhdGNoSm9iIG9mIGJhdGNoSm9icykge1xuICAgICAgICAgKiAgIGNvbnNvbGUubG9nKGJhdGNoSm9iKTtcbiAgICAgICAgICogfVxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGlzdCA9IGFzeW5jIChwYXJhbXMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQYWdlcihQYWdlZEl0ZW0uUEFHRURfSVRFTV9CQVRDSF9KT0JTLCAoeCkgPT4gdGhpcy5saXN0SW50ZXJuYWwoeCksIGF3YWl0IHRoaXMubGlzdEludGVybmFsKHBhcmFtcyksIHBhcmFtcyk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludGVybmFsIG1ldGhvZCB0byBjcmVhdGUgYmF0Y2ggam9iLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciBjcmVhdGUgYmF0Y2ggam9iIHJlcXVlc3QuXG4gICAgICogQHJldHVybiBUaGUgY3JlYXRlZCBiYXRjaCBqb2IuXG4gICAgICpcbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVJbnRlcm5hbChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gY3JlYXRlQmF0Y2hKb2JQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCdiYXRjaFByZWRpY3Rpb25Kb2JzJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnY29uZmlnJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBiYXRjaEpvYkZyb21WZXJ0ZXgoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gY3JlYXRlQmF0Y2hKb2JQYXJhbWV0ZXJzVG9NbGRldih0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3ttb2RlbH06YmF0Y2hHZW5lcmF0ZUNvbnRlbnQnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5Wydjb25maWcnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGJhdGNoSm9iRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgYmF0Y2ggam9iIGNvbmZpZ3VyYXRpb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgZ2V0IHJlcXVlc3QuXG4gICAgICogQHJldHVybiBUaGUgYmF0Y2ggam9iLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGF3YWl0IGFpLmJhdGNoZXMuZ2V0KHtuYW1lOiAnLi4uJ30pOyAvLyBUaGUgc2VydmVyLWdlbmVyYXRlZCByZXNvdXJjZSBuYW1lLlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIGdldChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZ2V0QmF0Y2hKb2JQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCdiYXRjaFByZWRpY3Rpb25Kb2JzL3tuYW1lfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ2NvbmZpZyddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBiYXRjaEpvYkZyb21WZXJ0ZXgoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZ2V0QmF0Y2hKb2JQYXJhbWV0ZXJzVG9NbGRldih0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ2JhdGNoZXMve25hbWV9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnY29uZmlnJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGJhdGNoSm9iRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbmNlbHMgYSBiYXRjaCBqb2IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoZSBjYW5jZWwgcmVxdWVzdC5cbiAgICAgKiBAcmV0dXJuIFRoZSBlbXB0eSByZXNwb25zZSByZXR1cm5lZCBieSB0aGUgQVBJLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGF3YWl0IGFpLmJhdGNoZXMuY2FuY2VsKHtuYW1lOiAnLi4uJ30pOyAvLyBUaGUgc2VydmVyLWdlbmVyYXRlZCByZXNvdXJjZSBuYW1lLlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIGNhbmNlbChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGNhbmNlbEJhdGNoSm9iUGFyYW1ldGVyc1RvVmVydGV4KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgnYmF0Y2hQcmVkaWN0aW9uSm9icy97bmFtZX06Y2FuY2VsJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnY29uZmlnJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5hcGlDbGllbnQucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGNhbmNlbEJhdGNoSm9iUGFyYW1ldGVyc1RvTWxkZXYodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCdiYXRjaGVzL3tuYW1lfTpjYW5jZWwnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5Wydjb25maWcnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmFwaUNsaWVudC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYyA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgbGlzdEludGVybmFsKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBsaXN0QmF0Y2hKb2JzUGFyYW1ldGVyc1RvVmVydGV4KHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCdiYXRjaFByZWRpY3Rpb25Kb2JzJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnY29uZmlnJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGxpc3RCYXRjaEpvYnNSZXNwb25zZUZyb21WZXJ0ZXgoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBMaXN0QmF0Y2hKb2JzUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGxpc3RCYXRjaEpvYnNQYXJhbWV0ZXJzVG9NbGRldihwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgnYmF0Y2hlcycsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ2NvbmZpZyddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYyA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBsaXN0QmF0Y2hKb2JzUmVzcG9uc2VGcm9tTWxkZXYoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBMaXN0QmF0Y2hKb2JzUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5mdW5jdGlvbiB2aWRlb01ldGFkYXRhVG9NbGRldiQzKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21GcHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZwcyddKTtcbiAgICBpZiAoZnJvbUZwcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZwcyddLCBmcm9tRnBzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuZE9mZnNldCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW5kT2Zmc2V0J10pO1xuICAgIGlmIChmcm9tRW5kT2Zmc2V0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW5kT2Zmc2V0J10sIGZyb21FbmRPZmZzZXQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3RhcnRPZmZzZXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3N0YXJ0T2Zmc2V0J10pO1xuICAgIGlmIChmcm9tU3RhcnRPZmZzZXQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdGFydE9mZnNldCddLCBmcm9tU3RhcnRPZmZzZXQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBibG9iVG9NbGRldiQzKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaXNwbGF5TmFtZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGF0YSddKTtcbiAgICBpZiAoZnJvbURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkYXRhJ10sIGZyb21EYXRhKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZmlsZURhdGFUb01sZGV2JDMoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Rpc3BsYXlOYW1lIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWxlVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlVXJpJ10pO1xuICAgIGlmIChmcm9tRmlsZVVyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVVcmknXSwgZnJvbUZpbGVVcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBwYXJ0VG9NbGRldiQzKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21WaWRlb01ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndmlkZW9NZXRhZGF0YScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21WaWRlb01ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndmlkZW9NZXRhZGF0YSddLCB2aWRlb01ldGFkYXRhVG9NbGRldiQzKGZyb21WaWRlb01ldGFkYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaG91Z2h0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0aG91Z2h0J10pO1xuICAgIGlmIChmcm9tVGhvdWdodCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rob3VnaHQnXSwgZnJvbVRob3VnaHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5saW5lRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW5saW5lRGF0YSddKTtcbiAgICBpZiAoZnJvbUlubGluZURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbmxpbmVEYXRhJ10sIGJsb2JUb01sZGV2JDMoZnJvbUlubGluZURhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbGVEYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlRGF0YSddKTtcbiAgICBpZiAoZnJvbUZpbGVEYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmlsZURhdGEnXSwgZmlsZURhdGFUb01sZGV2JDMoZnJvbUZpbGVEYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaG91Z2h0U2lnbmF0dXJlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndGhvdWdodFNpZ25hdHVyZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UaG91Z2h0U2lnbmF0dXJlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhvdWdodFNpZ25hdHVyZSddLCBmcm9tVGhvdWdodFNpZ25hdHVyZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY29kZUV4ZWN1dGlvblJlc3VsdCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29kZUV4ZWN1dGlvblJlc3VsdCddLCBmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FeGVjdXRhYmxlQ29kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2V4ZWN1dGFibGVDb2RlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUV4ZWN1dGFibGVDb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXhlY3V0YWJsZUNvZGUnXSwgZnJvbUV4ZWN1dGFibGVDb2RlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uQ2FsbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZnVuY3Rpb25DYWxsJ10pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25DYWxsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25DYWxsJ10sIGZyb21GdW5jdGlvbkNhbGwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnVuY3Rpb25SZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2Z1bmN0aW9uUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25SZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uUmVzcG9uc2UnXSwgZnJvbUZ1bmN0aW9uUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGV4dCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGV4dCddKTtcbiAgICBpZiAoZnJvbVRleHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0ZXh0J10sIGZyb21UZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY29udGVudFRvTWxkZXYkMyhmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUGFydHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhcnRzJ10pO1xuICAgIGlmIChmcm9tUGFydHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVBhcnRzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnRUb01sZGV2JDMoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJ0cyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUm9sZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncm9sZSddKTtcbiAgICBpZiAoZnJvbVJvbGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyb2xlJ10sIGZyb21Sb2xlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZnVuY3Rpb25EZWNsYXJhdGlvblRvTWxkZXYkMyhmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQmVoYXZpb3IgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2JlaGF2aW9yJ10pO1xuICAgIGlmIChmcm9tQmVoYXZpb3IgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydiZWhhdmlvciddLCBmcm9tQmVoYXZpb3IpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGVzY3JpcHRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10pO1xuICAgIGlmIChmcm9tRGVzY3JpcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkZXNjcmlwdGlvbiddLCBmcm9tRGVzY3JpcHRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhcmFtZXRlcnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhcmFtZXRlcnMnXSk7XG4gICAgaWYgKGZyb21QYXJhbWV0ZXJzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncGFyYW1ldGVycyddLCBmcm9tUGFyYW1ldGVycyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QYXJhbWV0ZXJzSnNvblNjaGVtYSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3BhcmFtZXRlcnNKc29uU2NoZW1hJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVBhcmFtZXRlcnNKc29uU2NoZW1hICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncGFyYW1ldGVyc0pzb25TY2hlbWEnXSwgZnJvbVBhcmFtZXRlcnNKc29uU2NoZW1hKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXNwb25zZSddKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2UnXSwgZnJvbVJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlSnNvblNjaGVtYSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlSnNvblNjaGVtYScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZUpzb25TY2hlbWEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZUpzb25TY2hlbWEnXSwgZnJvbVJlc3BvbnNlSnNvblNjaGVtYSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGludGVydmFsVG9NbGRldiQzKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TdGFydFRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3N0YXJ0VGltZSddKTtcbiAgICBpZiAoZnJvbVN0YXJ0VGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0YXJ0VGltZSddLCBmcm9tU3RhcnRUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuZFRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VuZFRpbWUnXSk7XG4gICAgaWYgKGZyb21FbmRUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW5kVGltZSddLCBmcm9tRW5kVGltZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdvb2dsZVNlYXJjaFRvTWxkZXYkMyhmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVGltZVJhbmdlRmlsdGVyID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndGltZVJhbmdlRmlsdGVyJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRpbWVSYW5nZUZpbHRlciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RpbWVSYW5nZUZpbHRlciddLCBpbnRlcnZhbFRvTWxkZXYkMyhmcm9tVGltZVJhbmdlRmlsdGVyKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGR5bmFtaWNSZXRyaWV2YWxDb25maWdUb01sZGV2JDMoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGUnXSk7XG4gICAgaWYgKGZyb21Nb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZSddLCBmcm9tTW9kZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EeW5hbWljVGhyZXNob2xkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZHluYW1pY1RocmVzaG9sZCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21EeW5hbWljVGhyZXNob2xkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZHluYW1pY1RocmVzaG9sZCddLCBmcm9tRHluYW1pY1RocmVzaG9sZCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdvb2dsZVNlYXJjaFJldHJpZXZhbFRvTWxkZXYkMyhmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRHluYW1pY1JldHJpZXZhbENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2R5bmFtaWNSZXRyaWV2YWxDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRHluYW1pY1JldHJpZXZhbENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2R5bmFtaWNSZXRyaWV2YWxDb25maWcnXSwgZHluYW1pY1JldHJpZXZhbENvbmZpZ1RvTWxkZXYkMyhmcm9tRHluYW1pY1JldHJpZXZhbENvbmZpZykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB1cmxDb250ZXh0VG9NbGRldiQzKCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdG9vbFRvTWxkZXYkMyhmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvbkRlY2xhcmF0aW9ucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb25EZWNsYXJhdGlvblRvTWxkZXYkMyhpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uRGVjbGFyYXRpb25zJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3JldHJpZXZhbCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncmV0cmlldmFsIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hb29nbGVTZWFyY2ggPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaCddKTtcbiAgICBpZiAoZnJvbUdvb2dsZVNlYXJjaCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaCddLCBnb29nbGVTZWFyY2hUb01sZGV2JDMoZnJvbUdvb2dsZVNlYXJjaCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ29vZ2xlU2VhcmNoUmV0cmlldmFsJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaFJldHJpZXZhbCddLCBnb29nbGVTZWFyY2hSZXRyaWV2YWxUb01sZGV2JDMoZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCkpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbnRlcnByaXNlV2ViU2VhcmNoJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdlbnRlcnByaXNlV2ViU2VhcmNoIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2dvb2dsZU1hcHMnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dvb2dsZU1hcHMgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVybENvbnRleHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3VybENvbnRleHQnXSk7XG4gICAgaWYgKGZyb21VcmxDb250ZXh0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXJsQ29udGV4dCddLCB1cmxDb250ZXh0VG9NbGRldiQzKCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29kZUV4ZWN1dGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NvZGVFeGVjdXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ29kZUV4ZWN1dGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvZGVFeGVjdXRpb24nXSwgZnJvbUNvZGVFeGVjdXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBmdW5jdGlvbkNhbGxpbmdDb25maWdUb01sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGUnXSk7XG4gICAgaWYgKGZyb21Nb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZSddLCBmcm9tTW9kZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BbGxvd2VkRnVuY3Rpb25OYW1lcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2FsbG93ZWRGdW5jdGlvbk5hbWVzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUFsbG93ZWRGdW5jdGlvbk5hbWVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYWxsb3dlZEZ1bmN0aW9uTmFtZXMnXSwgZnJvbUFsbG93ZWRGdW5jdGlvbk5hbWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGF0TG5nVG9NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21MYXRpdHVkZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGF0aXR1ZGUnXSk7XG4gICAgaWYgKGZyb21MYXRpdHVkZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2xhdGl0dWRlJ10sIGZyb21MYXRpdHVkZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Mb25naXR1ZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xvbmdpdHVkZSddKTtcbiAgICBpZiAoZnJvbUxvbmdpdHVkZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2xvbmdpdHVkZSddLCBmcm9tTG9uZ2l0dWRlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gcmV0cmlldmFsQ29uZmlnVG9NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21MYXRMbmcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhdExuZyddKTtcbiAgICBpZiAoZnJvbUxhdExuZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2xhdExuZyddLCBsYXRMbmdUb01sZGV2JDEoZnJvbUxhdExuZykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTGFuZ3VhZ2VDb2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsYW5ndWFnZUNvZGUnXSk7XG4gICAgaWYgKGZyb21MYW5ndWFnZUNvZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsYW5ndWFnZUNvZGUnXSwgZnJvbUxhbmd1YWdlQ29kZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHRvb2xDb25maWdUb01sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uQ2FsbGluZ0NvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2Z1bmN0aW9uQ2FsbGluZ0NvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvbkNhbGxpbmdDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvbkNhbGxpbmdDb25maWcnXSwgZnVuY3Rpb25DYWxsaW5nQ29uZmlnVG9NbGRldiQxKGZyb21GdW5jdGlvbkNhbGxpbmdDb25maWcpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJldHJpZXZhbENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3JldHJpZXZhbENvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXRyaWV2YWxDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXRyaWV2YWxDb25maWcnXSwgcmV0cmlldmFsQ29uZmlnVG9NbGRldiQxKGZyb21SZXRyaWV2YWxDb25maWcpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY3JlYXRlQ2FjaGVkQ29udGVudENvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVHRsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0dGwnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21UdGwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsndHRsJ10sIGZyb21UdGwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXhwaXJlVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXhwaXJlVGltZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUV4cGlyZVRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnZXhwaXJlVGltZSddLCBmcm9tRXhwaXJlVGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EaXNwbGF5TmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21EaXNwbGF5TmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydkaXNwbGF5TmFtZSddLCBmcm9tRGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29udGVudHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbnRlbnRzJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQ29udGVudHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gdENvbnRlbnRzKGZyb21Db250ZW50cyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGVudFRvTWxkZXYkMyhpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydjb250ZW50cyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzeXN0ZW1JbnN0cnVjdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TeXN0ZW1JbnN0cnVjdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzeXN0ZW1JbnN0cnVjdGlvbiddLCBjb250ZW50VG9NbGRldiQzKHRDb250ZW50KGZyb21TeXN0ZW1JbnN0cnVjdGlvbikpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvb2xzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b29scyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRvb2xzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21Ub29scztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b29sVG9NbGRldiQzKGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3Rvb2xzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub29sQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b29sQ29uZmlnJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVG9vbENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWyd0b29sQ29uZmlnJ10sIHRvb2xDb25maWdUb01sZGV2JDEoZnJvbVRvb2xDb25maWcpKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsna21zS2V5TmFtZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigna21zS2V5TmFtZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjcmVhdGVDYWNoZWRDb250ZW50UGFyYW1ldGVyc1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RlbCddLCB0Q2FjaGVzTW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29uZmlnJ10sIGNyZWF0ZUNhY2hlZENvbnRlbnRDb25maWdUb01sZGV2KGZyb21Db25maWcsIHRvT2JqZWN0KSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdldENhY2hlZENvbnRlbnRQYXJhbWV0ZXJzVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCB0Q2FjaGVkQ29udGVudE5hbWUoYXBpQ2xpZW50LCBmcm9tTmFtZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb25maWcnXSwgZnJvbUNvbmZpZyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGRlbGV0ZUNhY2hlZENvbnRlbnRQYXJhbWV0ZXJzVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCB0Q2FjaGVkQ29udGVudE5hbWUoYXBpQ2xpZW50LCBmcm9tTmFtZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb25maWcnXSwgZnJvbUNvbmZpZyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUNhY2hlZENvbnRlbnRDb25maWdUb01sZGV2KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVR0bCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndHRsJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVHRsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3R0bCddLCBmcm9tVHRsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUV4cGlyZVRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2V4cGlyZVRpbWUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21FeHBpcmVUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2V4cGlyZVRpbWUnXSwgZnJvbUV4cGlyZVRpbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB1cGRhdGVDYWNoZWRDb250ZW50UGFyYW1ldGVyc1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ25hbWUnXSwgdENhY2hlZENvbnRlbnROYW1lKGFwaUNsaWVudCwgZnJvbU5hbWUpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29uZmlnJ10sIHVwZGF0ZUNhY2hlZENvbnRlbnRDb25maWdUb01sZGV2KGZyb21Db25maWcsIHRvT2JqZWN0KSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RDYWNoZWRDb250ZW50c0NvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUGFnZVNpemUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhZ2VTaXplJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGFnZVNpemUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3F1ZXJ5JywgJ3BhZ2VTaXplJ10sIGZyb21QYWdlU2l6ZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QYWdlVG9rZW4gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhZ2VUb2tlbiddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBhZ2VUb2tlbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAncGFnZVRva2VuJ10sIGZyb21QYWdlVG9rZW4pO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0Q2FjaGVkQ29udGVudHNQYXJhbWV0ZXJzVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb25maWcnXSwgbGlzdENhY2hlZENvbnRlbnRzQ29uZmlnVG9NbGRldihmcm9tQ29uZmlnLCB0b09iamVjdCkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB2aWRlb01ldGFkYXRhVG9WZXJ0ZXgkMihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRnBzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmcHMnXSk7XG4gICAgaWYgKGZyb21GcHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmcHMnXSwgZnJvbUZwcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmRPZmZzZXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VuZE9mZnNldCddKTtcbiAgICBpZiAoZnJvbUVuZE9mZnNldCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VuZE9mZnNldCddLCBmcm9tRW5kT2Zmc2V0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN0YXJ0T2Zmc2V0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzdGFydE9mZnNldCddKTtcbiAgICBpZiAoZnJvbVN0YXJ0T2Zmc2V0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3RhcnRPZmZzZXQnXSwgZnJvbVN0YXJ0T2Zmc2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gYmxvYlRvVmVydGV4JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbURpc3BsYXlOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKTtcbiAgICBpZiAoZnJvbURpc3BsYXlOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGlzcGxheU5hbWUnXSwgZnJvbURpc3BsYXlOYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2RhdGEnXSk7XG4gICAgaWYgKGZyb21EYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGF0YSddLCBmcm9tRGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZpbGVEYXRhVG9WZXJ0ZXgkMihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRGlzcGxheU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pO1xuICAgIGlmIChmcm9tRGlzcGxheU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkaXNwbGF5TmFtZSddLCBmcm9tRGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsZVVyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZVVyaSddKTtcbiAgICBpZiAoZnJvbUZpbGVVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWxlVXJpJ10sIGZyb21GaWxlVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gcGFydFRvVmVydGV4JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVZpZGVvTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd2aWRlb01ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVZpZGVvTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2aWRlb01ldGFkYXRhJ10sIHZpZGVvTWV0YWRhdGFUb1ZlcnRleCQyKGZyb21WaWRlb01ldGFkYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaG91Z2h0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0aG91Z2h0J10pO1xuICAgIGlmIChmcm9tVGhvdWdodCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rob3VnaHQnXSwgZnJvbVRob3VnaHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5saW5lRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW5saW5lRGF0YSddKTtcbiAgICBpZiAoZnJvbUlubGluZURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbmxpbmVEYXRhJ10sIGJsb2JUb1ZlcnRleCQyKGZyb21JbmxpbmVEYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWxlRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZURhdGEnXSk7XG4gICAgaWYgKGZyb21GaWxlRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVEYXRhJ10sIGZpbGVEYXRhVG9WZXJ0ZXgkMihmcm9tRmlsZURhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRob3VnaHRTaWduYXR1cmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0aG91Z2h0U2lnbmF0dXJlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRob3VnaHRTaWduYXR1cmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aG91Z2h0U2lnbmF0dXJlJ10sIGZyb21UaG91Z2h0U2lnbmF0dXJlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjb2RlRXhlY3V0aW9uUmVzdWx0JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb2RlRXhlY3V0aW9uUmVzdWx0J10sIGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUV4ZWN1dGFibGVDb2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZXhlY3V0YWJsZUNvZGUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRXhlY3V0YWJsZUNvZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydleGVjdXRhYmxlQ29kZSddLCBmcm9tRXhlY3V0YWJsZUNvZGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnVuY3Rpb25DYWxsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmdW5jdGlvbkNhbGwnXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvbkNhbGwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvbkNhbGwnXSwgZnJvbUZ1bmN0aW9uQ2FsbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GdW5jdGlvblJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZnVuY3Rpb25SZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvblJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25SZXNwb25zZSddLCBmcm9tRnVuY3Rpb25SZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UZXh0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0ZXh0J10pO1xuICAgIGlmIChmcm9tVGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RleHQnXSwgZnJvbVRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjb250ZW50VG9WZXJ0ZXgkMihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUGFydHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhcnRzJ10pO1xuICAgIGlmIChmcm9tUGFydHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVBhcnRzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnRUb1ZlcnRleCQyKGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncGFydHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJvbGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3JvbGUnXSk7XG4gICAgaWYgKGZyb21Sb2xlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncm9sZSddLCBmcm9tUm9sZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZ1bmN0aW9uRGVjbGFyYXRpb25Ub1ZlcnRleCQyKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2JlaGF2aW9yJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiZWhhdmlvciBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBWZXJ0ZXggQUkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EZXNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGVzY3JpcHRpb24nXSk7XG4gICAgaWYgKGZyb21EZXNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10sIGZyb21EZXNjcmlwdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGFyYW1ldGVycyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFyYW1ldGVycyddKTtcbiAgICBpZiAoZnJvbVBhcmFtZXRlcnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJhbWV0ZXJzJ10sIGZyb21QYXJhbWV0ZXJzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhcmFtZXRlcnNKc29uU2NoZW1hID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncGFyYW1ldGVyc0pzb25TY2hlbWEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUGFyYW1ldGVyc0pzb25TY2hlbWEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJhbWV0ZXJzSnNvblNjaGVtYSddLCBmcm9tUGFyYW1ldGVyc0pzb25TY2hlbWEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Jlc3BvbnNlJ10pO1xuICAgIGlmIChmcm9tUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZSddLCBmcm9tUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VKc29uU2NoZW1hID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VKc29uU2NoZW1hJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlSnNvblNjaGVtYSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlSnNvblNjaGVtYSddLCBmcm9tUmVzcG9uc2VKc29uU2NoZW1hKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gaW50ZXJ2YWxUb1ZlcnRleCQyKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TdGFydFRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3N0YXJ0VGltZSddKTtcbiAgICBpZiAoZnJvbVN0YXJ0VGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0YXJ0VGltZSddLCBmcm9tU3RhcnRUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuZFRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VuZFRpbWUnXSk7XG4gICAgaWYgKGZyb21FbmRUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW5kVGltZSddLCBmcm9tRW5kVGltZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdvb2dsZVNlYXJjaFRvVmVydGV4JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVRpbWVSYW5nZUZpbHRlciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3RpbWVSYW5nZUZpbHRlcicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UaW1lUmFuZ2VGaWx0ZXIgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aW1lUmFuZ2VGaWx0ZXInXSwgaW50ZXJ2YWxUb1ZlcnRleCQyKGZyb21UaW1lUmFuZ2VGaWx0ZXIpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZHluYW1pY1JldHJpZXZhbENvbmZpZ1RvVmVydGV4JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGUnXSk7XG4gICAgaWYgKGZyb21Nb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZSddLCBmcm9tTW9kZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EeW5hbWljVGhyZXNob2xkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZHluYW1pY1RocmVzaG9sZCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21EeW5hbWljVGhyZXNob2xkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZHluYW1pY1RocmVzaG9sZCddLCBmcm9tRHluYW1pY1RocmVzaG9sZCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdvb2dsZVNlYXJjaFJldHJpZXZhbFRvVmVydGV4JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUR5bmFtaWNSZXRyaWV2YWxDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdkeW5hbWljUmV0cmlldmFsQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUR5bmFtaWNSZXRyaWV2YWxDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkeW5hbWljUmV0cmlldmFsQ29uZmlnJ10sIGR5bmFtaWNSZXRyaWV2YWxDb25maWdUb1ZlcnRleCQyKGZyb21EeW5hbWljUmV0cmlldmFsQ29uZmlnKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGVudGVycHJpc2VXZWJTZWFyY2hUb1ZlcnRleCQyKCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gYXBpS2V5Q29uZmlnVG9WZXJ0ZXgkMihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQXBpS2V5U3RyaW5nID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhcGlLZXlTdHJpbmcnXSk7XG4gICAgaWYgKGZyb21BcGlLZXlTdHJpbmcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhcGlLZXlTdHJpbmcnXSwgZnJvbUFwaUtleVN0cmluZyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGF1dGhDb25maWdUb1ZlcnRleCQyKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21BcGlLZXlDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2FwaUtleUNvbmZpZyddKTtcbiAgICBpZiAoZnJvbUFwaUtleUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2FwaUtleUNvbmZpZyddLCBhcGlLZXlDb25maWdUb1ZlcnRleCQyKGZyb21BcGlLZXlDb25maWcpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUF1dGhUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhdXRoVHlwZSddKTtcbiAgICBpZiAoZnJvbUF1dGhUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYXV0aFR5cGUnXSwgZnJvbUF1dGhUeXBlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvb2dsZVNlcnZpY2VBY2NvdW50Q29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ29vZ2xlU2VydmljZUFjY291bnRDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tR29vZ2xlU2VydmljZUFjY291bnRDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVTZXJ2aWNlQWNjb3VudENvbmZpZyddLCBmcm9tR29vZ2xlU2VydmljZUFjY291bnRDb25maWcpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSHR0cEJhc2ljQXV0aENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2h0dHBCYXNpY0F1dGhDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tSHR0cEJhc2ljQXV0aENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2h0dHBCYXNpY0F1dGhDb25maWcnXSwgZnJvbUh0dHBCYXNpY0F1dGhDb25maWcpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT2F1dGhDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ29hdXRoQ29uZmlnJ10pO1xuICAgIGlmIChmcm9tT2F1dGhDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydvYXV0aENvbmZpZyddLCBmcm9tT2F1dGhDb25maWcpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT2lkY0NvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnb2lkY0NvbmZpZyddKTtcbiAgICBpZiAoZnJvbU9pZGNDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydvaWRjQ29uZmlnJ10sIGZyb21PaWRjQ29uZmlnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ29vZ2xlTWFwc1RvVmVydGV4JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUF1dGhDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2F1dGhDb25maWcnXSk7XG4gICAgaWYgKGZyb21BdXRoQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYXV0aENvbmZpZyddLCBhdXRoQ29uZmlnVG9WZXJ0ZXgkMihmcm9tQXV0aENvbmZpZykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB1cmxDb250ZXh0VG9WZXJ0ZXgkMigpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHRvb2xUb1ZlcnRleCQyKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2Z1bmN0aW9uRGVjbGFyYXRpb25zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uRGVjbGFyYXRpb25zICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbkRlY2xhcmF0aW9uVG9WZXJ0ZXgkMihpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uRGVjbGFyYXRpb25zJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXRyaWV2YWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3JldHJpZXZhbCddKTtcbiAgICBpZiAoZnJvbVJldHJpZXZhbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JldHJpZXZhbCddLCBmcm9tUmV0cmlldmFsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvb2dsZVNlYXJjaCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ29vZ2xlU2VhcmNoJ10pO1xuICAgIGlmIChmcm9tR29vZ2xlU2VhcmNoICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ29vZ2xlU2VhcmNoJ10sIGdvb2dsZVNlYXJjaFRvVmVydGV4JDIoZnJvbUdvb2dsZVNlYXJjaCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ29vZ2xlU2VhcmNoUmV0cmlldmFsJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaFJldHJpZXZhbCddLCBnb29nbGVTZWFyY2hSZXRyaWV2YWxUb1ZlcnRleCQyKGZyb21Hb29nbGVTZWFyY2hSZXRyaWV2YWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVudGVycHJpc2VXZWJTZWFyY2ggPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdlbnRlcnByaXNlV2ViU2VhcmNoJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUVudGVycHJpc2VXZWJTZWFyY2ggIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbnRlcnByaXNlV2ViU2VhcmNoJ10sIGVudGVycHJpc2VXZWJTZWFyY2hUb1ZlcnRleCQyKCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlTWFwcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ29vZ2xlTWFwcyddKTtcbiAgICBpZiAoZnJvbUdvb2dsZU1hcHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVNYXBzJ10sIGdvb2dsZU1hcHNUb1ZlcnRleCQyKGZyb21Hb29nbGVNYXBzKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21VcmxDb250ZXh0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd1cmxDb250ZXh0J10pO1xuICAgIGlmIChmcm9tVXJsQ29udGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VybENvbnRleHQnXSwgdXJsQ29udGV4dFRvVmVydGV4JDIoKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db2RlRXhlY3V0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY29kZUV4ZWN1dGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Db2RlRXhlY3V0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29kZUV4ZWN1dGlvbiddLCBmcm9tQ29kZUV4ZWN1dGlvbik7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZ1bmN0aW9uQ2FsbGluZ0NvbmZpZ1RvVmVydGV4JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGUnXSk7XG4gICAgaWYgKGZyb21Nb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZSddLCBmcm9tTW9kZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BbGxvd2VkRnVuY3Rpb25OYW1lcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2FsbG93ZWRGdW5jdGlvbk5hbWVzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUFsbG93ZWRGdW5jdGlvbk5hbWVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYWxsb3dlZEZ1bmN0aW9uTmFtZXMnXSwgZnJvbUFsbG93ZWRGdW5jdGlvbk5hbWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGF0TG5nVG9WZXJ0ZXgkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTGF0aXR1ZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhdGl0dWRlJ10pO1xuICAgIGlmIChmcm9tTGF0aXR1ZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsYXRpdHVkZSddLCBmcm9tTGF0aXR1ZGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTG9uZ2l0dWRlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsb25naXR1ZGUnXSk7XG4gICAgaWYgKGZyb21Mb25naXR1ZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsb25naXR1ZGUnXSwgZnJvbUxvbmdpdHVkZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHJldHJpZXZhbENvbmZpZ1RvVmVydGV4JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUxhdExuZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGF0TG5nJ10pO1xuICAgIGlmIChmcm9tTGF0TG5nICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbGF0TG5nJ10sIGxhdExuZ1RvVmVydGV4JDEoZnJvbUxhdExuZykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTGFuZ3VhZ2VDb2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsYW5ndWFnZUNvZGUnXSk7XG4gICAgaWYgKGZyb21MYW5ndWFnZUNvZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsYW5ndWFnZUNvZGUnXSwgZnJvbUxhbmd1YWdlQ29kZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHRvb2xDb25maWdUb1ZlcnRleCQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21GdW5jdGlvbkNhbGxpbmdDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvbkNhbGxpbmdDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25DYWxsaW5nQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25DYWxsaW5nQ29uZmlnJ10sIGZ1bmN0aW9uQ2FsbGluZ0NvbmZpZ1RvVmVydGV4JDEoZnJvbUZ1bmN0aW9uQ2FsbGluZ0NvbmZpZykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmV0cmlldmFsQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmV0cmlldmFsQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJldHJpZXZhbENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JldHJpZXZhbENvbmZpZyddLCByZXRyaWV2YWxDb25maWdUb1ZlcnRleCQxKGZyb21SZXRyaWV2YWxDb25maWcpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY3JlYXRlQ2FjaGVkQ29udGVudENvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVR0bCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndHRsJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVHRsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3R0bCddLCBmcm9tVHRsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUV4cGlyZVRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2V4cGlyZVRpbWUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21FeHBpcmVUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2V4cGlyZVRpbWUnXSwgZnJvbUV4cGlyZVRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGlzcGxheU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRGlzcGxheU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnZGlzcGxheU5hbWUnXSwgZnJvbURpc3BsYXlOYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbnRlbnRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb250ZW50cyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUNvbnRlbnRzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IHRDb250ZW50cyhmcm9tQ29udGVudHMpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnRUb1ZlcnRleCQyKGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2NvbnRlbnRzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TeXN0ZW1JbnN0cnVjdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3N5c3RlbUluc3RydWN0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVN5c3RlbUluc3RydWN0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3N5c3RlbUluc3RydWN0aW9uJ10sIGNvbnRlbnRUb1ZlcnRleCQyKHRDb250ZW50KGZyb21TeXN0ZW1JbnN0cnVjdGlvbikpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvb2xzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b29scyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRvb2xzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21Ub29scztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b29sVG9WZXJ0ZXgkMihpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWyd0b29scyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9vbENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9vbENvbmZpZyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRvb2xDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsndG9vbENvbmZpZyddLCB0b29sQ29uZmlnVG9WZXJ0ZXgkMShmcm9tVG9vbENvbmZpZykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tS21zS2V5TmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsna21zS2V5TmFtZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUttc0tleU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnZW5jcnlwdGlvbl9zcGVjJywgJ2ttc0tleU5hbWUnXSwgZnJvbUttc0tleU5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjcmVhdGVDYWNoZWRDb250ZW50UGFyYW1ldGVyc1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZWwnXSwgdENhY2hlc01vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbmZpZyddLCBjcmVhdGVDYWNoZWRDb250ZW50Q29uZmlnVG9WZXJ0ZXgoZnJvbUNvbmZpZywgdG9PYmplY3QpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2V0Q2FjaGVkQ29udGVudFBhcmFtZXRlcnNUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCB0Q2FjaGVkQ29udGVudE5hbWUoYXBpQ2xpZW50LCBmcm9tTmFtZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb25maWcnXSwgZnJvbUNvbmZpZyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGRlbGV0ZUNhY2hlZENvbnRlbnRQYXJhbWV0ZXJzVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ25hbWUnXSwgdENhY2hlZENvbnRlbnROYW1lKGFwaUNsaWVudCwgZnJvbU5hbWUpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29uZmlnJ10sIGZyb21Db25maWcpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB1cGRhdGVDYWNoZWRDb250ZW50Q29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVHRsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0dGwnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21UdGwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsndHRsJ10sIGZyb21UdGwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXhwaXJlVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXhwaXJlVGltZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUV4cGlyZVRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnZXhwaXJlVGltZSddLCBmcm9tRXhwaXJlVGltZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUNhY2hlZENvbnRlbnRQYXJhbWV0ZXJzVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ25hbWUnXSwgdENhY2hlZENvbnRlbnROYW1lKGFwaUNsaWVudCwgZnJvbU5hbWUpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29uZmlnJ10sIHVwZGF0ZUNhY2hlZENvbnRlbnRDb25maWdUb1ZlcnRleChmcm9tQ29uZmlnLCB0b09iamVjdCkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0Q2FjaGVkQ29udGVudHNDb25maWdUb1ZlcnRleChmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21QYWdlU2l6ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFnZVNpemUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QYWdlU2l6ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAncGFnZVNpemUnXSwgZnJvbVBhZ2VTaXplKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhZ2VUb2tlbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFnZVRva2VuJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGFnZVRva2VuICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdwYWdlVG9rZW4nXSwgZnJvbVBhZ2VUb2tlbik7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RDYWNoZWRDb250ZW50c1BhcmFtZXRlcnNUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb25maWcnXSwgbGlzdENhY2hlZENvbnRlbnRzQ29uZmlnVG9WZXJ0ZXgoZnJvbUNvbmZpZywgdG9PYmplY3QpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY2FjaGVkQ29udGVudEZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURpc3BsYXlOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKTtcbiAgICBpZiAoZnJvbURpc3BsYXlOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGlzcGxheU5hbWUnXSwgZnJvbURpc3BsYXlOYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZWwnXSwgZnJvbU1vZGVsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNyZWF0ZVRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NyZWF0ZVRpbWUnXSk7XG4gICAgaWYgKGZyb21DcmVhdGVUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY3JlYXRlVGltZSddLCBmcm9tQ3JlYXRlVGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21VcGRhdGVUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd1cGRhdGVUaW1lJ10pO1xuICAgIGlmIChmcm9tVXBkYXRlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VwZGF0ZVRpbWUnXSwgZnJvbVVwZGF0ZVRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXhwaXJlVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXhwaXJlVGltZSddKTtcbiAgICBpZiAoZnJvbUV4cGlyZVRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydleHBpcmVUaW1lJ10sIGZyb21FeHBpcmVUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVzYWdlTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd1c2FnZU1ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVVzYWdlTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1c2FnZU1ldGFkYXRhJ10sIGZyb21Vc2FnZU1ldGFkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZGVsZXRlQ2FjaGVkQ29udGVudFJlc3BvbnNlRnJvbU1sZGV2KCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdENhY2hlZENvbnRlbnRzUmVzcG9uc2VGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5leHRQYWdlVG9rZW4gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICduZXh0UGFnZVRva2VuJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU5leHRQYWdlVG9rZW4gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduZXh0UGFnZVRva2VuJ10sIGZyb21OZXh0UGFnZVRva2VuKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNhY2hlZENvbnRlbnRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY2FjaGVkQ29udGVudHMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ2FjaGVkQ29udGVudHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUNhY2hlZENvbnRlbnRzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENvbnRlbnRGcm9tTWxkZXYoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjYWNoZWRDb250ZW50cyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjYWNoZWRDb250ZW50RnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURpc3BsYXlOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKTtcbiAgICBpZiAoZnJvbURpc3BsYXlOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGlzcGxheU5hbWUnXSwgZnJvbURpc3BsYXlOYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZWwnXSwgZnJvbU1vZGVsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNyZWF0ZVRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NyZWF0ZVRpbWUnXSk7XG4gICAgaWYgKGZyb21DcmVhdGVUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY3JlYXRlVGltZSddLCBmcm9tQ3JlYXRlVGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21VcGRhdGVUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd1cGRhdGVUaW1lJ10pO1xuICAgIGlmIChmcm9tVXBkYXRlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VwZGF0ZVRpbWUnXSwgZnJvbVVwZGF0ZVRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXhwaXJlVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXhwaXJlVGltZSddKTtcbiAgICBpZiAoZnJvbUV4cGlyZVRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydleHBpcmVUaW1lJ10sIGZyb21FeHBpcmVUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVzYWdlTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd1c2FnZU1ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVVzYWdlTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1c2FnZU1ldGFkYXRhJ10sIGZyb21Vc2FnZU1ldGFkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZGVsZXRlQ2FjaGVkQ29udGVudFJlc3BvbnNlRnJvbVZlcnRleCgpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RDYWNoZWRDb250ZW50c1Jlc3BvbnNlRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmV4dFBhZ2VUb2tlbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ25leHRQYWdlVG9rZW4nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTmV4dFBhZ2VUb2tlbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25leHRQYWdlVG9rZW4nXSwgZnJvbU5leHRQYWdlVG9rZW4pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2FjaGVkQ29udGVudHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjYWNoZWRDb250ZW50cycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21DYWNoZWRDb250ZW50cyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tQ2FjaGVkQ29udGVudHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkQ29udGVudEZyb21WZXJ0ZXgoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjYWNoZWRDb250ZW50cyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmNsYXNzIENhY2hlcyBleHRlbmRzIEJhc2VNb2R1bGUge1xuICAgIGNvbnN0cnVjdG9yKGFwaUNsaWVudCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmFwaUNsaWVudCA9IGFwaUNsaWVudDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3RzIGNhY2hlZCBjb250ZW50IGNvbmZpZ3VyYXRpb25zLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoZSBsaXN0IHJlcXVlc3QuXG4gICAgICAgICAqIEByZXR1cm4gVGhlIHBhZ2luYXRlZCByZXN1bHRzIG9mIHRoZSBsaXN0IG9mIGNhY2hlZCBjb250ZW50cy5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogYGBgdHNcbiAgICAgICAgICogY29uc3QgY2FjaGVkQ29udGVudHMgPSBhd2FpdCBhaS5jYWNoZXMubGlzdCh7Y29uZmlnOiB7J3BhZ2VTaXplJzogMn19KTtcbiAgICAgICAgICogZm9yIGF3YWl0IChjb25zdCBjYWNoZWRDb250ZW50IG9mIGNhY2hlZENvbnRlbnRzKSB7XG4gICAgICAgICAqICAgY29uc29sZS5sb2coY2FjaGVkQ29udGVudCk7XG4gICAgICAgICAqIH1cbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxpc3QgPSBhc3luYyAocGFyYW1zID0ge30pID0+IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUGFnZXIoUGFnZWRJdGVtLlBBR0VEX0lURU1fQ0FDSEVEX0NPTlRFTlRTLCAoeCkgPT4gdGhpcy5saXN0SW50ZXJuYWwoeCksIGF3YWl0IHRoaXMubGlzdEludGVybmFsKHBhcmFtcyksIHBhcmFtcyk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjYWNoZWQgY29udGVudHMgcmVzb3VyY2UuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIENvbnRleHQgY2FjaGluZyBpcyBvbmx5IHN1cHBvcnRlZCBmb3Igc3BlY2lmaWMgbW9kZWxzLiBTZWUgW0dlbWluaVxuICAgICAqIERldmVsb3BlciBBUEkgcmVmZXJlbmNlXShodHRwczovL2FpLmdvb2dsZS5kZXYvZ2VtaW5pLWFwaS9kb2NzL2NhY2hpbmc/bGFuZz1ub2RlL2NvbnRleHQtY2FjKVxuICAgICAqIGFuZCBbVmVydGV4IEFJIHJlZmVyZW5jZV0oaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL3ZlcnRleC1haS9nZW5lcmF0aXZlLWFpL2RvY3MvY29udGV4dC1jYWNoZS9jb250ZXh0LWNhY2hlLW92ZXJ2aWV3I3N1cHBvcnRlZF9tb2RlbHMpXG4gICAgICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoZSBjcmVhdGUgcmVxdWVzdC5cbiAgICAgKiBAcmV0dXJuIFRoZSBjcmVhdGVkIGNhY2hlZCBjb250ZW50LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IGNvbnRlbnRzID0gLi4uOyAvLyBJbml0aWFsaXplIHRoZSBjb250ZW50IHRvIGNhY2hlLlxuICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYWkuY2FjaGVzLmNyZWF0ZSh7XG4gICAgICogICBtb2RlbDogJ2dlbWluaS0yLjAtZmxhc2gtMDAxJyxcbiAgICAgKiAgIGNvbmZpZzoge1xuICAgICAqICAgICdjb250ZW50cyc6IGNvbnRlbnRzLFxuICAgICAqICAgICdkaXNwbGF5TmFtZSc6ICd0ZXN0IGNhY2hlJyxcbiAgICAgKiAgICAnc3lzdGVtSW5zdHJ1Y3Rpb24nOiAnV2hhdCBpcyB0aGUgc3VtIG9mIHRoZSB0d28gcGRmcz8nLFxuICAgICAqICAgICd0dGwnOiAnODY0MDBzJyxcbiAgICAgKiAgfVxuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZShwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gY3JlYXRlQ2FjaGVkQ29udGVudFBhcmFtZXRlcnNUb1ZlcnRleCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ2NhY2hlZENvbnRlbnRzJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnY29uZmlnJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBjYWNoZWRDb250ZW50RnJvbVZlcnRleChhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBjcmVhdGVDYWNoZWRDb250ZW50UGFyYW1ldGVyc1RvTWxkZXYodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCdjYWNoZWRDb250ZW50cycsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ2NvbmZpZyddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gY2FjaGVkQ29udGVudEZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGNhY2hlZCBjb250ZW50IGNvbmZpZ3VyYXRpb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgZ2V0IHJlcXVlc3QuXG4gICAgICogQHJldHVybiBUaGUgY2FjaGVkIGNvbnRlbnQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogYXdhaXQgYWkuY2FjaGVzLmdldCh7bmFtZTogJy4uLid9KTsgLy8gVGhlIHNlcnZlci1nZW5lcmF0ZWQgcmVzb3VyY2UgbmFtZS5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBnZXQocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGdldENhY2hlZENvbnRlbnRQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bmFtZX0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5Wydjb25maWcnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gY2FjaGVkQ29udGVudEZyb21WZXJ0ZXgoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZ2V0Q2FjaGVkQ29udGVudFBhcmFtZXRlcnNUb01sZGV2KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne25hbWV9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnY29uZmlnJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGNhY2hlZENvbnRlbnRGcm9tTWxkZXYoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBjYWNoZWQgY29udGVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhlIGRlbGV0ZSByZXF1ZXN0LlxuICAgICAqIEByZXR1cm4gVGhlIGVtcHR5IHJlc3BvbnNlIHJldHVybmVkIGJ5IHRoZSBBUEkuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogYXdhaXQgYWkuY2FjaGVzLmRlbGV0ZSh7bmFtZTogJy4uLid9KTsgLy8gVGhlIHNlcnZlci1nZW5lcmF0ZWQgcmVzb3VyY2UgbmFtZS5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBkZWxldGUocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGRlbGV0ZUNhY2hlZENvbnRlbnRQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bmFtZX0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5Wydjb25maWcnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdERUxFVEUnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGRlbGV0ZUNhY2hlZENvbnRlbnRSZXNwb25zZUZyb21WZXJ0ZXgoKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgRGVsZXRlQ2FjaGVkQ29udGVudFJlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBkZWxldGVDYWNoZWRDb250ZW50UGFyYW1ldGVyc1RvTWxkZXYodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bmFtZX0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5Wydjb25maWcnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdERUxFVEUnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGRlbGV0ZUNhY2hlZENvbnRlbnRSZXNwb25zZUZyb21NbGRldigpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBEZWxldGVDYWNoZWRDb250ZW50UmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgY2FjaGVkIGNvbnRlbnQgY29uZmlndXJhdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoZSB1cGRhdGUgcmVxdWVzdC5cbiAgICAgKiBAcmV0dXJuIFRoZSB1cGRhdGVkIGNhY2hlZCBjb250ZW50LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYWkuY2FjaGVzLnVwZGF0ZSh7XG4gICAgICogICBuYW1lOiAnLi4uJywgIC8vIFRoZSBzZXJ2ZXItZ2VuZXJhdGVkIHJlc291cmNlIG5hbWUuXG4gICAgICogICBjb25maWc6IHsndHRsJzogJzc2MDBzJ31cbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGUocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IHVwZGF0ZUNhY2hlZENvbnRlbnRQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bmFtZX0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5Wydjb25maWcnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQQVRDSCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBjYWNoZWRDb250ZW50RnJvbVZlcnRleChhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSB1cGRhdGVDYWNoZWRDb250ZW50UGFyYW1ldGVyc1RvTWxkZXYodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bmFtZX0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5Wydjb25maWcnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQQVRDSCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYyA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBjYWNoZWRDb250ZW50RnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGxpc3RJbnRlcm5hbChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gbGlzdENhY2hlZENvbnRlbnRzUGFyYW1ldGVyc1RvVmVydGV4KHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCdjYWNoZWRDb250ZW50cycsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ2NvbmZpZyddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBsaXN0Q2FjaGVkQ29udGVudHNSZXNwb25zZUZyb21WZXJ0ZXgoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBMaXN0Q2FjaGVkQ29udGVudHNSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gbGlzdENhY2hlZENvbnRlbnRzUGFyYW1ldGVyc1RvTWxkZXYocGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ2NhY2hlZENvbnRlbnRzJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnY29uZmlnJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGxpc3RDYWNoZWRDb250ZW50c1Jlc3BvbnNlRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgTGlzdENhY2hlZENvbnRlbnRzUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UsIFN1cHByZXNzZWRFcnJvciwgU3ltYm9sLCBJdGVyYXRvciAqL1xyXG5cclxuXHJcbmZ1bmN0aW9uIF9fdmFsdWVzKG8pIHtcclxuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XHJcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcclxuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX2F3YWl0KHYpIHtcclxuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX2FzeW5jR2VuZXJhdG9yKHRoaXNBcmcsIF9hcmd1bWVudHMsIGdlbmVyYXRvcikge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBnID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pLCBpLCBxID0gW107XHJcbiAgICByZXR1cm4gaSA9IE9iamVjdC5jcmVhdGUoKHR5cGVvZiBBc3luY0l0ZXJhdG9yID09PSBcImZ1bmN0aW9uXCIgPyBBc3luY0l0ZXJhdG9yIDogT2JqZWN0KS5wcm90b3R5cGUpLCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIsIGF3YWl0UmV0dXJuKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gYXdhaXRSZXR1cm4oZikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGYsIHJlamVjdCk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpZiAoZ1tuXSkgeyBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7IHEucHVzaChbbiwgdiwgYSwgYl0pID4gMSB8fCByZXN1bWUobiwgdik7IH0pOyB9OyBpZiAoZikgaVtuXSA9IGYoaVtuXSk7IH0gfVxyXG4gICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxyXG4gICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyB9XHJcbiAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fYXN5bmNWYWx1ZXMobykge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0sIGk7XHJcbiAgICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IChvID0gdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaSk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaVtuXSA9IG9bbl0gJiYgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdiA9IG9bbl0odiksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSk7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCBkLCB2KSB7IFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGZ1bmN0aW9uKHYpIHsgcmVzb2x2ZSh7IHZhbHVlOiB2LCBkb25lOiBkIH0pOyB9LCByZWplY3QpOyB9XHJcbn1cclxuXHJcbnR5cGVvZiBTdXBwcmVzc2VkRXJyb3IgPT09IFwiZnVuY3Rpb25cIiA/IFN1cHByZXNzZWRFcnJvciA6IGZ1bmN0aW9uIChlcnJvciwgc3VwcHJlc3NlZCwgbWVzc2FnZSkge1xyXG4gICAgdmFyIGUgPSBuZXcgRXJyb3IobWVzc2FnZSk7XHJcbiAgICByZXR1cm4gZS5uYW1lID0gXCJTdXBwcmVzc2VkRXJyb3JcIiwgZS5lcnJvciA9IGVycm9yLCBlLnN1cHByZXNzZWQgPSBzdXBwcmVzc2VkLCBlO1xyXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcmVzcG9uc2UgaXMgdmFsaWQsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNWYWxpZFJlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChyZXNwb25zZS5jYW5kaWRhdGVzID09IHVuZGVmaW5lZCB8fCByZXNwb25zZS5jYW5kaWRhdGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGNvbnRlbnQgPSAoX2EgPSByZXNwb25zZS5jYW5kaWRhdGVzWzBdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29udGVudDtcbiAgICBpZiAoY29udGVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGlzVmFsaWRDb250ZW50KGNvbnRlbnQpO1xufVxuZnVuY3Rpb24gaXNWYWxpZENvbnRlbnQoY29udGVudCkge1xuICAgIGlmIChjb250ZW50LnBhcnRzID09PSB1bmRlZmluZWQgfHwgY29udGVudC5wYXJ0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHBhcnQgb2YgY29udGVudC5wYXJ0cykge1xuICAgICAgICBpZiAocGFydCA9PT0gdW5kZWZpbmVkIHx8IE9iamVjdC5rZXlzKHBhcnQpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcGFydC50aG91Z2h0ICYmIHBhcnQudGV4dCAhPT0gdW5kZWZpbmVkICYmIHBhcnQudGV4dCA9PT0gJycpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuICogVmFsaWRhdGVzIHRoZSBoaXN0b3J5IGNvbnRhaW5zIHRoZSBjb3JyZWN0IHJvbGVzLlxuICpcbiAqIEB0aHJvd3MgRXJyb3IgaWYgdGhlIGhpc3RvcnkgZG9lcyBub3Qgc3RhcnQgd2l0aCBhIHVzZXIgdHVybi5cbiAqIEB0aHJvd3MgRXJyb3IgaWYgdGhlIGhpc3RvcnkgY29udGFpbnMgYW4gaW52YWxpZCByb2xlLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUhpc3RvcnkoaGlzdG9yeSkge1xuICAgIC8vIEVtcHR5IGhpc3RvcnkgaXMgdmFsaWQuXG4gICAgaWYgKGhpc3RvcnkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBjb250ZW50IG9mIGhpc3RvcnkpIHtcbiAgICAgICAgaWYgKGNvbnRlbnQucm9sZSAhPT0gJ3VzZXInICYmIGNvbnRlbnQucm9sZSAhPT0gJ21vZGVsJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSb2xlIG11c3QgYmUgdXNlciBvciBtb2RlbCwgYnV0IGdvdCAke2NvbnRlbnQucm9sZX0uYCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIEV4dHJhY3RzIHRoZSBjdXJhdGVkICh2YWxpZCkgaGlzdG9yeSBmcm9tIGEgY29tcHJlaGVuc2l2ZSBoaXN0b3J5LlxuICpcbiAqIEByZW1hcmtzXG4gKiBUaGUgbW9kZWwgbWF5IHNvbWV0aW1lcyBnZW5lcmF0ZSBpbnZhbGlkIG9yIGVtcHR5IGNvbnRlbnRzKGUuZy4sIGR1ZSB0byBzYWZ0eVxuICogZmlsdGVycyBvciByZWNpdGF0aW9uKS4gRXh0cmFjdGluZyB2YWxpZCB0dXJucyBmcm9tIHRoZSBoaXN0b3J5XG4gKiBlbnN1cmVzIHRoYXQgc3Vic2VxdWVudCByZXF1ZXN0cyBjb3VsZCBiZSBhY2NwZXRlZCBieSB0aGUgbW9kZWwuXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RDdXJhdGVkSGlzdG9yeShjb21wcmVoZW5zaXZlSGlzdG9yeSkge1xuICAgIGlmIChjb21wcmVoZW5zaXZlSGlzdG9yeSA9PT0gdW5kZWZpbmVkIHx8IGNvbXByZWhlbnNpdmVIaXN0b3J5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IGN1cmF0ZWRIaXN0b3J5ID0gW107XG4gICAgY29uc3QgbGVuZ3RoID0gY29tcHJlaGVuc2l2ZUhpc3RvcnkubGVuZ3RoO1xuICAgIGxldCBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGxlbmd0aCkge1xuICAgICAgICBpZiAoY29tcHJlaGVuc2l2ZUhpc3RvcnlbaV0ucm9sZSA9PT0gJ3VzZXInKSB7XG4gICAgICAgICAgICBjdXJhdGVkSGlzdG9yeS5wdXNoKGNvbXByZWhlbnNpdmVIaXN0b3J5W2ldKTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG1vZGVsT3V0cHV0ID0gW107XG4gICAgICAgICAgICBsZXQgaXNWYWxpZCA9IHRydWU7XG4gICAgICAgICAgICB3aGlsZSAoaSA8IGxlbmd0aCAmJiBjb21wcmVoZW5zaXZlSGlzdG9yeVtpXS5yb2xlID09PSAnbW9kZWwnKSB7XG4gICAgICAgICAgICAgICAgbW9kZWxPdXRwdXQucHVzaChjb21wcmVoZW5zaXZlSGlzdG9yeVtpXSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzVmFsaWQgJiYgIWlzVmFsaWRDb250ZW50KGNvbXByZWhlbnNpdmVIaXN0b3J5W2ldKSkge1xuICAgICAgICAgICAgICAgICAgICBpc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1ZhbGlkKSB7XG4gICAgICAgICAgICAgICAgY3VyYXRlZEhpc3RvcnkucHVzaCguLi5tb2RlbE91dHB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIGxhc3QgdXNlciBpbnB1dCB3aGVuIG1vZGVsIGNvbnRlbnQgaXMgaW52YWxpZC5cbiAgICAgICAgICAgICAgICBjdXJhdGVkSGlzdG9yeS5wb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY3VyYXRlZEhpc3Rvcnk7XG59XG4vKipcbiAqIEEgdXRpbGl0eSBjbGFzcyB0byBjcmVhdGUgYSBjaGF0IHNlc3Npb24uXG4gKi9cbmNsYXNzIENoYXRzIHtcbiAgICBjb25zdHJ1Y3Rvcihtb2RlbHNNb2R1bGUsIGFwaUNsaWVudCkge1xuICAgICAgICB0aGlzLm1vZGVsc01vZHVsZSA9IG1vZGVsc01vZHVsZTtcbiAgICAgICAgdGhpcy5hcGlDbGllbnQgPSBhcGlDbGllbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgY2hhdCBzZXNzaW9uLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBUaGUgY29uZmlnIGluIHRoZSBwYXJhbXMgd2lsbCBiZSB1c2VkIGZvciBhbGwgcmVxdWVzdHMgd2l0aGluIHRoZSBjaGF0XG4gICAgICogc2Vzc2lvbiB1bmxlc3Mgb3ZlcnJpZGRlbiBieSBhIHBlci1yZXF1ZXN0IGBjb25maWdgIGluXG4gICAgICogQHNlZSB7QGxpbmsgdHlwZXMuU2VuZE1lc3NhZ2VQYXJhbWV0ZXJzI2NvbmZpZ30uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gUGFyYW1ldGVycyBmb3IgY3JlYXRpbmcgYSBjaGF0IHNlc3Npb24uXG4gICAgICogQHJldHVybnMgQSBuZXcgY2hhdCBzZXNzaW9uLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IGNoYXQgPSBhaS5jaGF0cy5jcmVhdGUoe1xuICAgICAqICAgbW9kZWw6ICdnZW1pbmktMi4wLWZsYXNoJ1xuICAgICAqICAgY29uZmlnOiB7XG4gICAgICogICAgIHRlbXBlcmF0dXJlOiAwLjUsXG4gICAgICogICAgIG1heE91dHB1dFRva2VuczogMTAyNCxcbiAgICAgKiAgIH1cbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBjcmVhdGUocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2hhdCh0aGlzLmFwaUNsaWVudCwgdGhpcy5tb2RlbHNNb2R1bGUsIHBhcmFtcy5tb2RlbCwgcGFyYW1zLmNvbmZpZywgXG4gICAgICAgIC8vIERlZXAgY29weSB0aGUgaGlzdG9yeSB0byBhdm9pZCBtdXRhdGluZyB0aGUgaGlzdG9yeSBvdXRzaWRlIG9mIHRoZVxuICAgICAgICAvLyBjaGF0IHNlc3Npb24uXG4gICAgICAgIHN0cnVjdHVyZWRDbG9uZShwYXJhbXMuaGlzdG9yeSkpO1xuICAgIH1cbn1cbi8qKlxuICogQ2hhdCBzZXNzaW9uIHRoYXQgZW5hYmxlcyBzZW5kaW5nIG1lc3NhZ2VzIHRvIHRoZSBtb2RlbCB3aXRoIHByZXZpb3VzXG4gKiBjb252ZXJzYXRpb24gY29udGV4dC5cbiAqXG4gKiBAcmVtYXJrc1xuICogVGhlIHNlc3Npb24gbWFpbnRhaW5zIGFsbCB0aGUgdHVybnMgYmV0d2VlbiB1c2VyIGFuZCBtb2RlbC5cbiAqL1xuY2xhc3MgQ2hhdCB7XG4gICAgY29uc3RydWN0b3IoYXBpQ2xpZW50LCBtb2RlbHNNb2R1bGUsIG1vZGVsLCBjb25maWcgPSB7fSwgaGlzdG9yeSA9IFtdKSB7XG4gICAgICAgIHRoaXMuYXBpQ2xpZW50ID0gYXBpQ2xpZW50O1xuICAgICAgICB0aGlzLm1vZGVsc01vZHVsZSA9IG1vZGVsc01vZHVsZTtcbiAgICAgICAgdGhpcy5tb2RlbCA9IG1vZGVsO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgdGhpcy5oaXN0b3J5ID0gaGlzdG9yeTtcbiAgICAgICAgLy8gQSBwcm9taXNlIHRvIHJlcHJlc2VudCB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgbWVzc2FnZSBiZWluZyBzZW50IHRvIHRoZVxuICAgICAgICAvLyBtb2RlbC5cbiAgICAgICAgdGhpcy5zZW5kUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB2YWxpZGF0ZUhpc3RvcnkoaGlzdG9yeSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgbWVzc2FnZSB0byB0aGUgbW9kZWwgYW5kIHJldHVybnMgdGhlIHJlc3BvbnNlLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIHdhaXQgZm9yIHRoZSBwcmV2aW91cyBtZXNzYWdlIHRvIGJlIHByb2Nlc3NlZCBiZWZvcmVcbiAgICAgKiBzZW5kaW5nIHRoZSBuZXh0IG1lc3NhZ2UuXG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBDaGF0I3NlbmRNZXNzYWdlU3RyZWFtfSBmb3Igc3RyZWFtaW5nIG1ldGhvZC5cbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gcGFyYW1ldGVycyBmb3Igc2VuZGluZyBtZXNzYWdlcyB3aXRoaW4gYSBjaGF0IHNlc3Npb24uXG4gICAgICogQHJldHVybnMgVGhlIG1vZGVsJ3MgcmVzcG9uc2UuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgY2hhdCA9IGFpLmNoYXRzLmNyZWF0ZSh7bW9kZWw6ICdnZW1pbmktMi4wLWZsYXNoJ30pO1xuICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2hhdC5zZW5kTWVzc2FnZSh7XG4gICAgICogICBtZXNzYWdlOiAnV2h5IGlzIHRoZSBza3kgYmx1ZT8nXG4gICAgICogfSk7XG4gICAgICogY29uc29sZS5sb2cocmVzcG9uc2UudGV4dCk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgc2VuZE1lc3NhZ2UocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgYXdhaXQgdGhpcy5zZW5kUHJvbWlzZTtcbiAgICAgICAgY29uc3QgaW5wdXRDb250ZW50ID0gdENvbnRlbnQocGFyYW1zLm1lc3NhZ2UpO1xuICAgICAgICBjb25zdCByZXNwb25zZVByb21pc2UgPSB0aGlzLm1vZGVsc01vZHVsZS5nZW5lcmF0ZUNvbnRlbnQoe1xuICAgICAgICAgICAgbW9kZWw6IHRoaXMubW9kZWwsXG4gICAgICAgICAgICBjb250ZW50czogdGhpcy5nZXRIaXN0b3J5KHRydWUpLmNvbmNhdChpbnB1dENvbnRlbnQpLFxuICAgICAgICAgICAgY29uZmlnOiAoX2EgPSBwYXJhbXMuY29uZmlnKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLmNvbmZpZyxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2VuZFByb21pc2UgPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlc3BvbnNlUHJvbWlzZTtcbiAgICAgICAgICAgIGNvbnN0IG91dHB1dENvbnRlbnQgPSAoX2IgPSAoX2EgPSByZXNwb25zZS5jYW5kaWRhdGVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbMF0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jb250ZW50O1xuICAgICAgICAgICAgLy8gQmVjYXVzZSB0aGUgQUZDIGlucHV0IGNvbnRhaW5zIHRoZSBlbnRpcmUgY3VyYXRlZCBjaGF0IGhpc3RvcnkgaW5cbiAgICAgICAgICAgIC8vIGFkZGl0aW9uIHRvIHRoZSBuZXcgdXNlciBpbnB1dCwgd2UgbmVlZCB0byB0cnVuY2F0ZSB0aGUgQUZDIGhpc3RvcnlcbiAgICAgICAgICAgIC8vIHRvIGRlZHVwbGljYXRlIHRoZSBleGlzdGluZyBjaGF0IGhpc3RvcnkuXG4gICAgICAgICAgICBjb25zdCBmdWxsQXV0b21hdGljRnVuY3Rpb25DYWxsaW5nSGlzdG9yeSA9IHJlc3BvbnNlLmF1dG9tYXRpY0Z1bmN0aW9uQ2FsbGluZ0hpc3Rvcnk7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuZ2V0SGlzdG9yeSh0cnVlKS5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgYXV0b21hdGljRnVuY3Rpb25DYWxsaW5nSGlzdG9yeSA9IFtdO1xuICAgICAgICAgICAgaWYgKGZ1bGxBdXRvbWF0aWNGdW5jdGlvbkNhbGxpbmdIaXN0b3J5ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBhdXRvbWF0aWNGdW5jdGlvbkNhbGxpbmdIaXN0b3J5ID1cbiAgICAgICAgICAgICAgICAgICAgKF9jID0gZnVsbEF1dG9tYXRpY0Z1bmN0aW9uQ2FsbGluZ0hpc3Rvcnkuc2xpY2UoaW5kZXgpKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG1vZGVsT3V0cHV0ID0gb3V0cHV0Q29udGVudCA/IFtvdXRwdXRDb250ZW50XSA6IFtdO1xuICAgICAgICAgICAgdGhpcy5yZWNvcmRIaXN0b3J5KGlucHV0Q29udGVudCwgbW9kZWxPdXRwdXQsIGF1dG9tYXRpY0Z1bmN0aW9uQ2FsbGluZ0hpc3RvcnkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9KSgpO1xuICAgICAgICBhd2FpdCB0aGlzLnNlbmRQcm9taXNlLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICAgIC8vIFJlc2V0cyBzZW5kUHJvbWlzZSB0byBhdm9pZCBzdWJzZXF1ZW50IGNhbGxzIGZhaWxpbmdcbiAgICAgICAgICAgIHRoaXMuc2VuZFByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXNwb25zZVByb21pc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgbWVzc2FnZSB0byB0aGUgbW9kZWwgYW5kIHJldHVybnMgdGhlIHJlc3BvbnNlIGluIGNodW5rcy5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogVGhpcyBtZXRob2Qgd2lsbCB3YWl0IGZvciB0aGUgcHJldmlvdXMgbWVzc2FnZSB0byBiZSBwcm9jZXNzZWQgYmVmb3JlXG4gICAgICogc2VuZGluZyB0aGUgbmV4dCBtZXNzYWdlLlxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgQ2hhdCNzZW5kTWVzc2FnZX0gZm9yIG5vbi1zdHJlYW1pbmcgbWV0aG9kLlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBwYXJhbWV0ZXJzIGZvciBzZW5kaW5nIHRoZSBtZXNzYWdlLlxuICAgICAqIEByZXR1cm4gVGhlIG1vZGVsJ3MgcmVzcG9uc2UuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgY2hhdCA9IGFpLmNoYXRzLmNyZWF0ZSh7bW9kZWw6ICdnZW1pbmktMi4wLWZsYXNoJ30pO1xuICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2hhdC5zZW5kTWVzc2FnZVN0cmVhbSh7XG4gICAgICogICBtZXNzYWdlOiAnV2h5IGlzIHRoZSBza3kgYmx1ZT8nXG4gICAgICogfSk7XG4gICAgICogZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiByZXNwb25zZSkge1xuICAgICAqICAgY29uc29sZS5sb2coY2h1bmsudGV4dCk7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIHNlbmRNZXNzYWdlU3RyZWFtKHBhcmFtcykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGF3YWl0IHRoaXMuc2VuZFByb21pc2U7XG4gICAgICAgIGNvbnN0IGlucHV0Q29udGVudCA9IHRDb250ZW50KHBhcmFtcy5tZXNzYWdlKTtcbiAgICAgICAgY29uc3Qgc3RyZWFtUmVzcG9uc2UgPSB0aGlzLm1vZGVsc01vZHVsZS5nZW5lcmF0ZUNvbnRlbnRTdHJlYW0oe1xuICAgICAgICAgICAgbW9kZWw6IHRoaXMubW9kZWwsXG4gICAgICAgICAgICBjb250ZW50czogdGhpcy5nZXRIaXN0b3J5KHRydWUpLmNvbmNhdChpbnB1dENvbnRlbnQpLFxuICAgICAgICAgICAgY29uZmlnOiAoX2EgPSBwYXJhbXMuY29uZmlnKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLmNvbmZpZyxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFJlc29sdmUgdGhlIGludGVybmFsIHRyYWNraW5nIG9mIHNlbmQgY29tcGxldGlvbiBwcm9taXNlIC0gYHNlbmRQcm9taXNlYFxuICAgICAgICAvLyBmb3IgYm90aCBzdWNjZXNzIGFuZCBmYWlsdXJlIHJlc3BvbnNlLiBUaGUgYWN0dWFsIGZhaWx1cmUgaXMgc3RpbGxcbiAgICAgICAgLy8gcHJvcGFnYXRlZCBieSB0aGUgYGF3YWl0IHN0cmVhbVJlc3BvbnNlYC5cbiAgICAgICAgdGhpcy5zZW5kUHJvbWlzZSA9IHN0cmVhbVJlc3BvbnNlXG4gICAgICAgICAgICAudGhlbigoKSA9PiB1bmRlZmluZWQpXG4gICAgICAgICAgICAuY2F0Y2goKCkgPT4gdW5kZWZpbmVkKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBzdHJlYW1SZXNwb25zZTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5wcm9jZXNzU3RyZWFtUmVzcG9uc2UocmVzcG9uc2UsIGlucHV0Q29udGVudCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNoYXQgaGlzdG9yeS5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogVGhlIGhpc3RvcnkgaXMgYSBsaXN0IG9mIGNvbnRlbnRzIGFsdGVybmF0aW5nIGJldHdlZW4gdXNlciBhbmQgbW9kZWwuXG4gICAgICpcbiAgICAgKiBUaGVyZSBhcmUgdHdvIHR5cGVzIG9mIGhpc3Rvcnk6XG4gICAgICogLSBUaGUgYGN1cmF0ZWQgaGlzdG9yeWAgY29udGFpbnMgb25seSB0aGUgdmFsaWQgdHVybnMgYmV0d2VlbiB1c2VyIGFuZFxuICAgICAqIG1vZGVsLCB3aGljaCB3aWxsIGJlIGluY2x1ZGVkIGluIHRoZSBzdWJzZXF1ZW50IHJlcXVlc3RzIHNlbnQgdG8gdGhlIG1vZGVsLlxuICAgICAqIC0gVGhlIGBjb21wcmVoZW5zaXZlIGhpc3RvcnlgIGNvbnRhaW5zIGFsbCB0dXJucywgaW5jbHVkaW5nIGludmFsaWQgb3JcbiAgICAgKiAgIGVtcHR5IG1vZGVsIG91dHB1dHMsIHByb3ZpZGluZyBhIGNvbXBsZXRlIHJlY29yZCBvZiB0aGUgaGlzdG9yeS5cbiAgICAgKlxuICAgICAqIFRoZSBoaXN0b3J5IGlzIHVwZGF0ZWQgYWZ0ZXIgcmVjZWl2aW5nIHRoZSByZXNwb25zZSBmcm9tIHRoZSBtb2RlbCxcbiAgICAgKiBmb3Igc3RyZWFtaW5nIHJlc3BvbnNlLCBpdCBtZWFucyByZWNlaXZpbmcgdGhlIGxhc3QgY2h1bmsgb2YgdGhlIHJlc3BvbnNlLlxuICAgICAqXG4gICAgICogVGhlIGBjb21wcmVoZW5zaXZlIGhpc3RvcnlgIGlzIHJldHVybmVkIGJ5IGRlZmF1bHQuIFRvIGdldCB0aGUgYGN1cmF0ZWRcbiAgICAgKiBoaXN0b3J5YCwgc2V0IHRoZSBgY3VyYXRlZGAgcGFyYW1ldGVyIHRvIGB0cnVlYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjdXJhdGVkIC0gd2hldGhlciB0byByZXR1cm4gdGhlIGN1cmF0ZWQgaGlzdG9yeSBvciB0aGUgY29tcHJlaGVuc2l2ZVxuICAgICAqICAgICBoaXN0b3J5LlxuICAgICAqIEByZXR1cm4gSGlzdG9yeSBjb250ZW50cyBhbHRlcm5hdGluZyBiZXR3ZWVuIHVzZXIgYW5kIG1vZGVsIGZvciB0aGUgZW50aXJlXG4gICAgICogICAgIGNoYXQgc2Vzc2lvbi5cbiAgICAgKi9cbiAgICBnZXRIaXN0b3J5KGN1cmF0ZWQgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCBoaXN0b3J5ID0gY3VyYXRlZFxuICAgICAgICAgICAgPyBleHRyYWN0Q3VyYXRlZEhpc3RvcnkodGhpcy5oaXN0b3J5KVxuICAgICAgICAgICAgOiB0aGlzLmhpc3Rvcnk7XG4gICAgICAgIC8vIERlZXAgY29weSB0aGUgaGlzdG9yeSB0byBhdm9pZCBtdXRhdGluZyB0aGUgaGlzdG9yeSBvdXRzaWRlIG9mIHRoZVxuICAgICAgICAvLyBjaGF0IHNlc3Npb24uXG4gICAgICAgIHJldHVybiBzdHJ1Y3R1cmVkQ2xvbmUoaGlzdG9yeSk7XG4gICAgfVxuICAgIHByb2Nlc3NTdHJlYW1SZXNwb25zZShzdHJlYW1SZXNwb25zZSwgaW5wdXRDb250ZW50KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiBfX2FzeW5jR2VuZXJhdG9yKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24qIHByb2Nlc3NTdHJlYW1SZXNwb25zZV8xKCkge1xuICAgICAgICAgICAgdmFyIF9jLCBlXzEsIF9kLCBfZTtcbiAgICAgICAgICAgIGNvbnN0IG91dHB1dENvbnRlbnQgPSBbXTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2YgPSB0cnVlLCBzdHJlYW1SZXNwb25zZV8xID0gX19hc3luY1ZhbHVlcyhzdHJlYW1SZXNwb25zZSksIHN0cmVhbVJlc3BvbnNlXzFfMTsgc3RyZWFtUmVzcG9uc2VfMV8xID0geWllbGQgX19hd2FpdChzdHJlYW1SZXNwb25zZV8xLm5leHQoKSksIF9jID0gc3RyZWFtUmVzcG9uc2VfMV8xLmRvbmUsICFfYzsgX2YgPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIF9lID0gc3RyZWFtUmVzcG9uc2VfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBfZiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaHVuayA9IF9lO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNWYWxpZFJlc3BvbnNlKGNodW5rKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udGVudCA9IChfYiA9IChfYSA9IGNodW5rLmNhbmRpZGF0ZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVswXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0Q29udGVudC5wdXNoKGNvbnRlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHlpZWxkIF9fYXdhaXQoY2h1bmspO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIV9mICYmICFfYyAmJiAoX2QgPSBzdHJlYW1SZXNwb25zZV8xLnJldHVybikpIHlpZWxkIF9fYXdhaXQoX2QuY2FsbChzdHJlYW1SZXNwb25zZV8xKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVjb3JkSGlzdG9yeShpbnB1dENvbnRlbnQsIG91dHB1dENvbnRlbnQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVjb3JkSGlzdG9yeSh1c2VySW5wdXQsIG1vZGVsT3V0cHV0LCBhdXRvbWF0aWNGdW5jdGlvbkNhbGxpbmdIaXN0b3J5KSB7XG4gICAgICAgIGxldCBvdXRwdXRDb250ZW50cyA9IFtdO1xuICAgICAgICBpZiAobW9kZWxPdXRwdXQubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgbW9kZWxPdXRwdXQuZXZlcnkoKGNvbnRlbnQpID0+IGNvbnRlbnQucm9sZSAhPT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgb3V0cHV0Q29udGVudHMgPSBtb2RlbE91dHB1dDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEFwcGVuZHMgYW4gZW1wdHkgY29udGVudCB3aGVuIG1vZGVsIHJldHVybnMgZW1wdHkgcmVzcG9uc2UsIHNvIHRoYXQgdGhlXG4gICAgICAgICAgICAvLyBoaXN0b3J5IGlzIGFsd2F5cyBhbHRlcm5hdGluZyBiZXR3ZWVuIHVzZXIgYW5kIG1vZGVsLlxuICAgICAgICAgICAgb3V0cHV0Q29udGVudHMucHVzaCh7XG4gICAgICAgICAgICAgICAgcm9sZTogJ21vZGVsJyxcbiAgICAgICAgICAgICAgICBwYXJ0czogW10sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXV0b21hdGljRnVuY3Rpb25DYWxsaW5nSGlzdG9yeSAmJlxuICAgICAgICAgICAgYXV0b21hdGljRnVuY3Rpb25DYWxsaW5nSGlzdG9yeS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmhpc3RvcnkucHVzaCguLi5leHRyYWN0Q3VyYXRlZEhpc3RvcnkoYXV0b21hdGljRnVuY3Rpb25DYWxsaW5nSGlzdG9yeSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oaXN0b3J5LnB1c2godXNlcklucHV0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhpc3RvcnkucHVzaCguLi5vdXRwdXRDb250ZW50cyk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG4vKipcbiAqIEFQSSBlcnJvcnMgcmFpc2VkIGJ5IHRoZSBHZW5BSSBBUEkuXG4gKi9cbmNsYXNzIEFwaUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIob3B0aW9ucy5tZXNzYWdlKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0FwaUVycm9yJztcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBvcHRpb25zLnN0YXR1cztcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIEFwaUVycm9yLnByb3RvdHlwZSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG4vLyBDb2RlIGdlbmVyYXRlZCBieSB0aGUgR29vZ2xlIEdlbiBBSSBTREsgZ2VuZXJhdG9yIERPIE5PVCBFRElULlxuZnVuY3Rpb24gbGlzdEZpbGVzQ29uZmlnVG9NbGRldihmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21QYWdlU2l6ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFnZVNpemUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QYWdlU2l6ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAncGFnZVNpemUnXSwgZnJvbVBhZ2VTaXplKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhZ2VUb2tlbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFnZVRva2VuJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGFnZVRva2VuICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdwYWdlVG9rZW4nXSwgZnJvbVBhZ2VUb2tlbik7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RGaWxlc1BhcmFtZXRlcnNUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbmZpZyddLCBsaXN0RmlsZXNDb25maWdUb01sZGV2KGZyb21Db25maWcsIHRvT2JqZWN0KSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZpbGVTdGF0dXNUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21EZXRhaWxzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkZXRhaWxzJ10pO1xuICAgIGlmIChmcm9tRGV0YWlscyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2RldGFpbHMnXSwgZnJvbURldGFpbHMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWVzc2FnZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWVzc2FnZSddKTtcbiAgICBpZiAoZnJvbU1lc3NhZ2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtZXNzYWdlJ10sIGZyb21NZXNzYWdlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvZGUnXSk7XG4gICAgaWYgKGZyb21Db2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29kZSddLCBmcm9tQ29kZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZpbGVUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGlzcGxheU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pO1xuICAgIGlmIChmcm9tRGlzcGxheU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkaXNwbGF5TmFtZSddLCBmcm9tRGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2l6ZUJ5dGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzaXplQnl0ZXMnXSk7XG4gICAgaWYgKGZyb21TaXplQnl0ZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzaXplQnl0ZXMnXSwgZnJvbVNpemVCeXRlcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DcmVhdGVUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjcmVhdGVUaW1lJ10pO1xuICAgIGlmIChmcm9tQ3JlYXRlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NyZWF0ZVRpbWUnXSwgZnJvbUNyZWF0ZVRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXhwaXJhdGlvblRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdleHBpcmF0aW9uVGltZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FeHBpcmF0aW9uVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2V4cGlyYXRpb25UaW1lJ10sIGZyb21FeHBpcmF0aW9uVGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21VcGRhdGVUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd1cGRhdGVUaW1lJ10pO1xuICAgIGlmIChmcm9tVXBkYXRlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VwZGF0ZVRpbWUnXSwgZnJvbVVwZGF0ZVRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2hhMjU2SGFzaCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc2hhMjU2SGFzaCddKTtcbiAgICBpZiAoZnJvbVNoYTI1Nkhhc2ggIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzaGEyNTZIYXNoJ10sIGZyb21TaGEyNTZIYXNoKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndXJpJ10pO1xuICAgIGlmIChmcm9tVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXJpJ10sIGZyb21VcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRG93bmxvYWRVcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rvd25sb2FkVXJpJ10pO1xuICAgIGlmIChmcm9tRG93bmxvYWRVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkb3dubG9hZFVyaSddLCBmcm9tRG93bmxvYWRVcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3RhdGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3N0YXRlJ10pO1xuICAgIGlmIChmcm9tU3RhdGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdGF0ZSddLCBmcm9tU3RhdGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU291cmNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzb3VyY2UnXSk7XG4gICAgaWYgKGZyb21Tb3VyY2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzb3VyY2UnXSwgZnJvbVNvdXJjZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21WaWRlb01ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndmlkZW9NZXRhZGF0YScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21WaWRlb01ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndmlkZW9NZXRhZGF0YSddLCBmcm9tVmlkZW9NZXRhZGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FcnJvciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXJyb3InXSk7XG4gICAgaWYgKGZyb21FcnJvciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Vycm9yJ10sIGZpbGVTdGF0dXNUb01sZGV2KGZyb21FcnJvcikpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjcmVhdGVGaWxlUGFyYW1ldGVyc1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZpbGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGUnXSk7XG4gICAgaWYgKGZyb21GaWxlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmlsZSddLCBmaWxlVG9NbGRldihmcm9tRmlsZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb25maWcnXSwgZnJvbUNvbmZpZyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdldEZpbGVQYXJhbWV0ZXJzVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ2ZpbGUnXSwgdEZpbGVOYW1lKGZyb21OYW1lKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbmZpZyddLCBmcm9tQ29uZmlnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZGVsZXRlRmlsZVBhcmFtZXRlcnNUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnZmlsZSddLCB0RmlsZU5hbWUoZnJvbU5hbWUpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29uZmlnJ10sIGZyb21Db25maWcpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBmaWxlU3RhdHVzRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21EZXRhaWxzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkZXRhaWxzJ10pO1xuICAgIGlmIChmcm9tRGV0YWlscyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2RldGFpbHMnXSwgZnJvbURldGFpbHMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWVzc2FnZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWVzc2FnZSddKTtcbiAgICBpZiAoZnJvbU1lc3NhZ2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtZXNzYWdlJ10sIGZyb21NZXNzYWdlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvZGUnXSk7XG4gICAgaWYgKGZyb21Db2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29kZSddLCBmcm9tQ29kZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZpbGVGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EaXNwbGF5TmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSk7XG4gICAgaWYgKGZyb21EaXNwbGF5TmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10sIGZyb21EaXNwbGF5TmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TaXplQnl0ZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NpemVCeXRlcyddKTtcbiAgICBpZiAoZnJvbVNpemVCeXRlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NpemVCeXRlcyddLCBmcm9tU2l6ZUJ5dGVzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNyZWF0ZVRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NyZWF0ZVRpbWUnXSk7XG4gICAgaWYgKGZyb21DcmVhdGVUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY3JlYXRlVGltZSddLCBmcm9tQ3JlYXRlVGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FeHBpcmF0aW9uVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2V4cGlyYXRpb25UaW1lJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUV4cGlyYXRpb25UaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXhwaXJhdGlvblRpbWUnXSwgZnJvbUV4cGlyYXRpb25UaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVwZGF0ZVRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3VwZGF0ZVRpbWUnXSk7XG4gICAgaWYgKGZyb21VcGRhdGVUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXBkYXRlVGltZSddLCBmcm9tVXBkYXRlVGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TaGEyNTZIYXNoID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzaGEyNTZIYXNoJ10pO1xuICAgIGlmIChmcm9tU2hhMjU2SGFzaCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NoYTI1Nkhhc2gnXSwgZnJvbVNoYTI1Nkhhc2gpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd1cmknXSk7XG4gICAgaWYgKGZyb21VcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1cmknXSwgZnJvbVVyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Eb3dubG9hZFVyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZG93bmxvYWRVcmknXSk7XG4gICAgaWYgKGZyb21Eb3dubG9hZFVyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Rvd25sb2FkVXJpJ10sIGZyb21Eb3dubG9hZFVyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TdGF0ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3RhdGUnXSk7XG4gICAgaWYgKGZyb21TdGF0ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0YXRlJ10sIGZyb21TdGF0ZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Tb3VyY2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NvdXJjZSddKTtcbiAgICBpZiAoZnJvbVNvdXJjZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NvdXJjZSddLCBmcm9tU291cmNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVZpZGVvTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd2aWRlb01ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVZpZGVvTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2aWRlb01ldGFkYXRhJ10sIGZyb21WaWRlb01ldGFkYXRhKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVycm9yID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlcnJvciddKTtcbiAgICBpZiAoZnJvbUVycm9yICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXJyb3InXSwgZmlsZVN0YXR1c0Zyb21NbGRldihmcm9tRXJyb3IpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdEZpbGVzUmVzcG9uc2VGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5leHRQYWdlVG9rZW4gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICduZXh0UGFnZVRva2VuJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU5leHRQYWdlVG9rZW4gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduZXh0UGFnZVRva2VuJ10sIGZyb21OZXh0UGFnZVRva2VuKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlcyddKTtcbiAgICBpZiAoZnJvbUZpbGVzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21GaWxlcztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaWxlRnJvbU1sZGV2KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmlsZXMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY3JlYXRlRmlsZVJlc3BvbnNlRnJvbU1sZGV2KCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZGVsZXRlRmlsZVJlc3BvbnNlRnJvbU1sZGV2KCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5jbGFzcyBGaWxlcyBleHRlbmRzIEJhc2VNb2R1bGUge1xuICAgIGNvbnN0cnVjdG9yKGFwaUNsaWVudCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmFwaUNsaWVudCA9IGFwaUNsaWVudDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3RzIGFsbCBjdXJyZW50IHByb2plY3QgZmlsZXMgZnJvbSB0aGUgc2VydmljZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgbGlzdCByZXF1ZXN0XG4gICAgICAgICAqIEByZXR1cm4gVGhlIHBhZ2luYXRlZCByZXN1bHRzIG9mIHRoZSBsaXN0IG9mIGZpbGVzXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIFRoZSBmb2xsb3dpbmcgY29kZSBwcmludHMgdGhlIG5hbWVzIG9mIGFsbCBmaWxlcyBmcm9tIHRoZSBzZXJ2aWNlLCB0aGVcbiAgICAgICAgICogc2l6ZSBvZiBlYWNoIHBhZ2UgaXMgMTAuXG4gICAgICAgICAqXG4gICAgICAgICAqIGBgYHRzXG4gICAgICAgICAqIGNvbnN0IGxpc3RSZXNwb25zZSA9IGF3YWl0IGFpLmZpbGVzLmxpc3Qoe2NvbmZpZzogeydwYWdlU2l6ZSc6IDEwfX0pO1xuICAgICAgICAgKiBmb3IgYXdhaXQgKGNvbnN0IGZpbGUgb2YgbGlzdFJlc3BvbnNlKSB7XG4gICAgICAgICAqICAgY29uc29sZS5sb2coZmlsZS5uYW1lKTtcbiAgICAgICAgICogfVxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGlzdCA9IGFzeW5jIChwYXJhbXMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQYWdlcihQYWdlZEl0ZW0uUEFHRURfSVRFTV9GSUxFUywgKHgpID0+IHRoaXMubGlzdEludGVybmFsKHgpLCBhd2FpdCB0aGlzLmxpc3RJbnRlcm5hbChwYXJhbXMpLCBwYXJhbXMpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGxvYWRzIGEgZmlsZSBhc3luY2hyb25vdXNseSB0byB0aGUgR2VtaW5pIEFQSS5cbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBub3QgYXZhaWxhYmxlIGluIFZlcnRleCBBSS5cbiAgICAgKiBTdXBwb3J0ZWQgdXBsb2FkIHNvdXJjZXM6XG4gICAgICogLSBOb2RlLmpzOiBGaWxlIHBhdGggKHN0cmluZykgb3IgQmxvYiBvYmplY3QuXG4gICAgICogLSBCcm93c2VyOiBCbG9iIG9iamVjdCAoZS5nLiwgRmlsZSkuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFRoZSBgbWltZVR5cGVgIGNhbiBiZSBzcGVjaWZpZWQgaW4gdGhlIGBjb25maWdgIHBhcmFtZXRlci4gSWYgb21pdHRlZDpcbiAgICAgKiAgLSBGb3IgZmlsZSBwYXRoIChzdHJpbmcpIGlucHV0cywgdGhlIGBtaW1lVHlwZWAgd2lsbCBiZSBpbmZlcnJlZCBmcm9tIHRoZVxuICAgICAqICAgICBmaWxlIGV4dGVuc2lvbi5cbiAgICAgKiAgLSBGb3IgQmxvYiBvYmplY3QgaW5wdXRzLCB0aGUgYG1pbWVUeXBlYCB3aWxsIGJlIHNldCB0byB0aGUgQmxvYidzIGB0eXBlYFxuICAgICAqICAgICBwcm9wZXJ0eS5cbiAgICAgKiBTb21leCBlYW1wbGVzIGZvciBmaWxlIGV4dGVuc2lvbiB0byBtaW1lVHlwZSBtYXBwaW5nOlxuICAgICAqIC50eHQgLT4gdGV4dC9wbGFpblxuICAgICAqIC5qc29uIC0+IGFwcGxpY2F0aW9uL2pzb25cbiAgICAgKiAuanBnICAtPiBpbWFnZS9qcGVnXG4gICAgICogLnBuZyAtPiBpbWFnZS9wbmdcbiAgICAgKiAubXAzIC0+IGF1ZGlvL21wZWdcbiAgICAgKiAubXA0IC0+IHZpZGVvL21wNFxuICAgICAqXG4gICAgICogVGhpcyBzZWN0aW9uIGNhbiBjb250YWluIG11bHRpcGxlIHBhcmFncmFwaHMgYW5kIGNvZGUgZXhhbXBsZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gT3B0aW9uYWwgcGFyYW1ldGVycyBzcGVjaWZpZWQgaW4gdGhlXG4gICAgICogICAgICAgIGB0eXBlcy5VcGxvYWRGaWxlUGFyYW1ldGVyc2AgaW50ZXJmYWNlLlxuICAgICAqICAgICAgICAgQHNlZSB7QGxpbmsgdHlwZXMuVXBsb2FkRmlsZVBhcmFtZXRlcnMjY29uZmlnfSBmb3IgdGhlIG9wdGlvbmFsXG4gICAgICogICAgICAgICBjb25maWcgaW4gdGhlIHBhcmFtZXRlcnMuXG4gICAgICogQHJldHVybiBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGB0eXBlcy5GaWxlYCBvYmplY3QuXG4gICAgICogQHRocm93cyBBbiBlcnJvciBpZiBjYWxsZWQgb24gYSBWZXJ0ZXggQUkgY2xpZW50LlxuICAgICAqIEB0aHJvd3MgQW4gZXJyb3IgaWYgdGhlIGBtaW1lVHlwZWAgaXMgbm90IHByb3ZpZGVkIGFuZCBjYW4gbm90IGJlIGluZmVycmVkLFxuICAgICAqIHRoZSBgbWltZVR5cGVgIGNhbiBiZSBwcm92aWRlZCBpbiB0aGUgYHBhcmFtcy5jb25maWdgIHBhcmFtZXRlci5cbiAgICAgKiBAdGhyb3dzIEFuIGVycm9yIG9jY3VycyBpZiBhIHN1aXRhYmxlIHVwbG9hZCBsb2NhdGlvbiBjYW5ub3QgYmUgZXN0YWJsaXNoZWQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIFRoZSBmb2xsb3dpbmcgY29kZSB1cGxvYWRzIGEgZmlsZSB0byBHZW1pbmkgQVBJLlxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCBmaWxlID0gYXdhaXQgYWkuZmlsZXMudXBsb2FkKHtmaWxlOiAnZmlsZS50eHQnLCBjb25maWc6IHtcbiAgICAgKiAgIG1pbWVUeXBlOiAndGV4dC9wbGFpbicsXG4gICAgICogfX0pO1xuICAgICAqIGNvbnNvbGUubG9nKGZpbGUubmFtZSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgdXBsb2FkKHBhcmFtcykge1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZlcnRleCBBSSBkb2VzIG5vdCBzdXBwb3J0IHVwbG9hZGluZyBmaWxlcy4gWW91IGNhbiBzaGFyZSBmaWxlcyB0aHJvdWdoIGEgR0NTIGJ1Y2tldC4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgIC51cGxvYWRGaWxlKHBhcmFtcy5maWxlLCBwYXJhbXMuY29uZmlnKVxuICAgICAgICAgICAgLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmaWxlID0gZmlsZUZyb21NbGRldihyZXNwb25zZSk7XG4gICAgICAgICAgICByZXR1cm4gZmlsZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERvd25sb2FkcyBhIHJlbW90ZWx5IHN0b3JlZCBmaWxlIGFzeW5jaHJvbm91c2x5IHRvIGEgbG9jYXRpb24gc3BlY2lmaWVkIGluXG4gICAgICogdGhlIGBwYXJhbXNgIG9iamVjdC4gVGhpcyBtZXRob2Qgb25seSB3b3JrcyBvbiBOb2RlIGVudmlyb25tZW50LCB0b1xuICAgICAqIGRvd25sb2FkIGZpbGVzIGluIHRoZSBicm93c2VyLCB1c2UgYSBicm93c2VyIGNvbXBsaWFudCBtZXRob2QgbGlrZSBhbiA8YT5cbiAgICAgKiB0YWcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoZSBkb3dubG9hZCByZXF1ZXN0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBUaGUgZm9sbG93aW5nIGNvZGUgZG93bmxvYWRzIGFuIGV4YW1wbGUgZmlsZSBuYW1lZCBcImZpbGVzL21laG96cHhmODc3ZFwiIGFzXG4gICAgICogXCJmaWxlLnR4dFwiLlxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKiBhd2FpdCBhaS5maWxlcy5kb3dubG9hZCh7ZmlsZTogZmlsZS5uYW1lLCBkb3dubG9hZFBhdGg6ICdmaWxlLnR4dCd9KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBkb3dubG9hZChwYXJhbXMpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5hcGlDbGllbnQuZG93bmxvYWRGaWxlKHBhcmFtcyk7XG4gICAgfVxuICAgIGFzeW5jIGxpc3RJbnRlcm5hbChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBpcyBvbmx5IHN1cHBvcnRlZCBieSB0aGUgR2VtaW5pIERldmVsb3BlciBBUEkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gbGlzdEZpbGVzUGFyYW1ldGVyc1RvTWxkZXYocGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ2ZpbGVzJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnY29uZmlnJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGxpc3RGaWxlc1Jlc3BvbnNlRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgTGlzdEZpbGVzUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGNyZWF0ZUludGVybmFsKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIG9ubHkgc3VwcG9ydGVkIGJ5IHRoZSBHZW1pbmkgRGV2ZWxvcGVyIEFQSS4nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBjcmVhdGVGaWxlUGFyYW1ldGVyc1RvTWxkZXYocGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3VwbG9hZC92MWJldGEvZmlsZXMnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5Wydjb25maWcnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBjcmVhdGVGaWxlUmVzcG9uc2VGcm9tTWxkZXYoKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgQ3JlYXRlRmlsZVJlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGZpbGUgaW5mb3JtYXRpb24gZnJvbSB0aGUgc2VydmljZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhlIGdldCByZXF1ZXN0XG4gICAgICogQHJldHVybiBUaGUgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSB0eXBlcy5GaWxlIG9iamVjdCByZXF1ZXN0ZWQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgY29uZmlnOiBHZXRGaWxlUGFyYW1ldGVycyA9IHtcbiAgICAgKiAgIG5hbWU6IGZpbGVOYW1lLFxuICAgICAqIH07XG4gICAgICogZmlsZSA9IGF3YWl0IGFpLmZpbGVzLmdldChjb25maWcpO1xuICAgICAqIGNvbnNvbGUubG9nKGZpbGUubmFtZSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgZ2V0KHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIG9ubHkgc3VwcG9ydGVkIGJ5IHRoZSBHZW1pbmkgRGV2ZWxvcGVyIEFQSS4nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBnZXRGaWxlUGFyYW1ldGVyc1RvTWxkZXYocGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ2ZpbGVzL3tmaWxlfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ2NvbmZpZyddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBmaWxlRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgYSByZW1vdGVseSBzdG9yZWQgZmlsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhlIGRlbGV0ZSByZXF1ZXN0LlxuICAgICAqIEByZXR1cm4gVGhlIERlbGV0ZUZpbGVSZXNwb25zZSwgdGhlIHJlc3BvbnNlIGZvciB0aGUgZGVsZXRlIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogVGhlIGZvbGxvd2luZyBjb2RlIGRlbGV0ZXMgYW4gZXhhbXBsZSBmaWxlIG5hbWVkIFwiZmlsZXMvbWVob3pweGY4NzdkXCIuXG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAqIGF3YWl0IGFpLmZpbGVzLmRlbGV0ZSh7bmFtZTogZmlsZS5uYW1lfSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgZGVsZXRlKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIG9ubHkgc3VwcG9ydGVkIGJ5IHRoZSBHZW1pbmkgRGV2ZWxvcGVyIEFQSS4nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBkZWxldGVGaWxlUGFyYW1ldGVyc1RvTWxkZXYocGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ2ZpbGVzL3tmaWxlfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ2NvbmZpZyddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0RFTEVURScsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gZGVsZXRlRmlsZVJlc3BvbnNlRnJvbU1sZGV2KCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IERlbGV0ZUZpbGVSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmZ1bmN0aW9uIHByZWJ1aWx0Vm9pY2VDb25maWdUb01sZGV2JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVZvaWNlTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndm9pY2VOYW1lJ10pO1xuICAgIGlmIChmcm9tVm9pY2VOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndm9pY2VOYW1lJ10sIGZyb21Wb2ljZU5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBwcmVidWlsdFZvaWNlQ29uZmlnVG9WZXJ0ZXgkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVm9pY2VOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd2b2ljZU5hbWUnXSk7XG4gICAgaWYgKGZyb21Wb2ljZU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2b2ljZU5hbWUnXSwgZnJvbVZvaWNlTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHZvaWNlQ29uZmlnVG9NbGRldiQyKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21QcmVidWlsdFZvaWNlQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJlYnVpbHRWb2ljZUNvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21QcmVidWlsdFZvaWNlQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncHJlYnVpbHRWb2ljZUNvbmZpZyddLCBwcmVidWlsdFZvaWNlQ29uZmlnVG9NbGRldiQyKGZyb21QcmVidWlsdFZvaWNlQ29uZmlnKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHZvaWNlQ29uZmlnVG9WZXJ0ZXgkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUHJlYnVpbHRWb2ljZUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ByZWJ1aWx0Vm9pY2VDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUHJlYnVpbHRWb2ljZUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ByZWJ1aWx0Vm9pY2VDb25maWcnXSwgcHJlYnVpbHRWb2ljZUNvbmZpZ1RvVmVydGV4JDEoZnJvbVByZWJ1aWx0Vm9pY2VDb25maWcpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gc3BlYWtlclZvaWNlQ29uZmlnVG9NbGRldiQyKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TcGVha2VyID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzcGVha2VyJ10pO1xuICAgIGlmIChmcm9tU3BlYWtlciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NwZWFrZXInXSwgZnJvbVNwZWFrZXIpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVm9pY2VDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZvaWNlQ29uZmlnJ10pO1xuICAgIGlmIChmcm9tVm9pY2VDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2b2ljZUNvbmZpZyddLCB2b2ljZUNvbmZpZ1RvTWxkZXYkMihmcm9tVm9pY2VDb25maWcpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbXVsdGlTcGVha2VyVm9pY2VDb25maWdUb01sZGV2JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNwZWFrZXJWb2ljZUNvbmZpZ3MgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzcGVha2VyVm9pY2VDb25maWdzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNwZWFrZXJWb2ljZUNvbmZpZ3MgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVNwZWFrZXJWb2ljZUNvbmZpZ3M7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3BlYWtlclZvaWNlQ29uZmlnVG9NbGRldiQyKGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3BlYWtlclZvaWNlQ29uZmlncyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBzcGVlY2hDb25maWdUb01sZGV2JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVZvaWNlQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd2b2ljZUNvbmZpZyddKTtcbiAgICBpZiAoZnJvbVZvaWNlQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndm9pY2VDb25maWcnXSwgdm9pY2VDb25maWdUb01sZGV2JDIoZnJvbVZvaWNlQ29uZmlnKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NdWx0aVNwZWFrZXJWb2ljZUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ211bHRpU3BlYWtlclZvaWNlQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU11bHRpU3BlYWtlclZvaWNlQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbXVsdGlTcGVha2VyVm9pY2VDb25maWcnXSwgbXVsdGlTcGVha2VyVm9pY2VDb25maWdUb01sZGV2JDIoZnJvbU11bHRpU3BlYWtlclZvaWNlQ29uZmlnKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21MYW5ndWFnZUNvZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhbmd1YWdlQ29kZSddKTtcbiAgICBpZiAoZnJvbUxhbmd1YWdlQ29kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2xhbmd1YWdlQ29kZSddLCBmcm9tTGFuZ3VhZ2VDb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gc3BlZWNoQ29uZmlnVG9WZXJ0ZXgkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVm9pY2VDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZvaWNlQ29uZmlnJ10pO1xuICAgIGlmIChmcm9tVm9pY2VDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2b2ljZUNvbmZpZyddLCB2b2ljZUNvbmZpZ1RvVmVydGV4JDEoZnJvbVZvaWNlQ29uZmlnKSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ211bHRpU3BlYWtlclZvaWNlQ29uZmlnJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtdWx0aVNwZWFrZXJWb2ljZUNvbmZpZyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBWZXJ0ZXggQUkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21MYW5ndWFnZUNvZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhbmd1YWdlQ29kZSddKTtcbiAgICBpZiAoZnJvbUxhbmd1YWdlQ29kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2xhbmd1YWdlQ29kZSddLCBmcm9tTGFuZ3VhZ2VDb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdmlkZW9NZXRhZGF0YVRvTWxkZXYkMihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRnBzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmcHMnXSk7XG4gICAgaWYgKGZyb21GcHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmcHMnXSwgZnJvbUZwcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmRPZmZzZXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VuZE9mZnNldCddKTtcbiAgICBpZiAoZnJvbUVuZE9mZnNldCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VuZE9mZnNldCddLCBmcm9tRW5kT2Zmc2V0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN0YXJ0T2Zmc2V0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzdGFydE9mZnNldCddKTtcbiAgICBpZiAoZnJvbVN0YXJ0T2Zmc2V0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3RhcnRPZmZzZXQnXSwgZnJvbVN0YXJ0T2Zmc2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdmlkZW9NZXRhZGF0YVRvVmVydGV4JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZwcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZnBzJ10pO1xuICAgIGlmIChmcm9tRnBzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnBzJ10sIGZyb21GcHMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5kT2Zmc2V0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbmRPZmZzZXQnXSk7XG4gICAgaWYgKGZyb21FbmRPZmZzZXQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmRPZmZzZXQnXSwgZnJvbUVuZE9mZnNldCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TdGFydE9mZnNldCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3RhcnRPZmZzZXQnXSk7XG4gICAgaWYgKGZyb21TdGFydE9mZnNldCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0YXJ0T2Zmc2V0J10sIGZyb21TdGFydE9mZnNldCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGJsb2JUb01sZGV2JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Rpc3BsYXlOYW1lIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkYXRhJ10pO1xuICAgIGlmIChmcm9tRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2RhdGEnXSwgZnJvbURhdGEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBibG9iVG9WZXJ0ZXgkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRGlzcGxheU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pO1xuICAgIGlmIChmcm9tRGlzcGxheU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkaXNwbGF5TmFtZSddLCBmcm9tRGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGF0YSddKTtcbiAgICBpZiAoZnJvbURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkYXRhJ10sIGZyb21EYXRhKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZmlsZURhdGFUb01sZGV2JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Rpc3BsYXlOYW1lIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWxlVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlVXJpJ10pO1xuICAgIGlmIChmcm9tRmlsZVVyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVVcmknXSwgZnJvbUZpbGVVcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBmaWxlRGF0YVRvVmVydGV4JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbURpc3BsYXlOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKTtcbiAgICBpZiAoZnJvbURpc3BsYXlOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGlzcGxheU5hbWUnXSwgZnJvbURpc3BsYXlOYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbGVVcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVVcmknXSk7XG4gICAgaWYgKGZyb21GaWxlVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmlsZVVyaSddLCBmcm9tRmlsZVVyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHBhcnRUb01sZGV2JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVZpZGVvTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd2aWRlb01ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVZpZGVvTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2aWRlb01ldGFkYXRhJ10sIHZpZGVvTWV0YWRhdGFUb01sZGV2JDIoZnJvbVZpZGVvTWV0YWRhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRob3VnaHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rob3VnaHQnXSk7XG4gICAgaWYgKGZyb21UaG91Z2h0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhvdWdodCddLCBmcm9tVGhvdWdodCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbmxpbmVEYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbmxpbmVEYXRhJ10pO1xuICAgIGlmIChmcm9tSW5saW5lRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2lubGluZURhdGEnXSwgYmxvYlRvTWxkZXYkMihmcm9tSW5saW5lRGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsZURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVEYXRhJ10pO1xuICAgIGlmIChmcm9tRmlsZURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWxlRGF0YSddLCBmaWxlRGF0YVRvTWxkZXYkMihmcm9tRmlsZURhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRob3VnaHRTaWduYXR1cmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0aG91Z2h0U2lnbmF0dXJlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRob3VnaHRTaWduYXR1cmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aG91Z2h0U2lnbmF0dXJlJ10sIGZyb21UaG91Z2h0U2lnbmF0dXJlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjb2RlRXhlY3V0aW9uUmVzdWx0JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb2RlRXhlY3V0aW9uUmVzdWx0J10sIGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUV4ZWN1dGFibGVDb2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZXhlY3V0YWJsZUNvZGUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRXhlY3V0YWJsZUNvZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydleGVjdXRhYmxlQ29kZSddLCBmcm9tRXhlY3V0YWJsZUNvZGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnVuY3Rpb25DYWxsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmdW5jdGlvbkNhbGwnXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvbkNhbGwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvbkNhbGwnXSwgZnJvbUZ1bmN0aW9uQ2FsbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GdW5jdGlvblJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZnVuY3Rpb25SZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvblJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25SZXNwb25zZSddLCBmcm9tRnVuY3Rpb25SZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UZXh0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0ZXh0J10pO1xuICAgIGlmIChmcm9tVGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RleHQnXSwgZnJvbVRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBwYXJ0VG9WZXJ0ZXgkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVmlkZW9NZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ZpZGVvTWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVmlkZW9NZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZpZGVvTWV0YWRhdGEnXSwgdmlkZW9NZXRhZGF0YVRvVmVydGV4JDEoZnJvbVZpZGVvTWV0YWRhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRob3VnaHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rob3VnaHQnXSk7XG4gICAgaWYgKGZyb21UaG91Z2h0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhvdWdodCddLCBmcm9tVGhvdWdodCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbmxpbmVEYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbmxpbmVEYXRhJ10pO1xuICAgIGlmIChmcm9tSW5saW5lRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2lubGluZURhdGEnXSwgYmxvYlRvVmVydGV4JDEoZnJvbUlubGluZURhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbGVEYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlRGF0YSddKTtcbiAgICBpZiAoZnJvbUZpbGVEYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmlsZURhdGEnXSwgZmlsZURhdGFUb1ZlcnRleCQxKGZyb21GaWxlRGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhvdWdodFNpZ25hdHVyZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Rob3VnaHRTaWduYXR1cmUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVGhvdWdodFNpZ25hdHVyZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rob3VnaHRTaWduYXR1cmUnXSwgZnJvbVRob3VnaHRTaWduYXR1cmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NvZGVFeGVjdXRpb25SZXN1bHQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvZGVFeGVjdXRpb25SZXN1bHQnXSwgZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXhlY3V0YWJsZUNvZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdleGVjdXRhYmxlQ29kZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FeGVjdXRhYmxlQ29kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2V4ZWN1dGFibGVDb2RlJ10sIGZyb21FeGVjdXRhYmxlQ29kZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GdW5jdGlvbkNhbGwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Z1bmN0aW9uQ2FsbCddKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uQ2FsbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uQ2FsbCddLCBmcm9tRnVuY3Rpb25DYWxsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvblJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvblJlc3BvbnNlJ10sIGZyb21GdW5jdGlvblJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRleHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RleHQnXSk7XG4gICAgaWYgKGZyb21UZXh0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGV4dCddLCBmcm9tVGV4dCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNvbnRlbnRUb01sZGV2JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVBhcnRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYXJ0cyddKTtcbiAgICBpZiAoZnJvbVBhcnRzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21QYXJ0cztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0VG9NbGRldiQyKGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncGFydHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJvbGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3JvbGUnXSk7XG4gICAgaWYgKGZyb21Sb2xlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncm9sZSddLCBmcm9tUm9sZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNvbnRlbnRUb1ZlcnRleCQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21QYXJ0cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFydHMnXSk7XG4gICAgaWYgKGZyb21QYXJ0cyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tUGFydHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFydFRvVmVydGV4JDEoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJ0cyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUm9sZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncm9sZSddKTtcbiAgICBpZiAoZnJvbVJvbGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyb2xlJ10sIGZyb21Sb2xlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZnVuY3Rpb25EZWNsYXJhdGlvblRvTWxkZXYkMihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQmVoYXZpb3IgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2JlaGF2aW9yJ10pO1xuICAgIGlmIChmcm9tQmVoYXZpb3IgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydiZWhhdmlvciddLCBmcm9tQmVoYXZpb3IpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGVzY3JpcHRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10pO1xuICAgIGlmIChmcm9tRGVzY3JpcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkZXNjcmlwdGlvbiddLCBmcm9tRGVzY3JpcHRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhcmFtZXRlcnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhcmFtZXRlcnMnXSk7XG4gICAgaWYgKGZyb21QYXJhbWV0ZXJzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncGFyYW1ldGVycyddLCBmcm9tUGFyYW1ldGVycyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QYXJhbWV0ZXJzSnNvblNjaGVtYSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3BhcmFtZXRlcnNKc29uU2NoZW1hJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVBhcmFtZXRlcnNKc29uU2NoZW1hICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncGFyYW1ldGVyc0pzb25TY2hlbWEnXSwgZnJvbVBhcmFtZXRlcnNKc29uU2NoZW1hKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXNwb25zZSddKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2UnXSwgZnJvbVJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlSnNvblNjaGVtYSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlSnNvblNjaGVtYScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZUpzb25TY2hlbWEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZUpzb25TY2hlbWEnXSwgZnJvbVJlc3BvbnNlSnNvblNjaGVtYSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZ1bmN0aW9uRGVjbGFyYXRpb25Ub1ZlcnRleCQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2JlaGF2aW9yJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiZWhhdmlvciBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBWZXJ0ZXggQUkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EZXNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGVzY3JpcHRpb24nXSk7XG4gICAgaWYgKGZyb21EZXNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10sIGZyb21EZXNjcmlwdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGFyYW1ldGVycyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFyYW1ldGVycyddKTtcbiAgICBpZiAoZnJvbVBhcmFtZXRlcnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJhbWV0ZXJzJ10sIGZyb21QYXJhbWV0ZXJzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhcmFtZXRlcnNKc29uU2NoZW1hID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncGFyYW1ldGVyc0pzb25TY2hlbWEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUGFyYW1ldGVyc0pzb25TY2hlbWEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJhbWV0ZXJzSnNvblNjaGVtYSddLCBmcm9tUGFyYW1ldGVyc0pzb25TY2hlbWEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Jlc3BvbnNlJ10pO1xuICAgIGlmIChmcm9tUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZSddLCBmcm9tUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VKc29uU2NoZW1hID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VKc29uU2NoZW1hJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlSnNvblNjaGVtYSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlSnNvblNjaGVtYSddLCBmcm9tUmVzcG9uc2VKc29uU2NoZW1hKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gaW50ZXJ2YWxUb01sZGV2JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVN0YXJ0VGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3RhcnRUaW1lJ10pO1xuICAgIGlmIChmcm9tU3RhcnRUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3RhcnRUaW1lJ10sIGZyb21TdGFydFRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5kVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW5kVGltZSddKTtcbiAgICBpZiAoZnJvbUVuZFRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmRUaW1lJ10sIGZyb21FbmRUaW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gaW50ZXJ2YWxUb1ZlcnRleCQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TdGFydFRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3N0YXJ0VGltZSddKTtcbiAgICBpZiAoZnJvbVN0YXJ0VGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0YXJ0VGltZSddLCBmcm9tU3RhcnRUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuZFRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VuZFRpbWUnXSk7XG4gICAgaWYgKGZyb21FbmRUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW5kVGltZSddLCBmcm9tRW5kVGltZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdvb2dsZVNlYXJjaFRvTWxkZXYkMihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVGltZVJhbmdlRmlsdGVyID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndGltZVJhbmdlRmlsdGVyJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRpbWVSYW5nZUZpbHRlciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RpbWVSYW5nZUZpbHRlciddLCBpbnRlcnZhbFRvTWxkZXYkMihmcm9tVGltZVJhbmdlRmlsdGVyKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdvb2dsZVNlYXJjaFRvVmVydGV4JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVRpbWVSYW5nZUZpbHRlciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3RpbWVSYW5nZUZpbHRlcicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UaW1lUmFuZ2VGaWx0ZXIgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aW1lUmFuZ2VGaWx0ZXInXSwgaW50ZXJ2YWxUb1ZlcnRleCQxKGZyb21UaW1lUmFuZ2VGaWx0ZXIpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZHluYW1pY1JldHJpZXZhbENvbmZpZ1RvTWxkZXYkMihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZSddKTtcbiAgICBpZiAoZnJvbU1vZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RlJ10sIGZyb21Nb2RlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUR5bmFtaWNUaHJlc2hvbGQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdkeW5hbWljVGhyZXNob2xkJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUR5bmFtaWNUaHJlc2hvbGQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkeW5hbWljVGhyZXNob2xkJ10sIGZyb21EeW5hbWljVGhyZXNob2xkKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZHluYW1pY1JldHJpZXZhbENvbmZpZ1RvVmVydGV4JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGUnXSk7XG4gICAgaWYgKGZyb21Nb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZSddLCBmcm9tTW9kZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EeW5hbWljVGhyZXNob2xkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZHluYW1pY1RocmVzaG9sZCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21EeW5hbWljVGhyZXNob2xkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZHluYW1pY1RocmVzaG9sZCddLCBmcm9tRHluYW1pY1RocmVzaG9sZCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdvb2dsZVNlYXJjaFJldHJpZXZhbFRvTWxkZXYkMihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRHluYW1pY1JldHJpZXZhbENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2R5bmFtaWNSZXRyaWV2YWxDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRHluYW1pY1JldHJpZXZhbENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2R5bmFtaWNSZXRyaWV2YWxDb25maWcnXSwgZHluYW1pY1JldHJpZXZhbENvbmZpZ1RvTWxkZXYkMihmcm9tRHluYW1pY1JldHJpZXZhbENvbmZpZykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnb29nbGVTZWFyY2hSZXRyaWV2YWxUb1ZlcnRleCQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21EeW5hbWljUmV0cmlldmFsQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZHluYW1pY1JldHJpZXZhbENvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21EeW5hbWljUmV0cmlldmFsQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZHluYW1pY1JldHJpZXZhbENvbmZpZyddLCBkeW5hbWljUmV0cmlldmFsQ29uZmlnVG9WZXJ0ZXgkMShmcm9tRHluYW1pY1JldHJpZXZhbENvbmZpZykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBlbnRlcnByaXNlV2ViU2VhcmNoVG9WZXJ0ZXgkMSgpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGFwaUtleUNvbmZpZ1RvVmVydGV4JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUFwaUtleVN0cmluZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXBpS2V5U3RyaW5nJ10pO1xuICAgIGlmIChmcm9tQXBpS2V5U3RyaW5nICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYXBpS2V5U3RyaW5nJ10sIGZyb21BcGlLZXlTdHJpbmcpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBhdXRoQ29uZmlnVG9WZXJ0ZXgkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQXBpS2V5Q29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhcGlLZXlDb25maWcnXSk7XG4gICAgaWYgKGZyb21BcGlLZXlDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhcGlLZXlDb25maWcnXSwgYXBpS2V5Q29uZmlnVG9WZXJ0ZXgkMShmcm9tQXBpS2V5Q29uZmlnKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BdXRoVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXV0aFR5cGUnXSk7XG4gICAgaWYgKGZyb21BdXRoVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2F1dGhUeXBlJ10sIGZyb21BdXRoVHlwZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hb29nbGVTZXJ2aWNlQWNjb3VudENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2dvb2dsZVNlcnZpY2VBY2NvdW50Q29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUdvb2dsZVNlcnZpY2VBY2NvdW50Q29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ29vZ2xlU2VydmljZUFjY291bnRDb25maWcnXSwgZnJvbUdvb2dsZVNlcnZpY2VBY2NvdW50Q29uZmlnKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUh0dHBCYXNpY0F1dGhDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdodHRwQmFzaWNBdXRoQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUh0dHBCYXNpY0F1dGhDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydodHRwQmFzaWNBdXRoQ29uZmlnJ10sIGZyb21IdHRwQmFzaWNBdXRoQ29uZmlnKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU9hdXRoQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydvYXV0aENvbmZpZyddKTtcbiAgICBpZiAoZnJvbU9hdXRoQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnb2F1dGhDb25maWcnXSwgZnJvbU9hdXRoQ29uZmlnKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU9pZGNDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ29pZGNDb25maWcnXSk7XG4gICAgaWYgKGZyb21PaWRjQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnb2lkY0NvbmZpZyddLCBmcm9tT2lkY0NvbmZpZyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdvb2dsZU1hcHNUb1ZlcnRleCQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21BdXRoQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhdXRoQ29uZmlnJ10pO1xuICAgIGlmIChmcm9tQXV0aENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2F1dGhDb25maWcnXSwgYXV0aENvbmZpZ1RvVmVydGV4JDEoZnJvbUF1dGhDb25maWcpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdXJsQ29udGV4dFRvTWxkZXYkMigpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHVybENvbnRleHRUb1ZlcnRleCQxKCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdG9vbFRvTWxkZXYkMihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvbkRlY2xhcmF0aW9ucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb25EZWNsYXJhdGlvblRvTWxkZXYkMihpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uRGVjbGFyYXRpb25zJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3JldHJpZXZhbCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncmV0cmlldmFsIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hb29nbGVTZWFyY2ggPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaCddKTtcbiAgICBpZiAoZnJvbUdvb2dsZVNlYXJjaCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaCddLCBnb29nbGVTZWFyY2hUb01sZGV2JDIoZnJvbUdvb2dsZVNlYXJjaCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ29vZ2xlU2VhcmNoUmV0cmlldmFsJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaFJldHJpZXZhbCddLCBnb29nbGVTZWFyY2hSZXRyaWV2YWxUb01sZGV2JDIoZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCkpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbnRlcnByaXNlV2ViU2VhcmNoJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdlbnRlcnByaXNlV2ViU2VhcmNoIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2dvb2dsZU1hcHMnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dvb2dsZU1hcHMgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVybENvbnRleHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3VybENvbnRleHQnXSk7XG4gICAgaWYgKGZyb21VcmxDb250ZXh0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXJsQ29udGV4dCddLCB1cmxDb250ZXh0VG9NbGRldiQyKCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29kZUV4ZWN1dGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NvZGVFeGVjdXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ29kZUV4ZWN1dGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvZGVFeGVjdXRpb24nXSwgZnJvbUNvZGVFeGVjdXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB0b29sVG9WZXJ0ZXgkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvbkRlY2xhcmF0aW9ucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb25EZWNsYXJhdGlvblRvVmVydGV4JDEoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvbkRlY2xhcmF0aW9ucyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmV0cmlldmFsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXRyaWV2YWwnXSk7XG4gICAgaWYgKGZyb21SZXRyaWV2YWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXRyaWV2YWwnXSwgZnJvbVJldHJpZXZhbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hb29nbGVTZWFyY2ggPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaCddKTtcbiAgICBpZiAoZnJvbUdvb2dsZVNlYXJjaCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaCddLCBnb29nbGVTZWFyY2hUb1ZlcnRleCQxKGZyb21Hb29nbGVTZWFyY2gpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2dvb2dsZVNlYXJjaFJldHJpZXZhbCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Hb29nbGVTZWFyY2hSZXRyaWV2YWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVTZWFyY2hSZXRyaWV2YWwnXSwgZ29vZ2xlU2VhcmNoUmV0cmlldmFsVG9WZXJ0ZXgkMShmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbnRlcnByaXNlV2ViU2VhcmNoID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZW50ZXJwcmlzZVdlYlNlYXJjaCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FbnRlcnByaXNlV2ViU2VhcmNoICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW50ZXJwcmlzZVdlYlNlYXJjaCddLCBlbnRlcnByaXNlV2ViU2VhcmNoVG9WZXJ0ZXgkMSgpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvb2dsZU1hcHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2dvb2dsZU1hcHMnXSk7XG4gICAgaWYgKGZyb21Hb29nbGVNYXBzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ29vZ2xlTWFwcyddLCBnb29nbGVNYXBzVG9WZXJ0ZXgkMShmcm9tR29vZ2xlTWFwcykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXJsQ29udGV4dCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndXJsQ29udGV4dCddKTtcbiAgICBpZiAoZnJvbVVybENvbnRleHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1cmxDb250ZXh0J10sIHVybENvbnRleHRUb1ZlcnRleCQxKCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29kZUV4ZWN1dGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NvZGVFeGVjdXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ29kZUV4ZWN1dGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvZGVFeGVjdXRpb24nXSwgZnJvbUNvZGVFeGVjdXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBzZXNzaW9uUmVzdW1wdGlvbkNvbmZpZ1RvTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tSGFuZGxlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydoYW5kbGUnXSk7XG4gICAgaWYgKGZyb21IYW5kbGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydoYW5kbGUnXSwgZnJvbUhhbmRsZSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RyYW5zcGFyZW50J10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0cmFuc3BhcmVudCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBzZXNzaW9uUmVzdW1wdGlvbkNvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21IYW5kbGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2hhbmRsZSddKTtcbiAgICBpZiAoZnJvbUhhbmRsZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2hhbmRsZSddLCBmcm9tSGFuZGxlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRyYW5zcGFyZW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0cmFuc3BhcmVudCddKTtcbiAgICBpZiAoZnJvbVRyYW5zcGFyZW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndHJhbnNwYXJlbnQnXSwgZnJvbVRyYW5zcGFyZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gYXVkaW9UcmFuc2NyaXB0aW9uQ29uZmlnVG9NbGRldiQxKCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gYXVkaW9UcmFuc2NyaXB0aW9uQ29uZmlnVG9WZXJ0ZXgoKSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBhdXRvbWF0aWNBY3Rpdml0eURldGVjdGlvblRvTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRGlzYWJsZWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc2FibGVkJ10pO1xuICAgIGlmIChmcm9tRGlzYWJsZWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkaXNhYmxlZCddLCBmcm9tRGlzYWJsZWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3RhcnRPZlNwZWVjaFNlbnNpdGl2aXR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc3RhcnRPZlNwZWVjaFNlbnNpdGl2aXR5JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVN0YXJ0T2ZTcGVlY2hTZW5zaXRpdml0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0YXJ0T2ZTcGVlY2hTZW5zaXRpdml0eSddLCBmcm9tU3RhcnRPZlNwZWVjaFNlbnNpdGl2aXR5KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuZE9mU3BlZWNoU2Vuc2l0aXZpdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdlbmRPZlNwZWVjaFNlbnNpdGl2aXR5JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUVuZE9mU3BlZWNoU2Vuc2l0aXZpdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmRPZlNwZWVjaFNlbnNpdGl2aXR5J10sIGZyb21FbmRPZlNwZWVjaFNlbnNpdGl2aXR5KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVByZWZpeFBhZGRpbmdNcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ByZWZpeFBhZGRpbmdNcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21QcmVmaXhQYWRkaW5nTXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcmVmaXhQYWRkaW5nTXMnXSwgZnJvbVByZWZpeFBhZGRpbmdNcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TaWxlbmNlRHVyYXRpb25NcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NpbGVuY2VEdXJhdGlvbk1zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNpbGVuY2VEdXJhdGlvbk1zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2lsZW5jZUR1cmF0aW9uTXMnXSwgZnJvbVNpbGVuY2VEdXJhdGlvbk1zKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gYXV0b21hdGljQWN0aXZpdHlEZXRlY3Rpb25Ub1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRGlzYWJsZWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc2FibGVkJ10pO1xuICAgIGlmIChmcm9tRGlzYWJsZWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkaXNhYmxlZCddLCBmcm9tRGlzYWJsZWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3RhcnRPZlNwZWVjaFNlbnNpdGl2aXR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc3RhcnRPZlNwZWVjaFNlbnNpdGl2aXR5JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVN0YXJ0T2ZTcGVlY2hTZW5zaXRpdml0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0YXJ0T2ZTcGVlY2hTZW5zaXRpdml0eSddLCBmcm9tU3RhcnRPZlNwZWVjaFNlbnNpdGl2aXR5KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuZE9mU3BlZWNoU2Vuc2l0aXZpdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdlbmRPZlNwZWVjaFNlbnNpdGl2aXR5JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUVuZE9mU3BlZWNoU2Vuc2l0aXZpdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmRPZlNwZWVjaFNlbnNpdGl2aXR5J10sIGZyb21FbmRPZlNwZWVjaFNlbnNpdGl2aXR5KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVByZWZpeFBhZGRpbmdNcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ByZWZpeFBhZGRpbmdNcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21QcmVmaXhQYWRkaW5nTXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcmVmaXhQYWRkaW5nTXMnXSwgZnJvbVByZWZpeFBhZGRpbmdNcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TaWxlbmNlRHVyYXRpb25NcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NpbGVuY2VEdXJhdGlvbk1zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNpbGVuY2VEdXJhdGlvbk1zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2lsZW5jZUR1cmF0aW9uTXMnXSwgZnJvbVNpbGVuY2VEdXJhdGlvbk1zKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gcmVhbHRpbWVJbnB1dENvbmZpZ1RvTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQXV0b21hdGljQWN0aXZpdHlEZXRlY3Rpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdhdXRvbWF0aWNBY3Rpdml0eURldGVjdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21BdXRvbWF0aWNBY3Rpdml0eURldGVjdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2F1dG9tYXRpY0FjdGl2aXR5RGV0ZWN0aW9uJ10sIGF1dG9tYXRpY0FjdGl2aXR5RGV0ZWN0aW9uVG9NbGRldiQxKGZyb21BdXRvbWF0aWNBY3Rpdml0eURldGVjdGlvbikpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQWN0aXZpdHlIYW5kbGluZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2FjdGl2aXR5SGFuZGxpbmcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQWN0aXZpdHlIYW5kbGluZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2FjdGl2aXR5SGFuZGxpbmcnXSwgZnJvbUFjdGl2aXR5SGFuZGxpbmcpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVHVybkNvdmVyYWdlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0dXJuQ292ZXJhZ2UnXSk7XG4gICAgaWYgKGZyb21UdXJuQ292ZXJhZ2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0dXJuQ292ZXJhZ2UnXSwgZnJvbVR1cm5Db3ZlcmFnZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHJlYWx0aW1lSW5wdXRDb25maWdUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQXV0b21hdGljQWN0aXZpdHlEZXRlY3Rpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdhdXRvbWF0aWNBY3Rpdml0eURldGVjdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21BdXRvbWF0aWNBY3Rpdml0eURldGVjdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2F1dG9tYXRpY0FjdGl2aXR5RGV0ZWN0aW9uJ10sIGF1dG9tYXRpY0FjdGl2aXR5RGV0ZWN0aW9uVG9WZXJ0ZXgoZnJvbUF1dG9tYXRpY0FjdGl2aXR5RGV0ZWN0aW9uKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BY3Rpdml0eUhhbmRsaW5nID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnYWN0aXZpdHlIYW5kbGluZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21BY3Rpdml0eUhhbmRsaW5nICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYWN0aXZpdHlIYW5kbGluZyddLCBmcm9tQWN0aXZpdHlIYW5kbGluZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UdXJuQ292ZXJhZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3R1cm5Db3ZlcmFnZSddKTtcbiAgICBpZiAoZnJvbVR1cm5Db3ZlcmFnZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3R1cm5Db3ZlcmFnZSddLCBmcm9tVHVybkNvdmVyYWdlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gc2xpZGluZ1dpbmRvd1RvTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVGFyZ2V0VG9rZW5zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0YXJnZXRUb2tlbnMnXSk7XG4gICAgaWYgKGZyb21UYXJnZXRUb2tlbnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0YXJnZXRUb2tlbnMnXSwgZnJvbVRhcmdldFRva2Vucyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHNsaWRpbmdXaW5kb3dUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVGFyZ2V0VG9rZW5zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0YXJnZXRUb2tlbnMnXSk7XG4gICAgaWYgKGZyb21UYXJnZXRUb2tlbnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0YXJnZXRUb2tlbnMnXSwgZnJvbVRhcmdldFRva2Vucyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNvbnRleHRXaW5kb3dDb21wcmVzc2lvbkNvbmZpZ1RvTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVHJpZ2dlclRva2VucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3RyaWdnZXJUb2tlbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVHJpZ2dlclRva2VucyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RyaWdnZXJUb2tlbnMnXSwgZnJvbVRyaWdnZXJUb2tlbnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2xpZGluZ1dpbmRvdyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NsaWRpbmdXaW5kb3cnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2xpZGluZ1dpbmRvdyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NsaWRpbmdXaW5kb3cnXSwgc2xpZGluZ1dpbmRvd1RvTWxkZXYkMShmcm9tU2xpZGluZ1dpbmRvdykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjb250ZXh0V2luZG93Q29tcHJlc3Npb25Db25maWdUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVHJpZ2dlclRva2VucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3RyaWdnZXJUb2tlbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVHJpZ2dlclRva2VucyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RyaWdnZXJUb2tlbnMnXSwgZnJvbVRyaWdnZXJUb2tlbnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2xpZGluZ1dpbmRvdyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NsaWRpbmdXaW5kb3cnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2xpZGluZ1dpbmRvdyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NsaWRpbmdXaW5kb3cnXSwgc2xpZGluZ1dpbmRvd1RvVmVydGV4KGZyb21TbGlkaW5nV2luZG93KSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHByb2FjdGl2aXR5Q29uZmlnVG9NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Qcm9hY3RpdmVBdWRpbyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Byb2FjdGl2ZUF1ZGlvJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVByb2FjdGl2ZUF1ZGlvICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncHJvYWN0aXZlQXVkaW8nXSwgZnJvbVByb2FjdGl2ZUF1ZGlvKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gcHJvYWN0aXZpdHlDb25maWdUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUHJvYWN0aXZlQXVkaW8gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcm9hY3RpdmVBdWRpbycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Qcm9hY3RpdmVBdWRpbyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Byb2FjdGl2ZUF1ZGlvJ10sIGZyb21Qcm9hY3RpdmVBdWRpbyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpdmVDb25uZWN0Q29uZmlnVG9NbGRldiQxKGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUdlbmVyYXRpb25Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdnZW5lcmF0aW9uQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUdlbmVyYXRpb25Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZyddLCBmcm9tR2VuZXJhdGlvbkNvbmZpZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZU1vZGFsaXRpZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZU1vZGFsaXRpZXMnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUmVzcG9uc2VNb2RhbGl0aWVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAncmVzcG9uc2VNb2RhbGl0aWVzJ10sIGZyb21SZXNwb25zZU1vZGFsaXRpZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGVtcGVyYXR1cmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RlbXBlcmF0dXJlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVGVtcGVyYXR1cmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICd0ZW1wZXJhdHVyZSddLCBmcm9tVGVtcGVyYXR1cmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9wUCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9wUCddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRvcFAgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICd0b3BQJ10sIGZyb21Ub3BQKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvcEsgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RvcEsnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Ub3BLICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAndG9wSyddLCBmcm9tVG9wSyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NYXhPdXRwdXRUb2tlbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtYXhPdXRwdXRUb2tlbnMnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTWF4T3V0cHV0VG9rZW5zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAnbWF4T3V0cHV0VG9rZW5zJ10sIGZyb21NYXhPdXRwdXRUb2tlbnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWVkaWFSZXNvbHV0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbWVkaWFSZXNvbHV0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU1lZGlhUmVzb2x1dGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ21lZGlhUmVzb2x1dGlvbiddLCBmcm9tTWVkaWFSZXNvbHV0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNlZWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NlZWQnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TZWVkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAnc2VlZCddLCBmcm9tU2VlZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TcGVlY2hDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NwZWVjaENvbmZpZyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVNwZWVjaENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ3NwZWVjaENvbmZpZyddLCBzcGVlY2hDb25maWdUb01sZGV2JDIodExpdmVTcGVlY2hDb25maWcoZnJvbVNwZWVjaENvbmZpZykpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuYWJsZUFmZmVjdGl2ZURpYWxvZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2VuYWJsZUFmZmVjdGl2ZURpYWxvZycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21FbmFibGVBZmZlY3RpdmVEaWFsb2cgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICdlbmFibGVBZmZlY3RpdmVEaWFsb2cnXSwgZnJvbUVuYWJsZUFmZmVjdGl2ZURpYWxvZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TeXN0ZW1JbnN0cnVjdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3N5c3RlbUluc3RydWN0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVN5c3RlbUluc3RydWN0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ3N5c3RlbUluc3RydWN0aW9uJ10sIGNvbnRlbnRUb01sZGV2JDIodENvbnRlbnQoZnJvbVN5c3RlbUluc3RydWN0aW9uKSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9vbHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rvb2xzJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVG9vbHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gdFRvb2xzKGZyb21Ub29scyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9vbFRvTWxkZXYkMih0VG9vbChpdGVtKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAndG9vbHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNlc3Npb25SZXN1bXB0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2Vzc2lvblJlc3VtcHRpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU2Vzc2lvblJlc3VtcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnc2Vzc2lvblJlc3VtcHRpb24nXSwgc2Vzc2lvblJlc3VtcHRpb25Db25maWdUb01sZGV2JDEoZnJvbVNlc3Npb25SZXN1bXB0aW9uKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbnB1dEF1ZGlvVHJhbnNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2lucHV0QXVkaW9UcmFuc2NyaXB0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUlucHV0QXVkaW9UcmFuc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2lucHV0QXVkaW9UcmFuc2NyaXB0aW9uJ10sIGF1ZGlvVHJhbnNjcmlwdGlvbkNvbmZpZ1RvTWxkZXYkMSgpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU91dHB1dEF1ZGlvVHJhbnNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ291dHB1dEF1ZGlvVHJhbnNjcmlwdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21PdXRwdXRBdWRpb1RyYW5zY3JpcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnb3V0cHV0QXVkaW9UcmFuc2NyaXB0aW9uJ10sIGF1ZGlvVHJhbnNjcmlwdGlvbkNvbmZpZ1RvTWxkZXYkMSgpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlYWx0aW1lSW5wdXRDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZWFsdGltZUlucHV0Q29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVJlYWx0aW1lSW5wdXRDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAncmVhbHRpbWVJbnB1dENvbmZpZyddLCByZWFsdGltZUlucHV0Q29uZmlnVG9NbGRldiQxKGZyb21SZWFsdGltZUlucHV0Q29uZmlnKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db250ZXh0V2luZG93Q29tcHJlc3Npb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjb250ZXh0V2luZG93Q29tcHJlc3Npb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQ29udGV4dFdpbmRvd0NvbXByZXNzaW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2NvbnRleHRXaW5kb3dDb21wcmVzc2lvbiddLCBjb250ZXh0V2luZG93Q29tcHJlc3Npb25Db25maWdUb01sZGV2JDEoZnJvbUNvbnRleHRXaW5kb3dDb21wcmVzc2lvbikpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJvYWN0aXZpdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Byb2FjdGl2aXR5J10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUHJvYWN0aXZpdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAncHJvYWN0aXZpdHknXSwgcHJvYWN0aXZpdHlDb25maWdUb01sZGV2JDEoZnJvbVByb2FjdGl2aXR5KSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpdmVDb25uZWN0Q29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tR2VuZXJhdGlvbkNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2dlbmVyYXRpb25Db25maWcnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tR2VuZXJhdGlvbkNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJ10sIGZyb21HZW5lcmF0aW9uQ29uZmlnKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlTW9kYWxpdGllcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlTW9kYWxpdGllcycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21SZXNwb25zZU1vZGFsaXRpZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICdyZXNwb25zZU1vZGFsaXRpZXMnXSwgZnJvbVJlc3BvbnNlTW9kYWxpdGllcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UZW1wZXJhdHVyZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGVtcGVyYXR1cmUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21UZW1wZXJhdHVyZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ3RlbXBlcmF0dXJlJ10sIGZyb21UZW1wZXJhdHVyZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub3BQID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b3BQJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVG9wUCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ3RvcFAnXSwgZnJvbVRvcFApO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9wSyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9wSyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRvcEsgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICd0b3BLJ10sIGZyb21Ub3BLKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1heE91dHB1dFRva2VucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21heE91dHB1dFRva2VucycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21NYXhPdXRwdXRUb2tlbnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICdtYXhPdXRwdXRUb2tlbnMnXSwgZnJvbU1heE91dHB1dFRva2Vucyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NZWRpYVJlc29sdXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtZWRpYVJlc29sdXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTWVkaWFSZXNvbHV0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAnbWVkaWFSZXNvbHV0aW9uJ10sIGZyb21NZWRpYVJlc29sdXRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2VlZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc2VlZCddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVNlZWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICdzZWVkJ10sIGZyb21TZWVkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNwZWVjaENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3BlZWNoQ29uZmlnJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU3BlZWNoQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAnc3BlZWNoQ29uZmlnJ10sIHNwZWVjaENvbmZpZ1RvVmVydGV4JDEodExpdmVTcGVlY2hDb25maWcoZnJvbVNwZWVjaENvbmZpZykpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuYWJsZUFmZmVjdGl2ZURpYWxvZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2VuYWJsZUFmZmVjdGl2ZURpYWxvZycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21FbmFibGVBZmZlY3RpdmVEaWFsb2cgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICdlbmFibGVBZmZlY3RpdmVEaWFsb2cnXSwgZnJvbUVuYWJsZUFmZmVjdGl2ZURpYWxvZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TeXN0ZW1JbnN0cnVjdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3N5c3RlbUluc3RydWN0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVN5c3RlbUluc3RydWN0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ3N5c3RlbUluc3RydWN0aW9uJ10sIGNvbnRlbnRUb1ZlcnRleCQxKHRDb250ZW50KGZyb21TeXN0ZW1JbnN0cnVjdGlvbikpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvb2xzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b29scyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRvb2xzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IHRUb29scyhmcm9tVG9vbHMpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvb2xUb1ZlcnRleCQxKHRUb29sKGl0ZW0pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICd0b29scyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2Vzc2lvblJlc3VtcHRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZXNzaW9uUmVzdW1wdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TZXNzaW9uUmVzdW1wdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdzZXNzaW9uUmVzdW1wdGlvbiddLCBzZXNzaW9uUmVzdW1wdGlvbkNvbmZpZ1RvVmVydGV4KGZyb21TZXNzaW9uUmVzdW1wdGlvbikpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5wdXRBdWRpb1RyYW5zY3JpcHRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdpbnB1dEF1ZGlvVHJhbnNjcmlwdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21JbnB1dEF1ZGlvVHJhbnNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdpbnB1dEF1ZGlvVHJhbnNjcmlwdGlvbiddLCBhdWRpb1RyYW5zY3JpcHRpb25Db25maWdUb1ZlcnRleCgpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU91dHB1dEF1ZGlvVHJhbnNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ291dHB1dEF1ZGlvVHJhbnNjcmlwdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21PdXRwdXRBdWRpb1RyYW5zY3JpcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnb3V0cHV0QXVkaW9UcmFuc2NyaXB0aW9uJ10sIGF1ZGlvVHJhbnNjcmlwdGlvbkNvbmZpZ1RvVmVydGV4KCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVhbHRpbWVJbnB1dENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3JlYWx0aW1lSW5wdXRDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUmVhbHRpbWVJbnB1dENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdyZWFsdGltZUlucHV0Q29uZmlnJ10sIHJlYWx0aW1lSW5wdXRDb25maWdUb1ZlcnRleChmcm9tUmVhbHRpbWVJbnB1dENvbmZpZykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29udGV4dFdpbmRvd0NvbXByZXNzaW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY29udGV4dFdpbmRvd0NvbXByZXNzaW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUNvbnRleHRXaW5kb3dDb21wcmVzc2lvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdjb250ZXh0V2luZG93Q29tcHJlc3Npb24nXSwgY29udGV4dFdpbmRvd0NvbXByZXNzaW9uQ29uZmlnVG9WZXJ0ZXgoZnJvbUNvbnRleHRXaW5kb3dDb21wcmVzc2lvbikpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJvYWN0aXZpdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Byb2FjdGl2aXR5J10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUHJvYWN0aXZpdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAncHJvYWN0aXZpdHknXSwgcHJvYWN0aXZpdHlDb25maWdUb1ZlcnRleChmcm9tUHJvYWN0aXZpdHkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGl2ZUNvbm5lY3RQYXJhbWV0ZXJzVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NldHVwJywgJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb25maWcnXSwgbGl2ZUNvbm5lY3RDb25maWdUb01sZGV2JDEoZnJvbUNvbmZpZywgdG9PYmplY3QpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGl2ZUNvbm5lY3RQYXJhbWV0ZXJzVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZXR1cCcsICdtb2RlbCddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29uZmlnJ10sIGxpdmVDb25uZWN0Q29uZmlnVG9WZXJ0ZXgoZnJvbUNvbmZpZywgdG9PYmplY3QpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gYWN0aXZpdHlTdGFydFRvTWxkZXYoKSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBhY3Rpdml0eVN0YXJ0VG9WZXJ0ZXgoKSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBhY3Rpdml0eUVuZFRvTWxkZXYoKSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBhY3Rpdml0eUVuZFRvVmVydGV4KCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGl2ZVNlbmRSZWFsdGltZUlucHV0UGFyYW1ldGVyc1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1lZGlhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtZWRpYSddKTtcbiAgICBpZiAoZnJvbU1lZGlhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWVkaWFDaHVua3MnXSwgdEJsb2JzKGZyb21NZWRpYSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQXVkaW8gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2F1ZGlvJ10pO1xuICAgIGlmIChmcm9tQXVkaW8gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhdWRpbyddLCB0QXVkaW9CbG9iKGZyb21BdWRpbykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQXVkaW9TdHJlYW1FbmQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdhdWRpb1N0cmVhbUVuZCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21BdWRpb1N0cmVhbUVuZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2F1ZGlvU3RyZWFtRW5kJ10sIGZyb21BdWRpb1N0cmVhbUVuZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21WaWRlbyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndmlkZW8nXSk7XG4gICAgaWYgKGZyb21WaWRlbyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZpZGVvJ10sIHRJbWFnZUJsb2IoZnJvbVZpZGVvKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UZXh0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0ZXh0J10pO1xuICAgIGlmIChmcm9tVGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RleHQnXSwgZnJvbVRleHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQWN0aXZpdHlTdGFydCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2FjdGl2aXR5U3RhcnQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQWN0aXZpdHlTdGFydCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2FjdGl2aXR5U3RhcnQnXSwgYWN0aXZpdHlTdGFydFRvTWxkZXYoKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BY3Rpdml0eUVuZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYWN0aXZpdHlFbmQnXSk7XG4gICAgaWYgKGZyb21BY3Rpdml0eUVuZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2FjdGl2aXR5RW5kJ10sIGFjdGl2aXR5RW5kVG9NbGRldigpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGl2ZVNlbmRSZWFsdGltZUlucHV0UGFyYW1ldGVyc1RvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21NZWRpYSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWVkaWEnXSk7XG4gICAgaWYgKGZyb21NZWRpYSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21lZGlhQ2h1bmtzJ10sIHRCbG9icyhmcm9tTWVkaWEpKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXVkaW8nXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2F1ZGlvIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIFZlcnRleCBBSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUF1ZGlvU3RyZWFtRW5kID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnYXVkaW9TdHJlYW1FbmQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQXVkaW9TdHJlYW1FbmQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhdWRpb1N0cmVhbUVuZCddLCBmcm9tQXVkaW9TdHJlYW1FbmQpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd2aWRlbyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndmlkZW8gcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gVmVydGV4IEFJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0ZXh0J10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0ZXh0IHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIFZlcnRleCBBSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUFjdGl2aXR5U3RhcnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdhY3Rpdml0eVN0YXJ0JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUFjdGl2aXR5U3RhcnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhY3Rpdml0eVN0YXJ0J10sIGFjdGl2aXR5U3RhcnRUb1ZlcnRleCgpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUFjdGl2aXR5RW5kID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhY3Rpdml0eUVuZCddKTtcbiAgICBpZiAoZnJvbUFjdGl2aXR5RW5kICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYWN0aXZpdHlFbmQnXSwgYWN0aXZpdHlFbmRUb1ZlcnRleCgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gd2VpZ2h0ZWRQcm9tcHRUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21UZXh0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0ZXh0J10pO1xuICAgIGlmIChmcm9tVGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RleHQnXSwgZnJvbVRleHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tV2VpZ2h0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd3ZWlnaHQnXSk7XG4gICAgaWYgKGZyb21XZWlnaHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd3ZWlnaHQnXSwgZnJvbVdlaWdodCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpdmVNdXNpY1NldFdlaWdodGVkUHJvbXB0c1BhcmFtZXRlcnNUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21XZWlnaHRlZFByb21wdHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd3ZWlnaHRlZFByb21wdHMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tV2VpZ2h0ZWRQcm9tcHRzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21XZWlnaHRlZFByb21wdHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2VpZ2h0ZWRQcm9tcHRUb01sZGV2KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnd2VpZ2h0ZWRQcm9tcHRzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpdmVNdXNpY0dlbmVyYXRpb25Db25maWdUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21UZW1wZXJhdHVyZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGVtcGVyYXR1cmUnXSk7XG4gICAgaWYgKGZyb21UZW1wZXJhdHVyZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RlbXBlcmF0dXJlJ10sIGZyb21UZW1wZXJhdHVyZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub3BLID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b3BLJ10pO1xuICAgIGlmIChmcm9tVG9wSyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RvcEsnXSwgZnJvbVRvcEspO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2VlZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc2VlZCddKTtcbiAgICBpZiAoZnJvbVNlZWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZWVkJ10sIGZyb21TZWVkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUd1aWRhbmNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydndWlkYW5jZSddKTtcbiAgICBpZiAoZnJvbUd1aWRhbmNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ3VpZGFuY2UnXSwgZnJvbUd1aWRhbmNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUJwbSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYnBtJ10pO1xuICAgIGlmIChmcm9tQnBtICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYnBtJ10sIGZyb21CcG0pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGVuc2l0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGVuc2l0eSddKTtcbiAgICBpZiAoZnJvbURlbnNpdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkZW5zaXR5J10sIGZyb21EZW5zaXR5KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUJyaWdodG5lc3MgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2JyaWdodG5lc3MnXSk7XG4gICAgaWYgKGZyb21CcmlnaHRuZXNzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYnJpZ2h0bmVzcyddLCBmcm9tQnJpZ2h0bmVzcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TY2FsZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc2NhbGUnXSk7XG4gICAgaWYgKGZyb21TY2FsZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NjYWxlJ10sIGZyb21TY2FsZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NdXRlQmFzcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbXV0ZUJhc3MnXSk7XG4gICAgaWYgKGZyb21NdXRlQmFzcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ211dGVCYXNzJ10sIGZyb21NdXRlQmFzcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NdXRlRHJ1bXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ211dGVEcnVtcyddKTtcbiAgICBpZiAoZnJvbU11dGVEcnVtcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ211dGVEcnVtcyddLCBmcm9tTXV0ZURydW1zKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU9ubHlCYXNzQW5kRHJ1bXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdvbmx5QmFzc0FuZERydW1zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU9ubHlCYXNzQW5kRHJ1bXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydvbmx5QmFzc0FuZERydW1zJ10sIGZyb21Pbmx5QmFzc0FuZERydW1zKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGl2ZU11c2ljU2V0Q29uZmlnUGFyYW1ldGVyc1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU11c2ljR2VuZXJhdGlvbkNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ211c2ljR2VuZXJhdGlvbkNvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21NdXNpY0dlbmVyYXRpb25Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtdXNpY0dlbmVyYXRpb25Db25maWcnXSwgbGl2ZU11c2ljR2VuZXJhdGlvbkNvbmZpZ1RvTWxkZXYoZnJvbU11c2ljR2VuZXJhdGlvbkNvbmZpZykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXZlTXVzaWNDbGllbnRTZXR1cFRvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZWwnXSwgZnJvbU1vZGVsKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGl2ZU11c2ljQ2xpZW50Q29udGVudFRvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVdlaWdodGVkUHJvbXB0cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3dlaWdodGVkUHJvbXB0cycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21XZWlnaHRlZFByb21wdHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVdlaWdodGVkUHJvbXB0cztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB3ZWlnaHRlZFByb21wdFRvTWxkZXYoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd3ZWlnaHRlZFByb21wdHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGl2ZU11c2ljQ2xpZW50TWVzc2FnZVRvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNldHVwID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzZXR1cCddKTtcbiAgICBpZiAoZnJvbVNldHVwICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2V0dXAnXSwgbGl2ZU11c2ljQ2xpZW50U2V0dXBUb01sZGV2KGZyb21TZXR1cCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2xpZW50Q29udGVudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NsaWVudENvbnRlbnQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ2xpZW50Q29udGVudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NsaWVudENvbnRlbnQnXSwgbGl2ZU11c2ljQ2xpZW50Q29udGVudFRvTWxkZXYoZnJvbUNsaWVudENvbnRlbnQpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU11c2ljR2VuZXJhdGlvbkNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ211c2ljR2VuZXJhdGlvbkNvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21NdXNpY0dlbmVyYXRpb25Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtdXNpY0dlbmVyYXRpb25Db25maWcnXSwgbGl2ZU11c2ljR2VuZXJhdGlvbkNvbmZpZ1RvTWxkZXYoZnJvbU11c2ljR2VuZXJhdGlvbkNvbmZpZykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGxheWJhY2tDb250cm9sID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncGxheWJhY2tDb250cm9sJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVBsYXliYWNrQ29udHJvbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BsYXliYWNrQ29udHJvbCddLCBmcm9tUGxheWJhY2tDb250cm9sKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGl2ZVNlcnZlclNldHVwQ29tcGxldGVGcm9tTWxkZXYoKSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXZlU2VydmVyU2V0dXBDb21wbGV0ZUZyb21WZXJ0ZXgoKSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB2aWRlb01ldGFkYXRhRnJvbU1sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZwcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZnBzJ10pO1xuICAgIGlmIChmcm9tRnBzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnBzJ10sIGZyb21GcHMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5kT2Zmc2V0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbmRPZmZzZXQnXSk7XG4gICAgaWYgKGZyb21FbmRPZmZzZXQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmRPZmZzZXQnXSwgZnJvbUVuZE9mZnNldCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TdGFydE9mZnNldCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3RhcnRPZmZzZXQnXSk7XG4gICAgaWYgKGZyb21TdGFydE9mZnNldCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0YXJ0T2Zmc2V0J10sIGZyb21TdGFydE9mZnNldCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHZpZGVvTWV0YWRhdGFGcm9tVmVydGV4JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZwcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZnBzJ10pO1xuICAgIGlmIChmcm9tRnBzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnBzJ10sIGZyb21GcHMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5kT2Zmc2V0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbmRPZmZzZXQnXSk7XG4gICAgaWYgKGZyb21FbmRPZmZzZXQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmRPZmZzZXQnXSwgZnJvbUVuZE9mZnNldCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TdGFydE9mZnNldCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3RhcnRPZmZzZXQnXSk7XG4gICAgaWYgKGZyb21TdGFydE9mZnNldCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0YXJ0T2Zmc2V0J10sIGZyb21TdGFydE9mZnNldCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGJsb2JGcm9tTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGF0YSddKTtcbiAgICBpZiAoZnJvbURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkYXRhJ10sIGZyb21EYXRhKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gYmxvYkZyb21WZXJ0ZXgkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRGlzcGxheU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pO1xuICAgIGlmIChmcm9tRGlzcGxheU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkaXNwbGF5TmFtZSddLCBmcm9tRGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGF0YSddKTtcbiAgICBpZiAoZnJvbURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkYXRhJ10sIGZyb21EYXRhKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZmlsZURhdGFGcm9tTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRmlsZVVyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZVVyaSddKTtcbiAgICBpZiAoZnJvbUZpbGVVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWxlVXJpJ10sIGZyb21GaWxlVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZmlsZURhdGFGcm9tVmVydGV4JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbURpc3BsYXlOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKTtcbiAgICBpZiAoZnJvbURpc3BsYXlOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGlzcGxheU5hbWUnXSwgZnJvbURpc3BsYXlOYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbGVVcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVVcmknXSk7XG4gICAgaWYgKGZyb21GaWxlVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmlsZVVyaSddLCBmcm9tRmlsZVVyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHBhcnRGcm9tTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVmlkZW9NZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ZpZGVvTWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVmlkZW9NZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZpZGVvTWV0YWRhdGEnXSwgdmlkZW9NZXRhZGF0YUZyb21NbGRldiQxKGZyb21WaWRlb01ldGFkYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaG91Z2h0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0aG91Z2h0J10pO1xuICAgIGlmIChmcm9tVGhvdWdodCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rob3VnaHQnXSwgZnJvbVRob3VnaHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5saW5lRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW5saW5lRGF0YSddKTtcbiAgICBpZiAoZnJvbUlubGluZURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbmxpbmVEYXRhJ10sIGJsb2JGcm9tTWxkZXYkMShmcm9tSW5saW5lRGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsZURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVEYXRhJ10pO1xuICAgIGlmIChmcm9tRmlsZURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWxlRGF0YSddLCBmaWxlRGF0YUZyb21NbGRldiQxKGZyb21GaWxlRGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhvdWdodFNpZ25hdHVyZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Rob3VnaHRTaWduYXR1cmUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVGhvdWdodFNpZ25hdHVyZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rob3VnaHRTaWduYXR1cmUnXSwgZnJvbVRob3VnaHRTaWduYXR1cmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NvZGVFeGVjdXRpb25SZXN1bHQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvZGVFeGVjdXRpb25SZXN1bHQnXSwgZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXhlY3V0YWJsZUNvZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdleGVjdXRhYmxlQ29kZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FeGVjdXRhYmxlQ29kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2V4ZWN1dGFibGVDb2RlJ10sIGZyb21FeGVjdXRhYmxlQ29kZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GdW5jdGlvbkNhbGwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Z1bmN0aW9uQ2FsbCddKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uQ2FsbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uQ2FsbCddLCBmcm9tRnVuY3Rpb25DYWxsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvblJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvblJlc3BvbnNlJ10sIGZyb21GdW5jdGlvblJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRleHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RleHQnXSk7XG4gICAgaWYgKGZyb21UZXh0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGV4dCddLCBmcm9tVGV4dCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHBhcnRGcm9tVmVydGV4JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVZpZGVvTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd2aWRlb01ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVZpZGVvTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2aWRlb01ldGFkYXRhJ10sIHZpZGVvTWV0YWRhdGFGcm9tVmVydGV4JDEoZnJvbVZpZGVvTWV0YWRhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRob3VnaHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rob3VnaHQnXSk7XG4gICAgaWYgKGZyb21UaG91Z2h0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhvdWdodCddLCBmcm9tVGhvdWdodCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbmxpbmVEYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbmxpbmVEYXRhJ10pO1xuICAgIGlmIChmcm9tSW5saW5lRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2lubGluZURhdGEnXSwgYmxvYkZyb21WZXJ0ZXgkMShmcm9tSW5saW5lRGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsZURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVEYXRhJ10pO1xuICAgIGlmIChmcm9tRmlsZURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWxlRGF0YSddLCBmaWxlRGF0YUZyb21WZXJ0ZXgkMShmcm9tRmlsZURhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRob3VnaHRTaWduYXR1cmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0aG91Z2h0U2lnbmF0dXJlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRob3VnaHRTaWduYXR1cmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aG91Z2h0U2lnbmF0dXJlJ10sIGZyb21UaG91Z2h0U2lnbmF0dXJlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjb2RlRXhlY3V0aW9uUmVzdWx0JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb2RlRXhlY3V0aW9uUmVzdWx0J10sIGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUV4ZWN1dGFibGVDb2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZXhlY3V0YWJsZUNvZGUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRXhlY3V0YWJsZUNvZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydleGVjdXRhYmxlQ29kZSddLCBmcm9tRXhlY3V0YWJsZUNvZGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnVuY3Rpb25DYWxsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmdW5jdGlvbkNhbGwnXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvbkNhbGwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvbkNhbGwnXSwgZnJvbUZ1bmN0aW9uQ2FsbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GdW5jdGlvblJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZnVuY3Rpb25SZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvblJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25SZXNwb25zZSddLCBmcm9tRnVuY3Rpb25SZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UZXh0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0ZXh0J10pO1xuICAgIGlmIChmcm9tVGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RleHQnXSwgZnJvbVRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjb250ZW50RnJvbU1sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVBhcnRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYXJ0cyddKTtcbiAgICBpZiAoZnJvbVBhcnRzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21QYXJ0cztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0RnJvbU1sZGV2JDEoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJ0cyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUm9sZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncm9sZSddKTtcbiAgICBpZiAoZnJvbVJvbGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyb2xlJ10sIGZyb21Sb2xlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY29udGVudEZyb21WZXJ0ZXgkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUGFydHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhcnRzJ10pO1xuICAgIGlmIChmcm9tUGFydHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVBhcnRzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnRGcm9tVmVydGV4JDEoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJ0cyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUm9sZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncm9sZSddKTtcbiAgICBpZiAoZnJvbVJvbGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyb2xlJ10sIGZyb21Sb2xlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdHJhbnNjcmlwdGlvbkZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVGV4dCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGV4dCddKTtcbiAgICBpZiAoZnJvbVRleHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0ZXh0J10sIGZyb21UZXh0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbmlzaGVkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaW5pc2hlZCddKTtcbiAgICBpZiAoZnJvbUZpbmlzaGVkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmluaXNoZWQnXSwgZnJvbUZpbmlzaGVkKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdHJhbnNjcmlwdGlvbkZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVRleHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RleHQnXSk7XG4gICAgaWYgKGZyb21UZXh0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGV4dCddLCBmcm9tVGV4dCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaW5pc2hlZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmluaXNoZWQnXSk7XG4gICAgaWYgKGZyb21GaW5pc2hlZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbmlzaGVkJ10sIGZyb21GaW5pc2hlZCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHVybE1ldGFkYXRhRnJvbU1sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVJldHJpZXZlZFVybCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmV0cmlldmVkVXJsJ10pO1xuICAgIGlmIChmcm9tUmV0cmlldmVkVXJsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmV0cmlldmVkVXJsJ10sIGZyb21SZXRyaWV2ZWRVcmwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXJsUmV0cmlldmFsU3RhdHVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndXJsUmV0cmlldmFsU3RhdHVzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVVybFJldHJpZXZhbFN0YXR1cyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VybFJldHJpZXZhbFN0YXR1cyddLCBmcm9tVXJsUmV0cmlldmFsU3RhdHVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdXJsQ29udGV4dE1ldGFkYXRhRnJvbU1sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVVybE1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd1cmxNZXRhZGF0YSddKTtcbiAgICBpZiAoZnJvbVVybE1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21VcmxNZXRhZGF0YTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB1cmxNZXRhZGF0YUZyb21NbGRldiQxKGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXJsTWV0YWRhdGEnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGl2ZVNlcnZlckNvbnRlbnRGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsVHVybiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWxUdXJuJ10pO1xuICAgIGlmIChmcm9tTW9kZWxUdXJuICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZWxUdXJuJ10sIGNvbnRlbnRGcm9tTWxkZXYkMShmcm9tTW9kZWxUdXJuKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UdXJuQ29tcGxldGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3R1cm5Db21wbGV0ZSddKTtcbiAgICBpZiAoZnJvbVR1cm5Db21wbGV0ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3R1cm5Db21wbGV0ZSddLCBmcm9tVHVybkNvbXBsZXRlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUludGVycnVwdGVkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbnRlcnJ1cHRlZCddKTtcbiAgICBpZiAoZnJvbUludGVycnVwdGVkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW50ZXJydXB0ZWQnXSwgZnJvbUludGVycnVwdGVkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdyb3VuZGluZ01ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ3JvdW5kaW5nTWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tR3JvdW5kaW5nTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydncm91bmRpbmdNZXRhZGF0YSddLCBmcm9tR3JvdW5kaW5nTWV0YWRhdGEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR2VuZXJhdGlvbkNvbXBsZXRlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ2VuZXJhdGlvbkNvbXBsZXRlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUdlbmVyYXRpb25Db21wbGV0ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dlbmVyYXRpb25Db21wbGV0ZSddLCBmcm9tR2VuZXJhdGlvbkNvbXBsZXRlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUlucHV0VHJhbnNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2lucHV0VHJhbnNjcmlwdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21JbnB1dFRyYW5zY3JpcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbnB1dFRyYW5zY3JpcHRpb24nXSwgdHJhbnNjcmlwdGlvbkZyb21NbGRldihmcm9tSW5wdXRUcmFuc2NyaXB0aW9uKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21PdXRwdXRUcmFuc2NyaXB0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnb3V0cHV0VHJhbnNjcmlwdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21PdXRwdXRUcmFuc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnb3V0cHV0VHJhbnNjcmlwdGlvbiddLCB0cmFuc2NyaXB0aW9uRnJvbU1sZGV2KGZyb21PdXRwdXRUcmFuc2NyaXB0aW9uKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21VcmxDb250ZXh0TWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd1cmxDb250ZXh0TWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVXJsQ29udGV4dE1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXJsQ29udGV4dE1ldGFkYXRhJ10sIHVybENvbnRleHRNZXRhZGF0YUZyb21NbGRldiQxKGZyb21VcmxDb250ZXh0TWV0YWRhdGEpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGl2ZVNlcnZlckNvbnRlbnRGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbFR1cm4gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsVHVybiddKTtcbiAgICBpZiAoZnJvbU1vZGVsVHVybiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21vZGVsVHVybiddLCBjb250ZW50RnJvbVZlcnRleCQxKGZyb21Nb2RlbFR1cm4pKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVR1cm5Db21wbGV0ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndHVybkNvbXBsZXRlJ10pO1xuICAgIGlmIChmcm9tVHVybkNvbXBsZXRlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndHVybkNvbXBsZXRlJ10sIGZyb21UdXJuQ29tcGxldGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW50ZXJydXB0ZWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ludGVycnVwdGVkJ10pO1xuICAgIGlmIChmcm9tSW50ZXJydXB0ZWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbnRlcnJ1cHRlZCddLCBmcm9tSW50ZXJydXB0ZWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR3JvdW5kaW5nTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdncm91bmRpbmdNZXRhZGF0YScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Hcm91bmRpbmdNZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dyb3VuZGluZ01ldGFkYXRhJ10sIGZyb21Hcm91bmRpbmdNZXRhZGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21HZW5lcmF0aW9uQ29tcGxldGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdnZW5lcmF0aW9uQ29tcGxldGUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tR2VuZXJhdGlvbkNvbXBsZXRlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ2VuZXJhdGlvbkNvbXBsZXRlJ10sIGZyb21HZW5lcmF0aW9uQ29tcGxldGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5wdXRUcmFuc2NyaXB0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnaW5wdXRUcmFuc2NyaXB0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUlucHV0VHJhbnNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2lucHV0VHJhbnNjcmlwdGlvbiddLCB0cmFuc2NyaXB0aW9uRnJvbVZlcnRleChmcm9tSW5wdXRUcmFuc2NyaXB0aW9uKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21PdXRwdXRUcmFuc2NyaXB0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnb3V0cHV0VHJhbnNjcmlwdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21PdXRwdXRUcmFuc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnb3V0cHV0VHJhbnNjcmlwdGlvbiddLCB0cmFuc2NyaXB0aW9uRnJvbVZlcnRleChmcm9tT3V0cHV0VHJhbnNjcmlwdGlvbikpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBmdW5jdGlvbkNhbGxGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUlkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpZCddKTtcbiAgICBpZiAoZnJvbUlkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaWQnXSwgZnJvbUlkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUFyZ3MgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2FyZ3MnXSk7XG4gICAgaWYgKGZyb21BcmdzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYXJncyddLCBmcm9tQXJncyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBmdW5jdGlvbkNhbGxGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21BcmdzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhcmdzJ10pO1xuICAgIGlmIChmcm9tQXJncyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2FyZ3MnXSwgZnJvbUFyZ3MpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGl2ZVNlcnZlclRvb2xDYWxsRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21GdW5jdGlvbkNhbGxzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZnVuY3Rpb25DYWxscycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvbkNhbGxzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21GdW5jdGlvbkNhbGxzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uQ2FsbEZyb21NbGRldihpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uQ2FsbHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGl2ZVNlcnZlclRvb2xDYWxsRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRnVuY3Rpb25DYWxscyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2Z1bmN0aW9uQ2FsbHMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25DYWxscyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tRnVuY3Rpb25DYWxscztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbkNhbGxGcm9tVmVydGV4KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25DYWxscyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXZlU2VydmVyVG9vbENhbGxDYW5jZWxsYXRpb25Gcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUlkcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaWRzJ10pO1xuICAgIGlmIChmcm9tSWRzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaWRzJ10sIGZyb21JZHMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXZlU2VydmVyVG9vbENhbGxDYW5jZWxsYXRpb25Gcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21JZHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2lkcyddKTtcbiAgICBpZiAoZnJvbUlkcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2lkcyddLCBmcm9tSWRzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbW9kYWxpdHlUb2tlbkNvdW50RnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RhbGl0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kYWxpdHknXSk7XG4gICAgaWYgKGZyb21Nb2RhbGl0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21vZGFsaXR5J10sIGZyb21Nb2RhbGl0eSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub2tlbkNvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b2tlbkNvdW50J10pO1xuICAgIGlmIChmcm9tVG9rZW5Db3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rva2VuQ291bnQnXSwgZnJvbVRva2VuQ291bnQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBtb2RhbGl0eVRva2VuQ291bnRGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RhbGl0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kYWxpdHknXSk7XG4gICAgaWYgKGZyb21Nb2RhbGl0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21vZGFsaXR5J10sIGZyb21Nb2RhbGl0eSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub2tlbkNvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b2tlbkNvdW50J10pO1xuICAgIGlmIChmcm9tVG9rZW5Db3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rva2VuQ291bnQnXSwgZnJvbVRva2VuQ291bnQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB1c2FnZU1ldGFkYXRhRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Qcm9tcHRUb2tlbkNvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJvbXB0VG9rZW5Db3VudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Qcm9tcHRUb2tlbkNvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncHJvbXB0VG9rZW5Db3VudCddLCBmcm9tUHJvbXB0VG9rZW5Db3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DYWNoZWRDb250ZW50VG9rZW5Db3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NhY2hlZENvbnRlbnRUb2tlbkNvdW50JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNhY2hlZENvbnRlbnRUb2tlbkNvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2FjaGVkQ29udGVudFRva2VuQ291bnQnXSwgZnJvbUNhY2hlZENvbnRlbnRUb2tlbkNvdW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlVG9rZW5Db3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlVG9rZW5Db3VudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZVRva2VuQ291bnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZVRva2VuQ291bnQnXSwgZnJvbVJlc3BvbnNlVG9rZW5Db3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub29sVXNlUHJvbXB0VG9rZW5Db3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Rvb2xVc2VQcm9tcHRUb2tlbkNvdW50JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRvb2xVc2VQcm9tcHRUb2tlbkNvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG9vbFVzZVByb21wdFRva2VuQ291bnQnXSwgZnJvbVRvb2xVc2VQcm9tcHRUb2tlbkNvdW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRob3VnaHRzVG9rZW5Db3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Rob3VnaHRzVG9rZW5Db3VudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UaG91Z2h0c1Rva2VuQ291bnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aG91Z2h0c1Rva2VuQ291bnQnXSwgZnJvbVRob3VnaHRzVG9rZW5Db3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub3RhbFRva2VuQ291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0b3RhbFRva2VuQ291bnQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVG90YWxUb2tlbkNvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG90YWxUb2tlbkNvdW50J10sIGZyb21Ub3RhbFRva2VuQ291bnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJvbXB0VG9rZW5zRGV0YWlscyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Byb21wdFRva2Vuc0RldGFpbHMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUHJvbXB0VG9rZW5zRGV0YWlscyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tUHJvbXB0VG9rZW5zRGV0YWlscztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBtb2RhbGl0eVRva2VuQ291bnRGcm9tTWxkZXYoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcm9tcHRUb2tlbnNEZXRhaWxzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DYWNoZVRva2Vuc0RldGFpbHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjYWNoZVRva2Vuc0RldGFpbHMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ2FjaGVUb2tlbnNEZXRhaWxzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21DYWNoZVRva2Vuc0RldGFpbHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9kYWxpdHlUb2tlbkNvdW50RnJvbU1sZGV2KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2FjaGVUb2tlbnNEZXRhaWxzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZVRva2Vuc0RldGFpbHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZVRva2Vuc0RldGFpbHMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VUb2tlbnNEZXRhaWxzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21SZXNwb25zZVRva2Vuc0RldGFpbHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9kYWxpdHlUb2tlbkNvdW50RnJvbU1sZGV2KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VUb2tlbnNEZXRhaWxzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub29sVXNlUHJvbXB0VG9rZW5zRGV0YWlscyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Rvb2xVc2VQcm9tcHRUb2tlbnNEZXRhaWxzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRvb2xVc2VQcm9tcHRUb2tlbnNEZXRhaWxzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21Ub29sVXNlUHJvbXB0VG9rZW5zRGV0YWlscztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBtb2RhbGl0eVRva2VuQ291bnRGcm9tTWxkZXYoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b29sVXNlUHJvbXB0VG9rZW5zRGV0YWlscyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB1c2FnZU1ldGFkYXRhRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUHJvbXB0VG9rZW5Db3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Byb21wdFRva2VuQ291bnQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUHJvbXB0VG9rZW5Db3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Byb21wdFRva2VuQ291bnQnXSwgZnJvbVByb21wdFRva2VuQ291bnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2FjaGVkQ29udGVudFRva2VuQ291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjYWNoZWRDb250ZW50VG9rZW5Db3VudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21DYWNoZWRDb250ZW50VG9rZW5Db3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NhY2hlZENvbnRlbnRUb2tlbkNvdW50J10sIGZyb21DYWNoZWRDb250ZW50VG9rZW5Db3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZVRva2VuQ291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjYW5kaWRhdGVzVG9rZW5Db3VudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZVRva2VuQ291bnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZVRva2VuQ291bnQnXSwgZnJvbVJlc3BvbnNlVG9rZW5Db3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub29sVXNlUHJvbXB0VG9rZW5Db3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Rvb2xVc2VQcm9tcHRUb2tlbkNvdW50JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRvb2xVc2VQcm9tcHRUb2tlbkNvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG9vbFVzZVByb21wdFRva2VuQ291bnQnXSwgZnJvbVRvb2xVc2VQcm9tcHRUb2tlbkNvdW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRob3VnaHRzVG9rZW5Db3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Rob3VnaHRzVG9rZW5Db3VudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UaG91Z2h0c1Rva2VuQ291bnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aG91Z2h0c1Rva2VuQ291bnQnXSwgZnJvbVRob3VnaHRzVG9rZW5Db3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub3RhbFRva2VuQ291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0b3RhbFRva2VuQ291bnQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVG90YWxUb2tlbkNvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG90YWxUb2tlbkNvdW50J10sIGZyb21Ub3RhbFRva2VuQ291bnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJvbXB0VG9rZW5zRGV0YWlscyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Byb21wdFRva2Vuc0RldGFpbHMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUHJvbXB0VG9rZW5zRGV0YWlscyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tUHJvbXB0VG9rZW5zRGV0YWlscztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBtb2RhbGl0eVRva2VuQ291bnRGcm9tVmVydGV4KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncHJvbXB0VG9rZW5zRGV0YWlscyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2FjaGVUb2tlbnNEZXRhaWxzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY2FjaGVUb2tlbnNEZXRhaWxzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNhY2hlVG9rZW5zRGV0YWlscyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tQ2FjaGVUb2tlbnNEZXRhaWxzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vZGFsaXR5VG9rZW5Db3VudEZyb21WZXJ0ZXgoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjYWNoZVRva2Vuc0RldGFpbHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlVG9rZW5zRGV0YWlscyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NhbmRpZGF0ZXNUb2tlbnNEZXRhaWxzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlVG9rZW5zRGV0YWlscyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tUmVzcG9uc2VUb2tlbnNEZXRhaWxzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vZGFsaXR5VG9rZW5Db3VudEZyb21WZXJ0ZXgoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZVRva2Vuc0RldGFpbHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvb2xVc2VQcm9tcHRUb2tlbnNEZXRhaWxzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndG9vbFVzZVByb21wdFRva2Vuc0RldGFpbHMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVG9vbFVzZVByb21wdFRva2Vuc0RldGFpbHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVRvb2xVc2VQcm9tcHRUb2tlbnNEZXRhaWxzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vZGFsaXR5VG9rZW5Db3VudEZyb21WZXJ0ZXgoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b29sVXNlUHJvbXB0VG9rZW5zRGV0YWlscyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVHJhZmZpY1R5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RyYWZmaWNUeXBlJ10pO1xuICAgIGlmIChmcm9tVHJhZmZpY1R5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0cmFmZmljVHlwZSddLCBmcm9tVHJhZmZpY1R5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXZlU2VydmVyR29Bd2F5RnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21UaW1lTGVmdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGltZUxlZnQnXSk7XG4gICAgaWYgKGZyb21UaW1lTGVmdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RpbWVMZWZ0J10sIGZyb21UaW1lTGVmdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpdmVTZXJ2ZXJHb0F3YXlGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21UaW1lTGVmdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGltZUxlZnQnXSk7XG4gICAgaWYgKGZyb21UaW1lTGVmdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RpbWVMZWZ0J10sIGZyb21UaW1lTGVmdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpdmVTZXJ2ZXJTZXNzaW9uUmVzdW1wdGlvblVwZGF0ZUZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmV3SGFuZGxlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduZXdIYW5kbGUnXSk7XG4gICAgaWYgKGZyb21OZXdIYW5kbGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduZXdIYW5kbGUnXSwgZnJvbU5ld0hhbmRsZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXN1bWFibGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Jlc3VtYWJsZSddKTtcbiAgICBpZiAoZnJvbVJlc3VtYWJsZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3VtYWJsZSddLCBmcm9tUmVzdW1hYmxlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxhc3RDb25zdW1lZENsaWVudE1lc3NhZ2VJbmRleCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2xhc3RDb25zdW1lZENsaWVudE1lc3NhZ2VJbmRleCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21MYXN0Q29uc3VtZWRDbGllbnRNZXNzYWdlSW5kZXggIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsYXN0Q29uc3VtZWRDbGllbnRNZXNzYWdlSW5kZXgnXSwgZnJvbUxhc3RDb25zdW1lZENsaWVudE1lc3NhZ2VJbmRleCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpdmVTZXJ2ZXJTZXNzaW9uUmVzdW1wdGlvblVwZGF0ZUZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5ld0hhbmRsZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmV3SGFuZGxlJ10pO1xuICAgIGlmIChmcm9tTmV3SGFuZGxlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmV3SGFuZGxlJ10sIGZyb21OZXdIYW5kbGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzdW1hYmxlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXN1bWFibGUnXSk7XG4gICAgaWYgKGZyb21SZXN1bWFibGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXN1bWFibGUnXSwgZnJvbVJlc3VtYWJsZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21MYXN0Q29uc3VtZWRDbGllbnRNZXNzYWdlSW5kZXggPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdsYXN0Q29uc3VtZWRDbGllbnRNZXNzYWdlSW5kZXgnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTGFzdENvbnN1bWVkQ2xpZW50TWVzc2FnZUluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbGFzdENvbnN1bWVkQ2xpZW50TWVzc2FnZUluZGV4J10sIGZyb21MYXN0Q29uc3VtZWRDbGllbnRNZXNzYWdlSW5kZXgpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXZlU2VydmVyTWVzc2FnZUZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2V0dXBDb21wbGV0ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NldHVwQ29tcGxldGUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2V0dXBDb21wbGV0ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NldHVwQ29tcGxldGUnXSwgbGl2ZVNlcnZlclNldHVwQ29tcGxldGVGcm9tTWxkZXYoKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TZXJ2ZXJDb250ZW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2VydmVyQ29udGVudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZXJ2ZXJDb250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2VydmVyQ29udGVudCddLCBsaXZlU2VydmVyQ29udGVudEZyb21NbGRldihmcm9tU2VydmVyQ29udGVudCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9vbENhbGwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rvb2xDYWxsJ10pO1xuICAgIGlmIChmcm9tVG9vbENhbGwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b29sQ2FsbCddLCBsaXZlU2VydmVyVG9vbENhbGxGcm9tTWxkZXYoZnJvbVRvb2xDYWxsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub29sQ2FsbENhbmNlbGxhdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Rvb2xDYWxsQ2FuY2VsbGF0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRvb2xDYWxsQ2FuY2VsbGF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG9vbENhbGxDYW5jZWxsYXRpb24nXSwgbGl2ZVNlcnZlclRvb2xDYWxsQ2FuY2VsbGF0aW9uRnJvbU1sZGV2KGZyb21Ub29sQ2FsbENhbmNlbGxhdGlvbikpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXNhZ2VNZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3VzYWdlTWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVXNhZ2VNZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VzYWdlTWV0YWRhdGEnXSwgdXNhZ2VNZXRhZGF0YUZyb21NbGRldihmcm9tVXNhZ2VNZXRhZGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29Bd2F5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnb0F3YXknXSk7XG4gICAgaWYgKGZyb21Hb0F3YXkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb0F3YXknXSwgbGl2ZVNlcnZlckdvQXdheUZyb21NbGRldihmcm9tR29Bd2F5KSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TZXNzaW9uUmVzdW1wdGlvblVwZGF0ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nlc3Npb25SZXN1bXB0aW9uVXBkYXRlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNlc3Npb25SZXN1bXB0aW9uVXBkYXRlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2Vzc2lvblJlc3VtcHRpb25VcGRhdGUnXSwgbGl2ZVNlcnZlclNlc3Npb25SZXN1bXB0aW9uVXBkYXRlRnJvbU1sZGV2KGZyb21TZXNzaW9uUmVzdW1wdGlvblVwZGF0ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXZlU2VydmVyTWVzc2FnZUZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNldHVwQ29tcGxldGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZXR1cENvbXBsZXRlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNldHVwQ29tcGxldGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZXR1cENvbXBsZXRlJ10sIGxpdmVTZXJ2ZXJTZXR1cENvbXBsZXRlRnJvbVZlcnRleCgpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNlcnZlckNvbnRlbnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZXJ2ZXJDb250ZW50JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNlcnZlckNvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZXJ2ZXJDb250ZW50J10sIGxpdmVTZXJ2ZXJDb250ZW50RnJvbVZlcnRleChmcm9tU2VydmVyQ29udGVudCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9vbENhbGwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rvb2xDYWxsJ10pO1xuICAgIGlmIChmcm9tVG9vbENhbGwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b29sQ2FsbCddLCBsaXZlU2VydmVyVG9vbENhbGxGcm9tVmVydGV4KGZyb21Ub29sQ2FsbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9vbENhbGxDYW5jZWxsYXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0b29sQ2FsbENhbmNlbGxhdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Ub29sQ2FsbENhbmNlbGxhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rvb2xDYWxsQ2FuY2VsbGF0aW9uJ10sIGxpdmVTZXJ2ZXJUb29sQ2FsbENhbmNlbGxhdGlvbkZyb21WZXJ0ZXgoZnJvbVRvb2xDYWxsQ2FuY2VsbGF0aW9uKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Vc2FnZU1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndXNhZ2VNZXRhZGF0YScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Vc2FnZU1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXNhZ2VNZXRhZGF0YSddLCB1c2FnZU1ldGFkYXRhRnJvbVZlcnRleChmcm9tVXNhZ2VNZXRhZGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29Bd2F5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnb0F3YXknXSk7XG4gICAgaWYgKGZyb21Hb0F3YXkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb0F3YXknXSwgbGl2ZVNlcnZlckdvQXdheUZyb21WZXJ0ZXgoZnJvbUdvQXdheSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2Vzc2lvblJlc3VtcHRpb25VcGRhdGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZXNzaW9uUmVzdW1wdGlvblVwZGF0ZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZXNzaW9uUmVzdW1wdGlvblVwZGF0ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nlc3Npb25SZXN1bXB0aW9uVXBkYXRlJ10sIGxpdmVTZXJ2ZXJTZXNzaW9uUmVzdW1wdGlvblVwZGF0ZUZyb21WZXJ0ZXgoZnJvbVNlc3Npb25SZXN1bXB0aW9uVXBkYXRlKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpdmVNdXNpY1NlcnZlclNldHVwQ29tcGxldGVGcm9tTWxkZXYoKSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB3ZWlnaHRlZFByb21wdEZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVGV4dCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGV4dCddKTtcbiAgICBpZiAoZnJvbVRleHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0ZXh0J10sIGZyb21UZXh0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVdlaWdodCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnd2VpZ2h0J10pO1xuICAgIGlmIChmcm9tV2VpZ2h0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnd2VpZ2h0J10sIGZyb21XZWlnaHQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXZlTXVzaWNDbGllbnRDb250ZW50RnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21XZWlnaHRlZFByb21wdHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd3ZWlnaHRlZFByb21wdHMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tV2VpZ2h0ZWRQcm9tcHRzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21XZWlnaHRlZFByb21wdHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2VpZ2h0ZWRQcm9tcHRGcm9tTWxkZXYoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd3ZWlnaHRlZFByb21wdHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGl2ZU11c2ljR2VuZXJhdGlvbkNvbmZpZ0Zyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVGVtcGVyYXR1cmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RlbXBlcmF0dXJlJ10pO1xuICAgIGlmIChmcm9tVGVtcGVyYXR1cmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0ZW1wZXJhdHVyZSddLCBmcm9tVGVtcGVyYXR1cmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9wSyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9wSyddKTtcbiAgICBpZiAoZnJvbVRvcEsgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b3BLJ10sIGZyb21Ub3BLKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNlZWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NlZWQnXSk7XG4gICAgaWYgKGZyb21TZWVkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2VlZCddLCBmcm9tU2VlZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21HdWlkYW5jZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ3VpZGFuY2UnXSk7XG4gICAgaWYgKGZyb21HdWlkYW5jZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2d1aWRhbmNlJ10sIGZyb21HdWlkYW5jZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21CcG0gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2JwbSddKTtcbiAgICBpZiAoZnJvbUJwbSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2JwbSddLCBmcm9tQnBtKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURlbnNpdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2RlbnNpdHknXSk7XG4gICAgaWYgKGZyb21EZW5zaXR5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGVuc2l0eSddLCBmcm9tRGVuc2l0eSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21CcmlnaHRuZXNzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydicmlnaHRuZXNzJ10pO1xuICAgIGlmIChmcm9tQnJpZ2h0bmVzcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2JyaWdodG5lc3MnXSwgZnJvbUJyaWdodG5lc3MpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2NhbGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NjYWxlJ10pO1xuICAgIGlmIChmcm9tU2NhbGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzY2FsZSddLCBmcm9tU2NhbGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTXV0ZUJhc3MgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ211dGVCYXNzJ10pO1xuICAgIGlmIChmcm9tTXV0ZUJhc3MgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtdXRlQmFzcyddLCBmcm9tTXV0ZUJhc3MpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTXV0ZURydW1zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtdXRlRHJ1bXMnXSk7XG4gICAgaWYgKGZyb21NdXRlRHJ1bXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtdXRlRHJ1bXMnXSwgZnJvbU11dGVEcnVtcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Pbmx5QmFzc0FuZERydW1zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnb25seUJhc3NBbmREcnVtcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Pbmx5QmFzc0FuZERydW1zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnb25seUJhc3NBbmREcnVtcyddLCBmcm9tT25seUJhc3NBbmREcnVtcyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpdmVNdXNpY1NvdXJjZU1ldGFkYXRhRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21DbGllbnRDb250ZW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY2xpZW50Q29udGVudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21DbGllbnRDb250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2xpZW50Q29udGVudCddLCBsaXZlTXVzaWNDbGllbnRDb250ZW50RnJvbU1sZGV2KGZyb21DbGllbnRDb250ZW50KSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NdXNpY0dlbmVyYXRpb25Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtdXNpY0dlbmVyYXRpb25Db25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTXVzaWNHZW5lcmF0aW9uQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbXVzaWNHZW5lcmF0aW9uQ29uZmlnJ10sIGxpdmVNdXNpY0dlbmVyYXRpb25Db25maWdGcm9tTWxkZXYoZnJvbU11c2ljR2VuZXJhdGlvbkNvbmZpZykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBhdWRpb0NodW5rRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21EYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkYXRhJ10pO1xuICAgIGlmIChmcm9tRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2RhdGEnXSwgZnJvbURhdGEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU291cmNlTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzb3VyY2VNZXRhZGF0YScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Tb3VyY2VNZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NvdXJjZU1ldGFkYXRhJ10sIGxpdmVNdXNpY1NvdXJjZU1ldGFkYXRhRnJvbU1sZGV2KGZyb21Tb3VyY2VNZXRhZGF0YSkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXZlTXVzaWNTZXJ2ZXJDb250ZW50RnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21BdWRpb0NodW5rcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXVkaW9DaHVua3MnXSk7XG4gICAgaWYgKGZyb21BdWRpb0NodW5rcyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tQXVkaW9DaHVua3M7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXVkaW9DaHVua0Zyb21NbGRldihpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2F1ZGlvQ2h1bmtzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpdmVNdXNpY0ZpbHRlcmVkUHJvbXB0RnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21UZXh0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0ZXh0J10pO1xuICAgIGlmIChmcm9tVGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RleHQnXSwgZnJvbVRleHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsdGVyZWRSZWFzb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmaWx0ZXJlZFJlYXNvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GaWx0ZXJlZFJlYXNvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbHRlcmVkUmVhc29uJ10sIGZyb21GaWx0ZXJlZFJlYXNvbik7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpdmVNdXNpY1NlcnZlck1lc3NhZ2VGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNldHVwQ29tcGxldGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZXR1cENvbXBsZXRlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNldHVwQ29tcGxldGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZXR1cENvbXBsZXRlJ10sIGxpdmVNdXNpY1NlcnZlclNldHVwQ29tcGxldGVGcm9tTWxkZXYoKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TZXJ2ZXJDb250ZW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2VydmVyQ29udGVudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZXJ2ZXJDb250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2VydmVyQ29udGVudCddLCBsaXZlTXVzaWNTZXJ2ZXJDb250ZW50RnJvbU1sZGV2KGZyb21TZXJ2ZXJDb250ZW50KSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWx0ZXJlZFByb21wdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2ZpbHRlcmVkUHJvbXB0JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZpbHRlcmVkUHJvbXB0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmlsdGVyZWRQcm9tcHQnXSwgbGl2ZU11c2ljRmlsdGVyZWRQcm9tcHRGcm9tTWxkZXYoZnJvbUZpbHRlcmVkUHJvbXB0KSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuZnVuY3Rpb24gdmlkZW9NZXRhZGF0YVRvTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRnBzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmcHMnXSk7XG4gICAgaWYgKGZyb21GcHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmcHMnXSwgZnJvbUZwcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmRPZmZzZXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VuZE9mZnNldCddKTtcbiAgICBpZiAoZnJvbUVuZE9mZnNldCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VuZE9mZnNldCddLCBmcm9tRW5kT2Zmc2V0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN0YXJ0T2Zmc2V0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzdGFydE9mZnNldCddKTtcbiAgICBpZiAoZnJvbVN0YXJ0T2Zmc2V0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3RhcnRPZmZzZXQnXSwgZnJvbVN0YXJ0T2Zmc2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gYmxvYlRvTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZGlzcGxheU5hbWUgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2RhdGEnXSk7XG4gICAgaWYgKGZyb21EYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGF0YSddLCBmcm9tRGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZpbGVEYXRhVG9NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaXNwbGF5TmFtZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsZVVyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZVVyaSddKTtcbiAgICBpZiAoZnJvbUZpbGVVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWxlVXJpJ10sIGZyb21GaWxlVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gcGFydFRvTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVmlkZW9NZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ZpZGVvTWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVmlkZW9NZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZpZGVvTWV0YWRhdGEnXSwgdmlkZW9NZXRhZGF0YVRvTWxkZXYkMShmcm9tVmlkZW9NZXRhZGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhvdWdodCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGhvdWdodCddKTtcbiAgICBpZiAoZnJvbVRob3VnaHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aG91Z2h0J10sIGZyb21UaG91Z2h0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUlubGluZURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2lubGluZURhdGEnXSk7XG4gICAgaWYgKGZyb21JbmxpbmVEYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5saW5lRGF0YSddLCBibG9iVG9NbGRldiQxKGZyb21JbmxpbmVEYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWxlRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZURhdGEnXSk7XG4gICAgaWYgKGZyb21GaWxlRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVEYXRhJ10sIGZpbGVEYXRhVG9NbGRldiQxKGZyb21GaWxlRGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhvdWdodFNpZ25hdHVyZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Rob3VnaHRTaWduYXR1cmUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVGhvdWdodFNpZ25hdHVyZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rob3VnaHRTaWduYXR1cmUnXSwgZnJvbVRob3VnaHRTaWduYXR1cmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NvZGVFeGVjdXRpb25SZXN1bHQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvZGVFeGVjdXRpb25SZXN1bHQnXSwgZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXhlY3V0YWJsZUNvZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdleGVjdXRhYmxlQ29kZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FeGVjdXRhYmxlQ29kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2V4ZWN1dGFibGVDb2RlJ10sIGZyb21FeGVjdXRhYmxlQ29kZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GdW5jdGlvbkNhbGwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Z1bmN0aW9uQ2FsbCddKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uQ2FsbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uQ2FsbCddLCBmcm9tRnVuY3Rpb25DYWxsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvblJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvblJlc3BvbnNlJ10sIGZyb21GdW5jdGlvblJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRleHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RleHQnXSk7XG4gICAgaWYgKGZyb21UZXh0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGV4dCddLCBmcm9tVGV4dCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNvbnRlbnRUb01sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVBhcnRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYXJ0cyddKTtcbiAgICBpZiAoZnJvbVBhcnRzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21QYXJ0cztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0VG9NbGRldiQxKGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncGFydHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJvbGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3JvbGUnXSk7XG4gICAgaWYgKGZyb21Sb2xlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncm9sZSddLCBmcm9tUm9sZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHNjaGVtYVRvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUFueU9mID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhbnlPZiddKTtcbiAgICBpZiAoZnJvbUFueU9mICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYW55T2YnXSwgZnJvbUFueU9mKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURlZmF1bHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2RlZmF1bHQnXSk7XG4gICAgaWYgKGZyb21EZWZhdWx0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGVmYXVsdCddLCBmcm9tRGVmYXVsdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EZXNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGVzY3JpcHRpb24nXSk7XG4gICAgaWYgKGZyb21EZXNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10sIGZyb21EZXNjcmlwdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbnVtID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbnVtJ10pO1xuICAgIGlmIChmcm9tRW51bSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VudW0nXSwgZnJvbUVudW0pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXhhbXBsZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXhhbXBsZSddKTtcbiAgICBpZiAoZnJvbUV4YW1wbGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydleGFtcGxlJ10sIGZyb21FeGFtcGxlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZvcm1hdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZm9ybWF0J10pO1xuICAgIGlmIChmcm9tRm9ybWF0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZm9ybWF0J10sIGZyb21Gb3JtYXQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSXRlbXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2l0ZW1zJ10pO1xuICAgIGlmIChmcm9tSXRlbXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpdGVtcyddLCBmcm9tSXRlbXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWF4SXRlbXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21heEl0ZW1zJ10pO1xuICAgIGlmIChmcm9tTWF4SXRlbXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtYXhJdGVtcyddLCBmcm9tTWF4SXRlbXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWF4TGVuZ3RoID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtYXhMZW5ndGgnXSk7XG4gICAgaWYgKGZyb21NYXhMZW5ndGggIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtYXhMZW5ndGgnXSwgZnJvbU1heExlbmd0aCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NYXhQcm9wZXJ0aWVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbWF4UHJvcGVydGllcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21NYXhQcm9wZXJ0aWVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWF4UHJvcGVydGllcyddLCBmcm9tTWF4UHJvcGVydGllcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NYXhpbXVtID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtYXhpbXVtJ10pO1xuICAgIGlmIChmcm9tTWF4aW11bSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21heGltdW0nXSwgZnJvbU1heGltdW0pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWluSXRlbXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbkl0ZW1zJ10pO1xuICAgIGlmIChmcm9tTWluSXRlbXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW5JdGVtcyddLCBmcm9tTWluSXRlbXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWluTGVuZ3RoID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW5MZW5ndGgnXSk7XG4gICAgaWYgKGZyb21NaW5MZW5ndGggIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW5MZW5ndGgnXSwgZnJvbU1pbkxlbmd0aCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW5Qcm9wZXJ0aWVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbWluUHJvcGVydGllcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21NaW5Qcm9wZXJ0aWVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWluUHJvcGVydGllcyddLCBmcm9tTWluUHJvcGVydGllcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW5pbXVtID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW5pbXVtJ10pO1xuICAgIGlmIChmcm9tTWluaW11bSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbmltdW0nXSwgZnJvbU1pbmltdW0pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTnVsbGFibGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ251bGxhYmxlJ10pO1xuICAgIGlmIChmcm9tTnVsbGFibGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydudWxsYWJsZSddLCBmcm9tTnVsbGFibGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGF0dGVybiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGF0dGVybiddKTtcbiAgICBpZiAoZnJvbVBhdHRlcm4gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXR0ZXJuJ10sIGZyb21QYXR0ZXJuKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVByb3BlcnRpZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Byb3BlcnRpZXMnXSk7XG4gICAgaWYgKGZyb21Qcm9wZXJ0aWVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncHJvcGVydGllcyddLCBmcm9tUHJvcGVydGllcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Qcm9wZXJ0eU9yZGVyaW5nID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJvcGVydHlPcmRlcmluZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Qcm9wZXJ0eU9yZGVyaW5nICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncHJvcGVydHlPcmRlcmluZyddLCBmcm9tUHJvcGVydHlPcmRlcmluZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXF1aXJlZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmVxdWlyZWQnXSk7XG4gICAgaWYgKGZyb21SZXF1aXJlZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JlcXVpcmVkJ10sIGZyb21SZXF1aXJlZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaXRsZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGl0bGUnXSk7XG4gICAgaWYgKGZyb21UaXRsZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RpdGxlJ10sIGZyb21UaXRsZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0eXBlJ10pO1xuICAgIGlmIChmcm9tVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3R5cGUnXSwgZnJvbVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBzYWZldHlTZXR0aW5nVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtZXRob2QnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21ldGhvZCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2F0ZWdvcnkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NhdGVnb3J5J10pO1xuICAgIGlmIChmcm9tQ2F0ZWdvcnkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjYXRlZ29yeSddLCBmcm9tQ2F0ZWdvcnkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhyZXNob2xkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0aHJlc2hvbGQnXSk7XG4gICAgaWYgKGZyb21UaHJlc2hvbGQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aHJlc2hvbGQnXSwgZnJvbVRocmVzaG9sZCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZ1bmN0aW9uRGVjbGFyYXRpb25Ub01sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUJlaGF2aW9yID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydiZWhhdmlvciddKTtcbiAgICBpZiAoZnJvbUJlaGF2aW9yICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYmVoYXZpb3InXSwgZnJvbUJlaGF2aW9yKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURlc2NyaXB0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkZXNjcmlwdGlvbiddKTtcbiAgICBpZiAoZnJvbURlc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGVzY3JpcHRpb24nXSwgZnJvbURlc2NyaXB0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QYXJhbWV0ZXJzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYXJhbWV0ZXJzJ10pO1xuICAgIGlmIChmcm9tUGFyYW1ldGVycyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BhcmFtZXRlcnMnXSwgZnJvbVBhcmFtZXRlcnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGFyYW1ldGVyc0pzb25TY2hlbWEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwYXJhbWV0ZXJzSnNvblNjaGVtYScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21QYXJhbWV0ZXJzSnNvblNjaGVtYSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BhcmFtZXRlcnNKc29uU2NoZW1hJ10sIGZyb21QYXJhbWV0ZXJzSnNvblNjaGVtYSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmVzcG9uc2UnXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlJ10sIGZyb21SZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZUpzb25TY2hlbWEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZUpzb25TY2hlbWEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VKc29uU2NoZW1hICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VKc29uU2NoZW1hJ10sIGZyb21SZXNwb25zZUpzb25TY2hlbWEpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBpbnRlcnZhbFRvTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU3RhcnRUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzdGFydFRpbWUnXSk7XG4gICAgaWYgKGZyb21TdGFydFRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdGFydFRpbWUnXSwgZnJvbVN0YXJ0VGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmRUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbmRUaW1lJ10pO1xuICAgIGlmIChmcm9tRW5kVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VuZFRpbWUnXSwgZnJvbUVuZFRpbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnb29nbGVTZWFyY2hUb01sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVRpbWVSYW5nZUZpbHRlciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3RpbWVSYW5nZUZpbHRlcicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UaW1lUmFuZ2VGaWx0ZXIgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aW1lUmFuZ2VGaWx0ZXInXSwgaW50ZXJ2YWxUb01sZGV2JDEoZnJvbVRpbWVSYW5nZUZpbHRlcikpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBkeW5hbWljUmV0cmlldmFsQ29uZmlnVG9NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlJ10pO1xuICAgIGlmIChmcm9tTW9kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21vZGUnXSwgZnJvbU1vZGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRHluYW1pY1RocmVzaG9sZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2R5bmFtaWNUaHJlc2hvbGQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRHluYW1pY1RocmVzaG9sZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2R5bmFtaWNUaHJlc2hvbGQnXSwgZnJvbUR5bmFtaWNUaHJlc2hvbGQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnb29nbGVTZWFyY2hSZXRyaWV2YWxUb01sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUR5bmFtaWNSZXRyaWV2YWxDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdkeW5hbWljUmV0cmlldmFsQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUR5bmFtaWNSZXRyaWV2YWxDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkeW5hbWljUmV0cmlldmFsQ29uZmlnJ10sIGR5bmFtaWNSZXRyaWV2YWxDb25maWdUb01sZGV2JDEoZnJvbUR5bmFtaWNSZXRyaWV2YWxDb25maWcpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdXJsQ29udGV4dFRvTWxkZXYkMSgpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHRvb2xUb01sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uRGVjbGFyYXRpb25zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZnVuY3Rpb25EZWNsYXJhdGlvbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUZ1bmN0aW9uRGVjbGFyYXRpb25zO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uRGVjbGFyYXRpb25Ub01sZGV2JDEoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvbkRlY2xhcmF0aW9ucyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXRyaWV2YWwnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JldHJpZXZhbCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlU2VhcmNoID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnb29nbGVTZWFyY2gnXSk7XG4gICAgaWYgKGZyb21Hb29nbGVTZWFyY2ggIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVTZWFyY2gnXSwgZ29vZ2xlU2VhcmNoVG9NbGRldiQxKGZyb21Hb29nbGVTZWFyY2gpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2dvb2dsZVNlYXJjaFJldHJpZXZhbCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Hb29nbGVTZWFyY2hSZXRyaWV2YWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVTZWFyY2hSZXRyaWV2YWwnXSwgZ29vZ2xlU2VhcmNoUmV0cmlldmFsVG9NbGRldiQxKGZyb21Hb29nbGVTZWFyY2hSZXRyaWV2YWwpKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW50ZXJwcmlzZVdlYlNlYXJjaCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZW50ZXJwcmlzZVdlYlNlYXJjaCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnb29nbGVNYXBzJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdnb29nbGVNYXBzIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21VcmxDb250ZXh0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd1cmxDb250ZXh0J10pO1xuICAgIGlmIChmcm9tVXJsQ29udGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VybENvbnRleHQnXSwgdXJsQ29udGV4dFRvTWxkZXYkMSgpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvZGVFeGVjdXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjb2RlRXhlY3V0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNvZGVFeGVjdXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb2RlRXhlY3V0aW9uJ10sIGZyb21Db2RlRXhlY3V0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZnVuY3Rpb25DYWxsaW5nQ29uZmlnVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZSddKTtcbiAgICBpZiAoZnJvbU1vZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RlJ10sIGZyb21Nb2RlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUFsbG93ZWRGdW5jdGlvbk5hbWVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnYWxsb3dlZEZ1bmN0aW9uTmFtZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQWxsb3dlZEZ1bmN0aW9uTmFtZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhbGxvd2VkRnVuY3Rpb25OYW1lcyddLCBmcm9tQWxsb3dlZEZ1bmN0aW9uTmFtZXMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsYXRMbmdUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21MYXRpdHVkZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGF0aXR1ZGUnXSk7XG4gICAgaWYgKGZyb21MYXRpdHVkZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2xhdGl0dWRlJ10sIGZyb21MYXRpdHVkZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Mb25naXR1ZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xvbmdpdHVkZSddKTtcbiAgICBpZiAoZnJvbUxvbmdpdHVkZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2xvbmdpdHVkZSddLCBmcm9tTG9uZ2l0dWRlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gcmV0cmlldmFsQ29uZmlnVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTGF0TG5nID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsYXRMbmcnXSk7XG4gICAgaWYgKGZyb21MYXRMbmcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsYXRMbmcnXSwgbGF0TG5nVG9NbGRldihmcm9tTGF0TG5nKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21MYW5ndWFnZUNvZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhbmd1YWdlQ29kZSddKTtcbiAgICBpZiAoZnJvbUxhbmd1YWdlQ29kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2xhbmd1YWdlQ29kZSddLCBmcm9tTGFuZ3VhZ2VDb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdG9vbENvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uQ2FsbGluZ0NvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2Z1bmN0aW9uQ2FsbGluZ0NvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvbkNhbGxpbmdDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvbkNhbGxpbmdDb25maWcnXSwgZnVuY3Rpb25DYWxsaW5nQ29uZmlnVG9NbGRldihmcm9tRnVuY3Rpb25DYWxsaW5nQ29uZmlnKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXRyaWV2YWxDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXRyaWV2YWxDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmV0cmlldmFsQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmV0cmlldmFsQ29uZmlnJ10sIHJldHJpZXZhbENvbmZpZ1RvTWxkZXYoZnJvbVJldHJpZXZhbENvbmZpZykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBwcmVidWlsdFZvaWNlQ29uZmlnVG9NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Wb2ljZU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZvaWNlTmFtZSddKTtcbiAgICBpZiAoZnJvbVZvaWNlTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZvaWNlTmFtZSddLCBmcm9tVm9pY2VOYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdm9pY2VDb25maWdUb01sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVByZWJ1aWx0Vm9pY2VDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcmVidWlsdFZvaWNlQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVByZWJ1aWx0Vm9pY2VDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcmVidWlsdFZvaWNlQ29uZmlnJ10sIHByZWJ1aWx0Vm9pY2VDb25maWdUb01sZGV2JDEoZnJvbVByZWJ1aWx0Vm9pY2VDb25maWcpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gc3BlYWtlclZvaWNlQ29uZmlnVG9NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TcGVha2VyID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzcGVha2VyJ10pO1xuICAgIGlmIChmcm9tU3BlYWtlciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NwZWFrZXInXSwgZnJvbVNwZWFrZXIpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVm9pY2VDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZvaWNlQ29uZmlnJ10pO1xuICAgIGlmIChmcm9tVm9pY2VDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2b2ljZUNvbmZpZyddLCB2b2ljZUNvbmZpZ1RvTWxkZXYkMShmcm9tVm9pY2VDb25maWcpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbXVsdGlTcGVha2VyVm9pY2VDb25maWdUb01sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNwZWFrZXJWb2ljZUNvbmZpZ3MgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzcGVha2VyVm9pY2VDb25maWdzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNwZWFrZXJWb2ljZUNvbmZpZ3MgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVNwZWFrZXJWb2ljZUNvbmZpZ3M7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3BlYWtlclZvaWNlQ29uZmlnVG9NbGRldiQxKGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3BlYWtlclZvaWNlQ29uZmlncyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBzcGVlY2hDb25maWdUb01sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVZvaWNlQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd2b2ljZUNvbmZpZyddKTtcbiAgICBpZiAoZnJvbVZvaWNlQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndm9pY2VDb25maWcnXSwgdm9pY2VDb25maWdUb01sZGV2JDEoZnJvbVZvaWNlQ29uZmlnKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NdWx0aVNwZWFrZXJWb2ljZUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ211bHRpU3BlYWtlclZvaWNlQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU11bHRpU3BlYWtlclZvaWNlQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbXVsdGlTcGVha2VyVm9pY2VDb25maWcnXSwgbXVsdGlTcGVha2VyVm9pY2VDb25maWdUb01sZGV2JDEoZnJvbU11bHRpU3BlYWtlclZvaWNlQ29uZmlnKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21MYW5ndWFnZUNvZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhbmd1YWdlQ29kZSddKTtcbiAgICBpZiAoZnJvbUxhbmd1YWdlQ29kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2xhbmd1YWdlQ29kZSddLCBmcm9tTGFuZ3VhZ2VDb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdGhpbmtpbmdDb25maWdUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21JbmNsdWRlVGhvdWdodHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdpbmNsdWRlVGhvdWdodHMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tSW5jbHVkZVRob3VnaHRzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5jbHVkZVRob3VnaHRzJ10sIGZyb21JbmNsdWRlVGhvdWdodHMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhpbmtpbmdCdWRnZXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0aGlua2luZ0J1ZGdldCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UaGlua2luZ0J1ZGdldCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RoaW5raW5nQnVkZ2V0J10sIGZyb21UaGlua2luZ0J1ZGdldCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlQ29udGVudENvbmZpZ1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TeXN0ZW1JbnN0cnVjdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3N5c3RlbUluc3RydWN0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVN5c3RlbUluc3RydWN0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3N5c3RlbUluc3RydWN0aW9uJ10sIGNvbnRlbnRUb01sZGV2JDEodENvbnRlbnQoZnJvbVN5c3RlbUluc3RydWN0aW9uKSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGVtcGVyYXR1cmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RlbXBlcmF0dXJlJ10pO1xuICAgIGlmIChmcm9tVGVtcGVyYXR1cmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0ZW1wZXJhdHVyZSddLCBmcm9tVGVtcGVyYXR1cmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9wUCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9wUCddKTtcbiAgICBpZiAoZnJvbVRvcFAgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b3BQJ10sIGZyb21Ub3BQKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvcEsgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RvcEsnXSk7XG4gICAgaWYgKGZyb21Ub3BLICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG9wSyddLCBmcm9tVG9wSyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DYW5kaWRhdGVDb3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NhbmRpZGF0ZUNvdW50JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNhbmRpZGF0ZUNvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2FuZGlkYXRlQ291bnQnXSwgZnJvbUNhbmRpZGF0ZUNvdW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1heE91dHB1dFRva2VucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21heE91dHB1dFRva2VucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21NYXhPdXRwdXRUb2tlbnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtYXhPdXRwdXRUb2tlbnMnXSwgZnJvbU1heE91dHB1dFRva2Vucyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TdG9wU2VxdWVuY2VzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc3RvcFNlcXVlbmNlcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TdG9wU2VxdWVuY2VzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3RvcFNlcXVlbmNlcyddLCBmcm9tU3RvcFNlcXVlbmNlcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZUxvZ3Byb2JzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VMb2dwcm9icycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZUxvZ3Byb2JzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VMb2dwcm9icyddLCBmcm9tUmVzcG9uc2VMb2dwcm9icyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Mb2dwcm9icyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbG9ncHJvYnMnXSk7XG4gICAgaWYgKGZyb21Mb2dwcm9icyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2xvZ3Byb2JzJ10sIGZyb21Mb2dwcm9icyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QcmVzZW5jZVBlbmFsdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcmVzZW5jZVBlbmFsdHknLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUHJlc2VuY2VQZW5hbHR5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncHJlc2VuY2VQZW5hbHR5J10sIGZyb21QcmVzZW5jZVBlbmFsdHkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnJlcXVlbmN5UGVuYWx0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2ZyZXF1ZW5jeVBlbmFsdHknLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnJlcXVlbmN5UGVuYWx0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZyZXF1ZW5jeVBlbmFsdHknXSwgZnJvbUZyZXF1ZW5jeVBlbmFsdHkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2VlZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc2VlZCddKTtcbiAgICBpZiAoZnJvbVNlZWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZWVkJ10sIGZyb21TZWVkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZU1pbWVUeXBlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZU1pbWVUeXBlJ10sIGZyb21SZXNwb25zZU1pbWVUeXBlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlU2NoZW1hID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VTY2hlbWEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VTY2hlbWEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZVNjaGVtYSddLCBzY2hlbWFUb01sZGV2KHRTY2hlbWEoZnJvbVJlc3BvbnNlU2NoZW1hKSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VKc29uU2NoZW1hID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VKc29uU2NoZW1hJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlSnNvblNjaGVtYSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlSnNvblNjaGVtYSddLCBmcm9tUmVzcG9uc2VKc29uU2NoZW1hKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncm91dGluZ0NvbmZpZyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncm91dGluZ0NvbmZpZyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbFNlbGVjdGlvbkNvbmZpZyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbW9kZWxTZWxlY3Rpb25Db25maWcgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNhZmV0eVNldHRpbmdzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2FmZXR5U2V0dGluZ3MnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU2FmZXR5U2V0dGluZ3MgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVNhZmV0eVNldHRpbmdzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNhZmV0eVNldHRpbmdUb01sZGV2KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NhZmV0eVNldHRpbmdzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub29scyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9vbHMnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Ub29scyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSB0VG9vbHMoZnJvbVRvb2xzKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b29sVG9NbGRldiQxKHRUb29sKGl0ZW0pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWyd0b29scyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9vbENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9vbENvbmZpZyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRvb2xDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsndG9vbENvbmZpZyddLCB0b29sQ29uZmlnVG9NbGRldihmcm9tVG9vbENvbmZpZykpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsYWJlbHMnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xhYmVscyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2FjaGVkQ29udGVudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NhY2hlZENvbnRlbnQnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQ2FjaGVkQ29udGVudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydjYWNoZWRDb250ZW50J10sIHRDYWNoZWRDb250ZW50TmFtZShhcGlDbGllbnQsIGZyb21DYWNoZWRDb250ZW50KSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZU1vZGFsaXRpZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZU1vZGFsaXRpZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VNb2RhbGl0aWVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VNb2RhbGl0aWVzJ10sIGZyb21SZXNwb25zZU1vZGFsaXRpZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWVkaWFSZXNvbHV0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbWVkaWFSZXNvbHV0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU1lZGlhUmVzb2x1dGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21lZGlhUmVzb2x1dGlvbiddLCBmcm9tTWVkaWFSZXNvbHV0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNwZWVjaENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3BlZWNoQ29uZmlnJ10pO1xuICAgIGlmIChmcm9tU3BlZWNoQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3BlZWNoQ29uZmlnJ10sIHNwZWVjaENvbmZpZ1RvTWxkZXYkMSh0U3BlZWNoQ29uZmlnKGZyb21TcGVlY2hDb25maWcpKSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2F1ZGlvVGltZXN0YW1wJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhdWRpb1RpbWVzdGFtcCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhpbmtpbmdDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0aGlua2luZ0NvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UaGlua2luZ0NvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RoaW5raW5nQ29uZmlnJ10sIHRoaW5raW5nQ29uZmlnVG9NbGRldihmcm9tVGhpbmtpbmdDb25maWcpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVDb250ZW50UGFyYW1ldGVyc1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29udGVudHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbnRlbnRzJ10pO1xuICAgIGlmIChmcm9tQ29udGVudHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gdENvbnRlbnRzKGZyb21Db250ZW50cyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGVudFRvTWxkZXYkMShpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbnRlbnRzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dlbmVyYXRpb25Db25maWcnXSwgZ2VuZXJhdGVDb250ZW50Q29uZmlnVG9NbGRldihhcGlDbGllbnQsIGZyb21Db25maWcsIHRvT2JqZWN0KSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGVtYmVkQ29udGVudENvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVGFza1R5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rhc2tUeXBlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVGFza1R5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncmVxdWVzdHNbXScsICd0YXNrVHlwZSddLCBmcm9tVGFza1R5cGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGl0bGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RpdGxlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVGl0bGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncmVxdWVzdHNbXScsICd0aXRsZSddLCBmcm9tVGl0bGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0RGltZW5zaW9uYWxpdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdvdXRwdXREaW1lbnNpb25hbGl0eScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21PdXRwdXREaW1lbnNpb25hbGl0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydyZXF1ZXN0c1tdJywgJ291dHB1dERpbWVuc2lvbmFsaXR5J10sIGZyb21PdXRwdXREaW1lbnNpb25hbGl0eSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaW1lVHlwZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhdXRvVHJ1bmNhdGUnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2F1dG9UcnVuY2F0ZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBlbWJlZENvbnRlbnRQYXJhbWV0ZXJzVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbW9kZWwnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db250ZW50cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29udGVudHMnXSk7XG4gICAgaWYgKGZyb21Db250ZW50cyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JlcXVlc3RzW10nLCAnY29udGVudCddLCB0Q29udGVudHNGb3JFbWJlZChhcGlDbGllbnQsIGZyb21Db250ZW50cykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb25maWcnXSwgZW1iZWRDb250ZW50Q29uZmlnVG9NbGRldihmcm9tQ29uZmlnLCB0b09iamVjdCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTW9kZWxGb3JFbWJlZENvbnRlbnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWxGb3JFbWJlZENvbnRlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXF1ZXN0c1tdJywgJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbEZvckVtYmVkQ29udGVudCkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZUltYWdlc0NvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydvdXRwdXRHY3NVcmknXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ291dHB1dEdjc1VyaSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduZWdhdGl2ZVByb21wdCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbmVnYXRpdmVQcm9tcHQgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU51bWJlck9mSW1hZ2VzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbnVtYmVyT2ZJbWFnZXMnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTnVtYmVyT2ZJbWFnZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdzYW1wbGVDb3VudCddLCBmcm9tTnVtYmVyT2ZJbWFnZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQXNwZWN0UmF0aW8gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2FzcGVjdFJhdGlvJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQXNwZWN0UmF0aW8gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdhc3BlY3RSYXRpbyddLCBmcm9tQXNwZWN0UmF0aW8pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR3VpZGFuY2VTY2FsZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2d1aWRhbmNlU2NhbGUnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tR3VpZGFuY2VTY2FsZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2d1aWRhbmNlU2NhbGUnXSwgZnJvbUd1aWRhbmNlU2NhbGUpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzZWVkJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZWVkIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TYWZldHlGaWx0ZXJMZXZlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NhZmV0eUZpbHRlckxldmVsJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVNhZmV0eUZpbHRlckxldmVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnc2FmZXR5U2V0dGluZyddLCBmcm9tU2FmZXR5RmlsdGVyTGV2ZWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGVyc29uR2VuZXJhdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3BlcnNvbkdlbmVyYXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGVyc29uR2VuZXJhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3BlcnNvbkdlbmVyYXRpb24nXSwgZnJvbVBlcnNvbkdlbmVyYXRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5jbHVkZVNhZmV0eUF0dHJpYnV0ZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdpbmNsdWRlU2FmZXR5QXR0cmlidXRlcycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21JbmNsdWRlU2FmZXR5QXR0cmlidXRlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2luY2x1ZGVTYWZldHlBdHRyaWJ1dGVzJ10sIGZyb21JbmNsdWRlU2FmZXR5QXR0cmlidXRlcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbmNsdWRlUmFpUmVhc29uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnaW5jbHVkZVJhaVJlYXNvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21JbmNsdWRlUmFpUmVhc29uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnaW5jbHVkZVJhaVJlYXNvbiddLCBmcm9tSW5jbHVkZVJhaVJlYXNvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21MYW5ndWFnZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGFuZ3VhZ2UnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21MYW5ndWFnZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2xhbmd1YWdlJ10sIGZyb21MYW5ndWFnZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21PdXRwdXRNaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ291dHB1dE1pbWVUeXBlJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU91dHB1dE1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnb3V0cHV0T3B0aW9ucycsICdtaW1lVHlwZSddLCBmcm9tT3V0cHV0TWltZVR5cGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnb3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5JyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU91dHB1dENvbXByZXNzaW9uUXVhbGl0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ291dHB1dE9wdGlvbnMnLCAnY29tcHJlc3Npb25RdWFsaXR5J10sIGZyb21PdXRwdXRDb21wcmVzc2lvblF1YWxpdHkpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhZGRXYXRlcm1hcmsnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FkZFdhdGVybWFyayBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbmhhbmNlUHJvbXB0J10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdlbmhhbmNlUHJvbXB0IHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlSW1hZ2VzUGFyYW1ldGVyc1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJvbXB0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwcm9tcHQnXSk7XG4gICAgaWYgKGZyb21Qcm9tcHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAncHJvbXB0J10sIGZyb21Qcm9tcHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb25maWcnXSwgZ2VuZXJhdGVJbWFnZXNDb25maWdUb01sZGV2KGZyb21Db25maWcsIHRvT2JqZWN0KSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdldE1vZGVsUGFyYW1ldGVyc1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ25hbWUnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbmZpZyddLCBmcm9tQ29uZmlnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdE1vZGVsc0NvbmZpZ1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21QYWdlU2l6ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFnZVNpemUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QYWdlU2l6ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAncGFnZVNpemUnXSwgZnJvbVBhZ2VTaXplKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhZ2VUb2tlbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFnZVRva2VuJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGFnZVRva2VuICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdwYWdlVG9rZW4nXSwgZnJvbVBhZ2VUb2tlbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWx0ZXIgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbHRlciddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUZpbHRlciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAnZmlsdGVyJ10sIGZyb21GaWx0ZXIpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUXVlcnlCYXNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydxdWVyeUJhc2UnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21RdWVyeUJhc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3VybCcsICdtb2RlbHNfdXJsJ10sIHRNb2RlbHNVcmwoYXBpQ2xpZW50LCBmcm9tUXVlcnlCYXNlKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RNb2RlbHNQYXJhbWV0ZXJzVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbmZpZyddLCBsaXN0TW9kZWxzQ29uZmlnVG9NbGRldihhcGlDbGllbnQsIGZyb21Db25maWcsIHRvT2JqZWN0KSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHVwZGF0ZU1vZGVsQ29uZmlnVG9NbGRldihmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21EaXNwbGF5TmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21EaXNwbGF5TmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydkaXNwbGF5TmFtZSddLCBmcm9tRGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGVzY3JpcHRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRGVzY3JpcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnZGVzY3JpcHRpb24nXSwgZnJvbURlc2NyaXB0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURlZmF1bHRDaGVja3BvaW50SWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdkZWZhdWx0Q2hlY2twb2ludElkJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbURlZmF1bHRDaGVja3BvaW50SWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnZGVmYXVsdENoZWNrcG9pbnRJZCddLCBmcm9tRGVmYXVsdENoZWNrcG9pbnRJZCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHVwZGF0ZU1vZGVsUGFyYW1ldGVyc1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ25hbWUnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbmZpZyddLCB1cGRhdGVNb2RlbENvbmZpZ1RvTWxkZXYoZnJvbUNvbmZpZywgdG9PYmplY3QpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZGVsZXRlTW9kZWxQYXJhbWV0ZXJzVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29uZmlnJ10sIGZyb21Db25maWcpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjb3VudFRva2Vuc0NvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3lzdGVtSW5zdHJ1Y3Rpb24nXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N5c3RlbUluc3RydWN0aW9uIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rvb2xzJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0b29scyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnZW5lcmF0aW9uQ29uZmlnJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdnZW5lcmF0aW9uQ29uZmlnIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNvdW50VG9rZW5zUGFyYW1ldGVyc1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29udGVudHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbnRlbnRzJ10pO1xuICAgIGlmIChmcm9tQ29udGVudHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gdENvbnRlbnRzKGZyb21Db250ZW50cyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGVudFRvTWxkZXYkMShpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbnRlbnRzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbmZpZyddLCBjb3VudFRva2Vuc0NvbmZpZ1RvTWxkZXYoZnJvbUNvbmZpZykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBpbWFnZVRvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ2NzVXJpJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdnY3NVcmkgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUltYWdlQnl0ZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ltYWdlQnl0ZXMnXSk7XG4gICAgaWYgKGZyb21JbWFnZUJ5dGVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYnl0ZXNCYXNlNjRFbmNvZGVkJ10sIHRCeXRlcyhmcm9tSW1hZ2VCeXRlcykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVZpZGVvc0NvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTnVtYmVyT2ZWaWRlb3MgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdudW1iZXJPZlZpZGVvcycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21OdW1iZXJPZlZpZGVvcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3NhbXBsZUNvdW50J10sIGZyb21OdW1iZXJPZlZpZGVvcyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ291dHB1dEdjc1VyaSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignb3V0cHV0R2NzVXJpIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZwcyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZnBzIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EdXJhdGlvblNlY29uZHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdkdXJhdGlvblNlY29uZHMnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRHVyYXRpb25TZWNvbmRzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnZHVyYXRpb25TZWNvbmRzJ10sIGZyb21EdXJhdGlvblNlY29uZHMpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzZWVkJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZWVkIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Bc3BlY3RSYXRpbyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXNwZWN0UmF0aW8nXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Bc3BlY3RSYXRpbyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2FzcGVjdFJhdGlvJ10sIGZyb21Bc3BlY3RSYXRpbyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Jlc29sdXRpb24nXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Jlc29sdXRpb24gcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBlcnNvbkdlbmVyYXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwZXJzb25HZW5lcmF0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBlcnNvbkdlbmVyYXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdwZXJzb25HZW5lcmF0aW9uJ10sIGZyb21QZXJzb25HZW5lcmF0aW9uKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncHVic3ViVG9waWMnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3B1YnN1YlRvcGljIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OZWdhdGl2ZVByb21wdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ25lZ2F0aXZlUHJvbXB0JyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU5lZ2F0aXZlUHJvbXB0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnbmVnYXRpdmVQcm9tcHQnXSwgZnJvbU5lZ2F0aXZlUHJvbXB0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuaGFuY2VQcm9tcHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdlbmhhbmNlUHJvbXB0JyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUVuaGFuY2VQcm9tcHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdlbmhhbmNlUHJvbXB0J10sIGZyb21FbmhhbmNlUHJvbXB0KTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ2VuZXJhdGVBdWRpbyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZ2VuZXJhdGVBdWRpbyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsYXN0RnJhbWUnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xhc3RGcmFtZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb21wcmVzc2lvblF1YWxpdHknXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbXByZXNzaW9uUXVhbGl0eSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVZpZGVvc1BhcmFtZXRlcnNUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICdtb2RlbCddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVByb21wdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncHJvbXB0J10pO1xuICAgIGlmIChmcm9tUHJvbXB0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5zdGFuY2VzWzBdJywgJ3Byb21wdCddLCBmcm9tUHJvbXB0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUltYWdlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbWFnZSddKTtcbiAgICBpZiAoZnJvbUltYWdlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5zdGFuY2VzWzBdJywgJ2ltYWdlJ10sIGltYWdlVG9NbGRldihmcm9tSW1hZ2UpKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndmlkZW8nXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ZpZGVvIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbmZpZyddLCBnZW5lcmF0ZVZpZGVvc0NvbmZpZ1RvTWxkZXYoZnJvbUNvbmZpZywgdG9PYmplY3QpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdmlkZW9NZXRhZGF0YVRvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21GcHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZwcyddKTtcbiAgICBpZiAoZnJvbUZwcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZwcyddLCBmcm9tRnBzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuZE9mZnNldCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW5kT2Zmc2V0J10pO1xuICAgIGlmIChmcm9tRW5kT2Zmc2V0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW5kT2Zmc2V0J10sIGZyb21FbmRPZmZzZXQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3RhcnRPZmZzZXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3N0YXJ0T2Zmc2V0J10pO1xuICAgIGlmIChmcm9tU3RhcnRPZmZzZXQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdGFydE9mZnNldCddLCBmcm9tU3RhcnRPZmZzZXQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBibG9iVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbURpc3BsYXlOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKTtcbiAgICBpZiAoZnJvbURpc3BsYXlOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGlzcGxheU5hbWUnXSwgZnJvbURpc3BsYXlOYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2RhdGEnXSk7XG4gICAgaWYgKGZyb21EYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGF0YSddLCBmcm9tRGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZpbGVEYXRhVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbURpc3BsYXlOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKTtcbiAgICBpZiAoZnJvbURpc3BsYXlOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGlzcGxheU5hbWUnXSwgZnJvbURpc3BsYXlOYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbGVVcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVVcmknXSk7XG4gICAgaWYgKGZyb21GaWxlVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmlsZVVyaSddLCBmcm9tRmlsZVVyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHBhcnRUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVmlkZW9NZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ZpZGVvTWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVmlkZW9NZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZpZGVvTWV0YWRhdGEnXSwgdmlkZW9NZXRhZGF0YVRvVmVydGV4KGZyb21WaWRlb01ldGFkYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaG91Z2h0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0aG91Z2h0J10pO1xuICAgIGlmIChmcm9tVGhvdWdodCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rob3VnaHQnXSwgZnJvbVRob3VnaHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5saW5lRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW5saW5lRGF0YSddKTtcbiAgICBpZiAoZnJvbUlubGluZURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbmxpbmVEYXRhJ10sIGJsb2JUb1ZlcnRleChmcm9tSW5saW5lRGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsZURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVEYXRhJ10pO1xuICAgIGlmIChmcm9tRmlsZURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWxlRGF0YSddLCBmaWxlRGF0YVRvVmVydGV4KGZyb21GaWxlRGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhvdWdodFNpZ25hdHVyZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Rob3VnaHRTaWduYXR1cmUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVGhvdWdodFNpZ25hdHVyZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rob3VnaHRTaWduYXR1cmUnXSwgZnJvbVRob3VnaHRTaWduYXR1cmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NvZGVFeGVjdXRpb25SZXN1bHQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvZGVFeGVjdXRpb25SZXN1bHQnXSwgZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXhlY3V0YWJsZUNvZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdleGVjdXRhYmxlQ29kZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FeGVjdXRhYmxlQ29kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2V4ZWN1dGFibGVDb2RlJ10sIGZyb21FeGVjdXRhYmxlQ29kZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GdW5jdGlvbkNhbGwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Z1bmN0aW9uQ2FsbCddKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uQ2FsbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uQ2FsbCddLCBmcm9tRnVuY3Rpb25DYWxsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvblJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvblJlc3BvbnNlJ10sIGZyb21GdW5jdGlvblJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRleHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RleHQnXSk7XG4gICAgaWYgKGZyb21UZXh0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGV4dCddLCBmcm9tVGV4dCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNvbnRlbnRUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUGFydHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhcnRzJ10pO1xuICAgIGlmIChmcm9tUGFydHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVBhcnRzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnRUb1ZlcnRleChpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BhcnRzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Sb2xlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyb2xlJ10pO1xuICAgIGlmIChmcm9tUm9sZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JvbGUnXSwgZnJvbVJvbGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBzY2hlbWFUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQW55T2YgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2FueU9mJ10pO1xuICAgIGlmIChmcm9tQW55T2YgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhbnlPZiddLCBmcm9tQW55T2YpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGVmYXVsdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGVmYXVsdCddKTtcbiAgICBpZiAoZnJvbURlZmF1bHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkZWZhdWx0J10sIGZyb21EZWZhdWx0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURlc2NyaXB0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkZXNjcmlwdGlvbiddKTtcbiAgICBpZiAoZnJvbURlc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGVzY3JpcHRpb24nXSwgZnJvbURlc2NyaXB0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVudW0gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VudW0nXSk7XG4gICAgaWYgKGZyb21FbnVtICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW51bSddLCBmcm9tRW51bSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FeGFtcGxlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydleGFtcGxlJ10pO1xuICAgIGlmIChmcm9tRXhhbXBsZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2V4YW1wbGUnXSwgZnJvbUV4YW1wbGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRm9ybWF0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmb3JtYXQnXSk7XG4gICAgaWYgKGZyb21Gb3JtYXQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmb3JtYXQnXSwgZnJvbUZvcm1hdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JdGVtcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaXRlbXMnXSk7XG4gICAgaWYgKGZyb21JdGVtcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2l0ZW1zJ10sIGZyb21JdGVtcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NYXhJdGVtcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWF4SXRlbXMnXSk7XG4gICAgaWYgKGZyb21NYXhJdGVtcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21heEl0ZW1zJ10sIGZyb21NYXhJdGVtcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NYXhMZW5ndGggPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21heExlbmd0aCddKTtcbiAgICBpZiAoZnJvbU1heExlbmd0aCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21heExlbmd0aCddLCBmcm9tTWF4TGVuZ3RoKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1heFByb3BlcnRpZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtYXhQcm9wZXJ0aWVzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU1heFByb3BlcnRpZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtYXhQcm9wZXJ0aWVzJ10sIGZyb21NYXhQcm9wZXJ0aWVzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1heGltdW0gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21heGltdW0nXSk7XG4gICAgaWYgKGZyb21NYXhpbXVtICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWF4aW11bSddLCBmcm9tTWF4aW11bSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW5JdGVtcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWluSXRlbXMnXSk7XG4gICAgaWYgKGZyb21NaW5JdGVtcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbkl0ZW1zJ10sIGZyb21NaW5JdGVtcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW5MZW5ndGggPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbkxlbmd0aCddKTtcbiAgICBpZiAoZnJvbU1pbkxlbmd0aCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbkxlbmd0aCddLCBmcm9tTWluTGVuZ3RoKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pblByb3BlcnRpZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtaW5Qcm9wZXJ0aWVzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU1pblByb3BlcnRpZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW5Qcm9wZXJ0aWVzJ10sIGZyb21NaW5Qcm9wZXJ0aWVzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbmltdW0gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbmltdW0nXSk7XG4gICAgaWYgKGZyb21NaW5pbXVtICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWluaW11bSddLCBmcm9tTWluaW11bSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OdWxsYWJsZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbnVsbGFibGUnXSk7XG4gICAgaWYgKGZyb21OdWxsYWJsZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ251bGxhYmxlJ10sIGZyb21OdWxsYWJsZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QYXR0ZXJuID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYXR0ZXJuJ10pO1xuICAgIGlmIChmcm9tUGF0dGVybiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BhdHRlcm4nXSwgZnJvbVBhdHRlcm4pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJvcGVydGllcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncHJvcGVydGllcyddKTtcbiAgICBpZiAoZnJvbVByb3BlcnRpZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcm9wZXJ0aWVzJ10sIGZyb21Qcm9wZXJ0aWVzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVByb3BlcnR5T3JkZXJpbmcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcm9wZXJ0eU9yZGVyaW5nJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVByb3BlcnR5T3JkZXJpbmcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcm9wZXJ0eU9yZGVyaW5nJ10sIGZyb21Qcm9wZXJ0eU9yZGVyaW5nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlcXVpcmVkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXF1aXJlZCddKTtcbiAgICBpZiAoZnJvbVJlcXVpcmVkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVxdWlyZWQnXSwgZnJvbVJlcXVpcmVkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRpdGxlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0aXRsZSddKTtcbiAgICBpZiAoZnJvbVRpdGxlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGl0bGUnXSwgZnJvbVRpdGxlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3R5cGUnXSk7XG4gICAgaWYgKGZyb21UeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndHlwZSddLCBmcm9tVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIG1vZGVsU2VsZWN0aW9uQ29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZlYXR1cmVTZWxlY3Rpb25QcmVmZXJlbmNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZmVhdHVyZVNlbGVjdGlvblByZWZlcmVuY2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRmVhdHVyZVNlbGVjdGlvblByZWZlcmVuY2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmZWF0dXJlU2VsZWN0aW9uUHJlZmVyZW5jZSddLCBmcm9tRmVhdHVyZVNlbGVjdGlvblByZWZlcmVuY2UpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBzYWZldHlTZXR0aW5nVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1ldGhvZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWV0aG9kJ10pO1xuICAgIGlmIChmcm9tTWV0aG9kICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWV0aG9kJ10sIGZyb21NZXRob2QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2F0ZWdvcnkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NhdGVnb3J5J10pO1xuICAgIGlmIChmcm9tQ2F0ZWdvcnkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjYXRlZ29yeSddLCBmcm9tQ2F0ZWdvcnkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhyZXNob2xkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0aHJlc2hvbGQnXSk7XG4gICAgaWYgKGZyb21UaHJlc2hvbGQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aHJlc2hvbGQnXSwgZnJvbVRocmVzaG9sZCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZ1bmN0aW9uRGVjbGFyYXRpb25Ub1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydiZWhhdmlvciddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYmVoYXZpb3IgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gVmVydGV4IEFJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGVzY3JpcHRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10pO1xuICAgIGlmIChmcm9tRGVzY3JpcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkZXNjcmlwdGlvbiddLCBmcm9tRGVzY3JpcHRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhcmFtZXRlcnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhcmFtZXRlcnMnXSk7XG4gICAgaWYgKGZyb21QYXJhbWV0ZXJzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncGFyYW1ldGVycyddLCBmcm9tUGFyYW1ldGVycyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QYXJhbWV0ZXJzSnNvblNjaGVtYSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3BhcmFtZXRlcnNKc29uU2NoZW1hJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVBhcmFtZXRlcnNKc29uU2NoZW1hICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncGFyYW1ldGVyc0pzb25TY2hlbWEnXSwgZnJvbVBhcmFtZXRlcnNKc29uU2NoZW1hKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXNwb25zZSddKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2UnXSwgZnJvbVJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlSnNvblNjaGVtYSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlSnNvblNjaGVtYScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZUpzb25TY2hlbWEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZUpzb25TY2hlbWEnXSwgZnJvbVJlc3BvbnNlSnNvblNjaGVtYSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGludGVydmFsVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVN0YXJ0VGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3RhcnRUaW1lJ10pO1xuICAgIGlmIChmcm9tU3RhcnRUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3RhcnRUaW1lJ10sIGZyb21TdGFydFRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5kVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW5kVGltZSddKTtcbiAgICBpZiAoZnJvbUVuZFRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmRUaW1lJ10sIGZyb21FbmRUaW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ29vZ2xlU2VhcmNoVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVRpbWVSYW5nZUZpbHRlciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3RpbWVSYW5nZUZpbHRlcicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UaW1lUmFuZ2VGaWx0ZXIgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aW1lUmFuZ2VGaWx0ZXInXSwgaW50ZXJ2YWxUb1ZlcnRleChmcm9tVGltZVJhbmdlRmlsdGVyKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGR5bmFtaWNSZXRyaWV2YWxDb25maWdUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZSddKTtcbiAgICBpZiAoZnJvbU1vZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RlJ10sIGZyb21Nb2RlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUR5bmFtaWNUaHJlc2hvbGQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdkeW5hbWljVGhyZXNob2xkJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUR5bmFtaWNUaHJlc2hvbGQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkeW5hbWljVGhyZXNob2xkJ10sIGZyb21EeW5hbWljVGhyZXNob2xkKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ29vZ2xlU2VhcmNoUmV0cmlldmFsVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUR5bmFtaWNSZXRyaWV2YWxDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdkeW5hbWljUmV0cmlldmFsQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUR5bmFtaWNSZXRyaWV2YWxDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkeW5hbWljUmV0cmlldmFsQ29uZmlnJ10sIGR5bmFtaWNSZXRyaWV2YWxDb25maWdUb1ZlcnRleChmcm9tRHluYW1pY1JldHJpZXZhbENvbmZpZykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBlbnRlcnByaXNlV2ViU2VhcmNoVG9WZXJ0ZXgoKSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBhcGlLZXlDb25maWdUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQXBpS2V5U3RyaW5nID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhcGlLZXlTdHJpbmcnXSk7XG4gICAgaWYgKGZyb21BcGlLZXlTdHJpbmcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhcGlLZXlTdHJpbmcnXSwgZnJvbUFwaUtleVN0cmluZyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGF1dGhDb25maWdUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQXBpS2V5Q29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhcGlLZXlDb25maWcnXSk7XG4gICAgaWYgKGZyb21BcGlLZXlDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhcGlLZXlDb25maWcnXSwgYXBpS2V5Q29uZmlnVG9WZXJ0ZXgoZnJvbUFwaUtleUNvbmZpZykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQXV0aFR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2F1dGhUeXBlJ10pO1xuICAgIGlmIChmcm9tQXV0aFR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhdXRoVHlwZSddLCBmcm9tQXV0aFR5cGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlU2VydmljZUFjY291bnRDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdnb29nbGVTZXJ2aWNlQWNjb3VudENvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Hb29nbGVTZXJ2aWNlQWNjb3VudENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvb2dsZVNlcnZpY2VBY2NvdW50Q29uZmlnJ10sIGZyb21Hb29nbGVTZXJ2aWNlQWNjb3VudENvbmZpZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21IdHRwQmFzaWNBdXRoQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnaHR0cEJhc2ljQXV0aENvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21IdHRwQmFzaWNBdXRoQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaHR0cEJhc2ljQXV0aENvbmZpZyddLCBmcm9tSHR0cEJhc2ljQXV0aENvbmZpZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21PYXV0aENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnb2F1dGhDb25maWcnXSk7XG4gICAgaWYgKGZyb21PYXV0aENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ29hdXRoQ29uZmlnJ10sIGZyb21PYXV0aENvbmZpZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21PaWRjQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydvaWRjQ29uZmlnJ10pO1xuICAgIGlmIChmcm9tT2lkY0NvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ29pZGNDb25maWcnXSwgZnJvbU9pZGNDb25maWcpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnb29nbGVNYXBzVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUF1dGhDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2F1dGhDb25maWcnXSk7XG4gICAgaWYgKGZyb21BdXRoQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYXV0aENvbmZpZyddLCBhdXRoQ29uZmlnVG9WZXJ0ZXgoZnJvbUF1dGhDb25maWcpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdXJsQ29udGV4dFRvVmVydGV4KCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdG9vbFRvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2Z1bmN0aW9uRGVjbGFyYXRpb25zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uRGVjbGFyYXRpb25zICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbkRlY2xhcmF0aW9uVG9WZXJ0ZXgoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvbkRlY2xhcmF0aW9ucyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmV0cmlldmFsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXRyaWV2YWwnXSk7XG4gICAgaWYgKGZyb21SZXRyaWV2YWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXRyaWV2YWwnXSwgZnJvbVJldHJpZXZhbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hb29nbGVTZWFyY2ggPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaCddKTtcbiAgICBpZiAoZnJvbUdvb2dsZVNlYXJjaCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaCddLCBnb29nbGVTZWFyY2hUb1ZlcnRleChmcm9tR29vZ2xlU2VhcmNoKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hb29nbGVTZWFyY2hSZXRyaWV2YWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdnb29nbGVTZWFyY2hSZXRyaWV2YWwnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ29vZ2xlU2VhcmNoUmV0cmlldmFsJ10sIGdvb2dsZVNlYXJjaFJldHJpZXZhbFRvVmVydGV4KGZyb21Hb29nbGVTZWFyY2hSZXRyaWV2YWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVudGVycHJpc2VXZWJTZWFyY2ggPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdlbnRlcnByaXNlV2ViU2VhcmNoJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUVudGVycHJpc2VXZWJTZWFyY2ggIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbnRlcnByaXNlV2ViU2VhcmNoJ10sIGVudGVycHJpc2VXZWJTZWFyY2hUb1ZlcnRleCgpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvb2dsZU1hcHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2dvb2dsZU1hcHMnXSk7XG4gICAgaWYgKGZyb21Hb29nbGVNYXBzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ29vZ2xlTWFwcyddLCBnb29nbGVNYXBzVG9WZXJ0ZXgoZnJvbUdvb2dsZU1hcHMpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVybENvbnRleHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3VybENvbnRleHQnXSk7XG4gICAgaWYgKGZyb21VcmxDb250ZXh0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXJsQ29udGV4dCddLCB1cmxDb250ZXh0VG9WZXJ0ZXgoKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db2RlRXhlY3V0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY29kZUV4ZWN1dGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Db2RlRXhlY3V0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29kZUV4ZWN1dGlvbiddLCBmcm9tQ29kZUV4ZWN1dGlvbik7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZ1bmN0aW9uQ2FsbGluZ0NvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlJ10pO1xuICAgIGlmIChmcm9tTW9kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21vZGUnXSwgZnJvbU1vZGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQWxsb3dlZEZ1bmN0aW9uTmFtZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdhbGxvd2VkRnVuY3Rpb25OYW1lcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21BbGxvd2VkRnVuY3Rpb25OYW1lcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2FsbG93ZWRGdW5jdGlvbk5hbWVzJ10sIGZyb21BbGxvd2VkRnVuY3Rpb25OYW1lcyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxhdExuZ1RvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21MYXRpdHVkZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGF0aXR1ZGUnXSk7XG4gICAgaWYgKGZyb21MYXRpdHVkZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2xhdGl0dWRlJ10sIGZyb21MYXRpdHVkZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Mb25naXR1ZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xvbmdpdHVkZSddKTtcbiAgICBpZiAoZnJvbUxvbmdpdHVkZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2xvbmdpdHVkZSddLCBmcm9tTG9uZ2l0dWRlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gcmV0cmlldmFsQ29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUxhdExuZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGF0TG5nJ10pO1xuICAgIGlmIChmcm9tTGF0TG5nICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbGF0TG5nJ10sIGxhdExuZ1RvVmVydGV4KGZyb21MYXRMbmcpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxhbmd1YWdlQ29kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGFuZ3VhZ2VDb2RlJ10pO1xuICAgIGlmIChmcm9tTGFuZ3VhZ2VDb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbGFuZ3VhZ2VDb2RlJ10sIGZyb21MYW5ndWFnZUNvZGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB0b29sQ29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uQ2FsbGluZ0NvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2Z1bmN0aW9uQ2FsbGluZ0NvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvbkNhbGxpbmdDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvbkNhbGxpbmdDb25maWcnXSwgZnVuY3Rpb25DYWxsaW5nQ29uZmlnVG9WZXJ0ZXgoZnJvbUZ1bmN0aW9uQ2FsbGluZ0NvbmZpZykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmV0cmlldmFsQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmV0cmlldmFsQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJldHJpZXZhbENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JldHJpZXZhbENvbmZpZyddLCByZXRyaWV2YWxDb25maWdUb1ZlcnRleChmcm9tUmV0cmlldmFsQ29uZmlnKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHByZWJ1aWx0Vm9pY2VDb25maWdUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVm9pY2VOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd2b2ljZU5hbWUnXSk7XG4gICAgaWYgKGZyb21Wb2ljZU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2b2ljZU5hbWUnXSwgZnJvbVZvaWNlTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHZvaWNlQ29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVByZWJ1aWx0Vm9pY2VDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcmVidWlsdFZvaWNlQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVByZWJ1aWx0Vm9pY2VDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcmVidWlsdFZvaWNlQ29uZmlnJ10sIHByZWJ1aWx0Vm9pY2VDb25maWdUb1ZlcnRleChmcm9tUHJlYnVpbHRWb2ljZUNvbmZpZykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBzcGVlY2hDb25maWdUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVm9pY2VDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZvaWNlQ29uZmlnJ10pO1xuICAgIGlmIChmcm9tVm9pY2VDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2b2ljZUNvbmZpZyddLCB2b2ljZUNvbmZpZ1RvVmVydGV4KGZyb21Wb2ljZUNvbmZpZykpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtdWx0aVNwZWFrZXJWb2ljZUNvbmZpZyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbXVsdGlTcGVha2VyVm9pY2VDb25maWcgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gVmVydGV4IEFJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTGFuZ3VhZ2VDb2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsYW5ndWFnZUNvZGUnXSk7XG4gICAgaWYgKGZyb21MYW5ndWFnZUNvZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsYW5ndWFnZUNvZGUnXSwgZnJvbUxhbmd1YWdlQ29kZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHRoaW5raW5nQ29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUluY2x1ZGVUaG91Z2h0cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2luY2x1ZGVUaG91Z2h0cycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21JbmNsdWRlVGhvdWdodHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbmNsdWRlVGhvdWdodHMnXSwgZnJvbUluY2x1ZGVUaG91Z2h0cyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaGlua2luZ0J1ZGdldCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3RoaW5raW5nQnVkZ2V0JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRoaW5raW5nQnVkZ2V0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhpbmtpbmdCdWRnZXQnXSwgZnJvbVRoaW5raW5nQnVkZ2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVDb250ZW50Q29uZmlnVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TeXN0ZW1JbnN0cnVjdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3N5c3RlbUluc3RydWN0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVN5c3RlbUluc3RydWN0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3N5c3RlbUluc3RydWN0aW9uJ10sIGNvbnRlbnRUb1ZlcnRleCh0Q29udGVudChmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24pKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UZW1wZXJhdHVyZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGVtcGVyYXR1cmUnXSk7XG4gICAgaWYgKGZyb21UZW1wZXJhdHVyZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RlbXBlcmF0dXJlJ10sIGZyb21UZW1wZXJhdHVyZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub3BQID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b3BQJ10pO1xuICAgIGlmIChmcm9tVG9wUCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RvcFAnXSwgZnJvbVRvcFApO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9wSyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9wSyddKTtcbiAgICBpZiAoZnJvbVRvcEsgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b3BLJ10sIGZyb21Ub3BLKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNhbmRpZGF0ZUNvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY2FuZGlkYXRlQ291bnQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ2FuZGlkYXRlQ291bnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjYW5kaWRhdGVDb3VudCddLCBmcm9tQ2FuZGlkYXRlQ291bnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWF4T3V0cHV0VG9rZW5zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbWF4T3V0cHV0VG9rZW5zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU1heE91dHB1dFRva2VucyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21heE91dHB1dFRva2VucyddLCBmcm9tTWF4T3V0cHV0VG9rZW5zKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN0b3BTZXF1ZW5jZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzdG9wU2VxdWVuY2VzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVN0b3BTZXF1ZW5jZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdG9wU2VxdWVuY2VzJ10sIGZyb21TdG9wU2VxdWVuY2VzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlTG9ncHJvYnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZUxvZ3Byb2JzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlTG9ncHJvYnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZUxvZ3Byb2JzJ10sIGZyb21SZXNwb25zZUxvZ3Byb2JzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxvZ3Byb2JzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsb2dwcm9icyddKTtcbiAgICBpZiAoZnJvbUxvZ3Byb2JzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbG9ncHJvYnMnXSwgZnJvbUxvZ3Byb2JzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVByZXNlbmNlUGVuYWx0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ByZXNlbmNlUGVuYWx0eScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21QcmVzZW5jZVBlbmFsdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcmVzZW5jZVBlbmFsdHknXSwgZnJvbVByZXNlbmNlUGVuYWx0eSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GcmVxdWVuY3lQZW5hbHR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZnJlcXVlbmN5UGVuYWx0eScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GcmVxdWVuY3lQZW5hbHR5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnJlcXVlbmN5UGVuYWx0eSddLCBmcm9tRnJlcXVlbmN5UGVuYWx0eSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TZWVkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzZWVkJ10pO1xuICAgIGlmIChmcm9tU2VlZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NlZWQnXSwgZnJvbVNlZWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VNaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlTWltZVR5cGUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VNaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlTWltZVR5cGUnXSwgZnJvbVJlc3BvbnNlTWltZVR5cGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VTY2hlbWEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZVNjaGVtYScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZVNjaGVtYSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlU2NoZW1hJ10sIHNjaGVtYVRvVmVydGV4KHRTY2hlbWEoZnJvbVJlc3BvbnNlU2NoZW1hKSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VKc29uU2NoZW1hID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VKc29uU2NoZW1hJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlSnNvblNjaGVtYSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlSnNvblNjaGVtYSddLCBmcm9tUmVzcG9uc2VKc29uU2NoZW1hKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJvdXRpbmdDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyb3V0aW5nQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJvdXRpbmdDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyb3V0aW5nQ29uZmlnJ10sIGZyb21Sb3V0aW5nQ29uZmlnKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1vZGVsU2VsZWN0aW9uQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbW9kZWxTZWxlY3Rpb25Db25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTW9kZWxTZWxlY3Rpb25Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RlbENvbmZpZyddLCBtb2RlbFNlbGVjdGlvbkNvbmZpZ1RvVmVydGV4KGZyb21Nb2RlbFNlbGVjdGlvbkNvbmZpZykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2FmZXR5U2V0dGluZ3MgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzYWZldHlTZXR0aW5ncycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TYWZldHlTZXR0aW5ncyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tU2FmZXR5U2V0dGluZ3M7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2FmZXR5U2V0dGluZ1RvVmVydGV4KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NhZmV0eVNldHRpbmdzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub29scyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9vbHMnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Ub29scyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSB0VG9vbHMoZnJvbVRvb2xzKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b29sVG9WZXJ0ZXgodFRvb2woaXRlbSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3Rvb2xzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub29sQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b29sQ29uZmlnJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVG9vbENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWyd0b29sQ29uZmlnJ10sIHRvb2xDb25maWdUb1ZlcnRleChmcm9tVG9vbENvbmZpZykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTGFiZWxzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsYWJlbHMnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21MYWJlbHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnbGFiZWxzJ10sIGZyb21MYWJlbHMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2FjaGVkQ29udGVudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NhY2hlZENvbnRlbnQnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQ2FjaGVkQ29udGVudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydjYWNoZWRDb250ZW50J10sIHRDYWNoZWRDb250ZW50TmFtZShhcGlDbGllbnQsIGZyb21DYWNoZWRDb250ZW50KSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZU1vZGFsaXRpZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZU1vZGFsaXRpZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VNb2RhbGl0aWVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VNb2RhbGl0aWVzJ10sIGZyb21SZXNwb25zZU1vZGFsaXRpZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWVkaWFSZXNvbHV0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbWVkaWFSZXNvbHV0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU1lZGlhUmVzb2x1dGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21lZGlhUmVzb2x1dGlvbiddLCBmcm9tTWVkaWFSZXNvbHV0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNwZWVjaENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3BlZWNoQ29uZmlnJ10pO1xuICAgIGlmIChmcm9tU3BlZWNoQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3BlZWNoQ29uZmlnJ10sIHNwZWVjaENvbmZpZ1RvVmVydGV4KHRTcGVlY2hDb25maWcoZnJvbVNwZWVjaENvbmZpZykpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUF1ZGlvVGltZXN0YW1wID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnYXVkaW9UaW1lc3RhbXAnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQXVkaW9UaW1lc3RhbXAgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhdWRpb1RpbWVzdGFtcCddLCBmcm9tQXVkaW9UaW1lc3RhbXApO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhpbmtpbmdDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0aGlua2luZ0NvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UaGlua2luZ0NvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RoaW5raW5nQ29uZmlnJ10sIHRoaW5raW5nQ29uZmlnVG9WZXJ0ZXgoZnJvbVRoaW5raW5nQ29uZmlnKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlQ29udGVudFBhcmFtZXRlcnNUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbW9kZWwnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db250ZW50cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29udGVudHMnXSk7XG4gICAgaWYgKGZyb21Db250ZW50cyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSB0Q29udGVudHMoZnJvbUNvbnRlbnRzKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZW50VG9WZXJ0ZXgoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb250ZW50cyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnZW5lcmF0aW9uQ29uZmlnJ10sIGdlbmVyYXRlQ29udGVudENvbmZpZ1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbUNvbmZpZywgdG9PYmplY3QpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZW1iZWRDb250ZW50Q29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVGFza1R5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rhc2tUeXBlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVGFza1R5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnaW5zdGFuY2VzW10nLCAndGFza190eXBlJ10sIGZyb21UYXNrVHlwZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaXRsZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGl0bGUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21UaXRsZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydpbnN0YW5jZXNbXScsICd0aXRsZSddLCBmcm9tVGl0bGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0RGltZW5zaW9uYWxpdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdvdXRwdXREaW1lbnNpb25hbGl0eScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21PdXRwdXREaW1lbnNpb25hbGl0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ291dHB1dERpbWVuc2lvbmFsaXR5J10sIGZyb21PdXRwdXREaW1lbnNpb25hbGl0eSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydpbnN0YW5jZXNbXScsICdtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQXV0b1RydW5jYXRlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhdXRvVHJ1bmNhdGUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21BdXRvVHJ1bmNhdGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdhdXRvVHJ1bmNhdGUnXSwgZnJvbUF1dG9UcnVuY2F0ZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGVtYmVkQ29udGVudFBhcmFtZXRlcnNUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbW9kZWwnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db250ZW50cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29udGVudHMnXSk7XG4gICAgaWYgKGZyb21Db250ZW50cyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2luc3RhbmNlc1tdJywgJ2NvbnRlbnQnXSwgdENvbnRlbnRzRm9yRW1iZWQoYXBpQ2xpZW50LCBmcm9tQ29udGVudHMpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29uZmlnJ10sIGVtYmVkQ29udGVudENvbmZpZ1RvVmVydGV4KGZyb21Db25maWcsIHRvT2JqZWN0KSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlSW1hZ2VzQ29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tT3V0cHV0R2NzVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydvdXRwdXRHY3NVcmknXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21PdXRwdXRHY3NVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdzdG9yYWdlVXJpJ10sIGZyb21PdXRwdXRHY3NVcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmVnYXRpdmVQcm9tcHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICduZWdhdGl2ZVByb21wdCcsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21OZWdhdGl2ZVByb21wdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ25lZ2F0aXZlUHJvbXB0J10sIGZyb21OZWdhdGl2ZVByb21wdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OdW1iZXJPZkltYWdlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ251bWJlck9mSW1hZ2VzJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU51bWJlck9mSW1hZ2VzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnc2FtcGxlQ291bnQnXSwgZnJvbU51bWJlck9mSW1hZ2VzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUFzcGVjdFJhdGlvID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhc3BlY3RSYXRpbyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUFzcGVjdFJhdGlvICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnYXNwZWN0UmF0aW8nXSwgZnJvbUFzcGVjdFJhdGlvKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUd1aWRhbmNlU2NhbGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdndWlkYW5jZVNjYWxlJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUd1aWRhbmNlU2NhbGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdndWlkYW5jZVNjYWxlJ10sIGZyb21HdWlkYW5jZVNjYWxlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNlZWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NlZWQnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TZWVkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnc2VlZCddLCBmcm9tU2VlZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TYWZldHlGaWx0ZXJMZXZlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NhZmV0eUZpbHRlckxldmVsJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVNhZmV0eUZpbHRlckxldmVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnc2FmZXR5U2V0dGluZyddLCBmcm9tU2FmZXR5RmlsdGVyTGV2ZWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGVyc29uR2VuZXJhdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3BlcnNvbkdlbmVyYXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGVyc29uR2VuZXJhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3BlcnNvbkdlbmVyYXRpb24nXSwgZnJvbVBlcnNvbkdlbmVyYXRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5jbHVkZVNhZmV0eUF0dHJpYnV0ZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdpbmNsdWRlU2FmZXR5QXR0cmlidXRlcycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21JbmNsdWRlU2FmZXR5QXR0cmlidXRlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2luY2x1ZGVTYWZldHlBdHRyaWJ1dGVzJ10sIGZyb21JbmNsdWRlU2FmZXR5QXR0cmlidXRlcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbmNsdWRlUmFpUmVhc29uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnaW5jbHVkZVJhaVJlYXNvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21JbmNsdWRlUmFpUmVhc29uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnaW5jbHVkZVJhaVJlYXNvbiddLCBmcm9tSW5jbHVkZVJhaVJlYXNvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21MYW5ndWFnZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGFuZ3VhZ2UnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21MYW5ndWFnZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2xhbmd1YWdlJ10sIGZyb21MYW5ndWFnZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21PdXRwdXRNaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ291dHB1dE1pbWVUeXBlJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU91dHB1dE1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnb3V0cHV0T3B0aW9ucycsICdtaW1lVHlwZSddLCBmcm9tT3V0cHV0TWltZVR5cGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnb3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5JyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU91dHB1dENvbXByZXNzaW9uUXVhbGl0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ291dHB1dE9wdGlvbnMnLCAnY29tcHJlc3Npb25RdWFsaXR5J10sIGZyb21PdXRwdXRDb21wcmVzc2lvblF1YWxpdHkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQWRkV2F0ZXJtYXJrID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhZGRXYXRlcm1hcmsnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21BZGRXYXRlcm1hcmsgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdhZGRXYXRlcm1hcmsnXSwgZnJvbUFkZFdhdGVybWFyayk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmhhbmNlUHJvbXB0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZW5oYW5jZVByb21wdCcsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21FbmhhbmNlUHJvbXB0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnZW5oYW5jZVByb21wdCddLCBmcm9tRW5oYW5jZVByb21wdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlSW1hZ2VzUGFyYW1ldGVyc1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICdtb2RlbCddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVByb21wdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncHJvbXB0J10pO1xuICAgIGlmIChmcm9tUHJvbXB0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5zdGFuY2VzWzBdJywgJ3Byb21wdCddLCBmcm9tUHJvbXB0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29uZmlnJ10sIGdlbmVyYXRlSW1hZ2VzQ29uZmlnVG9WZXJ0ZXgoZnJvbUNvbmZpZywgdG9PYmplY3QpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gaW1hZ2VUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tR2NzVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnY3NVcmknXSk7XG4gICAgaWYgKGZyb21HY3NVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnY3NVcmknXSwgZnJvbUdjc1VyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbWFnZUJ5dGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbWFnZUJ5dGVzJ10pO1xuICAgIGlmIChmcm9tSW1hZ2VCeXRlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2J5dGVzQmFzZTY0RW5jb2RlZCddLCB0Qnl0ZXMoZnJvbUltYWdlQnl0ZXMpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbWFza1JlZmVyZW5jZUNvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21NYXNrTW9kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWFza01vZGUnXSk7XG4gICAgaWYgKGZyb21NYXNrTW9kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21hc2tNb2RlJ10sIGZyb21NYXNrTW9kZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TZWdtZW50YXRpb25DbGFzc2VzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2VnbWVudGF0aW9uQ2xhc3NlcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZWdtZW50YXRpb25DbGFzc2VzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWFza0NsYXNzZXMnXSwgZnJvbVNlZ21lbnRhdGlvbkNsYXNzZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWFza0RpbGF0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtYXNrRGlsYXRpb24nXSk7XG4gICAgaWYgKGZyb21NYXNrRGlsYXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkaWxhdGlvbiddLCBmcm9tTWFza0RpbGF0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY29udHJvbFJlZmVyZW5jZUNvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Db250cm9sVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29udHJvbFR5cGUnXSk7XG4gICAgaWYgKGZyb21Db250cm9sVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbnRyb2xUeXBlJ10sIGZyb21Db250cm9sVHlwZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmFibGVDb250cm9sSW1hZ2VDb21wdXRhdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2VuYWJsZUNvbnRyb2xJbWFnZUNvbXB1dGF0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUVuYWJsZUNvbnRyb2xJbWFnZUNvbXB1dGF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29tcHV0ZUNvbnRyb2wnXSwgZnJvbUVuYWJsZUNvbnRyb2xJbWFnZUNvbXB1dGF0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gc3R5bGVSZWZlcmVuY2VDb25maWdUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU3R5bGVEZXNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3N0eWxlRGVzY3JpcHRpb24nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU3R5bGVEZXNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0eWxlRGVzY3JpcHRpb24nXSwgZnJvbVN0eWxlRGVzY3JpcHRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBzdWJqZWN0UmVmZXJlbmNlQ29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVN1YmplY3RUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzdWJqZWN0VHlwZSddKTtcbiAgICBpZiAoZnJvbVN1YmplY3RUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3ViamVjdFR5cGUnXSwgZnJvbVN1YmplY3RUeXBlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN1YmplY3REZXNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3N1YmplY3REZXNjcmlwdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TdWJqZWN0RGVzY3JpcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdWJqZWN0RGVzY3JpcHRpb24nXSwgZnJvbVN1YmplY3REZXNjcmlwdGlvbik7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHJlZmVyZW5jZUltYWdlQVBJSW50ZXJuYWxUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUmVmZXJlbmNlSW1hZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZWZlcmVuY2VJbWFnZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZWZlcmVuY2VJbWFnZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JlZmVyZW5jZUltYWdlJ10sIGltYWdlVG9WZXJ0ZXgoZnJvbVJlZmVyZW5jZUltYWdlKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZWZlcmVuY2VJZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmVmZXJlbmNlSWQnXSk7XG4gICAgaWYgKGZyb21SZWZlcmVuY2VJZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JlZmVyZW5jZUlkJ10sIGZyb21SZWZlcmVuY2VJZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZWZlcmVuY2VUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVmZXJlbmNlVHlwZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZWZlcmVuY2VUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVmZXJlbmNlVHlwZSddLCBmcm9tUmVmZXJlbmNlVHlwZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NYXNrSW1hZ2VDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtYXNrSW1hZ2VDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTWFza0ltYWdlQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWFza0ltYWdlQ29uZmlnJ10sIG1hc2tSZWZlcmVuY2VDb25maWdUb1ZlcnRleChmcm9tTWFza0ltYWdlQ29uZmlnKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db250cm9sSW1hZ2VDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjb250cm9sSW1hZ2VDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ29udHJvbEltYWdlQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29udHJvbEltYWdlQ29uZmlnJ10sIGNvbnRyb2xSZWZlcmVuY2VDb25maWdUb1ZlcnRleChmcm9tQ29udHJvbEltYWdlQ29uZmlnKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TdHlsZUltYWdlQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc3R5bGVJbWFnZUNvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TdHlsZUltYWdlQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3R5bGVJbWFnZUNvbmZpZyddLCBzdHlsZVJlZmVyZW5jZUNvbmZpZ1RvVmVydGV4KGZyb21TdHlsZUltYWdlQ29uZmlnKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TdWJqZWN0SW1hZ2VDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzdWJqZWN0SW1hZ2VDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU3ViamVjdEltYWdlQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3ViamVjdEltYWdlQ29uZmlnJ10sIHN1YmplY3RSZWZlcmVuY2VDb25maWdUb1ZlcnRleChmcm9tU3ViamVjdEltYWdlQ29uZmlnKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGVkaXRJbWFnZUNvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU91dHB1dEdjc1VyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnb3V0cHV0R2NzVXJpJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tT3V0cHV0R2NzVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnc3RvcmFnZVVyaSddLCBmcm9tT3V0cHV0R2NzVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5lZ2F0aXZlUHJvbXB0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbmVnYXRpdmVQcm9tcHQnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTmVnYXRpdmVQcm9tcHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICduZWdhdGl2ZVByb21wdCddLCBmcm9tTmVnYXRpdmVQcm9tcHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTnVtYmVyT2ZJbWFnZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdudW1iZXJPZkltYWdlcycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21OdW1iZXJPZkltYWdlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3NhbXBsZUNvdW50J10sIGZyb21OdW1iZXJPZkltYWdlcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Bc3BlY3RSYXRpbyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXNwZWN0UmF0aW8nXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Bc3BlY3RSYXRpbyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2FzcGVjdFJhdGlvJ10sIGZyb21Bc3BlY3RSYXRpbyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21HdWlkYW5jZVNjYWxlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ3VpZGFuY2VTY2FsZScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21HdWlkYW5jZVNjYWxlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnZ3VpZGFuY2VTY2FsZSddLCBmcm9tR3VpZGFuY2VTY2FsZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TZWVkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzZWVkJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU2VlZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3NlZWQnXSwgZnJvbVNlZWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2FmZXR5RmlsdGVyTGV2ZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzYWZldHlGaWx0ZXJMZXZlbCcsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TYWZldHlGaWx0ZXJMZXZlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3NhZmV0eVNldHRpbmcnXSwgZnJvbVNhZmV0eUZpbHRlckxldmVsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBlcnNvbkdlbmVyYXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwZXJzb25HZW5lcmF0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBlcnNvbkdlbmVyYXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdwZXJzb25HZW5lcmF0aW9uJ10sIGZyb21QZXJzb25HZW5lcmF0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUluY2x1ZGVTYWZldHlBdHRyaWJ1dGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnaW5jbHVkZVNhZmV0eUF0dHJpYnV0ZXMnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tSW5jbHVkZVNhZmV0eUF0dHJpYnV0ZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdpbmNsdWRlU2FmZXR5QXR0cmlidXRlcyddLCBmcm9tSW5jbHVkZVNhZmV0eUF0dHJpYnV0ZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5jbHVkZVJhaVJlYXNvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2luY2x1ZGVSYWlSZWFzb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tSW5jbHVkZVJhaVJlYXNvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2luY2x1ZGVSYWlSZWFzb24nXSwgZnJvbUluY2x1ZGVSYWlSZWFzb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTGFuZ3VhZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhbmd1YWdlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTGFuZ3VhZ2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdsYW5ndWFnZSddLCBmcm9tTGFuZ3VhZ2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0TWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdvdXRwdXRNaW1lVHlwZScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21PdXRwdXRNaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ291dHB1dE9wdGlvbnMnLCAnbWltZVR5cGUnXSwgZnJvbU91dHB1dE1pbWVUeXBlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU91dHB1dENvbXByZXNzaW9uUXVhbGl0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ291dHB1dENvbXByZXNzaW9uUXVhbGl0eScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21PdXRwdXRDb21wcmVzc2lvblF1YWxpdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdvdXRwdXRPcHRpb25zJywgJ2NvbXByZXNzaW9uUXVhbGl0eSddLCBmcm9tT3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVkaXRNb2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlZGl0TW9kZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUVkaXRNb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnZWRpdE1vZGUnXSwgZnJvbUVkaXRNb2RlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUJhc2VTdGVwcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYmFzZVN0ZXBzJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQmFzZVN0ZXBzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnZWRpdENvbmZpZycsICdiYXNlU3RlcHMnXSwgZnJvbUJhc2VTdGVwcyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGVkaXRJbWFnZVBhcmFtZXRlcnNJbnRlcm5hbFRvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICdtb2RlbCddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVByb21wdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncHJvbXB0J10pO1xuICAgIGlmIChmcm9tUHJvbXB0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5zdGFuY2VzWzBdJywgJ3Byb21wdCddLCBmcm9tUHJvbXB0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlZmVyZW5jZUltYWdlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3JlZmVyZW5jZUltYWdlcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZWZlcmVuY2VJbWFnZXMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVJlZmVyZW5jZUltYWdlcztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWZlcmVuY2VJbWFnZUFQSUludGVybmFsVG9WZXJ0ZXgoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAncmVmZXJlbmNlSW1hZ2VzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbmZpZyddLCBlZGl0SW1hZ2VDb25maWdUb1ZlcnRleChmcm9tQ29uZmlnLCB0b09iamVjdCkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB1cHNjYWxlSW1hZ2VBUElDb25maWdJbnRlcm5hbFRvVmVydGV4KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUluY2x1ZGVSYWlSZWFzb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdpbmNsdWRlUmFpUmVhc29uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUluY2x1ZGVSYWlSZWFzb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdpbmNsdWRlUmFpUmVhc29uJ10sIGZyb21JbmNsdWRlUmFpUmVhc29uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU91dHB1dE1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnb3V0cHV0TWltZVR5cGUnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tT3V0cHV0TWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdvdXRwdXRPcHRpb25zJywgJ21pbWVUeXBlJ10sIGZyb21PdXRwdXRNaW1lVHlwZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21PdXRwdXRDb21wcmVzc2lvblF1YWxpdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdvdXRwdXRDb21wcmVzc2lvblF1YWxpdHknLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tT3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnb3V0cHV0T3B0aW9ucycsICdjb21wcmVzc2lvblF1YWxpdHknXSwgZnJvbU91dHB1dENvbXByZXNzaW9uUXVhbGl0eSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmhhbmNlSW5wdXRJbWFnZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2VuaGFuY2VJbnB1dEltYWdlJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUVuaGFuY2VJbnB1dEltYWdlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAndXBzY2FsZUNvbmZpZycsICdlbmhhbmNlSW5wdXRJbWFnZSddLCBmcm9tRW5oYW5jZUlucHV0SW1hZ2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW1hZ2VQcmVzZXJ2YXRpb25GYWN0b3IgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdpbWFnZVByZXNlcnZhdGlvbkZhY3RvcicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21JbWFnZVByZXNlcnZhdGlvbkZhY3RvciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3Vwc2NhbGVDb25maWcnLCAnaW1hZ2VQcmVzZXJ2YXRpb25GYWN0b3InXSwgZnJvbUltYWdlUHJlc2VydmF0aW9uRmFjdG9yKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU51bWJlck9mSW1hZ2VzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbnVtYmVyT2ZJbWFnZXMnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTnVtYmVyT2ZJbWFnZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdzYW1wbGVDb3VudCddLCBmcm9tTnVtYmVyT2ZJbWFnZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTW9kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU1vZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdtb2RlJ10sIGZyb21Nb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdXBzY2FsZUltYWdlQVBJUGFyYW1ldGVyc0ludGVybmFsVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW1hZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ltYWdlJ10pO1xuICAgIGlmIChmcm9tSW1hZ2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAnaW1hZ2UnXSwgaW1hZ2VUb1ZlcnRleChmcm9tSW1hZ2UpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVwc2NhbGVGYWN0b3IgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd1cHNjYWxlRmFjdG9yJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVVwc2NhbGVGYWN0b3IgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3Vwc2NhbGVDb25maWcnLCAndXBzY2FsZUZhY3RvciddLCBmcm9tVXBzY2FsZUZhY3Rvcik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbmZpZyddLCB1cHNjYWxlSW1hZ2VBUElDb25maWdJbnRlcm5hbFRvVmVydGV4KGZyb21Db25maWcsIHRvT2JqZWN0KSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdldE1vZGVsUGFyYW1ldGVyc1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICduYW1lJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb25maWcnXSwgZnJvbUNvbmZpZyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RNb2RlbHNDb25maWdUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVBhZ2VTaXplID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYWdlU2l6ZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBhZ2VTaXplICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdwYWdlU2l6ZSddLCBmcm9tUGFnZVNpemUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGFnZVRva2VuID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYWdlVG9rZW4nXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QYWdlVG9rZW4gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3F1ZXJ5JywgJ3BhZ2VUb2tlbiddLCBmcm9tUGFnZVRva2VuKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbHRlciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsdGVyJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRmlsdGVyICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdmaWx0ZXInXSwgZnJvbUZpbHRlcik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21RdWVyeUJhc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3F1ZXJ5QmFzZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVF1ZXJ5QmFzZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfdXJsJywgJ21vZGVsc191cmwnXSwgdE1vZGVsc1VybChhcGlDbGllbnQsIGZyb21RdWVyeUJhc2UpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdE1vZGVsc1BhcmFtZXRlcnNUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbmZpZyddLCBsaXN0TW9kZWxzQ29uZmlnVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tQ29uZmlnLCB0b09iamVjdCkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB1cGRhdGVNb2RlbENvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbURpc3BsYXlOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbURpc3BsYXlOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10sIGZyb21EaXNwbGF5TmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EZXNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGVzY3JpcHRpb24nXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21EZXNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydkZXNjcmlwdGlvbiddLCBmcm9tRGVzY3JpcHRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGVmYXVsdENoZWNrcG9pbnRJZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2RlZmF1bHRDaGVja3BvaW50SWQnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRGVmYXVsdENoZWNrcG9pbnRJZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydkZWZhdWx0Q2hlY2twb2ludElkJ10sIGZyb21EZWZhdWx0Q2hlY2twb2ludElkKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdXBkYXRlTW9kZWxQYXJhbWV0ZXJzVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb25maWcnXSwgdXBkYXRlTW9kZWxDb25maWdUb1ZlcnRleChmcm9tQ29uZmlnLCB0b09iamVjdCkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBkZWxldGVNb2RlbFBhcmFtZXRlcnNUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29uZmlnJ10sIGZyb21Db25maWcpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjb3VudFRva2Vuc0NvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVN5c3RlbUluc3RydWN0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc3lzdGVtSW5zdHJ1Y3Rpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc3lzdGVtSW5zdHJ1Y3Rpb24nXSwgY29udGVudFRvVmVydGV4KHRDb250ZW50KGZyb21TeXN0ZW1JbnN0cnVjdGlvbikpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvb2xzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b29scyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRvb2xzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21Ub29scztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b29sVG9WZXJ0ZXgoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsndG9vbHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdlbmVyYXRpb25Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdnZW5lcmF0aW9uQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUdlbmVyYXRpb25Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnZ2VuZXJhdGlvbkNvbmZpZyddLCBmcm9tR2VuZXJhdGlvbkNvbmZpZyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNvdW50VG9rZW5zUGFyYW1ldGVyc1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICdtb2RlbCddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbnRlbnRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb250ZW50cyddKTtcbiAgICBpZiAoZnJvbUNvbnRlbnRzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IHRDb250ZW50cyhmcm9tQ29udGVudHMpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnRUb1ZlcnRleChpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbnRlbnRzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbmZpZyddLCBjb3VudFRva2Vuc0NvbmZpZ1RvVmVydGV4KGZyb21Db25maWcsIHRvT2JqZWN0KSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVUb2tlbnNQYXJhbWV0ZXJzVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29udGVudHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbnRlbnRzJ10pO1xuICAgIGlmIChmcm9tQ29udGVudHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gdENvbnRlbnRzKGZyb21Db250ZW50cyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGVudFRvVmVydGV4KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29udGVudHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29uZmlnJ10sIGZyb21Db25maWcpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB2aWRlb1RvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21VcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3VyaSddKTtcbiAgICBpZiAoZnJvbVVyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2djc1VyaSddLCBmcm9tVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVZpZGVvQnl0ZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZpZGVvQnl0ZXMnXSk7XG4gICAgaWYgKGZyb21WaWRlb0J5dGVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYnl0ZXNCYXNlNjRFbmNvZGVkJ10sIHRCeXRlcyhmcm9tVmlkZW9CeXRlcykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVZpZGVvc0NvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU51bWJlck9mVmlkZW9zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbnVtYmVyT2ZWaWRlb3MnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTnVtYmVyT2ZWaWRlb3MgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdzYW1wbGVDb3VudCddLCBmcm9tTnVtYmVyT2ZWaWRlb3MpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0R2NzVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydvdXRwdXRHY3NVcmknXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21PdXRwdXRHY3NVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdzdG9yYWdlVXJpJ10sIGZyb21PdXRwdXRHY3NVcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnBzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmcHMnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21GcHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdmcHMnXSwgZnJvbUZwcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EdXJhdGlvblNlY29uZHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdkdXJhdGlvblNlY29uZHMnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRHVyYXRpb25TZWNvbmRzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnZHVyYXRpb25TZWNvbmRzJ10sIGZyb21EdXJhdGlvblNlY29uZHMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2VlZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc2VlZCddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVNlZWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdzZWVkJ10sIGZyb21TZWVkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUFzcGVjdFJhdGlvID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhc3BlY3RSYXRpbyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUFzcGVjdFJhdGlvICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnYXNwZWN0UmF0aW8nXSwgZnJvbUFzcGVjdFJhdGlvKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc29sdXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Jlc29sdXRpb24nXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21SZXNvbHV0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAncmVzb2x1dGlvbiddLCBmcm9tUmVzb2x1dGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QZXJzb25HZW5lcmF0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncGVyc29uR2VuZXJhdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QZXJzb25HZW5lcmF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAncGVyc29uR2VuZXJhdGlvbiddLCBmcm9tUGVyc29uR2VuZXJhdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QdWJzdWJUb3BpYyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncHVic3ViVG9waWMnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QdWJzdWJUb3BpYyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3B1YnN1YlRvcGljJ10sIGZyb21QdWJzdWJUb3BpYyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OZWdhdGl2ZVByb21wdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ25lZ2F0aXZlUHJvbXB0JyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU5lZ2F0aXZlUHJvbXB0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnbmVnYXRpdmVQcm9tcHQnXSwgZnJvbU5lZ2F0aXZlUHJvbXB0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuaGFuY2VQcm9tcHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdlbmhhbmNlUHJvbXB0JyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUVuaGFuY2VQcm9tcHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdlbmhhbmNlUHJvbXB0J10sIGZyb21FbmhhbmNlUHJvbXB0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdlbmVyYXRlQXVkaW8gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdnZW5lcmF0ZUF1ZGlvJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUdlbmVyYXRlQXVkaW8gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdnZW5lcmF0ZUF1ZGlvJ10sIGZyb21HZW5lcmF0ZUF1ZGlvKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxhc3RGcmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGFzdEZyYW1lJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTGFzdEZyYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICdsYXN0RnJhbWUnXSwgaW1hZ2VUb1ZlcnRleChmcm9tTGFzdEZyYW1lKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db21wcmVzc2lvblF1YWxpdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjb21wcmVzc2lvblF1YWxpdHknLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQ29tcHJlc3Npb25RdWFsaXR5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnY29tcHJlc3Npb25RdWFsaXR5J10sIGZyb21Db21wcmVzc2lvblF1YWxpdHkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVZpZGVvc1BhcmFtZXRlcnNUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbW9kZWwnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Qcm9tcHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Byb21wdCddKTtcbiAgICBpZiAoZnJvbVByb21wdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICdwcm9tcHQnXSwgZnJvbVByb21wdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbWFnZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW1hZ2UnXSk7XG4gICAgaWYgKGZyb21JbWFnZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICdpbWFnZSddLCBpbWFnZVRvVmVydGV4KGZyb21JbWFnZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVmlkZW8gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZpZGVvJ10pO1xuICAgIGlmIChmcm9tVmlkZW8gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAndmlkZW8nXSwgdmlkZW9Ub1ZlcnRleChmcm9tVmlkZW8pKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29uZmlnJ10sIGdlbmVyYXRlVmlkZW9zQ29uZmlnVG9WZXJ0ZXgoZnJvbUNvbmZpZywgdG9PYmplY3QpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdmlkZW9NZXRhZGF0YUZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRnBzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmcHMnXSk7XG4gICAgaWYgKGZyb21GcHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmcHMnXSwgZnJvbUZwcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmRPZmZzZXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VuZE9mZnNldCddKTtcbiAgICBpZiAoZnJvbUVuZE9mZnNldCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VuZE9mZnNldCddLCBmcm9tRW5kT2Zmc2V0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN0YXJ0T2Zmc2V0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzdGFydE9mZnNldCddKTtcbiAgICBpZiAoZnJvbVN0YXJ0T2Zmc2V0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3RhcnRPZmZzZXQnXSwgZnJvbVN0YXJ0T2Zmc2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gYmxvYkZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGF0YSddKTtcbiAgICBpZiAoZnJvbURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkYXRhJ10sIGZyb21EYXRhKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZmlsZURhdGFGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZpbGVVcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVVcmknXSk7XG4gICAgaWYgKGZyb21GaWxlVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmlsZVVyaSddLCBmcm9tRmlsZVVyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHBhcnRGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVZpZGVvTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd2aWRlb01ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVZpZGVvTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2aWRlb01ldGFkYXRhJ10sIHZpZGVvTWV0YWRhdGFGcm9tTWxkZXYoZnJvbVZpZGVvTWV0YWRhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRob3VnaHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rob3VnaHQnXSk7XG4gICAgaWYgKGZyb21UaG91Z2h0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhvdWdodCddLCBmcm9tVGhvdWdodCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbmxpbmVEYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbmxpbmVEYXRhJ10pO1xuICAgIGlmIChmcm9tSW5saW5lRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2lubGluZURhdGEnXSwgYmxvYkZyb21NbGRldihmcm9tSW5saW5lRGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsZURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVEYXRhJ10pO1xuICAgIGlmIChmcm9tRmlsZURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWxlRGF0YSddLCBmaWxlRGF0YUZyb21NbGRldihmcm9tRmlsZURhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRob3VnaHRTaWduYXR1cmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0aG91Z2h0U2lnbmF0dXJlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRob3VnaHRTaWduYXR1cmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aG91Z2h0U2lnbmF0dXJlJ10sIGZyb21UaG91Z2h0U2lnbmF0dXJlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjb2RlRXhlY3V0aW9uUmVzdWx0JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb2RlRXhlY3V0aW9uUmVzdWx0J10sIGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUV4ZWN1dGFibGVDb2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZXhlY3V0YWJsZUNvZGUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRXhlY3V0YWJsZUNvZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydleGVjdXRhYmxlQ29kZSddLCBmcm9tRXhlY3V0YWJsZUNvZGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnVuY3Rpb25DYWxsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmdW5jdGlvbkNhbGwnXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvbkNhbGwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvbkNhbGwnXSwgZnJvbUZ1bmN0aW9uQ2FsbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GdW5jdGlvblJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZnVuY3Rpb25SZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvblJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25SZXNwb25zZSddLCBmcm9tRnVuY3Rpb25SZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UZXh0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0ZXh0J10pO1xuICAgIGlmIChmcm9tVGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RleHQnXSwgZnJvbVRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjb250ZW50RnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21QYXJ0cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFydHMnXSk7XG4gICAgaWYgKGZyb21QYXJ0cyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tUGFydHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFydEZyb21NbGRldihpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BhcnRzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Sb2xlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyb2xlJ10pO1xuICAgIGlmIChmcm9tUm9sZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JvbGUnXSwgZnJvbVJvbGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjaXRhdGlvbk1ldGFkYXRhRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21DaXRhdGlvbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NpdGF0aW9uU291cmNlcyddKTtcbiAgICBpZiAoZnJvbUNpdGF0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NpdGF0aW9ucyddLCBmcm9tQ2l0YXRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdXJsTWV0YWRhdGFGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVJldHJpZXZlZFVybCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmV0cmlldmVkVXJsJ10pO1xuICAgIGlmIChmcm9tUmV0cmlldmVkVXJsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmV0cmlldmVkVXJsJ10sIGZyb21SZXRyaWV2ZWRVcmwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXJsUmV0cmlldmFsU3RhdHVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndXJsUmV0cmlldmFsU3RhdHVzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVVybFJldHJpZXZhbFN0YXR1cyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VybFJldHJpZXZhbFN0YXR1cyddLCBmcm9tVXJsUmV0cmlldmFsU3RhdHVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdXJsQ29udGV4dE1ldGFkYXRhRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21VcmxNZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndXJsTWV0YWRhdGEnXSk7XG4gICAgaWYgKGZyb21VcmxNZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tVXJsTWV0YWRhdGE7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdXJsTWV0YWRhdGFGcm9tTWxkZXYoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1cmxNZXRhZGF0YSddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjYW5kaWRhdGVGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUNvbnRlbnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbnRlbnQnXSk7XG4gICAgaWYgKGZyb21Db250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29udGVudCddLCBjb250ZW50RnJvbU1sZGV2KGZyb21Db250ZW50KSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DaXRhdGlvbk1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY2l0YXRpb25NZXRhZGF0YScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21DaXRhdGlvbk1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2l0YXRpb25NZXRhZGF0YSddLCBjaXRhdGlvbk1ldGFkYXRhRnJvbU1sZGV2KGZyb21DaXRhdGlvbk1ldGFkYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub2tlbkNvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b2tlbkNvdW50J10pO1xuICAgIGlmIChmcm9tVG9rZW5Db3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rva2VuQ291bnQnXSwgZnJvbVRva2VuQ291bnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmluaXNoUmVhc29uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaW5pc2hSZWFzb24nXSk7XG4gICAgaWYgKGZyb21GaW5pc2hSZWFzb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaW5pc2hSZWFzb24nXSwgZnJvbUZpbmlzaFJlYXNvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21VcmxDb250ZXh0TWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd1cmxDb250ZXh0TWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVXJsQ29udGV4dE1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXJsQ29udGV4dE1ldGFkYXRhJ10sIHVybENvbnRleHRNZXRhZGF0YUZyb21NbGRldihmcm9tVXJsQ29udGV4dE1ldGFkYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BdmdMb2dwcm9icyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXZnTG9ncHJvYnMnXSk7XG4gICAgaWYgKGZyb21BdmdMb2dwcm9icyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2F2Z0xvZ3Byb2JzJ10sIGZyb21BdmdMb2dwcm9icyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hcm91bmRpbmdNZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2dyb3VuZGluZ01ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUdyb3VuZGluZ01ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ3JvdW5kaW5nTWV0YWRhdGEnXSwgZnJvbUdyb3VuZGluZ01ldGFkYXRhKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUluZGV4ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbmRleCddKTtcbiAgICBpZiAoZnJvbUluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5kZXgnXSwgZnJvbUluZGV4KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxvZ3Byb2JzUmVzdWx0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbG9ncHJvYnNSZXN1bHQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTG9ncHJvYnNSZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsb2dwcm9ic1Jlc3VsdCddLCBmcm9tTG9ncHJvYnNSZXN1bHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2FmZXR5UmF0aW5ncyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NhZmV0eVJhdGluZ3MnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2FmZXR5UmF0aW5ncyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NhZmV0eVJhdGluZ3MnXSwgZnJvbVNhZmV0eVJhdGluZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZUNvbnRlbnRSZXNwb25zZUZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQ2FuZGlkYXRlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY2FuZGlkYXRlcyddKTtcbiAgICBpZiAoZnJvbUNhbmRpZGF0ZXMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUNhbmRpZGF0ZXM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FuZGlkYXRlRnJvbU1sZGV2KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2FuZGlkYXRlcyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTW9kZWxWZXJzaW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbFZlcnNpb24nXSk7XG4gICAgaWYgKGZyb21Nb2RlbFZlcnNpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RlbFZlcnNpb24nXSwgZnJvbU1vZGVsVmVyc2lvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Qcm9tcHRGZWVkYmFjayA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Byb21wdEZlZWRiYWNrJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVByb21wdEZlZWRiYWNrICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncHJvbXB0RmVlZGJhY2snXSwgZnJvbVByb21wdEZlZWRiYWNrKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVzYWdlTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd1c2FnZU1ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVVzYWdlTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1c2FnZU1ldGFkYXRhJ10sIGZyb21Vc2FnZU1ldGFkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY29udGVudEVtYmVkZGluZ0Zyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVmFsdWVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd2YWx1ZXMnXSk7XG4gICAgaWYgKGZyb21WYWx1ZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2YWx1ZXMnXSwgZnJvbVZhbHVlcyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGVtYmVkQ29udGVudE1ldGFkYXRhRnJvbU1sZGV2KCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZW1iZWRDb250ZW50UmVzcG9uc2VGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUVtYmVkZGluZ3MgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VtYmVkZGluZ3MnXSk7XG4gICAgaWYgKGZyb21FbWJlZGRpbmdzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21FbWJlZGRpbmdzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnRFbWJlZGRpbmdGcm9tTWxkZXYoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbWJlZGRpbmdzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWV0YWRhdGEnXSk7XG4gICAgaWYgKGZyb21NZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21ldGFkYXRhJ10sIGVtYmVkQ29udGVudE1ldGFkYXRhRnJvbU1sZGV2KCkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBpbWFnZUZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tSW1hZ2VCeXRlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2J5dGVzQmFzZTY0RW5jb2RlZCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21JbWFnZUJ5dGVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW1hZ2VCeXRlcyddLCB0Qnl0ZXMoZnJvbUltYWdlQnl0ZXMpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gc2FmZXR5QXR0cmlidXRlc0Zyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQ2F0ZWdvcmllcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NhZmV0eUF0dHJpYnV0ZXMnLFxuICAgICAgICAnY2F0ZWdvcmllcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21DYXRlZ29yaWVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2F0ZWdvcmllcyddLCBmcm9tQ2F0ZWdvcmllcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TY29yZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzYWZldHlBdHRyaWJ1dGVzJyxcbiAgICAgICAgJ3Njb3JlcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TY29yZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzY29yZXMnXSwgZnJvbVNjb3Jlcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db250ZW50VHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29udGVudFR5cGUnXSk7XG4gICAgaWYgKGZyb21Db250ZW50VHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbnRlbnRUeXBlJ10sIGZyb21Db250ZW50VHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlZEltYWdlRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21JbWFnZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnX3NlbGYnXSk7XG4gICAgaWYgKGZyb21JbWFnZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ltYWdlJ10sIGltYWdlRnJvbU1sZGV2KGZyb21JbWFnZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmFpRmlsdGVyZWRSZWFzb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyYWlGaWx0ZXJlZFJlYXNvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SYWlGaWx0ZXJlZFJlYXNvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JhaUZpbHRlcmVkUmVhc29uJ10sIGZyb21SYWlGaWx0ZXJlZFJlYXNvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TYWZldHlBdHRyaWJ1dGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydfc2VsZiddKTtcbiAgICBpZiAoZnJvbVNhZmV0eUF0dHJpYnV0ZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzYWZldHlBdHRyaWJ1dGVzJ10sIHNhZmV0eUF0dHJpYnV0ZXNGcm9tTWxkZXYoZnJvbVNhZmV0eUF0dHJpYnV0ZXMpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVJbWFnZXNSZXNwb25zZUZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tR2VuZXJhdGVkSW1hZ2VzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJlZGljdGlvbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tR2VuZXJhdGVkSW1hZ2VzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21HZW5lcmF0ZWRJbWFnZXM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2VuZXJhdGVkSW1hZ2VGcm9tTWxkZXYoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnZW5lcmF0ZWRJbWFnZXMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBvc2l0aXZlUHJvbXB0U2FmZXR5QXR0cmlidXRlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Bvc2l0aXZlUHJvbXB0U2FmZXR5QXR0cmlidXRlcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Qb3NpdGl2ZVByb21wdFNhZmV0eUF0dHJpYnV0ZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwb3NpdGl2ZVByb21wdFNhZmV0eUF0dHJpYnV0ZXMnXSwgc2FmZXR5QXR0cmlidXRlc0Zyb21NbGRldihmcm9tUG9zaXRpdmVQcm9tcHRTYWZldHlBdHRyaWJ1dGVzKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHR1bmVkTW9kZWxJbmZvRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21CYXNlTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Jhc2VNb2RlbCddKTtcbiAgICBpZiAoZnJvbUJhc2VNb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Jhc2VNb2RlbCddLCBmcm9tQmFzZU1vZGVsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNyZWF0ZVRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NyZWF0ZVRpbWUnXSk7XG4gICAgaWYgKGZyb21DcmVhdGVUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY3JlYXRlVGltZSddLCBmcm9tQ3JlYXRlVGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21VcGRhdGVUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd1cGRhdGVUaW1lJ10pO1xuICAgIGlmIChmcm9tVXBkYXRlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VwZGF0ZVRpbWUnXSwgZnJvbVVwZGF0ZVRpbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBtb2RlbEZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURpc3BsYXlOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKTtcbiAgICBpZiAoZnJvbURpc3BsYXlOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGlzcGxheU5hbWUnXSwgZnJvbURpc3BsYXlOYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURlc2NyaXB0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkZXNjcmlwdGlvbiddKTtcbiAgICBpZiAoZnJvbURlc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGVzY3JpcHRpb24nXSwgZnJvbURlc2NyaXB0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVZlcnNpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZlcnNpb24nXSk7XG4gICAgaWYgKGZyb21WZXJzaW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndmVyc2lvbiddLCBmcm9tVmVyc2lvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UdW5lZE1vZGVsSW5mbyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnX3NlbGYnXSk7XG4gICAgaWYgKGZyb21UdW5lZE1vZGVsSW5mbyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3R1bmVkTW9kZWxJbmZvJ10sIHR1bmVkTW9kZWxJbmZvRnJvbU1sZGV2KGZyb21UdW5lZE1vZGVsSW5mbykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5wdXRUb2tlbkxpbWl0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnaW5wdXRUb2tlbkxpbWl0JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUlucHV0VG9rZW5MaW1pdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2lucHV0VG9rZW5MaW1pdCddLCBmcm9tSW5wdXRUb2tlbkxpbWl0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU91dHB1dFRva2VuTGltaXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdvdXRwdXRUb2tlbkxpbWl0JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU91dHB1dFRva2VuTGltaXQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydvdXRwdXRUb2tlbkxpbWl0J10sIGZyb21PdXRwdXRUb2tlbkxpbWl0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN1cHBvcnRlZEFjdGlvbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzdXBwb3J0ZWRHZW5lcmF0aW9uTWV0aG9kcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TdXBwb3J0ZWRBY3Rpb25zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3VwcG9ydGVkQWN0aW9ucyddLCBmcm9tU3VwcG9ydGVkQWN0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RNb2RlbHNSZXNwb25zZUZyb21NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OZXh0UGFnZVRva2VuID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbmV4dFBhZ2VUb2tlbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21OZXh0UGFnZVRva2VuICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmV4dFBhZ2VUb2tlbiddLCBmcm9tTmV4dFBhZ2VUb2tlbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Nb2RlbHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ19zZWxmJ10pO1xuICAgIGlmIChmcm9tTW9kZWxzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IHRFeHRyYWN0TW9kZWxzKGZyb21Nb2RlbHMpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vZGVsRnJvbU1sZGV2KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZWxzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGRlbGV0ZU1vZGVsUmVzcG9uc2VGcm9tTWxkZXYoKSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjb3VudFRva2Vuc1Jlc3BvbnNlRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Ub3RhbFRva2VucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG90YWxUb2tlbnMnXSk7XG4gICAgaWYgKGZyb21Ub3RhbFRva2VucyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RvdGFsVG9rZW5zJ10sIGZyb21Ub3RhbFRva2Vucyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DYWNoZWRDb250ZW50VG9rZW5Db3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NhY2hlZENvbnRlbnRUb2tlbkNvdW50JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNhY2hlZENvbnRlbnRUb2tlbkNvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2FjaGVkQ29udGVudFRva2VuQ291bnQnXSwgZnJvbUNhY2hlZENvbnRlbnRUb2tlbkNvdW50KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdmlkZW9Gcm9tTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd2aWRlbycsICd1cmknXSk7XG4gICAgaWYgKGZyb21VcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1cmknXSwgZnJvbVVyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21WaWRlb0J5dGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndmlkZW8nLFxuICAgICAgICAnZW5jb2RlZFZpZGVvJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVZpZGVvQnl0ZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2aWRlb0J5dGVzJ10sIHRCeXRlcyhmcm9tVmlkZW9CeXRlcykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VuY29kaW5nJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZWRWaWRlb0Zyb21NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21WaWRlbyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnX3NlbGYnXSk7XG4gICAgaWYgKGZyb21WaWRlbyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZpZGVvJ10sIHZpZGVvRnJvbU1sZGV2JDEoZnJvbVZpZGVvKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlVmlkZW9zUmVzcG9uc2VGcm9tTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tR2VuZXJhdGVkVmlkZW9zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ2VuZXJhdGVkU2FtcGxlcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21HZW5lcmF0ZWRWaWRlb3MgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUdlbmVyYXRlZFZpZGVvcztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZW5lcmF0ZWRWaWRlb0Zyb21NbGRldiQxKGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ2VuZXJhdGVkVmlkZW9zJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SYWlNZWRpYUZpbHRlcmVkQ291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyYWlNZWRpYUZpbHRlcmVkQ291bnQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmFpTWVkaWFGaWx0ZXJlZENvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmFpTWVkaWFGaWx0ZXJlZENvdW50J10sIGZyb21SYWlNZWRpYUZpbHRlcmVkQ291bnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmFpTWVkaWFGaWx0ZXJlZFJlYXNvbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyYWlNZWRpYUZpbHRlcmVkUmVhc29ucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SYWlNZWRpYUZpbHRlcmVkUmVhc29ucyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JhaU1lZGlhRmlsdGVyZWRSZWFzb25zJ10sIGZyb21SYWlNZWRpYUZpbHRlcmVkUmVhc29ucyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlVmlkZW9zT3BlcmF0aW9uRnJvbU1sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWV0YWRhdGEnXSk7XG4gICAgaWYgKGZyb21NZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21ldGFkYXRhJ10sIGZyb21NZXRhZGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Eb25lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkb25lJ10pO1xuICAgIGlmIChmcm9tRG9uZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2RvbmUnXSwgZnJvbURvbmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXJyb3IgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Vycm9yJ10pO1xuICAgIGlmIChmcm9tRXJyb3IgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlcnJvciddLCBmcm9tRXJyb3IpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZScsXG4gICAgICAgICdnZW5lcmF0ZVZpZGVvUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZSddLCBnZW5lcmF0ZVZpZGVvc1Jlc3BvbnNlRnJvbU1sZGV2JDEoZnJvbVJlc3BvbnNlKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHZpZGVvTWV0YWRhdGFGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21GcHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZwcyddKTtcbiAgICBpZiAoZnJvbUZwcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZwcyddLCBmcm9tRnBzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuZE9mZnNldCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW5kT2Zmc2V0J10pO1xuICAgIGlmIChmcm9tRW5kT2Zmc2V0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW5kT2Zmc2V0J10sIGZyb21FbmRPZmZzZXQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3RhcnRPZmZzZXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3N0YXJ0T2Zmc2V0J10pO1xuICAgIGlmIChmcm9tU3RhcnRPZmZzZXQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdGFydE9mZnNldCddLCBmcm9tU3RhcnRPZmZzZXQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBibG9iRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRGlzcGxheU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pO1xuICAgIGlmIChmcm9tRGlzcGxheU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkaXNwbGF5TmFtZSddLCBmcm9tRGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGF0YSddKTtcbiAgICBpZiAoZnJvbURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkYXRhJ10sIGZyb21EYXRhKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZmlsZURhdGFGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21EaXNwbGF5TmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSk7XG4gICAgaWYgKGZyb21EaXNwbGF5TmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10sIGZyb21EaXNwbGF5TmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWxlVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlVXJpJ10pO1xuICAgIGlmIChmcm9tRmlsZVVyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVVcmknXSwgZnJvbUZpbGVVcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBwYXJ0RnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVmlkZW9NZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ZpZGVvTWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVmlkZW9NZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZpZGVvTWV0YWRhdGEnXSwgdmlkZW9NZXRhZGF0YUZyb21WZXJ0ZXgoZnJvbVZpZGVvTWV0YWRhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRob3VnaHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rob3VnaHQnXSk7XG4gICAgaWYgKGZyb21UaG91Z2h0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhvdWdodCddLCBmcm9tVGhvdWdodCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbmxpbmVEYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbmxpbmVEYXRhJ10pO1xuICAgIGlmIChmcm9tSW5saW5lRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2lubGluZURhdGEnXSwgYmxvYkZyb21WZXJ0ZXgoZnJvbUlubGluZURhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbGVEYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlRGF0YSddKTtcbiAgICBpZiAoZnJvbUZpbGVEYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmlsZURhdGEnXSwgZmlsZURhdGFGcm9tVmVydGV4KGZyb21GaWxlRGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhvdWdodFNpZ25hdHVyZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Rob3VnaHRTaWduYXR1cmUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVGhvdWdodFNpZ25hdHVyZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rob3VnaHRTaWduYXR1cmUnXSwgZnJvbVRob3VnaHRTaWduYXR1cmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NvZGVFeGVjdXRpb25SZXN1bHQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvZGVFeGVjdXRpb25SZXN1bHQnXSwgZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXhlY3V0YWJsZUNvZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdleGVjdXRhYmxlQ29kZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FeGVjdXRhYmxlQ29kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2V4ZWN1dGFibGVDb2RlJ10sIGZyb21FeGVjdXRhYmxlQ29kZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GdW5jdGlvbkNhbGwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Z1bmN0aW9uQ2FsbCddKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uQ2FsbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uQ2FsbCddLCBmcm9tRnVuY3Rpb25DYWxsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvblJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvblJlc3BvbnNlJ10sIGZyb21GdW5jdGlvblJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRleHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RleHQnXSk7XG4gICAgaWYgKGZyb21UZXh0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGV4dCddLCBmcm9tVGV4dCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNvbnRlbnRGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21QYXJ0cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFydHMnXSk7XG4gICAgaWYgKGZyb21QYXJ0cyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tUGFydHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFydEZyb21WZXJ0ZXgoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJ0cyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUm9sZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncm9sZSddKTtcbiAgICBpZiAoZnJvbVJvbGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyb2xlJ10sIGZyb21Sb2xlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY2l0YXRpb25NZXRhZGF0YUZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUNpdGF0aW9ucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY2l0YXRpb25zJ10pO1xuICAgIGlmIChmcm9tQ2l0YXRpb25zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2l0YXRpb25zJ10sIGZyb21DaXRhdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB1cmxNZXRhZGF0YUZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVJldHJpZXZlZFVybCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmV0cmlldmVkVXJsJ10pO1xuICAgIGlmIChmcm9tUmV0cmlldmVkVXJsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmV0cmlldmVkVXJsJ10sIGZyb21SZXRyaWV2ZWRVcmwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXJsUmV0cmlldmFsU3RhdHVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndXJsUmV0cmlldmFsU3RhdHVzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVVybFJldHJpZXZhbFN0YXR1cyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VybFJldHJpZXZhbFN0YXR1cyddLCBmcm9tVXJsUmV0cmlldmFsU3RhdHVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdXJsQ29udGV4dE1ldGFkYXRhRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVXJsTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3VybE1ldGFkYXRhJ10pO1xuICAgIGlmIChmcm9tVXJsTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVVybE1ldGFkYXRhO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVybE1ldGFkYXRhRnJvbVZlcnRleChpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VybE1ldGFkYXRhJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNhbmRpZGF0ZUZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUNvbnRlbnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbnRlbnQnXSk7XG4gICAgaWYgKGZyb21Db250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29udGVudCddLCBjb250ZW50RnJvbVZlcnRleChmcm9tQ29udGVudCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2l0YXRpb25NZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NpdGF0aW9uTWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ2l0YXRpb25NZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NpdGF0aW9uTWV0YWRhdGEnXSwgY2l0YXRpb25NZXRhZGF0YUZyb21WZXJ0ZXgoZnJvbUNpdGF0aW9uTWV0YWRhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbmlzaE1lc3NhZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmaW5pc2hNZXNzYWdlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZpbmlzaE1lc3NhZ2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaW5pc2hNZXNzYWdlJ10sIGZyb21GaW5pc2hNZXNzYWdlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbmlzaFJlYXNvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmluaXNoUmVhc29uJ10pO1xuICAgIGlmIChmcm9tRmluaXNoUmVhc29uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmluaXNoUmVhc29uJ10sIGZyb21GaW5pc2hSZWFzb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXJsQ29udGV4dE1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndXJsQ29udGV4dE1ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVVybENvbnRleHRNZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VybENvbnRleHRNZXRhZGF0YSddLCB1cmxDb250ZXh0TWV0YWRhdGFGcm9tVmVydGV4KGZyb21VcmxDb250ZXh0TWV0YWRhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUF2Z0xvZ3Byb2JzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhdmdMb2dwcm9icyddKTtcbiAgICBpZiAoZnJvbUF2Z0xvZ3Byb2JzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYXZnTG9ncHJvYnMnXSwgZnJvbUF2Z0xvZ3Byb2JzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdyb3VuZGluZ01ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ3JvdW5kaW5nTWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tR3JvdW5kaW5nTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydncm91bmRpbmdNZXRhZGF0YSddLCBmcm9tR3JvdW5kaW5nTWV0YWRhdGEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5kZXggPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2luZGV4J10pO1xuICAgIGlmIChmcm9tSW5kZXggIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbmRleCddLCBmcm9tSW5kZXgpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTG9ncHJvYnNSZXN1bHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdsb2dwcm9ic1Jlc3VsdCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Mb2dwcm9ic1Jlc3VsdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2xvZ3Byb2JzUmVzdWx0J10sIGZyb21Mb2dwcm9ic1Jlc3VsdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TYWZldHlSYXRpbmdzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2FmZXR5UmF0aW5ncycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TYWZldHlSYXRpbmdzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2FmZXR5UmF0aW5ncyddLCBmcm9tU2FmZXR5UmF0aW5ncyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlQ29udGVudFJlc3BvbnNlRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQ2FuZGlkYXRlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY2FuZGlkYXRlcyddKTtcbiAgICBpZiAoZnJvbUNhbmRpZGF0ZXMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUNhbmRpZGF0ZXM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FuZGlkYXRlRnJvbVZlcnRleChpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NhbmRpZGF0ZXMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNyZWF0ZVRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NyZWF0ZVRpbWUnXSk7XG4gICAgaWYgKGZyb21DcmVhdGVUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY3JlYXRlVGltZSddLCBmcm9tQ3JlYXRlVGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZUlkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXNwb25zZUlkJ10pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VJZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlSWQnXSwgZnJvbVJlc3BvbnNlSWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTW9kZWxWZXJzaW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbFZlcnNpb24nXSk7XG4gICAgaWYgKGZyb21Nb2RlbFZlcnNpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RlbFZlcnNpb24nXSwgZnJvbU1vZGVsVmVyc2lvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Qcm9tcHRGZWVkYmFjayA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Byb21wdEZlZWRiYWNrJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVByb21wdEZlZWRiYWNrICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncHJvbXB0RmVlZGJhY2snXSwgZnJvbVByb21wdEZlZWRiYWNrKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVzYWdlTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd1c2FnZU1ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVVzYWdlTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1c2FnZU1ldGFkYXRhJ10sIGZyb21Vc2FnZU1ldGFkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY29udGVudEVtYmVkZGluZ1N0YXRpc3RpY3NGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21UcnVuY2F0ZWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RydW5jYXRlZCddKTtcbiAgICBpZiAoZnJvbVRydW5jYXRlZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RydW5jYXRlZCddLCBmcm9tVHJ1bmNhdGVkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRva2VuQ291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rva2VuX2NvdW50J10pO1xuICAgIGlmIChmcm9tVG9rZW5Db3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rva2VuQ291bnQnXSwgZnJvbVRva2VuQ291bnQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjb250ZW50RW1iZWRkaW5nRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVmFsdWVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd2YWx1ZXMnXSk7XG4gICAgaWYgKGZyb21WYWx1ZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2YWx1ZXMnXSwgZnJvbVZhbHVlcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TdGF0aXN0aWNzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzdGF0aXN0aWNzJ10pO1xuICAgIGlmIChmcm9tU3RhdGlzdGljcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0YXRpc3RpY3MnXSwgY29udGVudEVtYmVkZGluZ1N0YXRpc3RpY3NGcm9tVmVydGV4KGZyb21TdGF0aXN0aWNzKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGVtYmVkQ29udGVudE1ldGFkYXRhRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQmlsbGFibGVDaGFyYWN0ZXJDb3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2JpbGxhYmxlQ2hhcmFjdGVyQ291bnQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQmlsbGFibGVDaGFyYWN0ZXJDb3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2JpbGxhYmxlQ2hhcmFjdGVyQ291bnQnXSwgZnJvbUJpbGxhYmxlQ2hhcmFjdGVyQ291bnQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBlbWJlZENvbnRlbnRSZXNwb25zZUZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUVtYmVkZGluZ3MgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcmVkaWN0aW9uc1tdJyxcbiAgICAgICAgJ2VtYmVkZGluZ3MnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRW1iZWRkaW5ncyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tRW1iZWRkaW5ncztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZW50RW1iZWRkaW5nRnJvbVZlcnRleChpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VtYmVkZGluZ3MnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtZXRhZGF0YSddKTtcbiAgICBpZiAoZnJvbU1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWV0YWRhdGEnXSwgZW1iZWRDb250ZW50TWV0YWRhdGFGcm9tVmVydGV4KGZyb21NZXRhZGF0YSkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBpbWFnZUZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUdjc1VyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ2NzVXJpJ10pO1xuICAgIGlmIChmcm9tR2NzVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ2NzVXJpJ10sIGZyb21HY3NVcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW1hZ2VCeXRlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2J5dGVzQmFzZTY0RW5jb2RlZCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21JbWFnZUJ5dGVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW1hZ2VCeXRlcyddLCB0Qnl0ZXMoZnJvbUltYWdlQnl0ZXMpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gc2FmZXR5QXR0cmlidXRlc0Zyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUNhdGVnb3JpZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzYWZldHlBdHRyaWJ1dGVzJyxcbiAgICAgICAgJ2NhdGVnb3JpZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ2F0ZWdvcmllcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NhdGVnb3JpZXMnXSwgZnJvbUNhdGVnb3JpZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2NvcmVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2FmZXR5QXR0cmlidXRlcycsXG4gICAgICAgICdzY29yZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2NvcmVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2NvcmVzJ10sIGZyb21TY29yZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29udGVudFR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbnRlbnRUeXBlJ10pO1xuICAgIGlmIChmcm9tQ29udGVudFR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb250ZW50VHlwZSddLCBmcm9tQ29udGVudFR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZWRJbWFnZUZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUltYWdlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydfc2VsZiddKTtcbiAgICBpZiAoZnJvbUltYWdlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW1hZ2UnXSwgaW1hZ2VGcm9tVmVydGV4KGZyb21JbWFnZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmFpRmlsdGVyZWRSZWFzb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyYWlGaWx0ZXJlZFJlYXNvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SYWlGaWx0ZXJlZFJlYXNvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JhaUZpbHRlcmVkUmVhc29uJ10sIGZyb21SYWlGaWx0ZXJlZFJlYXNvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TYWZldHlBdHRyaWJ1dGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydfc2VsZiddKTtcbiAgICBpZiAoZnJvbVNhZmV0eUF0dHJpYnV0ZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzYWZldHlBdHRyaWJ1dGVzJ10sIHNhZmV0eUF0dHJpYnV0ZXNGcm9tVmVydGV4KGZyb21TYWZldHlBdHRyaWJ1dGVzKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmhhbmNlZFByb21wdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncHJvbXB0J10pO1xuICAgIGlmIChmcm9tRW5oYW5jZWRQcm9tcHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmhhbmNlZFByb21wdCddLCBmcm9tRW5oYW5jZWRQcm9tcHQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZUltYWdlc1Jlc3BvbnNlRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tR2VuZXJhdGVkSW1hZ2VzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJlZGljdGlvbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tR2VuZXJhdGVkSW1hZ2VzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21HZW5lcmF0ZWRJbWFnZXM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2VuZXJhdGVkSW1hZ2VGcm9tVmVydGV4KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ2VuZXJhdGVkSW1hZ2VzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Qb3NpdGl2ZVByb21wdFNhZmV0eUF0dHJpYnV0ZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwb3NpdGl2ZVByb21wdFNhZmV0eUF0dHJpYnV0ZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUG9zaXRpdmVQcm9tcHRTYWZldHlBdHRyaWJ1dGVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncG9zaXRpdmVQcm9tcHRTYWZldHlBdHRyaWJ1dGVzJ10sIHNhZmV0eUF0dHJpYnV0ZXNGcm9tVmVydGV4KGZyb21Qb3NpdGl2ZVByb21wdFNhZmV0eUF0dHJpYnV0ZXMpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZWRpdEltYWdlUmVzcG9uc2VGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21HZW5lcmF0ZWRJbWFnZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcmVkaWN0aW9ucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21HZW5lcmF0ZWRJbWFnZXMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUdlbmVyYXRlZEltYWdlcztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZW5lcmF0ZWRJbWFnZUZyb21WZXJ0ZXgoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnZW5lcmF0ZWRJbWFnZXMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdXBzY2FsZUltYWdlUmVzcG9uc2VGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21HZW5lcmF0ZWRJbWFnZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcmVkaWN0aW9ucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21HZW5lcmF0ZWRJbWFnZXMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUdlbmVyYXRlZEltYWdlcztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZW5lcmF0ZWRJbWFnZUZyb21WZXJ0ZXgoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnZW5lcmF0ZWRJbWFnZXMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZW5kcG9pbnRGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbmRwb2ludCddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURlcGxveWVkTW9kZWxJZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2RlcGxveWVkTW9kZWxJZCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21EZXBsb3llZE1vZGVsSWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkZXBsb3llZE1vZGVsSWQnXSwgZnJvbURlcGxveWVkTW9kZWxJZCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHR1bmVkTW9kZWxJbmZvRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQmFzZU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbGFiZWxzJyxcbiAgICAgICAgJ2dvb2dsZS12ZXJ0ZXgtbGxtLXR1bmluZy1iYXNlLW1vZGVsLWlkJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUJhc2VNb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Jhc2VNb2RlbCddLCBmcm9tQmFzZU1vZGVsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNyZWF0ZVRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NyZWF0ZVRpbWUnXSk7XG4gICAgaWYgKGZyb21DcmVhdGVUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY3JlYXRlVGltZSddLCBmcm9tQ3JlYXRlVGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21VcGRhdGVUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd1cGRhdGVUaW1lJ10pO1xuICAgIGlmIChmcm9tVXBkYXRlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VwZGF0ZVRpbWUnXSwgZnJvbVVwZGF0ZVRpbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjaGVja3BvaW50RnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQ2hlY2twb2ludElkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjaGVja3BvaW50SWQnXSk7XG4gICAgaWYgKGZyb21DaGVja3BvaW50SWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjaGVja3BvaW50SWQnXSwgZnJvbUNoZWNrcG9pbnRJZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FcG9jaCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXBvY2gnXSk7XG4gICAgaWYgKGZyb21FcG9jaCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Vwb2NoJ10sIGZyb21FcG9jaCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TdGVwID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzdGVwJ10pO1xuICAgIGlmIChmcm9tU3RlcCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0ZXAnXSwgZnJvbVN0ZXApO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBtb2RlbEZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EaXNwbGF5TmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSk7XG4gICAgaWYgKGZyb21EaXNwbGF5TmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10sIGZyb21EaXNwbGF5TmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EZXNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGVzY3JpcHRpb24nXSk7XG4gICAgaWYgKGZyb21EZXNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10sIGZyb21EZXNjcmlwdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21WZXJzaW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd2ZXJzaW9uSWQnXSk7XG4gICAgaWYgKGZyb21WZXJzaW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndmVyc2lvbiddLCBmcm9tVmVyc2lvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmRwb2ludHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2RlcGxveWVkTW9kZWxzJ10pO1xuICAgIGlmIChmcm9tRW5kcG9pbnRzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21FbmRwb2ludHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5kcG9pbnRGcm9tVmVydGV4KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW5kcG9pbnRzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21MYWJlbHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhYmVscyddKTtcbiAgICBpZiAoZnJvbUxhYmVscyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2xhYmVscyddLCBmcm9tTGFiZWxzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVR1bmVkTW9kZWxJbmZvID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydfc2VsZiddKTtcbiAgICBpZiAoZnJvbVR1bmVkTW9kZWxJbmZvICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndHVuZWRNb2RlbEluZm8nXSwgdHVuZWRNb2RlbEluZm9Gcm9tVmVydGV4KGZyb21UdW5lZE1vZGVsSW5mbykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGVmYXVsdENoZWNrcG9pbnRJZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2RlZmF1bHRDaGVja3BvaW50SWQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRGVmYXVsdENoZWNrcG9pbnRJZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2RlZmF1bHRDaGVja3BvaW50SWQnXSwgZnJvbURlZmF1bHRDaGVja3BvaW50SWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2hlY2twb2ludHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NoZWNrcG9pbnRzJ10pO1xuICAgIGlmIChmcm9tQ2hlY2twb2ludHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUNoZWNrcG9pbnRzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoZWNrcG9pbnRGcm9tVmVydGV4KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2hlY2twb2ludHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdE1vZGVsc1Jlc3BvbnNlRnJvbVZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OZXh0UGFnZVRva2VuID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbmV4dFBhZ2VUb2tlbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21OZXh0UGFnZVRva2VuICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmV4dFBhZ2VUb2tlbiddLCBmcm9tTmV4dFBhZ2VUb2tlbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Nb2RlbHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ19zZWxmJ10pO1xuICAgIGlmIChmcm9tTW9kZWxzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IHRFeHRyYWN0TW9kZWxzKGZyb21Nb2RlbHMpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vZGVsRnJvbVZlcnRleChpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21vZGVscyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBkZWxldGVNb2RlbFJlc3BvbnNlRnJvbVZlcnRleCgpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNvdW50VG9rZW5zUmVzcG9uc2VGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Ub3RhbFRva2VucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG90YWxUb2tlbnMnXSk7XG4gICAgaWYgKGZyb21Ub3RhbFRva2VucyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RvdGFsVG9rZW5zJ10sIGZyb21Ub3RhbFRva2Vucyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVUb2tlbnNSZXNwb25zZUZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVRva2Vuc0luZm8gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rva2Vuc0luZm8nXSk7XG4gICAgaWYgKGZyb21Ub2tlbnNJbmZvICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG9rZW5zSW5mbyddLCBmcm9tVG9rZW5zSW5mbyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHZpZGVvRnJvbVZlcnRleCQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21VcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2djc1VyaSddKTtcbiAgICBpZiAoZnJvbVVyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VyaSddLCBmcm9tVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVZpZGVvQnl0ZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdieXRlc0Jhc2U2NEVuY29kZWQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVmlkZW9CeXRlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZpZGVvQnl0ZXMnXSwgdEJ5dGVzKGZyb21WaWRlb0J5dGVzKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlZFZpZGVvRnJvbVZlcnRleCQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21WaWRlbyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnX3NlbGYnXSk7XG4gICAgaWYgKGZyb21WaWRlbyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZpZGVvJ10sIHZpZGVvRnJvbVZlcnRleCQxKGZyb21WaWRlbykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVZpZGVvc1Jlc3BvbnNlRnJvbVZlcnRleCQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21HZW5lcmF0ZWRWaWRlb3MgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZpZGVvcyddKTtcbiAgICBpZiAoZnJvbUdlbmVyYXRlZFZpZGVvcyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tR2VuZXJhdGVkVmlkZW9zO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdlbmVyYXRlZFZpZGVvRnJvbVZlcnRleCQxKGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ2VuZXJhdGVkVmlkZW9zJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SYWlNZWRpYUZpbHRlcmVkQ291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyYWlNZWRpYUZpbHRlcmVkQ291bnQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmFpTWVkaWFGaWx0ZXJlZENvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmFpTWVkaWFGaWx0ZXJlZENvdW50J10sIGZyb21SYWlNZWRpYUZpbHRlcmVkQ291bnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmFpTWVkaWFGaWx0ZXJlZFJlYXNvbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyYWlNZWRpYUZpbHRlcmVkUmVhc29ucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SYWlNZWRpYUZpbHRlcmVkUmVhc29ucyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JhaU1lZGlhRmlsdGVyZWRSZWFzb25zJ10sIGZyb21SYWlNZWRpYUZpbHRlcmVkUmVhc29ucyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlVmlkZW9zT3BlcmF0aW9uRnJvbVZlcnRleCQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21ldGFkYXRhJ10pO1xuICAgIGlmIChmcm9tTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtZXRhZGF0YSddLCBmcm9tTWV0YWRhdGEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRG9uZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZG9uZSddKTtcbiAgICBpZiAoZnJvbURvbmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkb25lJ10sIGZyb21Eb25lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVycm9yID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlcnJvciddKTtcbiAgICBpZiAoZnJvbUVycm9yICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXJyb3InXSwgZnJvbUVycm9yKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXNwb25zZSddKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2UnXSwgZ2VuZXJhdGVWaWRlb3NSZXNwb25zZUZyb21WZXJ0ZXgkMShmcm9tUmVzcG9uc2UpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5jb25zdCBDT05URU5UX1RZUEVfSEVBREVSID0gJ0NvbnRlbnQtVHlwZSc7XG5jb25zdCBTRVJWRVJfVElNRU9VVF9IRUFERVIgPSAnWC1TZXJ2ZXItVGltZW91dCc7XG5jb25zdCBVU0VSX0FHRU5UX0hFQURFUiA9ICdVc2VyLUFnZW50JztcbmNvbnN0IEdPT0dMRV9BUElfQ0xJRU5UX0hFQURFUiA9ICd4LWdvb2ctYXBpLWNsaWVudCc7XG5jb25zdCBTREtfVkVSU0lPTiA9ICcxLjcuMCc7IC8vIHgtcmVsZWFzZS1wbGVhc2UtdmVyc2lvblxuY29uc3QgTElCUkFSWV9MQUJFTCA9IGBnb29nbGUtZ2VuYWktc2RrLyR7U0RLX1ZFUlNJT059YDtcbmNvbnN0IFZFUlRFWF9BSV9BUElfREVGQVVMVF9WRVJTSU9OID0gJ3YxYmV0YTEnO1xuY29uc3QgR09PR0xFX0FJX0FQSV9ERUZBVUxUX1ZFUlNJT04gPSAndjFiZXRhJztcbmNvbnN0IHJlc3BvbnNlTGluZVJFID0gL15kYXRhOiAoLiopKD86XFxuXFxufFxcclxccnxcXHJcXG5cXHJcXG4pLztcbi8qKlxuICogVGhlIEFwaUNsaWVudCBjbGFzcyBpcyB1c2VkIHRvIHNlbmQgcmVxdWVzdHMgdG8gdGhlIEdlbWluaSBBUEkgb3IgVmVydGV4IEFJXG4gKiBlbmRwb2ludHMuXG4gKi9cbmNsYXNzIEFwaUNsaWVudCB7XG4gICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB0aGlzLmNsaWVudE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdHMpLCB7IHByb2plY3Q6IG9wdHMucHJvamVjdCwgbG9jYXRpb246IG9wdHMubG9jYXRpb24sIGFwaUtleTogb3B0cy5hcGlLZXksIHZlcnRleGFpOiBvcHRzLnZlcnRleGFpIH0pO1xuICAgICAgICBjb25zdCBpbml0SHR0cE9wdGlvbnMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuY2xpZW50T3B0aW9ucy52ZXJ0ZXhhaSkge1xuICAgICAgICAgICAgaW5pdEh0dHBPcHRpb25zLmFwaVZlcnNpb24gPVxuICAgICAgICAgICAgICAgIChfYSA9IHRoaXMuY2xpZW50T3B0aW9ucy5hcGlWZXJzaW9uKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBWRVJURVhfQUlfQVBJX0RFRkFVTFRfVkVSU0lPTjtcbiAgICAgICAgICAgIGluaXRIdHRwT3B0aW9ucy5iYXNlVXJsID0gdGhpcy5iYXNlVXJsRnJvbVByb2plY3RMb2NhdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5ub3JtYWxpemVBdXRoUGFyYW1ldGVycygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gR2VtaW5pIEFQSVxuICAgICAgICAgICAgaW5pdEh0dHBPcHRpb25zLmFwaVZlcnNpb24gPVxuICAgICAgICAgICAgICAgIChfYiA9IHRoaXMuY2xpZW50T3B0aW9ucy5hcGlWZXJzaW9uKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBHT09HTEVfQUlfQVBJX0RFRkFVTFRfVkVSU0lPTjtcbiAgICAgICAgICAgIGluaXRIdHRwT3B0aW9ucy5iYXNlVXJsID0gYGh0dHBzOi8vZ2VuZXJhdGl2ZWxhbmd1YWdlLmdvb2dsZWFwaXMuY29tL2A7XG4gICAgICAgIH1cbiAgICAgICAgaW5pdEh0dHBPcHRpb25zLmhlYWRlcnMgPSB0aGlzLmdldERlZmF1bHRIZWFkZXJzKCk7XG4gICAgICAgIHRoaXMuY2xpZW50T3B0aW9ucy5odHRwT3B0aW9ucyA9IGluaXRIdHRwT3B0aW9ucztcbiAgICAgICAgaWYgKG9wdHMuaHR0cE9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuY2xpZW50T3B0aW9ucy5odHRwT3B0aW9ucyA9IHRoaXMucGF0Y2hIdHRwT3B0aW9ucyhpbml0SHR0cE9wdGlvbnMsIG9wdHMuaHR0cE9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgdGhlIGJhc2UgVVJMIGZvciBWZXJ0ZXggQUkgYmFzZWQgb24gcHJvamVjdCBhbmQgbG9jYXRpb24uXG4gICAgICogVXNlcyB0aGUgZ2xvYmFsIGVuZHBvaW50IGlmIGxvY2F0aW9uIGlzICdnbG9iYWwnIG9yIGlmIHByb2plY3QvbG9jYXRpb25cbiAgICAgKiBhcmUgbm90IHNwZWNpZmllZCAoaW1wbHlpbmcgQVBJIGtleSB1c2FnZSkuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBiYXNlVXJsRnJvbVByb2plY3RMb2NhdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xpZW50T3B0aW9ucy5wcm9qZWN0ICYmXG4gICAgICAgICAgICB0aGlzLmNsaWVudE9wdGlvbnMubG9jYXRpb24gJiZcbiAgICAgICAgICAgIHRoaXMuY2xpZW50T3B0aW9ucy5sb2NhdGlvbiAhPT0gJ2dsb2JhbCcpIHtcbiAgICAgICAgICAgIC8vIFJlZ2lvbmFsIGVuZHBvaW50XG4gICAgICAgICAgICByZXR1cm4gYGh0dHBzOi8vJHt0aGlzLmNsaWVudE9wdGlvbnMubG9jYXRpb259LWFpcGxhdGZvcm0uZ29vZ2xlYXBpcy5jb20vYDtcbiAgICAgICAgfVxuICAgICAgICAvLyBHbG9iYWwgZW5kcG9pbnQgKGNvdmVycyAnZ2xvYmFsJyBsb2NhdGlvbiBhbmQgQVBJIGtleSB1c2FnZSlcbiAgICAgICAgcmV0dXJuIGBodHRwczovL2FpcGxhdGZvcm0uZ29vZ2xlYXBpcy5jb20vYDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTm9ybWFsaXplcyBhdXRoZW50aWNhdGlvbiBwYXJhbWV0ZXJzIGZvciBWZXJ0ZXggQUkuXG4gICAgICogSWYgcHJvamVjdCBhbmQgbG9jYXRpb24gYXJlIHByb3ZpZGVkLCBBUEkga2V5IGlzIGNsZWFyZWQuXG4gICAgICogSWYgcHJvamVjdCBhbmQgbG9jYXRpb24gYXJlIG5vdCBwcm92aWRlZCAoaW1wbHlpbmcgQVBJIGtleSB1c2FnZSksXG4gICAgICogcHJvamVjdCBhbmQgbG9jYXRpb24gYXJlIGNsZWFyZWQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBub3JtYWxpemVBdXRoUGFyYW1ldGVycygpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xpZW50T3B0aW9ucy5wcm9qZWN0ICYmIHRoaXMuY2xpZW50T3B0aW9ucy5sb2NhdGlvbikge1xuICAgICAgICAgICAgLy8gVXNpbmcgcHJvamVjdC9sb2NhdGlvbiBmb3IgYXV0aCwgY2xlYXIgcG90ZW50aWFsIEFQSSBrZXlcbiAgICAgICAgICAgIHRoaXMuY2xpZW50T3B0aW9ucy5hcGlLZXkgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXNpbmcgQVBJIGtleSBmb3IgYXV0aCAob3Igbm8gYXV0aCBwcm92aWRlZCB5ZXQpLCBjbGVhciBwcm9qZWN0L2xvY2F0aW9uXG4gICAgICAgIHRoaXMuY2xpZW50T3B0aW9ucy5wcm9qZWN0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmNsaWVudE9wdGlvbnMubG9jYXRpb24gPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlzVmVydGV4QUkoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMuY2xpZW50T3B0aW9ucy52ZXJ0ZXhhaSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmFsc2U7XG4gICAgfVxuICAgIGdldFByb2plY3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudE9wdGlvbnMucHJvamVjdDtcbiAgICB9XG4gICAgZ2V0TG9jYXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudE9wdGlvbnMubG9jYXRpb247XG4gICAgfVxuICAgIGdldEFwaVZlcnNpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmNsaWVudE9wdGlvbnMuaHR0cE9wdGlvbnMgJiZcbiAgICAgICAgICAgIHRoaXMuY2xpZW50T3B0aW9ucy5odHRwT3B0aW9ucy5hcGlWZXJzaW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNsaWVudE9wdGlvbnMuaHR0cE9wdGlvbnMuYXBpVmVyc2lvbjtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FQSSB2ZXJzaW9uIGlzIG5vdCBzZXQuJyk7XG4gICAgfVxuICAgIGdldEJhc2VVcmwoKSB7XG4gICAgICAgIGlmICh0aGlzLmNsaWVudE9wdGlvbnMuaHR0cE9wdGlvbnMgJiZcbiAgICAgICAgICAgIHRoaXMuY2xpZW50T3B0aW9ucy5odHRwT3B0aW9ucy5iYXNlVXJsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNsaWVudE9wdGlvbnMuaHR0cE9wdGlvbnMuYmFzZVVybDtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Jhc2UgVVJMIGlzIG5vdCBzZXQuJyk7XG4gICAgfVxuICAgIGdldFJlcXVlc3RVcmwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFJlcXVlc3RVcmxJbnRlcm5hbCh0aGlzLmNsaWVudE9wdGlvbnMuaHR0cE9wdGlvbnMpO1xuICAgIH1cbiAgICBnZXRIZWFkZXJzKCkge1xuICAgICAgICBpZiAodGhpcy5jbGllbnRPcHRpb25zLmh0dHBPcHRpb25zICYmXG4gICAgICAgICAgICB0aGlzLmNsaWVudE9wdGlvbnMuaHR0cE9wdGlvbnMuaGVhZGVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jbGllbnRPcHRpb25zLmh0dHBPcHRpb25zLmhlYWRlcnM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hlYWRlcnMgYXJlIG5vdCBzZXQuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0UmVxdWVzdFVybEludGVybmFsKGh0dHBPcHRpb25zKSB7XG4gICAgICAgIGlmICghaHR0cE9wdGlvbnMgfHxcbiAgICAgICAgICAgIGh0dHBPcHRpb25zLmJhc2VVcmwgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgaHR0cE9wdGlvbnMuYXBpVmVyc2lvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hUVFAgb3B0aW9ucyBhcmUgbm90IGNvcnJlY3RseSBzZXQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYmFzZVVybCA9IGh0dHBPcHRpb25zLmJhc2VVcmwuZW5kc1dpdGgoJy8nKVxuICAgICAgICAgICAgPyBodHRwT3B0aW9ucy5iYXNlVXJsLnNsaWNlKDAsIC0xKVxuICAgICAgICAgICAgOiBodHRwT3B0aW9ucy5iYXNlVXJsO1xuICAgICAgICBjb25zdCB1cmxFbGVtZW50ID0gW2Jhc2VVcmxdO1xuICAgICAgICBpZiAoaHR0cE9wdGlvbnMuYXBpVmVyc2lvbiAmJiBodHRwT3B0aW9ucy5hcGlWZXJzaW9uICE9PSAnJykge1xuICAgICAgICAgICAgdXJsRWxlbWVudC5wdXNoKGh0dHBPcHRpb25zLmFwaVZlcnNpb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1cmxFbGVtZW50LmpvaW4oJy8nKTtcbiAgICB9XG4gICAgZ2V0QmFzZVJlc291cmNlUGF0aCgpIHtcbiAgICAgICAgcmV0dXJuIGBwcm9qZWN0cy8ke3RoaXMuY2xpZW50T3B0aW9ucy5wcm9qZWN0fS9sb2NhdGlvbnMvJHt0aGlzLmNsaWVudE9wdGlvbnMubG9jYXRpb259YDtcbiAgICB9XG4gICAgZ2V0QXBpS2V5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnRPcHRpb25zLmFwaUtleTtcbiAgICB9XG4gICAgZ2V0V2Vic29ja2V0QmFzZVVybCgpIHtcbiAgICAgICAgY29uc3QgYmFzZVVybCA9IHRoaXMuZ2V0QmFzZVVybCgpO1xuICAgICAgICBjb25zdCB1cmxQYXJ0cyA9IG5ldyBVUkwoYmFzZVVybCk7XG4gICAgICAgIHVybFBhcnRzLnByb3RvY29sID0gdXJsUGFydHMucHJvdG9jb2wgPT0gJ2h0dHA6JyA/ICd3cycgOiAnd3NzJztcbiAgICAgICAgcmV0dXJuIHVybFBhcnRzLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIHNldEJhc2VVcmwodXJsKSB7XG4gICAgICAgIGlmICh0aGlzLmNsaWVudE9wdGlvbnMuaHR0cE9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuY2xpZW50T3B0aW9ucy5odHRwT3B0aW9ucy5iYXNlVXJsID0gdXJsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIVFRQIG9wdGlvbnMgYXJlIG5vdCBjb3JyZWN0bHkgc2V0LicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0cnVjdFVybChwYXRoLCBodHRwT3B0aW9ucywgcHJlcGVuZFByb2plY3RMb2NhdGlvbikge1xuICAgICAgICBjb25zdCB1cmxFbGVtZW50ID0gW3RoaXMuZ2V0UmVxdWVzdFVybEludGVybmFsKGh0dHBPcHRpb25zKV07XG4gICAgICAgIGlmIChwcmVwZW5kUHJvamVjdExvY2F0aW9uKSB7XG4gICAgICAgICAgICB1cmxFbGVtZW50LnB1c2godGhpcy5nZXRCYXNlUmVzb3VyY2VQYXRoKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXRoICE9PSAnJykge1xuICAgICAgICAgICAgdXJsRWxlbWVudC5wdXNoKHBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoYCR7dXJsRWxlbWVudC5qb2luKCcvJyl9YCk7XG4gICAgICAgIHJldHVybiB1cmw7XG4gICAgfVxuICAgIHNob3VsZFByZXBlbmRWZXJ0ZXhQcm9qZWN0UGF0aChyZXF1ZXN0KSB7XG4gICAgICAgIGlmICh0aGlzLmNsaWVudE9wdGlvbnMuYXBpS2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmNsaWVudE9wdGlvbnMudmVydGV4YWkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVxdWVzdC5wYXRoLnN0YXJ0c1dpdGgoJ3Byb2plY3RzLycpKSB7XG4gICAgICAgICAgICAvLyBBc3N1bWUgdGhlIHBhdGggYWxyZWFkeSBzdGFydHMgd2l0aFxuICAgICAgICAgICAgLy8gYHByb2plY3RzLzxwcm9qZWN0Pi9sb2NhdGlvbi88bG9jYXRpb24+YC5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVxdWVzdC5odHRwTWV0aG9kID09PSAnR0VUJyAmJlxuICAgICAgICAgICAgcmVxdWVzdC5wYXRoLnN0YXJ0c1dpdGgoJ3B1Ymxpc2hlcnMvZ29vZ2xlL21vZGVscycpKSB7XG4gICAgICAgICAgICAvLyBUaGVzZSBwYXRocyBhcmUgdXNlZCBieSBWZXJ0ZXgncyBtb2RlbHMuZ2V0IGFuZCBtb2RlbHMubGlzdFxuICAgICAgICAgICAgLy8gY2FsbHMuIEZvciBiYXNlIG1vZGVscyBWZXJ0ZXggZG9lcyBub3QgYWNjZXB0IGEgcHJvamVjdC9sb2NhdGlvblxuICAgICAgICAgICAgLy8gcHJlZml4IChmb3IgdHVuZWQgbW9kZWwgdGhlIHByZWZpeCBpcyByZXF1aXJlZCkuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGFzeW5jIHJlcXVlc3QocmVxdWVzdCkge1xuICAgICAgICBsZXQgcGF0Y2hlZEh0dHBPcHRpb25zID0gdGhpcy5jbGllbnRPcHRpb25zLmh0dHBPcHRpb25zO1xuICAgICAgICBpZiAocmVxdWVzdC5odHRwT3B0aW9ucykge1xuICAgICAgICAgICAgcGF0Y2hlZEh0dHBPcHRpb25zID0gdGhpcy5wYXRjaEh0dHBPcHRpb25zKHRoaXMuY2xpZW50T3B0aW9ucy5odHRwT3B0aW9ucywgcmVxdWVzdC5odHRwT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJlcGVuZFByb2plY3RMb2NhdGlvbiA9IHRoaXMuc2hvdWxkUHJlcGVuZFZlcnRleFByb2plY3RQYXRoKHJlcXVlc3QpO1xuICAgICAgICBjb25zdCB1cmwgPSB0aGlzLmNvbnN0cnVjdFVybChyZXF1ZXN0LnBhdGgsIHBhdGNoZWRIdHRwT3B0aW9ucywgcHJlcGVuZFByb2plY3RMb2NhdGlvbik7XG4gICAgICAgIGlmIChyZXF1ZXN0LnF1ZXJ5UGFyYW1zKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhyZXF1ZXN0LnF1ZXJ5UGFyYW1zKSkge1xuICAgICAgICAgICAgICAgIHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGtleSwgU3RyaW5nKHZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlcXVlc3RJbml0ID0ge307XG4gICAgICAgIGlmIChyZXF1ZXN0Lmh0dHBNZXRob2QgPT09ICdHRVQnKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdC5ib2R5ICYmIHJlcXVlc3QuYm9keSAhPT0gJ3t9Jykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVxdWVzdCBib2R5IHNob3VsZCBiZSBlbXB0eSBmb3IgR0VUIHJlcXVlc3QsIGJ1dCBnb3Qgbm9uIGVtcHR5IHJlcXVlc3QgYm9keScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVxdWVzdEluaXQuYm9keSA9IHJlcXVlc3QuYm9keTtcbiAgICAgICAgfVxuICAgICAgICByZXF1ZXN0SW5pdCA9IGF3YWl0IHRoaXMuaW5jbHVkZUV4dHJhSHR0cE9wdGlvbnNUb1JlcXVlc3RJbml0KHJlcXVlc3RJbml0LCBwYXRjaGVkSHR0cE9wdGlvbnMsIHJlcXVlc3QuYWJvcnRTaWduYWwpO1xuICAgICAgICByZXR1cm4gdGhpcy51bmFyeUFwaUNhbGwodXJsLCByZXF1ZXN0SW5pdCwgcmVxdWVzdC5odHRwTWV0aG9kKTtcbiAgICB9XG4gICAgcGF0Y2hIdHRwT3B0aW9ucyhiYXNlSHR0cE9wdGlvbnMsIHJlcXVlc3RIdHRwT3B0aW9ucykge1xuICAgICAgICBjb25zdCBwYXRjaGVkSHR0cE9wdGlvbnMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGJhc2VIdHRwT3B0aW9ucykpO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhyZXF1ZXN0SHR0cE9wdGlvbnMpKSB7XG4gICAgICAgICAgICAvLyBSZWNvcmRzIGNvbXBpbGUgdG8gb2JqZWN0cy5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBUUzIzNDVUUzcwNTM6IEVsZW1lbnQgaW1wbGljaXRseSBoYXMgYW4gJ2FueScgdHlwZVxuICAgICAgICAgICAgICAgIC8vIGJlY2F1c2UgZXhwcmVzc2lvbiBvZiB0eXBlICdzdHJpbmcnIGNhbid0IGJlIHVzZWQgdG8gaW5kZXggdHlwZVxuICAgICAgICAgICAgICAgIC8vICdIdHRwT3B0aW9ucycuXG4gICAgICAgICAgICAgICAgcGF0Y2hlZEh0dHBPcHRpb25zW2tleV0gPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHBhdGNoZWRIdHRwT3B0aW9uc1trZXldKSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgVFMyMzQ1VFM3MDUzOiBFbGVtZW50IGltcGxpY2l0bHkgaGFzIGFuICdhbnknIHR5cGVcbiAgICAgICAgICAgICAgICAvLyBiZWNhdXNlIGV4cHJlc3Npb24gb2YgdHlwZSAnc3RyaW5nJyBjYW4ndCBiZSB1c2VkIHRvIGluZGV4IHR5cGVcbiAgICAgICAgICAgICAgICAvLyAnSHR0cE9wdGlvbnMnLlxuICAgICAgICAgICAgICAgIHBhdGNoZWRIdHRwT3B0aW9uc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhdGNoZWRIdHRwT3B0aW9ucztcbiAgICB9XG4gICAgYXN5bmMgcmVxdWVzdFN0cmVhbShyZXF1ZXN0KSB7XG4gICAgICAgIGxldCBwYXRjaGVkSHR0cE9wdGlvbnMgPSB0aGlzLmNsaWVudE9wdGlvbnMuaHR0cE9wdGlvbnM7XG4gICAgICAgIGlmIChyZXF1ZXN0Lmh0dHBPcHRpb25zKSB7XG4gICAgICAgICAgICBwYXRjaGVkSHR0cE9wdGlvbnMgPSB0aGlzLnBhdGNoSHR0cE9wdGlvbnModGhpcy5jbGllbnRPcHRpb25zLmh0dHBPcHRpb25zLCByZXF1ZXN0Lmh0dHBPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmVwZW5kUHJvamVjdExvY2F0aW9uID0gdGhpcy5zaG91bGRQcmVwZW5kVmVydGV4UHJvamVjdFBhdGgocmVxdWVzdCk7XG4gICAgICAgIGNvbnN0IHVybCA9IHRoaXMuY29uc3RydWN0VXJsKHJlcXVlc3QucGF0aCwgcGF0Y2hlZEh0dHBPcHRpb25zLCBwcmVwZW5kUHJvamVjdExvY2F0aW9uKTtcbiAgICAgICAgaWYgKCF1cmwuc2VhcmNoUGFyYW1zLmhhcygnYWx0JykgfHwgdXJsLnNlYXJjaFBhcmFtcy5nZXQoJ2FsdCcpICE9PSAnc3NlJykge1xuICAgICAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoJ2FsdCcsICdzc2UnKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVxdWVzdEluaXQgPSB7fTtcbiAgICAgICAgcmVxdWVzdEluaXQuYm9keSA9IHJlcXVlc3QuYm9keTtcbiAgICAgICAgcmVxdWVzdEluaXQgPSBhd2FpdCB0aGlzLmluY2x1ZGVFeHRyYUh0dHBPcHRpb25zVG9SZXF1ZXN0SW5pdChyZXF1ZXN0SW5pdCwgcGF0Y2hlZEh0dHBPcHRpb25zLCByZXF1ZXN0LmFib3J0U2lnbmFsKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtQXBpQ2FsbCh1cmwsIHJlcXVlc3RJbml0LCByZXF1ZXN0Lmh0dHBNZXRob2QpO1xuICAgIH1cbiAgICBhc3luYyBpbmNsdWRlRXh0cmFIdHRwT3B0aW9uc1RvUmVxdWVzdEluaXQocmVxdWVzdEluaXQsIGh0dHBPcHRpb25zLCBhYm9ydFNpZ25hbCkge1xuICAgICAgICBpZiAoKGh0dHBPcHRpb25zICYmIGh0dHBPcHRpb25zLnRpbWVvdXQpIHx8IGFib3J0U2lnbmFsKSB7XG4gICAgICAgICAgICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICAgICAgICBjb25zdCBzaWduYWwgPSBhYm9ydENvbnRyb2xsZXIuc2lnbmFsO1xuICAgICAgICAgICAgaWYgKGh0dHBPcHRpb25zLnRpbWVvdXQgJiYgKGh0dHBPcHRpb25zID09PSBudWxsIHx8IGh0dHBPcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBodHRwT3B0aW9ucy50aW1lb3V0KSA+IDApIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IGFib3J0Q29udHJvbGxlci5hYm9ydCgpLCBodHRwT3B0aW9ucy50aW1lb3V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhYm9ydFNpZ25hbCkge1xuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBhYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcXVlc3RJbml0LnNpZ25hbCA9IHNpZ25hbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaHR0cE9wdGlvbnMgJiYgaHR0cE9wdGlvbnMuZXh0cmFCb2R5ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpbmNsdWRlRXh0cmFCb2R5VG9SZXF1ZXN0SW5pdChyZXF1ZXN0SW5pdCwgaHR0cE9wdGlvbnMuZXh0cmFCb2R5KTtcbiAgICAgICAgfVxuICAgICAgICByZXF1ZXN0SW5pdC5oZWFkZXJzID0gYXdhaXQgdGhpcy5nZXRIZWFkZXJzSW50ZXJuYWwoaHR0cE9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gcmVxdWVzdEluaXQ7XG4gICAgfVxuICAgIGFzeW5jIHVuYXJ5QXBpQ2FsbCh1cmwsIHJlcXVlc3RJbml0LCBodHRwTWV0aG9kKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFwaUNhbGwodXJsLnRvU3RyaW5nKCksIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVxdWVzdEluaXQpLCB7IG1ldGhvZDogaHR0cE1ldGhvZCB9KSlcbiAgICAgICAgICAgIC50aGVuKGFzeW5jIChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgYXdhaXQgdGhyb3dFcnJvcklmTm90T0socmVzcG9uc2UpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBIdHRwUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihKU09OLnN0cmluZ2lmeShlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBzdHJlYW1BcGlDYWxsKHVybCwgcmVxdWVzdEluaXQsIGh0dHBNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBpQ2FsbCh1cmwudG9TdHJpbmcoKSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZXF1ZXN0SW5pdCksIHsgbWV0aG9kOiBodHRwTWV0aG9kIH0pKVxuICAgICAgICAgICAgLnRoZW4oYXN5bmMgKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICBhd2FpdCB0aHJvd0Vycm9ySWZOb3RPSyhyZXNwb25zZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzU3RyZWFtUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihKU09OLnN0cmluZ2lmeShlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwcm9jZXNzU3RyZWFtUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gX19hc3luY0dlbmVyYXRvcih0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKiBwcm9jZXNzU3RyZWFtUmVzcG9uc2VfMSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlYWRlciA9IChfYSA9IHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS5ib2R5KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0UmVhZGVyKCk7XG4gICAgICAgICAgICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCd1dGYtOCcpO1xuICAgICAgICAgICAgaWYgKCFyZWFkZXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc3BvbnNlIGJvZHkgaXMgZW1wdHknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbGV0IGJ1ZmZlciA9ICcnO1xuICAgICAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IHlpZWxkIF9fYXdhaXQocmVhZGVyLnJlYWQoKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYnVmZmVyLnRyaW0oKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmNvbXBsZXRlIEpTT04gc2VnbWVudCBhdCB0aGUgZW5kJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaHVua1N0cmluZyA9IGRlY29kZXIuZGVjb2RlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgYW5kIHRocm93IGFuIGVycm9yIGlmIHRoZSBjaHVuayBjb250YWlucyBhbiBlcnJvci5cbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rSnNvbiA9IEpTT04ucGFyc2UoY2h1bmtTdHJpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCdlcnJvcicgaW4gY2h1bmtKc29uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3JKc29uID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShjaHVua0pzb25bJ2Vycm9yJ10pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGF0dXMgPSBlcnJvckpzb25bJ3N0YXR1cyddO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvZGUgPSBlcnJvckpzb25bJ2NvZGUnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBgZ290IHN0YXR1czogJHtzdGF0dXN9LiAke0pTT04uc3RyaW5naWZ5KGNodW5rSnNvbil9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29kZSA+PSA0MDAgJiYgY29kZSA8IDYwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhcGlFcnJvciA9IG5ldyBBcGlFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBlcnJvck1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IGNvZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBhcGlFcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvci5uYW1lID09PSAnQXBpRXJyb3InKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBidWZmZXIgKz0gY2h1bmtTdHJpbmc7XG4gICAgICAgICAgICAgICAgICAgIGxldCBtYXRjaCA9IGJ1ZmZlci5tYXRjaChyZXNwb25zZUxpbmVSRSk7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvY2Vzc2VkQ2h1bmtTdHJpbmcgPSBtYXRjaFsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFydGlhbFJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKHByb2Nlc3NlZENodW5rU3RyaW5nLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1c1RleHQ6IHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS5zdGF0dXNUZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIHlpZWxkIF9fYXdhaXQobmV3IEh0dHBSZXNwb25zZShwYXJ0aWFsUmVzcG9uc2UpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIgPSBidWZmZXIuc2xpY2UobWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IGJ1ZmZlci5tYXRjaChyZXNwb25zZUxpbmVSRSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZXhjZXB0aW9uIHBhcnNpbmcgc3RyZWFtIGNodW5rICR7cHJvY2Vzc2VkQ2h1bmtTdHJpbmd9LiAke2V9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICByZWFkZXIucmVsZWFzZUxvY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGFwaUNhbGwodXJsLCByZXF1ZXN0SW5pdCkge1xuICAgICAgICByZXR1cm4gZmV0Y2godXJsLCByZXF1ZXN0SW5pdCkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZXhjZXB0aW9uICR7ZX0gc2VuZGluZyByZXF1ZXN0YCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXREZWZhdWx0SGVhZGVycygpIHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHt9O1xuICAgICAgICBjb25zdCB2ZXJzaW9uSGVhZGVyVmFsdWUgPSBMSUJSQVJZX0xBQkVMICsgJyAnICsgdGhpcy5jbGllbnRPcHRpb25zLnVzZXJBZ2VudEV4dHJhO1xuICAgICAgICBoZWFkZXJzW1VTRVJfQUdFTlRfSEVBREVSXSA9IHZlcnNpb25IZWFkZXJWYWx1ZTtcbiAgICAgICAgaGVhZGVyc1tHT09HTEVfQVBJX0NMSUVOVF9IRUFERVJdID0gdmVyc2lvbkhlYWRlclZhbHVlO1xuICAgICAgICBoZWFkZXJzW0NPTlRFTlRfVFlQRV9IRUFERVJdID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICByZXR1cm4gaGVhZGVycztcbiAgICB9XG4gICAgYXN5bmMgZ2V0SGVhZGVyc0ludGVybmFsKGh0dHBPcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycygpO1xuICAgICAgICBpZiAoaHR0cE9wdGlvbnMgJiYgaHR0cE9wdGlvbnMuaGVhZGVycykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoaHR0cE9wdGlvbnMuaGVhZGVycykpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFwcGVuZCBhIHRpbWVvdXQgaGVhZGVyIGlmIGl0IGlzIHNldCwgbm90ZSB0aGF0IHRoZSB0aW1lb3V0IG9wdGlvbiBpc1xuICAgICAgICAgICAgLy8gaW4gbWlsbGlzZWNvbmRzIGJ1dCB0aGUgaGVhZGVyIGlzIGluIHNlY29uZHMuXG4gICAgICAgICAgICBpZiAoaHR0cE9wdGlvbnMudGltZW91dCAmJiBodHRwT3B0aW9ucy50aW1lb3V0ID4gMCkge1xuICAgICAgICAgICAgICAgIGhlYWRlcnMuYXBwZW5kKFNFUlZFUl9USU1FT1VUX0hFQURFUiwgU3RyaW5nKE1hdGguY2VpbChodHRwT3B0aW9ucy50aW1lb3V0IC8gMTAwMCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLmNsaWVudE9wdGlvbnMuYXV0aC5hZGRBdXRoSGVhZGVycyhoZWFkZXJzKTtcbiAgICAgICAgcmV0dXJuIGhlYWRlcnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwbG9hZHMgYSBmaWxlIGFzeW5jaHJvbm91c2x5IHVzaW5nIEdlbWluaSBBUEkgb25seSwgdGhpcyBpcyBub3Qgc3VwcG9ydGVkXG4gICAgICogaW4gVmVydGV4IEFJLlxuICAgICAqXG4gICAgICogQHBhcmFtIGZpbGUgVGhlIHN0cmluZyBwYXRoIHRvIHRoZSBmaWxlIHRvIGJlIHVwbG9hZGVkIG9yIGEgQmxvYiBvYmplY3QuXG4gICAgICogQHBhcmFtIGNvbmZpZyBPcHRpb25hbCBwYXJhbWV0ZXJzIHNwZWNpZmllZCBpbiB0aGUgYFVwbG9hZEZpbGVDb25maWdgXG4gICAgICogICAgIGludGVyZmFjZS4gQHNlZSB7QGxpbmsgVXBsb2FkRmlsZUNvbmZpZ31cbiAgICAgKiBAcmV0dXJuIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEZpbGVgIG9iamVjdC5cbiAgICAgKiBAdGhyb3dzIEFuIGVycm9yIGlmIGNhbGxlZCBvbiBhIFZlcnRleCBBSSBjbGllbnQuXG4gICAgICogQHRocm93cyBBbiBlcnJvciBpZiB0aGUgYG1pbWVUeXBlYCBpcyBub3QgcHJvdmlkZWQgYW5kIGNhbiBub3QgYmUgaW5mZXJyZWQsXG4gICAgICovXG4gICAgYXN5bmMgdXBsb2FkRmlsZShmaWxlLCBjb25maWcpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBmaWxlVG9VcGxvYWQgPSB7fTtcbiAgICAgICAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgICAgICBmaWxlVG9VcGxvYWQubWltZVR5cGUgPSBjb25maWcubWltZVR5cGU7XG4gICAgICAgICAgICBmaWxlVG9VcGxvYWQubmFtZSA9IGNvbmZpZy5uYW1lO1xuICAgICAgICAgICAgZmlsZVRvVXBsb2FkLmRpc3BsYXlOYW1lID0gY29uZmlnLmRpc3BsYXlOYW1lO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaWxlVG9VcGxvYWQubmFtZSAmJiAhZmlsZVRvVXBsb2FkLm5hbWUuc3RhcnRzV2l0aCgnZmlsZXMvJykpIHtcbiAgICAgICAgICAgIGZpbGVUb1VwbG9hZC5uYW1lID0gYGZpbGVzLyR7ZmlsZVRvVXBsb2FkLm5hbWV9YDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cGxvYWRlciA9IHRoaXMuY2xpZW50T3B0aW9ucy51cGxvYWRlcjtcbiAgICAgICAgY29uc3QgZmlsZVN0YXQgPSBhd2FpdCB1cGxvYWRlci5zdGF0KGZpbGUpO1xuICAgICAgICBmaWxlVG9VcGxvYWQuc2l6ZUJ5dGVzID0gU3RyaW5nKGZpbGVTdGF0LnNpemUpO1xuICAgICAgICBjb25zdCBtaW1lVHlwZSA9IChfYSA9IGNvbmZpZyA9PT0gbnVsbCB8fCBjb25maWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZy5taW1lVHlwZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmlsZVN0YXQudHlwZTtcbiAgICAgICAgaWYgKG1pbWVUeXBlID09PSB1bmRlZmluZWQgfHwgbWltZVR5cGUgPT09ICcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBub3QgZGV0ZXJtaW5lIG1pbWVUeXBlLiBQbGVhc2UgcHJvdmlkZSBtaW1lVHlwZSBpbiB0aGUgY29uZmlnLicpO1xuICAgICAgICB9XG4gICAgICAgIGZpbGVUb1VwbG9hZC5taW1lVHlwZSA9IG1pbWVUeXBlO1xuICAgICAgICBjb25zdCB1cGxvYWRVcmwgPSBhd2FpdCB0aGlzLmZldGNoVXBsb2FkVXJsKGZpbGVUb1VwbG9hZCwgY29uZmlnKTtcbiAgICAgICAgcmV0dXJuIHVwbG9hZGVyLnVwbG9hZChmaWxlLCB1cGxvYWRVcmwsIHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEb3dubG9hZHMgYSBmaWxlIGFzeW5jaHJvbm91c2x5IHRvIHRoZSBzcGVjaWZpZWQgcGF0aC5cbiAgICAgKlxuICAgICAqIEBwYXJhbXMgcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoZSBkb3dubG9hZCByZXF1ZXN0LCBzZWUge0BsaW5rXG4gICAgICogRG93bmxvYWRGaWxlUGFyYW1ldGVyc31cbiAgICAgKi9cbiAgICBhc3luYyBkb3dubG9hZEZpbGUocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGRvd25sb2FkZXIgPSB0aGlzLmNsaWVudE9wdGlvbnMuZG93bmxvYWRlcjtcbiAgICAgICAgYXdhaXQgZG93bmxvYWRlci5kb3dubG9hZChwYXJhbXMsIHRoaXMpO1xuICAgIH1cbiAgICBhc3luYyBmZXRjaFVwbG9hZFVybChmaWxlLCBjb25maWcpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgaHR0cE9wdGlvbnMgPSB7fTtcbiAgICAgICAgaWYgKGNvbmZpZyA9PT0gbnVsbCB8fCBjb25maWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZy5odHRwT3B0aW9ucykge1xuICAgICAgICAgICAgaHR0cE9wdGlvbnMgPSBjb25maWcuaHR0cE9wdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBodHRwT3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICBhcGlWZXJzaW9uOiAnJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAgICAgICAgICdYLUdvb2ctVXBsb2FkLVByb3RvY29sJzogJ3Jlc3VtYWJsZScsXG4gICAgICAgICAgICAgICAgICAgICdYLUdvb2ctVXBsb2FkLUNvbW1hbmQnOiAnc3RhcnQnLFxuICAgICAgICAgICAgICAgICAgICAnWC1Hb29nLVVwbG9hZC1IZWFkZXItQ29udGVudC1MZW5ndGgnOiBgJHtmaWxlLnNpemVCeXRlc31gLFxuICAgICAgICAgICAgICAgICAgICAnWC1Hb29nLVVwbG9hZC1IZWFkZXItQ29udGVudC1UeXBlJzogYCR7ZmlsZS5taW1lVHlwZX1gLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJvZHkgPSB7XG4gICAgICAgICAgICAnZmlsZSc6IGZpbGUsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGh0dHBSZXNwb25zZSA9IGF3YWl0IHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICBwYXRoOiBmb3JtYXRNYXAoJ3VwbG9hZC92MWJldGEvZmlsZXMnLCBib2R5WydfdXJsJ10pLFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICBodHRwT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghaHR0cFJlc3BvbnNlIHx8ICEoaHR0cFJlc3BvbnNlID09PSBudWxsIHx8IGh0dHBSZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogaHR0cFJlc3BvbnNlLmhlYWRlcnMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlcnZlciBkaWQgbm90IHJldHVybiBhbiBIdHRwUmVzcG9uc2Ugb3IgdGhlIHJldHVybmVkIEh0dHBSZXNwb25zZSBkaWQgbm90IGhhdmUgaGVhZGVycy4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cGxvYWRVcmwgPSAoX2EgPSBodHRwUmVzcG9uc2UgPT09IG51bGwgfHwgaHR0cFJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBodHRwUmVzcG9uc2UuaGVhZGVycykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWyd4LWdvb2ctdXBsb2FkLXVybCddO1xuICAgICAgICBpZiAodXBsb2FkVXJsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGdldCB1cGxvYWQgdXJsLiBTZXJ2ZXIgZGlkIG5vdCByZXR1cm4gdGhlIHgtZ29vZ2xlLXVwbG9hZC11cmwgaW4gdGhlIGhlYWRlcnMnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXBsb2FkVXJsO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHRocm93RXJyb3JJZk5vdE9LKHJlc3BvbnNlKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChyZXNwb25zZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncmVzcG9uc2UgaXMgdW5kZWZpbmVkJyk7XG4gICAgfVxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3Qgc3RhdHVzID0gcmVzcG9uc2Uuc3RhdHVzO1xuICAgICAgICBsZXQgZXJyb3JCb2R5O1xuICAgICAgICBpZiAoKF9hID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaW5jbHVkZXMoJ2FwcGxpY2F0aW9uL2pzb24nKSkge1xuICAgICAgICAgICAgZXJyb3JCb2R5ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZXJyb3JCb2R5ID0ge1xuICAgICAgICAgICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGF3YWl0IHJlc3BvbnNlLnRleHQoKSxcbiAgICAgICAgICAgICAgICAgICAgY29kZTogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1c1RleHQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gSlNPTi5zdHJpbmdpZnkoZXJyb3JCb2R5KTtcbiAgICAgICAgaWYgKHN0YXR1cyA+PSA0MDAgJiYgc3RhdHVzIDwgNjAwKSB7XG4gICAgICAgICAgICBjb25zdCBhcGlFcnJvciA9IG5ldyBBcGlFcnJvcih7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JNZXNzYWdlLFxuICAgICAgICAgICAgICAgIHN0YXR1czogc3RhdHVzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aHJvdyBhcGlFcnJvcjtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgICB9XG59XG4vKipcbiAqIFJlY3Vyc2l2ZWx5IHVwZGF0ZXMgdGhlIGByZXF1ZXN0SW5pdC5ib2R5YCB3aXRoIHZhbHVlcyBmcm9tIGFuIGBleHRyYUJvZHlgIG9iamVjdC5cbiAqXG4gKiBJZiBgcmVxdWVzdEluaXQuYm9keWAgaXMgYSBzdHJpbmcsIGl0J3MgYXNzdW1lZCB0byBiZSBKU09OIGFuZCB3aWxsIGJlIHBhcnNlZC5cbiAqIFRoZSBgZXh0cmFCb2R5YCBpcyB0aGVuIGRlZXBseSBtZXJnZWQgaW50byB0aGlzIHBhcnNlZCBvYmplY3QuXG4gKiBJZiBgcmVxdWVzdEluaXQuYm9keWAgaXMgYSBCbG9iLCBgZXh0cmFCb2R5YCB3aWxsIGJlIGlnbm9yZWQsIGFuZCBhIHdhcm5pbmcgbG9nZ2VkLFxuICogYXMgbWVyZ2luZyBzdHJ1Y3R1cmVkIGRhdGEgaW50byBhbiBvcGFxdWUgQmxvYiBpcyBub3Qgc3VwcG9ydGVkLlxuICpcbiAqIFRoZSBmdW5jdGlvbiBkb2VzIG5vdCBlbmZvcmNlIHRoYXQgdXBkYXRlZCB2YWx1ZXMgZnJvbSBgZXh0cmFCb2R5YCBoYXZlIHRoZVxuICogc2FtZSB0eXBlIGFzIGV4aXN0aW5nIHZhbHVlcyBpbiBgcmVxdWVzdEluaXQuYm9keWAuIFR5cGUgbWlzbWF0Y2hlcyBkdXJpbmdcbiAqIHRoZSBtZXJnZSB3aWxsIHJlc3VsdCBpbiBhIHdhcm5pbmcsIGJ1dCB0aGUgdmFsdWUgZnJvbSBgZXh0cmFCb2R5YCB3aWxsIG92ZXJ3cml0ZVxuICogdGhlIG9yaWdpbmFsLiBgZXh0cmFCb2R5YCB1c2VycyBhcmUgcmVzcG9uc2libGUgZm9yIGVuc3VyaW5nIGBleHRyYUJvZHlgIGhhcyB0aGUgY29ycmVjdCBzdHJ1Y3R1cmUuXG4gKlxuICogQHBhcmFtIHJlcXVlc3RJbml0IFRoZSBSZXF1ZXN0SW5pdCBvYmplY3Qgd2hvc2UgYm9keSB3aWxsIGJlIHVwZGF0ZWQuXG4gKiBAcGFyYW0gZXh0cmFCb2R5IFRoZSBvYmplY3QgY29udGFpbmluZyB1cGRhdGVzIHRvIGJlIG1lcmdlZCBpbnRvIGByZXF1ZXN0SW5pdC5ib2R5YC5cbiAqL1xuZnVuY3Rpb24gaW5jbHVkZUV4dHJhQm9keVRvUmVxdWVzdEluaXQocmVxdWVzdEluaXQsIGV4dHJhQm9keSkge1xuICAgIGlmICghZXh0cmFCb2R5IHx8IE9iamVjdC5rZXlzKGV4dHJhQm9keSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHJlcXVlc3RJbml0LmJvZHkgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignaW5jbHVkZUV4dHJhQm9keVRvUmVxdWVzdEluaXQ6IGV4dHJhQm9keSBwcm92aWRlZCBidXQgY3VycmVudCByZXF1ZXN0IGJvZHkgaXMgYSBCbG9iLiBleHRyYUJvZHkgd2lsbCBiZSBpZ25vcmVkIGFzIG1lcmdpbmcgaXMgbm90IHN1cHBvcnRlZCBmb3IgQmxvYiBib2RpZXMuJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGN1cnJlbnRCb2R5T2JqZWN0ID0ge307XG4gICAgLy8gSWYgYWRkaW5nIG5ldyB0eXBlIHRvIEh0dHBSZXF1ZXN0LmJvZHksIHBsZWFzZSBjaGVjayB0aGUgY29kZSBiZWxvdyB0b1xuICAgIC8vIHNlZSBpZiB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgbG9naWMuXG4gICAgaWYgKHR5cGVvZiByZXF1ZXN0SW5pdC5ib2R5ID09PSAnc3RyaW5nJyAmJiByZXF1ZXN0SW5pdC5ib2R5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZEJvZHkgPSBKU09OLnBhcnNlKHJlcXVlc3RJbml0LmJvZHkpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJzZWRCb2R5ID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgIHBhcnNlZEJvZHkgIT09IG51bGwgJiZcbiAgICAgICAgICAgICAgICAhQXJyYXkuaXNBcnJheShwYXJzZWRCb2R5KSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRCb2R5T2JqZWN0ID0gcGFyc2VkQm9keTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignaW5jbHVkZUV4dHJhQm9keVRvUmVxdWVzdEluaXQ6IE9yaWdpbmFsIHJlcXVlc3QgYm9keSBpcyB2YWxpZCBKU09OIGJ1dCBub3QgYSBub24tYXJyYXkgb2JqZWN0LiBTa2lwIGFwcGx5aW5nIGV4dHJhQm9keSB0byB0aGUgcmVxdWVzdCBib2R5LicpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qICBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzICovXG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignaW5jbHVkZUV4dHJhQm9keVRvUmVxdWVzdEluaXQ6IE9yaWdpbmFsIHJlcXVlc3QgYm9keSBpcyBub3QgdmFsaWQgSlNPTi4gU2tpcCBhcHBseWluZyBleHRyYUJvZHkgdG8gdGhlIHJlcXVlc3QgYm9keS4nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBkZWVwTWVyZ2UodGFyZ2V0LCBzb3VyY2UpIHtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gT2JqZWN0LmFzc2lnbih7fSwgdGFyZ2V0KTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZVZhbHVlID0gc291cmNlW2tleV07XG4gICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0VmFsdWUgPSBvdXRwdXRba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoc291cmNlVmFsdWUgJiZcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHNvdXJjZVZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgICAgICAhQXJyYXkuaXNBcnJheShzb3VyY2VWYWx1ZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0VmFsdWUgJiZcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHRhcmdldFZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgICAgICAhQXJyYXkuaXNBcnJheSh0YXJnZXRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0W2tleV0gPSBkZWVwTWVyZ2UodGFyZ2V0VmFsdWUsIHNvdXJjZVZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRWYWx1ZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlVmFsdWUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiB0YXJnZXRWYWx1ZSAhPT0gdHlwZW9mIHNvdXJjZVZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYGluY2x1ZGVFeHRyYUJvZHlUb1JlcXVlc3RJbml0OmRlZXBNZXJnZTogVHlwZSBtaXNtYXRjaCBmb3Iga2V5IFwiJHtrZXl9XCIuIE9yaWdpbmFsIHR5cGU6ICR7dHlwZW9mIHRhcmdldFZhbHVlfSwgTmV3IHR5cGU6ICR7dHlwZW9mIHNvdXJjZVZhbHVlfS4gT3ZlcndyaXRpbmcuYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0W2tleV0gPSBzb3VyY2VWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG4gICAgY29uc3QgbWVyZ2VkQm9keSA9IGRlZXBNZXJnZShjdXJyZW50Qm9keU9iamVjdCwgZXh0cmFCb2R5KTtcbiAgICByZXF1ZXN0SW5pdC5ib2R5ID0gSlNPTi5zdHJpbmdpZnkobWVyZ2VkQm9keSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbi8vIFRPRE86IGIvNDE2MDQxMjI5IC0gRGV0ZXJtaW5lIGhvdyB0byByZXRyaWV2ZSB0aGUgTUNQIHBhY2thZ2UgdmVyc2lvbi5cbmNvbnN0IE1DUF9MQUJFTCA9ICdtY3BfdXNlZC91bmtub3duJztcbi8vIENoZWNrcyB3aGV0aGVyIHRoZSBsaXN0IG9mIHRvb2xzIGNvbnRhaW5zIGFueSBNQ1AgdG9vbHMuXG5mdW5jdGlvbiBoYXNNY3BUb29sVXNhZ2UodG9vbHMpIHtcbiAgICBmb3IgKGNvbnN0IHRvb2wgb2YgdG9vbHMpIHtcbiAgICAgICAgaWYgKGlzTWNwQ2FsbGFibGVUb29sKHRvb2wpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRvb2wgPT09ICdvYmplY3QnICYmICdpbnB1dFNjaGVtYScgaW4gdG9vbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLy8gU2V0cyB0aGUgTUNQIHZlcnNpb24gbGFiZWwgaW4gdGhlIEdvb2dsZSBBUEkgY2xpZW50IGhlYWRlci5cbmZ1bmN0aW9uIHNldE1jcFVzYWdlSGVhZGVyKGhlYWRlcnMpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgZXhpc3RpbmdIZWFkZXIgPSAoX2EgPSBoZWFkZXJzW0dPT0dMRV9BUElfQ0xJRU5UX0hFQURFUl0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnO1xuICAgIGhlYWRlcnNbR09PR0xFX0FQSV9DTElFTlRfSEVBREVSXSA9IChleGlzdGluZ0hlYWRlciArIGAgJHtNQ1BfTEFCRUx9YCkudHJpbVN0YXJ0KCk7XG59XG4vLyBDaGVja3Mgd2hldGhlciB0aGUgbGlzdCBvZiB0b29scyBjb250YWlucyBhbnkgTUNQIGNsaWVudHMuIFdpbGwgcmV0dXJuIHRydWVcbi8vIGlmIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBNQ1AgY2xpZW50LlxuZnVuY3Rpb24gaGFzTWNwQ2xpZW50VG9vbHMocGFyYW1zKSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgcmV0dXJuIChfYyA9IChfYiA9IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b29scykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNvbWUoKHRvb2wpID0+IGlzTWNwQ2FsbGFibGVUb29sKHRvb2wpKSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogZmFsc2U7XG59XG4vLyBDaGVja3Mgd2hldGhlciB0aGUgbGlzdCBvZiB0b29scyBjb250YWlucyBhbnkgbm9uLU1DUCB0b29scy4gV2lsbCByZXR1cm4gdHJ1ZVxuLy8gaWYgdGhlcmUgaXMgYXQgbGVhc3Qgb25lIG5vbi1NQ1AgdG9vbC5cbmZ1bmN0aW9uIGhhc05vbk1jcFRvb2xzKHBhcmFtcykge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIHJldHVybiAoKF9jID0gKF9iID0gKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRvb2xzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc29tZSgodG9vbCkgPT4gIWlzTWNwQ2FsbGFibGVUb29sKHRvb2wpKSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogZmFsc2UpO1xufVxuLy8gUmV0dXJucyB0cnVlIGlmIHRoZSBvYmplY3QgaXMgYSBNQ1AgQ2FsbGFibGVUb29sLCBvdGhlcndpc2UgZmFsc2UuXG5mdW5jdGlvbiBpc01jcENhbGxhYmxlVG9vbChvYmplY3QpIHtcbiAgICByZXR1cm4gKG9iamVjdCAhPT0gbnVsbCAmJlxuICAgICAgICB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJlxuICAgICAgICBvYmplY3QgaW5zdGFuY2VvZiBNY3BDYWxsYWJsZVRvb2wpO1xufVxuLy8gTGlzdCBhbGwgdG9vbHMgZnJvbSB0aGUgTUNQIGNsaWVudC5cbmZ1bmN0aW9uIGxpc3RBbGxUb29scyhtY3BDbGllbnQsIG1heFRvb2xzID0gMTAwKSB7XG4gICAgcmV0dXJuIF9fYXN5bmNHZW5lcmF0b3IodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiogbGlzdEFsbFRvb2xzXzEoKSB7XG4gICAgICAgIGxldCBjdXJzb3IgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBudW1Ub29scyA9IDA7XG4gICAgICAgIHdoaWxlIChudW1Ub29scyA8IG1heFRvb2xzKSB7XG4gICAgICAgICAgICBjb25zdCB0ID0geWllbGQgX19hd2FpdChtY3BDbGllbnQubGlzdFRvb2xzKHsgY3Vyc29yIH0pKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdG9vbCBvZiB0LnRvb2xzKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgeWllbGQgX19hd2FpdCh0b29sKTtcbiAgICAgICAgICAgICAgICBudW1Ub29scysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0Lm5leHRDdXJzb3IpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnNvciA9IHQubmV4dEN1cnNvcjtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuLyoqXG4gKiBNY3BDYWxsYWJsZVRvb2wgY2FuIGJlIHVzZWQgZm9yIG1vZGVsIGluZmVyZW5jZSBhbmQgaW52b2tpbmcgTUNQIGNsaWVudHMgd2l0aFxuICogZ2l2ZW4gZnVuY3Rpb24gY2FsbCBhcmd1bWVudHMuXG4gKlxuICogQGV4cGVyaW1lbnRhbCBCdWlsdC1pbiBNQ1Agc3VwcG9ydCBpcyBhbiBleHBlcmltZW50YWwgZmVhdHVyZSwgbWF5IGNoYW5nZSBpbiBmdXR1cmVcbiAqIHZlcnNpb25zLlxuICovXG5jbGFzcyBNY3BDYWxsYWJsZVRvb2wge1xuICAgIGNvbnN0cnVjdG9yKG1jcENsaWVudHMgPSBbXSwgY29uZmlnKSB7XG4gICAgICAgIHRoaXMubWNwVG9vbHMgPSBbXTtcbiAgICAgICAgdGhpcy5mdW5jdGlvbk5hbWVUb01jcENsaWVudCA9IHt9O1xuICAgICAgICB0aGlzLm1jcENsaWVudHMgPSBtY3BDbGllbnRzO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIE1jcENhbGxhYmxlVG9vbC5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKG1jcENsaWVudHMsIGNvbmZpZykge1xuICAgICAgICByZXR1cm4gbmV3IE1jcENhbGxhYmxlVG9vbChtY3BDbGllbnRzLCBjb25maWcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZXMgdGhlIGZ1bmN0aW9uIG5hbWVzIGFyZSBub3QgZHVwbGljYXRlIGFuZCBpbml0aWFsaXplIHRoZSBmdW5jdGlvblxuICAgICAqIG5hbWUgdG8gTUNQIGNsaWVudCBtYXBwaW5nLlxuICAgICAqXG4gICAgICogQHRocm93cyB7RXJyb3J9IGlmIHRoZSBNQ1AgdG9vbHMgZnJvbSB0aGUgTUNQIGNsaWVudHMgaGF2ZSBkdXBsaWNhdGUgdG9vbFxuICAgICAqICAgICBuYW1lcy5cbiAgICAgKi9cbiAgICBhc3luYyBpbml0aWFsaXplKCkge1xuICAgICAgICB2YXIgX2EsIGVfMSwgX2IsIF9jO1xuICAgICAgICBpZiAodGhpcy5tY3BUb29scy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZnVuY3Rpb25NYXAgPSB7fTtcbiAgICAgICAgY29uc3QgbWNwVG9vbHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBtY3BDbGllbnQgb2YgdGhpcy5tY3BDbGllbnRzKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9kID0gdHJ1ZSwgX2UgPSAoZV8xID0gdm9pZCAwLCBfX2FzeW5jVmFsdWVzKGxpc3RBbGxUb29scyhtY3BDbGllbnQpKSksIF9mOyBfZiA9IGF3YWl0IF9lLm5leHQoKSwgX2EgPSBfZi5kb25lLCAhX2E7IF9kID0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBfYyA9IF9mLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBfZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtY3BUb29sID0gX2M7XG4gICAgICAgICAgICAgICAgICAgIG1jcFRvb2xzLnB1c2gobWNwVG9vbCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1jcFRvb2xOYW1lID0gbWNwVG9vbC5uYW1lO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZnVuY3Rpb25NYXBbbWNwVG9vbE5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYER1cGxpY2F0ZSBmdW5jdGlvbiBuYW1lICR7bWNwVG9vbE5hbWV9IGZvdW5kIGluIE1DUCB0b29scy4gUGxlYXNlIGVuc3VyZSBmdW5jdGlvbiBuYW1lcyBhcmUgdW5pcXVlLmApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uTWFwW21jcFRvb2xOYW1lXSA9IG1jcENsaWVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfZCAmJiAhX2EgJiYgKF9iID0gX2UucmV0dXJuKSkgYXdhaXQgX2IuY2FsbChfZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1jcFRvb2xzID0gbWNwVG9vbHM7XG4gICAgICAgIHRoaXMuZnVuY3Rpb25OYW1lVG9NY3BDbGllbnQgPSBmdW5jdGlvbk1hcDtcbiAgICB9XG4gICAgYXN5bmMgdG9vbCgpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgICAgIHJldHVybiBtY3BUb29sc1RvR2VtaW5pVG9vbCh0aGlzLm1jcFRvb2xzLCB0aGlzLmNvbmZpZyk7XG4gICAgfVxuICAgIGFzeW5jIGNhbGxUb29sKGZ1bmN0aW9uQ2FsbHMpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgICAgIGNvbnN0IGZ1bmN0aW9uQ2FsbFJlc3BvbnNlUGFydHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBmdW5jdGlvbkNhbGwgb2YgZnVuY3Rpb25DYWxscykge1xuICAgICAgICAgICAgaWYgKGZ1bmN0aW9uQ2FsbC5uYW1lIGluIHRoaXMuZnVuY3Rpb25OYW1lVG9NY3BDbGllbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtY3BDbGllbnQgPSB0aGlzLmZ1bmN0aW9uTmFtZVRvTWNwQ2xpZW50W2Z1bmN0aW9uQ2FsbC5uYW1lXTtcbiAgICAgICAgICAgICAgICBsZXQgcmVxdWVzdE9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogYi80MjQyMzg2NTQgLSBBZGQgc3VwcG9ydCBmb3IgZmluZXIgZ3JhaW5lZCB0aW1lb3V0IGNvbnRyb2wuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlnLnRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdE9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lb3V0OiB0aGlzLmNvbmZpZy50aW1lb3V0LFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjYWxsVG9vbFJlc3BvbnNlID0gYXdhaXQgbWNwQ2xpZW50LmNhbGxUb29sKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogZnVuY3Rpb25DYWxsLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50czogZnVuY3Rpb25DYWxsLmFyZ3MsXG4gICAgICAgICAgICAgICAgfSwgXG4gICAgICAgICAgICAgICAgLy8gU2V0IHRoZSByZXN1bHQgc2NoZW1hIHRvIHVuZGVmaW5lZCB0byBhbGxvdyBNQ1AgdG8gcmVseSBvbiB0aGVcbiAgICAgICAgICAgICAgICAvLyBkZWZhdWx0IHNjaGVtYS5cbiAgICAgICAgICAgICAgICB1bmRlZmluZWQsIHJlcXVlc3RPcHRpb25zKTtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbkNhbGxSZXNwb25zZVBhcnRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvblJlc3BvbnNlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBmdW5jdGlvbkNhbGwubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlOiBjYWxsVG9vbFJlc3BvbnNlLmlzRXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHsgZXJyb3I6IGNhbGxUb29sUmVzcG9uc2UgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogY2FsbFRvb2xSZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb25DYWxsUmVzcG9uc2VQYXJ0cztcbiAgICB9XG59XG5mdW5jdGlvbiBpc01jcENsaWVudChjbGllbnQpIHtcbiAgICByZXR1cm4gKGNsaWVudCAhPT0gbnVsbCAmJlxuICAgICAgICB0eXBlb2YgY2xpZW50ID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAnbGlzdFRvb2xzJyBpbiBjbGllbnQgJiZcbiAgICAgICAgdHlwZW9mIGNsaWVudC5saXN0VG9vbHMgPT09ICdmdW5jdGlvbicpO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgTWNwQ2FsbGFibGVUb29sIGZyb20gTUNQIGNsaWVudHMgYW5kIGFuIG9wdGlvbmFsIGNvbmZpZy5cbiAqXG4gKiBUaGUgY2FsbGFibGUgdG9vbCBjYW4gaW52b2tlIHRoZSBNQ1AgY2xpZW50cyB3aXRoIGdpdmVuIGZ1bmN0aW9uIGNhbGxcbiAqIGFyZ3VtZW50cy4gKG9mdGVuIGZvciBhdXRvbWF0aWMgZnVuY3Rpb24gY2FsbGluZykuXG4gKiBVc2UgdGhlIGNvbmZpZyB0byBtb2RpZnkgdG9vbCBwYXJhbWV0ZXJzIHN1Y2ggYXMgYmVoYXZpb3IuXG4gKlxuICogQGV4cGVyaW1lbnRhbCBCdWlsdC1pbiBNQ1Agc3VwcG9ydCBpcyBhbiBleHBlcmltZW50YWwgZmVhdHVyZSwgbWF5IGNoYW5nZSBpbiBmdXR1cmVcbiAqIHZlcnNpb25zLlxuICovXG5mdW5jdGlvbiBtY3BUb1Rvb2woLi4uYXJncykge1xuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIE1DUCBjbGllbnRzIHByb3ZpZGVkJyk7XG4gICAgfVxuICAgIGNvbnN0IG1heWJlQ29uZmlnID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdO1xuICAgIGlmIChpc01jcENsaWVudChtYXliZUNvbmZpZykpIHtcbiAgICAgICAgcmV0dXJuIE1jcENhbGxhYmxlVG9vbC5jcmVhdGUoYXJncywge30pO1xuICAgIH1cbiAgICByZXR1cm4gTWNwQ2FsbGFibGVUb29sLmNyZWF0ZShhcmdzLnNsaWNlKDAsIGFyZ3MubGVuZ3RoIC0gMSksIG1heWJlQ29uZmlnKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuLyoqXG4gKiBIYW5kbGVzIGluY29taW5nIG1lc3NhZ2VzIGZyb20gdGhlIFdlYlNvY2tldC5cbiAqXG4gKiBAcmVtYXJrc1xuICogVGhpcyBmdW5jdGlvbiBpcyByZXNwb25zaWJsZSBmb3IgcGFyc2luZyBpbmNvbWluZyBtZXNzYWdlcywgdHJhbnNmb3JtaW5nIHRoZW1cbiAqIGludG8gTGl2ZU11c2ljU2VydmVyTWVzc2FnZSwgYW5kIHRoZW4gY2FsbGluZyB0aGUgb25tZXNzYWdlIGNhbGxiYWNrLlxuICogTm90ZSB0aGF0IHRoZSBmaXJzdCBtZXNzYWdlIHdoaWNoIGlzIHJlY2VpdmVkIGZyb20gdGhlIHNlcnZlciBpcyBhXG4gKiBzZXR1cENvbXBsZXRlIG1lc3NhZ2UuXG4gKlxuICogQHBhcmFtIGFwaUNsaWVudCBUaGUgQXBpQ2xpZW50IGluc3RhbmNlLlxuICogQHBhcmFtIG9ubWVzc2FnZSBUaGUgdXNlci1wcm92aWRlZCBvbm1lc3NhZ2UgY2FsbGJhY2sgKGlmIGFueSkuXG4gKiBAcGFyYW0gZXZlbnQgVGhlIE1lc3NhZ2VFdmVudCBmcm9tIHRoZSBXZWJTb2NrZXQuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZVdlYlNvY2tldE1lc3NhZ2UkMShhcGlDbGllbnQsIG9ubWVzc2FnZSwgZXZlbnQpIHtcbiAgICBjb25zdCBzZXJ2ZXJNZXNzYWdlID0gbmV3IExpdmVNdXNpY1NlcnZlck1lc3NhZ2UoKTtcbiAgICBsZXQgZGF0YTtcbiAgICBpZiAoZXZlbnQuZGF0YSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoYXdhaXQgZXZlbnQuZGF0YS50ZXh0KCkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoZXZlbnQuZGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3BvbnNlID0gbGl2ZU11c2ljU2VydmVyTWVzc2FnZUZyb21NbGRldihkYXRhKTtcbiAgICBPYmplY3QuYXNzaWduKHNlcnZlck1lc3NhZ2UsIHJlc3BvbnNlKTtcbiAgICBvbm1lc3NhZ2Uoc2VydmVyTWVzc2FnZSk7XG59XG4vKipcbiAgIExpdmVNdXNpYyBjbGFzcyBlbmNhcHN1bGF0ZXMgdGhlIGNvbmZpZ3VyYXRpb24gZm9yIGxpdmUgbXVzaWNcbiAgIGdlbmVyYXRpb24gdmlhIEx5cmlhIExpdmUgbW9kZWxzLlxuXG4gICBAZXhwZXJpbWVudGFsXG4gICovXG5jbGFzcyBMaXZlTXVzaWMge1xuICAgIGNvbnN0cnVjdG9yKGFwaUNsaWVudCwgYXV0aCwgd2ViU29ja2V0RmFjdG9yeSkge1xuICAgICAgICB0aGlzLmFwaUNsaWVudCA9IGFwaUNsaWVudDtcbiAgICAgICAgdGhpcy5hdXRoID0gYXV0aDtcbiAgICAgICAgdGhpcy53ZWJTb2NrZXRGYWN0b3J5ID0gd2ViU29ja2V0RmFjdG9yeTtcbiAgICB9XG4gICAgLyoqXG4gICAgICAgRXN0YWJsaXNoZXMgYSBjb25uZWN0aW9uIHRvIHRoZSBzcGVjaWZpZWQgbW9kZWwgYW5kIHJldHVybnMgYVxuICAgICAgIExpdmVNdXNpY1Nlc3Npb24gb2JqZWN0IHJlcHJlc2VudGluZyB0aGF0IGNvbm5lY3Rpb24uXG4gIFxuICAgICAgIEBleHBlcmltZW50YWxcbiAgXG4gICAgICAgQHJlbWFya3NcbiAgXG4gICAgICAgQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciBlc3RhYmxpc2hpbmcgYSBjb25uZWN0aW9uIHRvIHRoZSBtb2RlbC5cbiAgICAgICBAcmV0dXJuIEEgbGl2ZSBzZXNzaW9uLlxuICBcbiAgICAgICBAZXhhbXBsZVxuICAgICAgIGBgYHRzXG4gICAgICAgbGV0IG1vZGVsID0gJ21vZGVscy9seXJpYS1yZWFsdGltZS1leHAnO1xuICAgICAgIGNvbnN0IHNlc3Npb24gPSBhd2FpdCBhaS5saXZlLm11c2ljLmNvbm5lY3Qoe1xuICAgICAgICAgbW9kZWw6IG1vZGVsLFxuICAgICAgICAgY2FsbGJhY2tzOiB7XG4gICAgICAgICAgIG9ubWVzc2FnZTogKGU6IE1lc3NhZ2VFdmVudCkgPT4ge1xuICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdSZWNlaXZlZCBtZXNzYWdlIGZyb20gdGhlIHNlcnZlcjogJXNcXG4nLCBkZWJ1ZyhlLmRhdGEpKTtcbiAgICAgICAgICAgfSxcbiAgICAgICAgICAgb25lcnJvcjogKGU6IEVycm9yRXZlbnQpID0+IHtcbiAgICAgICAgICAgICBjb25zb2xlLmxvZygnRXJyb3Igb2NjdXJyZWQ6ICVzXFxuJywgZGVidWcoZS5lcnJvcikpO1xuICAgICAgICAgICB9LFxuICAgICAgICAgICBvbmNsb3NlOiAoZTogQ2xvc2VFdmVudCkgPT4ge1xuICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdDb25uZWN0aW9uIGNsb3NlZC4nKTtcbiAgICAgICAgICAgfSxcbiAgICAgICAgIH0sXG4gICAgICAgfSk7XG4gICAgICAgYGBgXG4gICAgICAqL1xuICAgIGFzeW5jIGNvbm5lY3QocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTGl2ZSBtdXNpYyBpcyBub3Qgc3VwcG9ydGVkIGZvciBWZXJ0ZXggQUkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS53YXJuKCdMaXZlIG11c2ljIGdlbmVyYXRpb24gaXMgZXhwZXJpbWVudGFsIGFuZCBtYXkgY2hhbmdlIGluIGZ1dHVyZSB2ZXJzaW9ucy4nKTtcbiAgICAgICAgY29uc3Qgd2Vic29ja2V0QmFzZVVybCA9IHRoaXMuYXBpQ2xpZW50LmdldFdlYnNvY2tldEJhc2VVcmwoKTtcbiAgICAgICAgY29uc3QgYXBpVmVyc2lvbiA9IHRoaXMuYXBpQ2xpZW50LmdldEFwaVZlcnNpb24oKTtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IG1hcFRvSGVhZGVycyQxKHRoaXMuYXBpQ2xpZW50LmdldERlZmF1bHRIZWFkZXJzKCkpO1xuICAgICAgICBjb25zdCBhcGlLZXkgPSB0aGlzLmFwaUNsaWVudC5nZXRBcGlLZXkoKTtcbiAgICAgICAgY29uc3QgdXJsID0gYCR7d2Vic29ja2V0QmFzZVVybH0vd3MvZ29vZ2xlLmFpLmdlbmVyYXRpdmVsYW5ndWFnZS4ke2FwaVZlcnNpb259LkdlbmVyYXRpdmVTZXJ2aWNlLkJpZGlHZW5lcmF0ZU11c2ljP2tleT0ke2FwaUtleX1gO1xuICAgICAgICBsZXQgb25vcGVuUmVzb2x2ZSA9ICgpID0+IHsgfTtcbiAgICAgICAgY29uc3Qgb25vcGVuUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICBvbm9wZW5SZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IHBhcmFtcy5jYWxsYmFja3M7XG4gICAgICAgIGNvbnN0IG9ub3BlbkF3YWl0ZWRDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIG9ub3BlblJlc29sdmUoe30pO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBhcGlDbGllbnQgPSB0aGlzLmFwaUNsaWVudDtcbiAgICAgICAgY29uc3Qgd2Vic29ja2V0Q2FsbGJhY2tzID0ge1xuICAgICAgICAgICAgb25vcGVuOiBvbm9wZW5Bd2FpdGVkQ2FsbGJhY2ssXG4gICAgICAgICAgICBvbm1lc3NhZ2U6IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHZvaWQgaGFuZGxlV2ViU29ja2V0TWVzc2FnZSQxKGFwaUNsaWVudCwgY2FsbGJhY2tzLm9ubWVzc2FnZSwgZXZlbnQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uZXJyb3I6IChfYSA9IGNhbGxiYWNrcyA9PT0gbnVsbCB8fCBjYWxsYmFja3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhbGxiYWNrcy5vbmVycm9yKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uY2xvc2U6IChfYiA9IGNhbGxiYWNrcyA9PT0gbnVsbCB8fCBjYWxsYmFja3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhbGxiYWNrcy5vbmNsb3NlKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY29ubiA9IHRoaXMud2ViU29ja2V0RmFjdG9yeS5jcmVhdGUodXJsLCBoZWFkZXJzVG9NYXAkMShoZWFkZXJzKSwgd2Vic29ja2V0Q2FsbGJhY2tzKTtcbiAgICAgICAgY29ubi5jb25uZWN0KCk7XG4gICAgICAgIC8vIFdhaXQgZm9yIHRoZSB3ZWJzb2NrZXQgdG8gb3BlbiBiZWZvcmUgc2VuZGluZyByZXF1ZXN0cy5cbiAgICAgICAgYXdhaXQgb25vcGVuUHJvbWlzZTtcbiAgICAgICAgY29uc3QgbW9kZWwgPSB0TW9kZWwodGhpcy5hcGlDbGllbnQsIHBhcmFtcy5tb2RlbCk7XG4gICAgICAgIGNvbnN0IHNldHVwID0gbGl2ZU11c2ljQ2xpZW50U2V0dXBUb01sZGV2KHtcbiAgICAgICAgICAgIG1vZGVsLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY2xpZW50TWVzc2FnZSA9IGxpdmVNdXNpY0NsaWVudE1lc3NhZ2VUb01sZGV2KHsgc2V0dXAgfSk7XG4gICAgICAgIGNvbm4uc2VuZChKU09OLnN0cmluZ2lmeShjbGllbnRNZXNzYWdlKSk7XG4gICAgICAgIHJldHVybiBuZXcgTGl2ZU11c2ljU2Vzc2lvbihjb25uLCB0aGlzLmFwaUNsaWVudCk7XG4gICAgfVxufVxuLyoqXG4gICBSZXByZXNlbnRzIGEgY29ubmVjdGlvbiB0byB0aGUgQVBJLlxuXG4gICBAZXhwZXJpbWVudGFsXG4gICovXG5jbGFzcyBMaXZlTXVzaWNTZXNzaW9uIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25uLCBhcGlDbGllbnQpIHtcbiAgICAgICAgdGhpcy5jb25uID0gY29ubjtcbiAgICAgICAgdGhpcy5hcGlDbGllbnQgPSBhcGlDbGllbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAgU2V0cyBpbnB1dHMgdG8gc3RlZXIgbXVzaWMgZ2VuZXJhdGlvbi4gVXBkYXRlcyB0aGUgc2Vzc2lvbidzIGN1cnJlbnRcbiAgICAgIHdlaWdodGVkIHByb21wdHMuXG4gIFxuICAgICAgQHBhcmFtIHBhcmFtcyAtIENvbnRhaW5zIG9uZSBwcm9wZXJ0eSwgYHdlaWdodGVkUHJvbXB0c2AuXG4gIFxuICAgICAgICAtIGB3ZWlnaHRlZFByb21wdHNgIHRvIHNlbmQgdG8gdGhlIG1vZGVsOyB3ZWlnaHRzIGFyZSBub3JtYWxpemVkIHRvXG4gICAgICAgICAgc3VtIHRvIDEuMC5cbiAgXG4gICAgICBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgYXN5bmMgc2V0V2VpZ2h0ZWRQcm9tcHRzKHBhcmFtcykge1xuICAgICAgICBpZiAoIXBhcmFtcy53ZWlnaHRlZFByb21wdHMgfHxcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHBhcmFtcy53ZWlnaHRlZFByb21wdHMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZWlnaHRlZCBwcm9tcHRzIG11c3QgYmUgc2V0IGFuZCBjb250YWluIGF0IGxlYXN0IG9uZSBlbnRyeS4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZXRXZWlnaHRlZFByb21wdHNQYXJhbWV0ZXJzID0gbGl2ZU11c2ljU2V0V2VpZ2h0ZWRQcm9tcHRzUGFyYW1ldGVyc1RvTWxkZXYocGFyYW1zKTtcbiAgICAgICAgY29uc3QgY2xpZW50Q29udGVudCA9IGxpdmVNdXNpY0NsaWVudENvbnRlbnRUb01sZGV2KHNldFdlaWdodGVkUHJvbXB0c1BhcmFtZXRlcnMpO1xuICAgICAgICB0aGlzLmNvbm4uc2VuZChKU09OLnN0cmluZ2lmeSh7IGNsaWVudENvbnRlbnQgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgIFNldHMgYSBjb25maWd1cmF0aW9uIHRvIHRoZSBtb2RlbC4gVXBkYXRlcyB0aGUgc2Vzc2lvbidzIGN1cnJlbnRcbiAgICAgIG11c2ljIGdlbmVyYXRpb24gY29uZmlnLlxuICBcbiAgICAgIEBwYXJhbSBwYXJhbXMgLSBDb250YWlucyBvbmUgcHJvcGVydHksIGBtdXNpY0dlbmVyYXRpb25Db25maWdgLlxuICBcbiAgICAgICAgLSBgbXVzaWNHZW5lcmF0aW9uQ29uZmlnYCB0byBzZXQgaW4gdGhlIG1vZGVsLiBQYXNzaW5nIGFuIGVtcHR5IG9yXG4gICAgICB1bmRlZmluZWQgY29uZmlnIHRvIHRoZSBtb2RlbCB3aWxsIHJlc2V0IHRoZSBjb25maWcgdG8gZGVmYXVsdHMuXG4gIFxuICAgICAgQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIGFzeW5jIHNldE11c2ljR2VuZXJhdGlvbkNvbmZpZyhwYXJhbXMpIHtcbiAgICAgICAgaWYgKCFwYXJhbXMubXVzaWNHZW5lcmF0aW9uQ29uZmlnKSB7XG4gICAgICAgICAgICBwYXJhbXMubXVzaWNHZW5lcmF0aW9uQ29uZmlnID0ge307XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2V0Q29uZmlnUGFyYW1ldGVycyA9IGxpdmVNdXNpY1NldENvbmZpZ1BhcmFtZXRlcnNUb01sZGV2KHBhcmFtcyk7XG4gICAgICAgIGNvbnN0IGNsaWVudE1lc3NhZ2UgPSBsaXZlTXVzaWNDbGllbnRNZXNzYWdlVG9NbGRldihzZXRDb25maWdQYXJhbWV0ZXJzKTtcbiAgICAgICAgdGhpcy5jb25uLnNlbmQoSlNPTi5zdHJpbmdpZnkoY2xpZW50TWVzc2FnZSkpO1xuICAgIH1cbiAgICBzZW5kUGxheWJhY2tDb250cm9sKHBsYXliYWNrQ29udHJvbCkge1xuICAgICAgICBjb25zdCBjbGllbnRNZXNzYWdlID0gbGl2ZU11c2ljQ2xpZW50TWVzc2FnZVRvTWxkZXYoe1xuICAgICAgICAgICAgcGxheWJhY2tDb250cm9sLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb25uLnNlbmQoSlNPTi5zdHJpbmdpZnkoY2xpZW50TWVzc2FnZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydCB0aGUgbXVzaWMgc3RyZWFtLlxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHBsYXkoKSB7XG4gICAgICAgIHRoaXMuc2VuZFBsYXliYWNrQ29udHJvbChMaXZlTXVzaWNQbGF5YmFja0NvbnRyb2wuUExBWSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRlbXBvcmFyaWx5IGhhbHQgdGhlIG11c2ljIHN0cmVhbS4gVXNlIGBwbGF5YCB0byByZXN1bWUgZnJvbSB0aGUgY3VycmVudFxuICAgICAqIHBvc2l0aW9uLlxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHBhdXNlKCkge1xuICAgICAgICB0aGlzLnNlbmRQbGF5YmFja0NvbnRyb2woTGl2ZU11c2ljUGxheWJhY2tDb250cm9sLlBBVVNFKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RvcCB0aGUgbXVzaWMgc3RyZWFtIGFuZCByZXNldCB0aGUgc3RhdGUuIFJldGFpbnMgdGhlIGN1cnJlbnQgcHJvbXB0c1xuICAgICAqIGFuZCBjb25maWcuXG4gICAgICpcbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgc3RvcCgpIHtcbiAgICAgICAgdGhpcy5zZW5kUGxheWJhY2tDb250cm9sKExpdmVNdXNpY1BsYXliYWNrQ29udHJvbC5TVE9QKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzZXRzIHRoZSBjb250ZXh0IG9mIHRoZSBtdXNpYyBnZW5lcmF0aW9uIHdpdGhvdXQgc3RvcHBpbmcgaXQuXG4gICAgICogUmV0YWlucyB0aGUgY3VycmVudCBwcm9tcHRzIGFuZCBjb25maWcuXG4gICAgICpcbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgcmVzZXRDb250ZXh0KCkge1xuICAgICAgICB0aGlzLnNlbmRQbGF5YmFja0NvbnRyb2woTGl2ZU11c2ljUGxheWJhY2tDb250cm9sLlJFU0VUX0NPTlRFWFQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgICBUZXJtaW5hdGVzIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbi5cbiAgXG4gICAgICAgQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIGNsb3NlKCkge1xuICAgICAgICB0aGlzLmNvbm4uY2xvc2UoKTtcbiAgICB9XG59XG4vLyBDb252ZXJ0cyBhbiBoZWFkZXJzIG9iamVjdCB0byBhIFwibWFwXCIgb2JqZWN0IGFzIGV4cGVjdGVkIGJ5IHRoZSBXZWJTb2NrZXRcbi8vIGNvbnN0cnVjdG9yLiBXZSB1c2UgdGhpcyBhcyB0aGUgQXV0aCBpbnRlcmZhY2Ugd29ya3Mgd2l0aCBIZWFkZXJzIG9iamVjdHNcbi8vIHdoaWxlIHRoZSBXZWJTb2NrZXQgY29uc3RydWN0b3IgdGFrZXMgYSBtYXAuXG5mdW5jdGlvbiBoZWFkZXJzVG9NYXAkMShoZWFkZXJzKSB7XG4gICAgY29uc3QgaGVhZGVyTWFwID0ge307XG4gICAgaGVhZGVycy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgIGhlYWRlck1hcFtrZXldID0gdmFsdWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIGhlYWRlck1hcDtcbn1cbi8vIENvbnZlcnRzIGEgXCJtYXBcIiBvYmplY3QgdG8gYSBoZWFkZXJzIG9iamVjdC4gV2UgdXNlIHRoaXMgYXMgdGhlIEF1dGhcbi8vIGludGVyZmFjZSB3b3JrcyB3aXRoIEhlYWRlcnMgb2JqZWN0cyB3aGlsZSB0aGUgQVBJIGNsaWVudCBkZWZhdWx0IGhlYWRlcnNcbi8vIHJldHVybnMgYSBtYXAuXG5mdW5jdGlvbiBtYXBUb0hlYWRlcnMkMShtYXApIHtcbiAgICBjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhtYXApKSB7XG4gICAgICAgIGhlYWRlcnMuYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gaGVhZGVycztcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuY29uc3QgRlVOQ1RJT05fUkVTUE9OU0VfUkVRVUlSRVNfSUQgPSAnRnVuY3Rpb25SZXNwb25zZSByZXF1ZXN0IG11c3QgaGF2ZSBhbiBgaWRgIGZpZWxkIGZyb20gdGhlIHJlc3BvbnNlIG9mIGEgVG9vbENhbGwuRnVuY3Rpb25hbENhbGxzIGluIEdvb2dsZSBBSS4nO1xuLyoqXG4gKiBIYW5kbGVzIGluY29taW5nIG1lc3NhZ2VzIGZyb20gdGhlIFdlYlNvY2tldC5cbiAqXG4gKiBAcmVtYXJrc1xuICogVGhpcyBmdW5jdGlvbiBpcyByZXNwb25zaWJsZSBmb3IgcGFyc2luZyBpbmNvbWluZyBtZXNzYWdlcywgdHJhbnNmb3JtaW5nIHRoZW1cbiAqIGludG8gTGl2ZVNlcnZlck1lc3NhZ2VzLCBhbmQgdGhlbiBjYWxsaW5nIHRoZSBvbm1lc3NhZ2UgY2FsbGJhY2suIE5vdGUgdGhhdFxuICogdGhlIGZpcnN0IG1lc3NhZ2Ugd2hpY2ggaXMgcmVjZWl2ZWQgZnJvbSB0aGUgc2VydmVyIGlzIGEgc2V0dXBDb21wbGV0ZVxuICogbWVzc2FnZS5cbiAqXG4gKiBAcGFyYW0gYXBpQ2xpZW50IFRoZSBBcGlDbGllbnQgaW5zdGFuY2UuXG4gKiBAcGFyYW0gb25tZXNzYWdlIFRoZSB1c2VyLXByb3ZpZGVkIG9ubWVzc2FnZSBjYWxsYmFjayAoaWYgYW55KS5cbiAqIEBwYXJhbSBldmVudCBUaGUgTWVzc2FnZUV2ZW50IGZyb20gdGhlIFdlYlNvY2tldC5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gaGFuZGxlV2ViU29ja2V0TWVzc2FnZShhcGlDbGllbnQsIG9ubWVzc2FnZSwgZXZlbnQpIHtcbiAgICBjb25zdCBzZXJ2ZXJNZXNzYWdlID0gbmV3IExpdmVTZXJ2ZXJNZXNzYWdlKCk7XG4gICAgbGV0IGpzb25EYXRhO1xuICAgIGlmIChldmVudC5kYXRhIGluc3RhbmNlb2YgQmxvYikge1xuICAgICAgICBqc29uRGF0YSA9IGF3YWl0IGV2ZW50LmRhdGEudGV4dCgpO1xuICAgIH1cbiAgICBlbHNlIGlmIChldmVudC5kYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAganNvbkRhdGEgPSBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoZXZlbnQuZGF0YSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBqc29uRGF0YSA9IGV2ZW50LmRhdGE7XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKGpzb25EYXRhKTtcbiAgICBpZiAoYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICBjb25zdCByZXNwID0gbGl2ZVNlcnZlck1lc3NhZ2VGcm9tVmVydGV4KGRhdGEpO1xuICAgICAgICBPYmplY3QuYXNzaWduKHNlcnZlck1lc3NhZ2UsIHJlc3ApO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgcmVzcCA9IGxpdmVTZXJ2ZXJNZXNzYWdlRnJvbU1sZGV2KGRhdGEpO1xuICAgICAgICBPYmplY3QuYXNzaWduKHNlcnZlck1lc3NhZ2UsIHJlc3ApO1xuICAgIH1cbiAgICBvbm1lc3NhZ2Uoc2VydmVyTWVzc2FnZSk7XG59XG4vKipcbiAgIExpdmUgY2xhc3MgZW5jYXBzdWxhdGVzIHRoZSBjb25maWd1cmF0aW9uIGZvciBsaXZlIGludGVyYWN0aW9uIHdpdGggdGhlXG4gICBHZW5lcmF0aXZlIExhbmd1YWdlIEFQSS4gSXQgZW1iZWRzIEFwaUNsaWVudCBmb3IgZ2VuZXJhbCBBUEkgc2V0dGluZ3MuXG5cbiAgIEBleHBlcmltZW50YWxcbiAgKi9cbmNsYXNzIExpdmUge1xuICAgIGNvbnN0cnVjdG9yKGFwaUNsaWVudCwgYXV0aCwgd2ViU29ja2V0RmFjdG9yeSkge1xuICAgICAgICB0aGlzLmFwaUNsaWVudCA9IGFwaUNsaWVudDtcbiAgICAgICAgdGhpcy5hdXRoID0gYXV0aDtcbiAgICAgICAgdGhpcy53ZWJTb2NrZXRGYWN0b3J5ID0gd2ViU29ja2V0RmFjdG9yeTtcbiAgICAgICAgdGhpcy5tdXNpYyA9IG5ldyBMaXZlTXVzaWModGhpcy5hcGlDbGllbnQsIHRoaXMuYXV0aCwgdGhpcy53ZWJTb2NrZXRGYWN0b3J5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICAgRXN0YWJsaXNoZXMgYSBjb25uZWN0aW9uIHRvIHRoZSBzcGVjaWZpZWQgbW9kZWwgd2l0aCB0aGUgZ2l2ZW5cbiAgICAgICBjb25maWd1cmF0aW9uIGFuZCByZXR1cm5zIGEgU2Vzc2lvbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoYXQgY29ubmVjdGlvbi5cbiAgXG4gICAgICAgQGV4cGVyaW1lbnRhbCBCdWlsdC1pbiBNQ1Agc3VwcG9ydCBpcyBhbiBleHBlcmltZW50YWwgZmVhdHVyZSwgbWF5IGNoYW5nZSBpblxuICAgICAgIGZ1dHVyZSB2ZXJzaW9ucy5cbiAgXG4gICAgICAgQHJlbWFya3NcbiAgXG4gICAgICAgQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciBlc3RhYmxpc2hpbmcgYSBjb25uZWN0aW9uIHRvIHRoZSBtb2RlbC5cbiAgICAgICBAcmV0dXJuIEEgbGl2ZSBzZXNzaW9uLlxuICBcbiAgICAgICBAZXhhbXBsZVxuICAgICAgIGBgYHRzXG4gICAgICAgbGV0IG1vZGVsOiBzdHJpbmc7XG4gICAgICAgaWYgKEdPT0dMRV9HRU5BSV9VU0VfVkVSVEVYQUkpIHtcbiAgICAgICAgIG1vZGVsID0gJ2dlbWluaS0yLjAtZmxhc2gtbGl2ZS1wcmV2aWV3LTA0LTA5JztcbiAgICAgICB9IGVsc2Uge1xuICAgICAgICAgbW9kZWwgPSAnZ2VtaW5pLTIuMC1mbGFzaC1saXZlLTAwMSc7XG4gICAgICAgfVxuICAgICAgIGNvbnN0IHNlc3Npb24gPSBhd2FpdCBhaS5saXZlLmNvbm5lY3Qoe1xuICAgICAgICAgbW9kZWw6IG1vZGVsLFxuICAgICAgICAgY29uZmlnOiB7XG4gICAgICAgICAgIHJlc3BvbnNlTW9kYWxpdGllczogW01vZGFsaXR5LkFVRElPXSxcbiAgICAgICAgIH0sXG4gICAgICAgICBjYWxsYmFja3M6IHtcbiAgICAgICAgICAgb25vcGVuOiAoKSA9PiB7XG4gICAgICAgICAgICAgY29uc29sZS5sb2coJ0Nvbm5lY3RlZCB0byB0aGUgc29ja2V0LicpO1xuICAgICAgICAgICB9LFxuICAgICAgICAgICBvbm1lc3NhZ2U6IChlOiBNZXNzYWdlRXZlbnQpID0+IHtcbiAgICAgICAgICAgICBjb25zb2xlLmxvZygnUmVjZWl2ZWQgbWVzc2FnZSBmcm9tIHRoZSBzZXJ2ZXI6ICVzXFxuJywgZGVidWcoZS5kYXRhKSk7XG4gICAgICAgICAgIH0sXG4gICAgICAgICAgIG9uZXJyb3I6IChlOiBFcnJvckV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgY29uc29sZS5sb2coJ0Vycm9yIG9jY3VycmVkOiAlc1xcbicsIGRlYnVnKGUuZXJyb3IpKTtcbiAgICAgICAgICAgfSxcbiAgICAgICAgICAgb25jbG9zZTogKGU6IENsb3NlRXZlbnQpID0+IHtcbiAgICAgICAgICAgICBjb25zb2xlLmxvZygnQ29ubmVjdGlvbiBjbG9zZWQuJyk7XG4gICAgICAgICAgIH0sXG4gICAgICAgICB9LFxuICAgICAgIH0pO1xuICAgICAgIGBgYFxuICAgICAgKi9cbiAgICBhc3luYyBjb25uZWN0KHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgICAgICAgY29uc3Qgd2Vic29ja2V0QmFzZVVybCA9IHRoaXMuYXBpQ2xpZW50LmdldFdlYnNvY2tldEJhc2VVcmwoKTtcbiAgICAgICAgY29uc3QgYXBpVmVyc2lvbiA9IHRoaXMuYXBpQ2xpZW50LmdldEFwaVZlcnNpb24oKTtcbiAgICAgICAgbGV0IHVybDtcbiAgICAgICAgY29uc3QgZGVmYXVsdEhlYWRlcnMgPSB0aGlzLmFwaUNsaWVudC5nZXREZWZhdWx0SGVhZGVycygpO1xuICAgICAgICBpZiAocGFyYW1zLmNvbmZpZyAmJlxuICAgICAgICAgICAgcGFyYW1zLmNvbmZpZy50b29scyAmJlxuICAgICAgICAgICAgaGFzTWNwVG9vbFVzYWdlKHBhcmFtcy5jb25maWcudG9vbHMpKSB7XG4gICAgICAgICAgICBzZXRNY3BVc2FnZUhlYWRlcihkZWZhdWx0SGVhZGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGVhZGVycyA9IG1hcFRvSGVhZGVycyhkZWZhdWx0SGVhZGVycyk7XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIHVybCA9IGAke3dlYnNvY2tldEJhc2VVcmx9L3dzL2dvb2dsZS5jbG91ZC5haXBsYXRmb3JtLiR7YXBpVmVyc2lvbn0uTGxtQmlkaVNlcnZpY2UvQmlkaUdlbmVyYXRlQ29udGVudGA7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmF1dGguYWRkQXV0aEhlYWRlcnMoaGVhZGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBhcGlLZXkgPSB0aGlzLmFwaUNsaWVudC5nZXRBcGlLZXkoKTtcbiAgICAgICAgICAgIGxldCBtZXRob2QgPSAnQmlkaUdlbmVyYXRlQ29udGVudCc7XG4gICAgICAgICAgICBsZXQga2V5TmFtZSA9ICdrZXknO1xuICAgICAgICAgICAgaWYgKGFwaUtleSA9PT0gbnVsbCB8fCBhcGlLZXkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFwaUtleS5zdGFydHNXaXRoKCdhdXRoX3Rva2Vucy8nKSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignV2FybmluZzogRXBoZW1lcmFsIHRva2VuIHN1cHBvcnQgaXMgZXhwZXJpbWVudGFsIGFuZCBtYXkgY2hhbmdlIGluIGZ1dHVyZSB2ZXJzaW9ucy4nKTtcbiAgICAgICAgICAgICAgICBtZXRob2QgPSAnQmlkaUdlbmVyYXRlQ29udGVudENvbnN0cmFpbmVkJztcbiAgICAgICAgICAgICAgICBrZXlOYW1lID0gJ2FjY2Vzc190b2tlbic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1cmwgPSBgJHt3ZWJzb2NrZXRCYXNlVXJsfS93cy9nb29nbGUuYWkuZ2VuZXJhdGl2ZWxhbmd1YWdlLiR7YXBpVmVyc2lvbn0uR2VuZXJhdGl2ZVNlcnZpY2UuJHttZXRob2R9PyR7a2V5TmFtZX09JHthcGlLZXl9YDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgb25vcGVuUmVzb2x2ZSA9ICgpID0+IHsgfTtcbiAgICAgICAgY29uc3Qgb25vcGVuUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICBvbm9wZW5SZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IHBhcmFtcy5jYWxsYmFja3M7XG4gICAgICAgIGNvbnN0IG9ub3BlbkF3YWl0ZWRDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIChfYSA9IGNhbGxiYWNrcyA9PT0gbnVsbCB8fCBjYWxsYmFja3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhbGxiYWNrcy5vbm9wZW4pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGNhbGxiYWNrcyk7XG4gICAgICAgICAgICBvbm9wZW5SZXNvbHZlKHt9KTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgYXBpQ2xpZW50ID0gdGhpcy5hcGlDbGllbnQ7XG4gICAgICAgIGNvbnN0IHdlYnNvY2tldENhbGxiYWNrcyA9IHtcbiAgICAgICAgICAgIG9ub3Blbjogb25vcGVuQXdhaXRlZENhbGxiYWNrLFxuICAgICAgICAgICAgb25tZXNzYWdlOiAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICB2b2lkIGhhbmRsZVdlYlNvY2tldE1lc3NhZ2UoYXBpQ2xpZW50LCBjYWxsYmFja3Mub25tZXNzYWdlLCBldmVudCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25lcnJvcjogKF9hID0gY2FsbGJhY2tzID09PSBudWxsIHx8IGNhbGxiYWNrcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FsbGJhY2tzLm9uZXJyb3IpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25jbG9zZTogKF9iID0gY2FsbGJhY2tzID09PSBudWxsIHx8IGNhbGxiYWNrcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FsbGJhY2tzLm9uY2xvc2UpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjb25uID0gdGhpcy53ZWJTb2NrZXRGYWN0b3J5LmNyZWF0ZSh1cmwsIGhlYWRlcnNUb01hcChoZWFkZXJzKSwgd2Vic29ja2V0Q2FsbGJhY2tzKTtcbiAgICAgICAgY29ubi5jb25uZWN0KCk7XG4gICAgICAgIC8vIFdhaXQgZm9yIHRoZSB3ZWJzb2NrZXQgdG8gb3BlbiBiZWZvcmUgc2VuZGluZyByZXF1ZXN0cy5cbiAgICAgICAgYXdhaXQgb25vcGVuUHJvbWlzZTtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTW9kZWwgPSB0TW9kZWwodGhpcy5hcGlDbGllbnQsIHBhcmFtcy5tb2RlbCk7XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkgJiZcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTW9kZWwuc3RhcnRzV2l0aCgncHVibGlzaGVycy8nKSkge1xuICAgICAgICAgICAgY29uc3QgcHJvamVjdCA9IHRoaXMuYXBpQ2xpZW50LmdldFByb2plY3QoKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2F0aW9uID0gdGhpcy5hcGlDbGllbnQuZ2V0TG9jYXRpb24oKTtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTW9kZWwgPVxuICAgICAgICAgICAgICAgIGBwcm9qZWN0cy8ke3Byb2plY3R9L2xvY2F0aW9ucy8ke2xvY2F0aW9ufS9gICsgdHJhbnNmb3JtZWRNb2RlbDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY2xpZW50TWVzc2FnZSA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpICYmXG4gICAgICAgICAgICAoKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnJlc3BvbnNlTW9kYWxpdGllcykgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gU2V0IGRlZmF1bHQgdG8gQVVESU8gdG8gYWxpZ24gd2l0aCBNTERldiBBUEkuXG4gICAgICAgICAgICBpZiAocGFyYW1zLmNvbmZpZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zLmNvbmZpZyA9IHsgcmVzcG9uc2VNb2RhbGl0aWVzOiBbTW9kYWxpdHkuQVVESU9dIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMuY29uZmlnLnJlc3BvbnNlTW9kYWxpdGllcyA9IFtNb2RhbGl0eS5BVURJT107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5nZW5lcmF0aW9uQ29uZmlnKSB7XG4gICAgICAgICAgICAvLyBSYWlzZSBkZXByZWNhdGlvbiB3YXJuaW5nIGZvciBnZW5lcmF0aW9uQ29uZmlnLlxuICAgICAgICAgICAgY29uc29sZS53YXJuKCdTZXR0aW5nIGBMaXZlQ29ubmVjdENvbmZpZy5nZW5lcmF0aW9uX2NvbmZpZ2AgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHNldCB0aGUgZmllbGRzIG9uIGBMaXZlQ29ubmVjdENvbmZpZ2AgZGlyZWN0bHkuIFRoaXMgd2lsbCBiZWNvbWUgYW4gZXJyb3IgaW4gYSBmdXR1cmUgdmVyc2lvbiAobm90IGJlZm9yZSBRMyAyMDI1KS4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbnB1dFRvb2xzID0gKF9mID0gKF9lID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLnRvb2xzKSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiBbXTtcbiAgICAgICAgY29uc3QgY29udmVydGVkVG9vbHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCB0b29sIG9mIGlucHV0VG9vbHMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzQ2FsbGFibGVUb29sKHRvb2wpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FsbGFibGVUb29sID0gdG9vbDtcbiAgICAgICAgICAgICAgICBjb252ZXJ0ZWRUb29scy5wdXNoKGF3YWl0IGNhbGxhYmxlVG9vbC50b29sKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udmVydGVkVG9vbHMucHVzaCh0b29sKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udmVydGVkVG9vbHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcGFyYW1zLmNvbmZpZy50b29scyA9IGNvbnZlcnRlZFRvb2xzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxpdmVDb25uZWN0UGFyYW1ldGVycyA9IHtcbiAgICAgICAgICAgIG1vZGVsOiB0cmFuc2Zvcm1lZE1vZGVsLFxuICAgICAgICAgICAgY29uZmlnOiBwYXJhbXMuY29uZmlnLFxuICAgICAgICAgICAgY2FsbGJhY2tzOiBwYXJhbXMuY2FsbGJhY2tzLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjbGllbnRNZXNzYWdlID0gbGl2ZUNvbm5lY3RQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIGxpdmVDb25uZWN0UGFyYW1ldGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjbGllbnRNZXNzYWdlID0gbGl2ZUNvbm5lY3RQYXJhbWV0ZXJzVG9NbGRldih0aGlzLmFwaUNsaWVudCwgbGl2ZUNvbm5lY3RQYXJhbWV0ZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgY2xpZW50TWVzc2FnZVsnY29uZmlnJ107XG4gICAgICAgIGNvbm4uc2VuZChKU09OLnN0cmluZ2lmeShjbGllbnRNZXNzYWdlKSk7XG4gICAgICAgIHJldHVybiBuZXcgU2Vzc2lvbihjb25uLCB0aGlzLmFwaUNsaWVudCk7XG4gICAgfVxuICAgIC8vIFRPRE86IGIvNDE2MDQxMjI5IC0gQWJzdHJhY3QgdGhpcyBtZXRob2QgdG8gYSBjb21tb24gcGxhY2UuXG4gICAgaXNDYWxsYWJsZVRvb2wodG9vbCkge1xuICAgICAgICByZXR1cm4gJ2NhbGxUb29sJyBpbiB0b29sICYmIHR5cGVvZiB0b29sLmNhbGxUb29sID09PSAnZnVuY3Rpb24nO1xuICAgIH1cbn1cbmNvbnN0IGRlZmF1bHRMaXZlU2VuZENsaWVudENvbnRlbnRQYXJhbWVydGVycyA9IHtcbiAgICB0dXJuQ29tcGxldGU6IHRydWUsXG59O1xuLyoqXG4gICBSZXByZXNlbnRzIGEgY29ubmVjdGlvbiB0byB0aGUgQVBJLlxuXG4gICBAZXhwZXJpbWVudGFsXG4gICovXG5jbGFzcyBTZXNzaW9uIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25uLCBhcGlDbGllbnQpIHtcbiAgICAgICAgdGhpcy5jb25uID0gY29ubjtcbiAgICAgICAgdGhpcy5hcGlDbGllbnQgPSBhcGlDbGllbnQ7XG4gICAgfVxuICAgIHRMaXZlQ2xpZW50Q29udGVudChhcGlDbGllbnQsIHBhcmFtcykge1xuICAgICAgICBpZiAocGFyYW1zLnR1cm5zICE9PSBudWxsICYmIHBhcmFtcy50dXJucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsZXQgY29udGVudHMgPSBbXTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29udGVudHMgPSB0Q29udGVudHMocGFyYW1zLnR1cm5zKTtcbiAgICAgICAgICAgICAgICBpZiAoYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50cyA9IGNvbnRlbnRzLm1hcCgoaXRlbSkgPT4gY29udGVudFRvVmVydGV4KGl0ZW0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRzID0gY29udGVudHMubWFwKChpdGVtKSA9PiBjb250ZW50VG9NbGRldiQxKGl0ZW0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBwYXJzZSBjbGllbnQgY29udGVudCBcInR1cm5zXCIsIHR5cGU6ICcke3R5cGVvZiBwYXJhbXMudHVybnN9J2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjbGllbnRDb250ZW50OiB7IHR1cm5zOiBjb250ZW50cywgdHVybkNvbXBsZXRlOiBwYXJhbXMudHVybkNvbXBsZXRlIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjbGllbnRDb250ZW50OiB7IHR1cm5Db21wbGV0ZTogcGFyYW1zLnR1cm5Db21wbGV0ZSB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICB0TGl2ZUNsaWVudHRUb29sUmVzcG9uc2UoYXBpQ2xpZW50LCBwYXJhbXMpIHtcbiAgICAgICAgbGV0IGZ1bmN0aW9uUmVzcG9uc2VzID0gW107XG4gICAgICAgIGlmIChwYXJhbXMuZnVuY3Rpb25SZXNwb25zZXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmdW5jdGlvblJlc3BvbnNlcyBpcyByZXF1aXJlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocGFyYW1zLmZ1bmN0aW9uUmVzcG9uc2VzKSkge1xuICAgICAgICAgICAgZnVuY3Rpb25SZXNwb25zZXMgPSBbcGFyYW1zLmZ1bmN0aW9uUmVzcG9uc2VzXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uUmVzcG9uc2VzID0gcGFyYW1zLmZ1bmN0aW9uUmVzcG9uc2VzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmdW5jdGlvblJlc3BvbnNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZnVuY3Rpb25SZXNwb25zZXMgaXMgcmVxdWlyZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBmdW5jdGlvblJlc3BvbnNlIG9mIGZ1bmN0aW9uUmVzcG9uc2VzKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGZ1bmN0aW9uUmVzcG9uc2UgIT09ICdvYmplY3QnIHx8XG4gICAgICAgICAgICAgICAgZnVuY3Rpb25SZXNwb25zZSA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgICEoJ25hbWUnIGluIGZ1bmN0aW9uUmVzcG9uc2UpIHx8XG4gICAgICAgICAgICAgICAgISgncmVzcG9uc2UnIGluIGZ1bmN0aW9uUmVzcG9uc2UpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgcGFyc2UgZnVuY3Rpb24gcmVzcG9uc2UsIHR5cGUgJyR7dHlwZW9mIGZ1bmN0aW9uUmVzcG9uc2V9Jy5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYXBpQ2xpZW50LmlzVmVydGV4QUkoKSAmJiAhKCdpZCcgaW4gZnVuY3Rpb25SZXNwb25zZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoRlVOQ1RJT05fUkVTUE9OU0VfUkVRVUlSRVNfSUQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNsaWVudE1lc3NhZ2UgPSB7XG4gICAgICAgICAgICB0b29sUmVzcG9uc2U6IHsgZnVuY3Rpb25SZXNwb25zZXM6IGZ1bmN0aW9uUmVzcG9uc2VzIH0sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBjbGllbnRNZXNzYWdlO1xuICAgIH1cbiAgICAvKipcbiAgICAgIFNlbmQgYSBtZXNzYWdlIG92ZXIgdGhlIGVzdGFibGlzaGVkIGNvbm5lY3Rpb24uXG4gIFxuICAgICAgQHBhcmFtIHBhcmFtcyAtIENvbnRhaW5zIHR3byAqKm9wdGlvbmFsKiogcHJvcGVydGllcywgYHR1cm5zYCBhbmRcbiAgICAgICAgICBgdHVybkNvbXBsZXRlYC5cbiAgXG4gICAgICAgIC0gYHR1cm5zYCB3aWxsIGJlIGNvbnZlcnRlZCB0byBhIGBDb250ZW50W11gXG4gICAgICAgIC0gYHR1cm5Db21wbGV0ZTogdHJ1ZWAgW2RlZmF1bHRdIGluZGljYXRlcyB0aGF0IHlvdSBhcmUgZG9uZSBzZW5kaW5nXG4gICAgICAgICAgY29udGVudCBhbmQgZXhwZWN0IGEgcmVzcG9uc2UuIElmIGB0dXJuQ29tcGxldGU6IGZhbHNlYCwgdGhlIHNlcnZlclxuICAgICAgICAgIHdpbGwgd2FpdCBmb3IgYWRkaXRpb25hbCBtZXNzYWdlcyBiZWZvcmUgc3RhcnRpbmcgZ2VuZXJhdGlvbi5cbiAgXG4gICAgICBAZXhwZXJpbWVudGFsXG4gIFxuICAgICAgQHJlbWFya3NcbiAgICAgIFRoZXJlIGFyZSB0d28gd2F5cyB0byBzZW5kIG1lc3NhZ2VzIHRvIHRoZSBsaXZlIEFQSTpcbiAgICAgIGBzZW5kQ2xpZW50Q29udGVudGAgYW5kIGBzZW5kUmVhbHRpbWVJbnB1dGAuXG4gIFxuICAgICAgYHNlbmRDbGllbnRDb250ZW50YCBtZXNzYWdlcyBhcmUgYWRkZWQgdG8gdGhlIG1vZGVsIGNvbnRleHQgKippbiBvcmRlcioqLlxuICAgICAgSGF2aW5nIGEgY29udmVyc2F0aW9uIHVzaW5nIGBzZW5kQ2xpZW50Q29udGVudGAgbWVzc2FnZXMgaXMgcm91Z2hseVxuICAgICAgZXF1aXZhbGVudCB0byB1c2luZyB0aGUgYENoYXQuc2VuZE1lc3NhZ2VTdHJlYW1gLCBleGNlcHQgdGhhdCB0aGUgc3RhdGUgb2ZcbiAgICAgIHRoZSBgY2hhdGAgaGlzdG9yeSBpcyBzdG9yZWQgb24gdGhlIEFQSSBzZXJ2ZXIgaW5zdGVhZCBvZiBsb2NhbGx5LlxuICBcbiAgICAgIEJlY2F1c2Ugb2YgYHNlbmRDbGllbnRDb250ZW50YCdzIG9yZGVyIGd1YXJhbnRlZSwgdGhlIG1vZGVsIGNhbm5vdCByZXNwb25zXG4gICAgICBhcyBxdWlja2x5IHRvIGBzZW5kQ2xpZW50Q29udGVudGAgbWVzc2FnZXMgYXMgdG8gYHNlbmRSZWFsdGltZUlucHV0YFxuICAgICAgbWVzc2FnZXMuIFRoaXMgbWFrZXMgdGhlIGJpZ2dlc3QgZGlmZmVyZW5jZSB3aGVuIHNlbmRpbmcgb2JqZWN0cyB0aGF0IGhhdmVcbiAgICAgIHNpZ25pZmljYW50IHByZXByb2Nlc3NpbmcgdGltZSAodHlwaWNhbGx5IGltYWdlcykuXG4gIFxuICAgICAgVGhlIGBzZW5kQ2xpZW50Q29udGVudGAgbWVzc2FnZSBzZW5kcyBhIGBDb250ZW50W11gXG4gICAgICB3aGljaCBoYXMgbW9yZSBvcHRpb25zIHRoYW4gdGhlIGBCbG9iYCBzZW50IGJ5IGBzZW5kUmVhbHRpbWVJbnB1dGAuXG4gIFxuICAgICAgU28gdGhlIG1haW4gdXNlLWNhc2VzIGZvciBgc2VuZENsaWVudENvbnRlbnRgIG92ZXIgYHNlbmRSZWFsdGltZUlucHV0YCBhcmU6XG4gIFxuICAgICAgLSBTZW5kaW5nIGFueXRoaW5nIHRoYXQgY2FuJ3QgYmUgcmVwcmVzZW50ZWQgYXMgYSBgQmxvYmAgKHRleHQsXG4gICAgICBgc2VuZENsaWVudENvbnRlbnQoe3R1cm5zPVwiSGVsbG8/XCJ9YCkpLlxuICAgICAgLSBNYW5hZ2luZyB0dXJucyB3aGVuIG5vdCB1c2luZyBhdWRpbyBpbnB1dCBhbmQgdm9pY2UgYWN0aXZpdHkgZGV0ZWN0aW9uLlxuICAgICAgICAoYHNlbmRDbGllbnRDb250ZW50KHt0dXJuQ29tcGxldGU6dHJ1ZX0pYCBvciB0aGUgc2hvcnQgZm9ybVxuICAgICAgYHNlbmRDbGllbnRDb250ZW50KClgKVxuICAgICAgLSBQcmVmaWxsaW5nIGEgY29udmVyc2F0aW9uIGNvbnRleHRcbiAgICAgICAgYGBgXG4gICAgICAgIHNlbmRDbGllbnRDb250ZW50KHtcbiAgICAgICAgICAgIHR1cm5zOiBbXG4gICAgICAgICAgICAgIENvbnRlbnQoe3JvbGU6dXNlciwgcGFydHM6Li4ufSksXG4gICAgICAgICAgICAgIENvbnRlbnQoe3JvbGU6dXNlciwgcGFydHM6Li4ufSksXG4gICAgICAgICAgICAgIC4uLlxuICAgICAgICAgICAgXVxuICAgICAgICB9KVxuICAgICAgICBgYGBcbiAgICAgIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICBzZW5kQ2xpZW50Q29udGVudChwYXJhbXMpIHtcbiAgICAgICAgcGFyYW1zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0TGl2ZVNlbmRDbGllbnRDb250ZW50UGFyYW1lcnRlcnMpLCBwYXJhbXMpO1xuICAgICAgICBjb25zdCBjbGllbnRNZXNzYWdlID0gdGhpcy50TGl2ZUNsaWVudENvbnRlbnQodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgIHRoaXMuY29ubi5zZW5kKEpTT04uc3RyaW5naWZ5KGNsaWVudE1lc3NhZ2UpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICBTZW5kIGEgcmVhbHRpbWUgbWVzc2FnZSBvdmVyIHRoZSBlc3RhYmxpc2hlZCBjb25uZWN0aW9uLlxuICBcbiAgICAgIEBwYXJhbSBwYXJhbXMgLSBDb250YWlucyBvbmUgcHJvcGVydHksIGBtZWRpYWAuXG4gIFxuICAgICAgICAtIGBtZWRpYWAgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gYSBgQmxvYmBcbiAgXG4gICAgICBAZXhwZXJpbWVudGFsXG4gIFxuICAgICAgQHJlbWFya3NcbiAgICAgIFVzZSBgc2VuZFJlYWx0aW1lSW5wdXRgIGZvciByZWFsdGltZSBhdWRpbyBjaHVua3MgYW5kIHZpZGVvIGZyYW1lcyAoaW1hZ2VzKS5cbiAgXG4gICAgICBXaXRoIGBzZW5kUmVhbHRpbWVJbnB1dGAgdGhlIGFwaSB3aWxsIHJlc3BvbmQgdG8gYXVkaW8gYXV0b21hdGljYWxseVxuICAgICAgYmFzZWQgb24gdm9pY2UgYWN0aXZpdHkgZGV0ZWN0aW9uIChWQUQpLlxuICBcbiAgICAgIGBzZW5kUmVhbHRpbWVJbnB1dGAgaXMgb3B0aW1pemVkIGZvciByZXNwb25zaXZuZXNzIGF0IHRoZSBleHBlbnNlIG9mXG4gICAgICBkZXRlcm1pbmlzdGljIG9yZGVyaW5nIGd1YXJhbnRlZXMuIEF1ZGlvIGFuZCB2aWRlbyB0b2tlbnMgYXJlIHRvIHRoZVxuICAgICAgY29udGV4dCB3aGVuIHRoZXkgYmVjb21lIGF2YWlsYWJsZS5cbiAgXG4gICAgICBOb3RlOiBUaGUgQ2FsbCBzaWduYXR1cmUgZXhwZWN0cyBhIGBCbG9iYCBvYmplY3QsIGJ1dCBvbmx5IGEgc3Vic2V0XG4gICAgICBvZiBhdWRpbyBhbmQgaW1hZ2UgbWltZXR5cGVzIGFyZSBhbGxvd2VkLlxuICAgICAqL1xuICAgIHNlbmRSZWFsdGltZUlucHV0KHBhcmFtcykge1xuICAgICAgICBsZXQgY2xpZW50TWVzc2FnZSA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjbGllbnRNZXNzYWdlID0ge1xuICAgICAgICAgICAgICAgICdyZWFsdGltZUlucHV0JzogbGl2ZVNlbmRSZWFsdGltZUlucHV0UGFyYW1ldGVyc1RvVmVydGV4KHBhcmFtcyksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2xpZW50TWVzc2FnZSA9IHtcbiAgICAgICAgICAgICAgICAncmVhbHRpbWVJbnB1dCc6IGxpdmVTZW5kUmVhbHRpbWVJbnB1dFBhcmFtZXRlcnNUb01sZGV2KHBhcmFtcyksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29ubi5zZW5kKEpTT04uc3RyaW5naWZ5KGNsaWVudE1lc3NhZ2UpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICBTZW5kIGEgZnVuY3Rpb24gcmVzcG9uc2UgbWVzc2FnZSBvdmVyIHRoZSBlc3RhYmxpc2hlZCBjb25uZWN0aW9uLlxuICBcbiAgICAgIEBwYXJhbSBwYXJhbXMgLSBDb250YWlucyBwcm9wZXJ0eSBgZnVuY3Rpb25SZXNwb25zZXNgLlxuICBcbiAgICAgICAgLSBgZnVuY3Rpb25SZXNwb25zZXNgIHdpbGwgYmUgY29udmVydGVkIHRvIGEgYGZ1bmN0aW9uUmVzcG9uc2VzW11gXG4gIFxuICAgICAgQHJlbWFya3NcbiAgICAgIFVzZSBgc2VuZEZ1bmN0aW9uUmVzcG9uc2VgIHRvIHJlcGx5IHRvIGBMaXZlU2VydmVyVG9vbENhbGxgIGZyb20gdGhlIHNlcnZlci5cbiAgXG4gICAgICBVc2Uge0BsaW5rIHR5cGVzLkxpdmVDb25uZWN0Q29uZmlnI3Rvb2xzfSB0byBjb25maWd1cmUgdGhlIGNhbGxhYmxlIGZ1bmN0aW9ucy5cbiAgXG4gICAgICBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgc2VuZFRvb2xSZXNwb25zZShwYXJhbXMpIHtcbiAgICAgICAgaWYgKHBhcmFtcy5mdW5jdGlvblJlc3BvbnNlcyA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Rvb2wgcmVzcG9uc2UgcGFyYW1ldGVycyBhcmUgcmVxdWlyZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2xpZW50TWVzc2FnZSA9IHRoaXMudExpdmVDbGllbnR0VG9vbFJlc3BvbnNlKHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICB0aGlzLmNvbm4uc2VuZChKU09OLnN0cmluZ2lmeShjbGllbnRNZXNzYWdlKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAgIFRlcm1pbmF0ZXMgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uLlxuICBcbiAgICAgICBAZXhwZXJpbWVudGFsXG4gIFxuICAgICAgIEBleGFtcGxlXG4gICAgICAgYGBgdHNcbiAgICAgICBsZXQgbW9kZWw6IHN0cmluZztcbiAgICAgICBpZiAoR09PR0xFX0dFTkFJX1VTRV9WRVJURVhBSSkge1xuICAgICAgICAgbW9kZWwgPSAnZ2VtaW5pLTIuMC1mbGFzaC1saXZlLXByZXZpZXctMDQtMDknO1xuICAgICAgIH0gZWxzZSB7XG4gICAgICAgICBtb2RlbCA9ICdnZW1pbmktMi4wLWZsYXNoLWxpdmUtMDAxJztcbiAgICAgICB9XG4gICAgICAgY29uc3Qgc2Vzc2lvbiA9IGF3YWl0IGFpLmxpdmUuY29ubmVjdCh7XG4gICAgICAgICBtb2RlbDogbW9kZWwsXG4gICAgICAgICBjb25maWc6IHtcbiAgICAgICAgICAgcmVzcG9uc2VNb2RhbGl0aWVzOiBbTW9kYWxpdHkuQVVESU9dLFxuICAgICAgICAgfVxuICAgICAgIH0pO1xuICBcbiAgICAgICBzZXNzaW9uLmNsb3NlKCk7XG4gICAgICAgYGBgXG4gICAgICovXG4gICAgY2xvc2UoKSB7XG4gICAgICAgIHRoaXMuY29ubi5jbG9zZSgpO1xuICAgIH1cbn1cbi8vIENvbnZlcnRzIGFuIGhlYWRlcnMgb2JqZWN0IHRvIGEgXCJtYXBcIiBvYmplY3QgYXMgZXhwZWN0ZWQgYnkgdGhlIFdlYlNvY2tldFxuLy8gY29uc3RydWN0b3IuIFdlIHVzZSB0aGlzIGFzIHRoZSBBdXRoIGludGVyZmFjZSB3b3JrcyB3aXRoIEhlYWRlcnMgb2JqZWN0c1xuLy8gd2hpbGUgdGhlIFdlYlNvY2tldCBjb25zdHJ1Y3RvciB0YWtlcyBhIG1hcC5cbmZ1bmN0aW9uIGhlYWRlcnNUb01hcChoZWFkZXJzKSB7XG4gICAgY29uc3QgaGVhZGVyTWFwID0ge307XG4gICAgaGVhZGVycy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgIGhlYWRlck1hcFtrZXldID0gdmFsdWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIGhlYWRlck1hcDtcbn1cbi8vIENvbnZlcnRzIGEgXCJtYXBcIiBvYmplY3QgdG8gYSBoZWFkZXJzIG9iamVjdC4gV2UgdXNlIHRoaXMgYXMgdGhlIEF1dGhcbi8vIGludGVyZmFjZSB3b3JrcyB3aXRoIEhlYWRlcnMgb2JqZWN0cyB3aGlsZSB0aGUgQVBJIGNsaWVudCBkZWZhdWx0IGhlYWRlcnNcbi8vIHJldHVybnMgYSBtYXAuXG5mdW5jdGlvbiBtYXBUb0hlYWRlcnMobWFwKSB7XG4gICAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKCk7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMobWFwKSkge1xuICAgICAgICBoZWFkZXJzLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGhlYWRlcnM7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmNvbnN0IERFRkFVTFRfTUFYX1JFTU9URV9DQUxMUyA9IDEwO1xuLyoqIFJldHVybnMgd2hldGhlciBhdXRvbWF0aWMgZnVuY3Rpb24gY2FsbGluZyBpcyBkaXNhYmxlZC4gKi9cbmZ1bmN0aW9uIHNob3VsZERpc2FibGVBZmMoY29uZmlnKSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgaWYgKChfYSA9IGNvbmZpZyA9PT0gbnVsbCB8fCBjb25maWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZy5hdXRvbWF0aWNGdW5jdGlvbkNhbGxpbmcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kaXNhYmxlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBsZXQgY2FsbGFibGVUb29sc1ByZXNlbnQgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IHRvb2wgb2YgKF9iID0gY29uZmlnID09PSBudWxsIHx8IGNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnLnRvb2xzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXSkge1xuICAgICAgICBpZiAoaXNDYWxsYWJsZVRvb2wodG9vbCkpIHtcbiAgICAgICAgICAgIGNhbGxhYmxlVG9vbHNQcmVzZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghY2FsbGFibGVUb29sc1ByZXNlbnQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0IG1heENhbGxzID0gKF9jID0gY29uZmlnID09PSBudWxsIHx8IGNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnLmF1dG9tYXRpY0Z1bmN0aW9uQ2FsbGluZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLm1heGltdW1SZW1vdGVDYWxscztcbiAgICBpZiAoKG1heENhbGxzICYmIChtYXhDYWxscyA8IDAgfHwgIU51bWJlci5pc0ludGVnZXIobWF4Q2FsbHMpKSkgfHxcbiAgICAgICAgbWF4Q2FsbHMgPT0gMCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0ludmFsaWQgbWF4aW11bVJlbW90ZUNhbGxzIHZhbHVlIHByb3ZpZGVkIGZvciBhdXRvbWF0aWMgZnVuY3Rpb24gY2FsbGluZy4gRGlzYWJsZWQgYXV0b21hdGljIGZ1bmN0aW9uIGNhbGxpbmcuIFBsZWFzZSBwcm92aWRlIGEgdmFsaWQgaW50ZWdlciB2YWx1ZSBncmVhdGVyIHRoYW4gMC4gbWF4aW11bVJlbW90ZUNhbGxzIHByb3ZpZGVkOicsIG1heENhbGxzKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzQ2FsbGFibGVUb29sKHRvb2wpIHtcbiAgICByZXR1cm4gJ2NhbGxUb29sJyBpbiB0b29sICYmIHR5cGVvZiB0b29sLmNhbGxUb29sID09PSAnZnVuY3Rpb24nO1xufVxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgdG8gYXBwZW5kIGF1dG9tYXRpYyBmdW5jdGlvbiBjYWxsaW5nIGhpc3RvcnkgdG8gdGhlXG4gKiByZXNwb25zZS5cbiAqL1xuZnVuY3Rpb24gc2hvdWxkQXBwZW5kQWZjSGlzdG9yeShjb25maWcpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuICEoKF9hID0gY29uZmlnID09PSBudWxsIHx8IGNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnLmF1dG9tYXRpY0Z1bmN0aW9uQ2FsbGluZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlnbm9yZUNhbGxIaXN0b3J5KTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuY2xhc3MgTW9kZWxzIGV4dGVuZHMgQmFzZU1vZHVsZSB7XG4gICAgY29uc3RydWN0b3IoYXBpQ2xpZW50KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYXBpQ2xpZW50ID0gYXBpQ2xpZW50O1xuICAgICAgICAvKipcbiAgICAgICAgICogTWFrZXMgYW4gQVBJIHJlcXVlc3QgdG8gZ2VuZXJhdGUgY29udGVudCB3aXRoIGEgZ2l2ZW4gbW9kZWwuXG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciB0aGUgYG1vZGVsYCBwYXJhbWV0ZXIsIHN1cHBvcnRlZCBmb3JtYXRzIGZvciBWZXJ0ZXggQUkgQVBJIGluY2x1ZGU6XG4gICAgICAgICAqIC0gVGhlIEdlbWluaSBtb2RlbCBJRCwgZm9yIGV4YW1wbGU6ICdnZW1pbmktMi4wLWZsYXNoJ1xuICAgICAgICAgKiAtIFRoZSBmdWxsIHJlc291cmNlIG5hbWUgc3RhcnRzIHdpdGggJ3Byb2plY3RzLycsIGZvciBleGFtcGxlOlxuICAgICAgICAgKiAgJ3Byb2plY3RzL215LXByb2plY3QtaWQvbG9jYXRpb25zL3VzLWNlbnRyYWwxL3B1Ymxpc2hlcnMvZ29vZ2xlL21vZGVscy9nZW1pbmktMi4wLWZsYXNoJ1xuICAgICAgICAgKiAtIFRoZSBwYXJ0aWFsIHJlc291cmNlIG5hbWUgd2l0aCAncHVibGlzaGVycy8nLCBmb3IgZXhhbXBsZTpcbiAgICAgICAgICogICdwdWJsaXNoZXJzL2dvb2dsZS9tb2RlbHMvZ2VtaW5pLTIuMC1mbGFzaCcgb3JcbiAgICAgICAgICogICdwdWJsaXNoZXJzL21ldGEvbW9kZWxzL2xsYW1hLTMuMS00MDViLWluc3RydWN0LW1hYXMnXG4gICAgICAgICAqIC0gYC9gIHNlcGFyYXRlZCBwdWJsaXNoZXIgYW5kIG1vZGVsIG5hbWUsIGZvciBleGFtcGxlOlxuICAgICAgICAgKiAnZ29vZ2xlL2dlbWluaS0yLjAtZmxhc2gnIG9yICdtZXRhL2xsYW1hLTMuMS00MDViLWluc3RydWN0LW1hYXMnXG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciB0aGUgYG1vZGVsYCBwYXJhbWV0ZXIsIHN1cHBvcnRlZCBmb3JtYXRzIGZvciBHZW1pbmkgQVBJIGluY2x1ZGU6XG4gICAgICAgICAqIC0gVGhlIEdlbWluaSBtb2RlbCBJRCwgZm9yIGV4YW1wbGU6ICdnZW1pbmktMi4wLWZsYXNoJ1xuICAgICAgICAgKiAtIFRoZSBtb2RlbCBuYW1lIHN0YXJ0cyB3aXRoICdtb2RlbHMvJywgZm9yIGV4YW1wbGU6XG4gICAgICAgICAqICAnbW9kZWxzL2dlbWluaS0yLjAtZmxhc2gnXG4gICAgICAgICAqIC0gRm9yIHR1bmVkIG1vZGVscywgdGhlIG1vZGVsIG5hbWUgc3RhcnRzIHdpdGggJ3R1bmVkTW9kZWxzLycsXG4gICAgICAgICAqIGZvciBleGFtcGxlOlxuICAgICAgICAgKiAndHVuZWRNb2RlbHMvMTIzNDU2Nzg5MDEyMzQ1Njc4OSdcbiAgICAgICAgICpcbiAgICAgICAgICogU29tZSBtb2RlbHMgc3VwcG9ydCBtdWx0aW1vZGFsIGlucHV0IGFuZCBvdXRwdXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgZ2VuZXJhdGluZyBjb250ZW50LlxuICAgICAgICAgKiBAcmV0dXJuIFRoZSByZXNwb25zZSBmcm9tIGdlbmVyYXRpbmcgY29udGVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogYGBgdHNcbiAgICAgICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhaS5tb2RlbHMuZ2VuZXJhdGVDb250ZW50KHtcbiAgICAgICAgICogICBtb2RlbDogJ2dlbWluaS0yLjAtZmxhc2gnLFxuICAgICAgICAgKiAgIGNvbnRlbnRzOiAnd2h5IGlzIHRoZSBza3kgYmx1ZT8nLFxuICAgICAgICAgKiAgIGNvbmZpZzoge1xuICAgICAgICAgKiAgICAgY2FuZGlkYXRlQ291bnQ6IDIsXG4gICAgICAgICAqICAgfVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICogY29uc29sZS5sb2cocmVzcG9uc2UpO1xuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2VuZXJhdGVDb250ZW50ID0gYXN5bmMgKHBhcmFtcykgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybWVkUGFyYW1zID0gYXdhaXQgdGhpcy5wcm9jZXNzUGFyYW1zRm9yTWNwVXNhZ2UocGFyYW1zKTtcbiAgICAgICAgICAgIGlmICghaGFzTWNwQ2xpZW50VG9vbHMocGFyYW1zKSB8fCBzaG91bGREaXNhYmxlQWZjKHBhcmFtcy5jb25maWcpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2VuZXJhdGVDb250ZW50SW50ZXJuYWwodHJhbnNmb3JtZWRQYXJhbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhhc05vbk1jcFRvb2xzKHBhcmFtcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F1dG9tYXRpYyBmdW5jdGlvbiBjYWxsaW5nIHdpdGggQ2FsbGFibGVUb29scyBhbmQgVG9vbHMgaXMgbm90IHlldCBzdXBwb3J0ZWQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgICAgICBsZXQgZnVuY3Rpb25SZXNwb25zZUNvbnRlbnQ7XG4gICAgICAgICAgICBjb25zdCBhdXRvbWF0aWNGdW5jdGlvbkNhbGxpbmdIaXN0b3J5ID0gdENvbnRlbnRzKHRyYW5zZm9ybWVkUGFyYW1zLmNvbnRlbnRzKTtcbiAgICAgICAgICAgIGNvbnN0IG1heFJlbW90ZUNhbGxzID0gKF9jID0gKF9iID0gKF9hID0gdHJhbnNmb3JtZWRQYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYXV0b21hdGljRnVuY3Rpb25DYWxsaW5nKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubWF4aW11bVJlbW90ZUNhbGxzKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBERUZBVUxUX01BWF9SRU1PVEVfQ0FMTFM7XG4gICAgICAgICAgICBsZXQgcmVtb3RlQ2FsbHMgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKHJlbW90ZUNhbGxzIDwgbWF4UmVtb3RlQ2FsbHMpIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IHRoaXMuZ2VuZXJhdGVDb250ZW50SW50ZXJuYWwodHJhbnNmb3JtZWRQYXJhbXMpO1xuICAgICAgICAgICAgICAgIGlmICghcmVzcG9uc2UuZnVuY3Rpb25DYWxscyB8fCByZXNwb25zZS5mdW5jdGlvbkNhbGxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VDb250ZW50ID0gcmVzcG9uc2UuY2FuZGlkYXRlc1swXS5jb250ZW50O1xuICAgICAgICAgICAgICAgIGNvbnN0IGZ1bmN0aW9uUmVzcG9uc2VQYXJ0cyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdG9vbCBvZiAoX2UgPSAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QudG9vbHMpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IFtdKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0NhbGxhYmxlVG9vbCh0b29sKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FsbGFibGVUb29sID0gdG9vbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gYXdhaXQgY2FsbGFibGVUb29sLmNhbGxUb29sKHJlc3BvbnNlLmZ1bmN0aW9uQ2FsbHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25SZXNwb25zZVBhcnRzLnB1c2goLi4ucGFydHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlbW90ZUNhbGxzKys7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb25SZXNwb25zZUNvbnRlbnQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHJvbGU6ICd1c2VyJyxcbiAgICAgICAgICAgICAgICAgICAgcGFydHM6IGZ1bmN0aW9uUmVzcG9uc2VQYXJ0cyxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkUGFyYW1zLmNvbnRlbnRzID0gdENvbnRlbnRzKHRyYW5zZm9ybWVkUGFyYW1zLmNvbnRlbnRzKTtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZFBhcmFtcy5jb250ZW50cy5wdXNoKHJlc3BvbnNlQ29udGVudCk7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtZWRQYXJhbXMuY29udGVudHMucHVzaChmdW5jdGlvblJlc3BvbnNlQ29udGVudCk7XG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZEFwcGVuZEFmY0hpc3RvcnkodHJhbnNmb3JtZWRQYXJhbXMuY29uZmlnKSkge1xuICAgICAgICAgICAgICAgICAgICBhdXRvbWF0aWNGdW5jdGlvbkNhbGxpbmdIaXN0b3J5LnB1c2gocmVzcG9uc2VDb250ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgYXV0b21hdGljRnVuY3Rpb25DYWxsaW5nSGlzdG9yeS5wdXNoKGZ1bmN0aW9uUmVzcG9uc2VDb250ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2hvdWxkQXBwZW5kQWZjSGlzdG9yeSh0cmFuc2Zvcm1lZFBhcmFtcy5jb25maWcpKSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UuYXV0b21hdGljRnVuY3Rpb25DYWxsaW5nSGlzdG9yeSA9XG4gICAgICAgICAgICAgICAgICAgIGF1dG9tYXRpY0Z1bmN0aW9uQ2FsbGluZ0hpc3Rvcnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYWtlcyBhbiBBUEkgcmVxdWVzdCB0byBnZW5lcmF0ZSBjb250ZW50IHdpdGggYSBnaXZlbiBtb2RlbCBhbmQgeWllbGRzIHRoZVxuICAgICAgICAgKiByZXNwb25zZSBpbiBjaHVua3MuXG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciB0aGUgYG1vZGVsYCBwYXJhbWV0ZXIsIHN1cHBvcnRlZCBmb3JtYXRzIGZvciBWZXJ0ZXggQUkgQVBJIGluY2x1ZGU6XG4gICAgICAgICAqIC0gVGhlIEdlbWluaSBtb2RlbCBJRCwgZm9yIGV4YW1wbGU6ICdnZW1pbmktMi4wLWZsYXNoJ1xuICAgICAgICAgKiAtIFRoZSBmdWxsIHJlc291cmNlIG5hbWUgc3RhcnRzIHdpdGggJ3Byb2plY3RzLycsIGZvciBleGFtcGxlOlxuICAgICAgICAgKiAgJ3Byb2plY3RzL215LXByb2plY3QtaWQvbG9jYXRpb25zL3VzLWNlbnRyYWwxL3B1Ymxpc2hlcnMvZ29vZ2xlL21vZGVscy9nZW1pbmktMi4wLWZsYXNoJ1xuICAgICAgICAgKiAtIFRoZSBwYXJ0aWFsIHJlc291cmNlIG5hbWUgd2l0aCAncHVibGlzaGVycy8nLCBmb3IgZXhhbXBsZTpcbiAgICAgICAgICogICdwdWJsaXNoZXJzL2dvb2dsZS9tb2RlbHMvZ2VtaW5pLTIuMC1mbGFzaCcgb3JcbiAgICAgICAgICogICdwdWJsaXNoZXJzL21ldGEvbW9kZWxzL2xsYW1hLTMuMS00MDViLWluc3RydWN0LW1hYXMnXG4gICAgICAgICAqIC0gYC9gIHNlcGFyYXRlZCBwdWJsaXNoZXIgYW5kIG1vZGVsIG5hbWUsIGZvciBleGFtcGxlOlxuICAgICAgICAgKiAnZ29vZ2xlL2dlbWluaS0yLjAtZmxhc2gnIG9yICdtZXRhL2xsYW1hLTMuMS00MDViLWluc3RydWN0LW1hYXMnXG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciB0aGUgYG1vZGVsYCBwYXJhbWV0ZXIsIHN1cHBvcnRlZCBmb3JtYXRzIGZvciBHZW1pbmkgQVBJIGluY2x1ZGU6XG4gICAgICAgICAqIC0gVGhlIEdlbWluaSBtb2RlbCBJRCwgZm9yIGV4YW1wbGU6ICdnZW1pbmktMi4wLWZsYXNoJ1xuICAgICAgICAgKiAtIFRoZSBtb2RlbCBuYW1lIHN0YXJ0cyB3aXRoICdtb2RlbHMvJywgZm9yIGV4YW1wbGU6XG4gICAgICAgICAqICAnbW9kZWxzL2dlbWluaS0yLjAtZmxhc2gnXG4gICAgICAgICAqIC0gRm9yIHR1bmVkIG1vZGVscywgdGhlIG1vZGVsIG5hbWUgc3RhcnRzIHdpdGggJ3R1bmVkTW9kZWxzLycsXG4gICAgICAgICAqIGZvciBleGFtcGxlOlxuICAgICAgICAgKiAgJ3R1bmVkTW9kZWxzLzEyMzQ1Njc4OTAxMjM0NTY3ODknXG4gICAgICAgICAqXG4gICAgICAgICAqIFNvbWUgbW9kZWxzIHN1cHBvcnQgbXVsdGltb2RhbCBpbnB1dCBhbmQgb3V0cHV0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIGdlbmVyYXRpbmcgY29udGVudCB3aXRoIHN0cmVhbWluZyByZXNwb25zZS5cbiAgICAgICAgICogQHJldHVybiBUaGUgcmVzcG9uc2UgZnJvbSBnZW5lcmF0aW5nIGNvbnRlbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGBgYHRzXG4gICAgICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYWkubW9kZWxzLmdlbmVyYXRlQ29udGVudFN0cmVhbSh7XG4gICAgICAgICAqICAgbW9kZWw6ICdnZW1pbmktMi4wLWZsYXNoJyxcbiAgICAgICAgICogICBjb250ZW50czogJ3doeSBpcyB0aGUgc2t5IGJsdWU/JyxcbiAgICAgICAgICogICBjb25maWc6IHtcbiAgICAgICAgICogICAgIG1heE91dHB1dFRva2VuczogMjAwLFxuICAgICAgICAgKiAgIH1cbiAgICAgICAgICogfSk7XG4gICAgICAgICAqIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgcmVzcG9uc2UpIHtcbiAgICAgICAgICogICBjb25zb2xlLmxvZyhjaHVuayk7XG4gICAgICAgICAqIH1cbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdlbmVyYXRlQ29udGVudFN0cmVhbSA9IGFzeW5jIChwYXJhbXMpID0+IHtcbiAgICAgICAgICAgIGlmIChzaG91bGREaXNhYmxlQWZjKHBhcmFtcy5jb25maWcpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtZWRQYXJhbXMgPSBhd2FpdCB0aGlzLnByb2Nlc3NQYXJhbXNGb3JNY3BVc2FnZShwYXJhbXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmdlbmVyYXRlQ29udGVudFN0cmVhbUludGVybmFsKHRyYW5zZm9ybWVkUGFyYW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnByb2Nlc3NBZmNTdHJlYW0ocGFyYW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdlbmVyYXRlcyBhbiBpbWFnZSBiYXNlZCBvbiBhIHRleHQgZGVzY3JpcHRpb24gYW5kIGNvbmZpZ3VyYXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgZ2VuZXJhdGluZyBpbWFnZXMuXG4gICAgICAgICAqIEByZXR1cm4gVGhlIHJlc3BvbnNlIGZyb20gdGhlIEFQSS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogYGBgdHNcbiAgICAgICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjbGllbnQubW9kZWxzLmdlbmVyYXRlSW1hZ2VzKHtcbiAgICAgICAgICogIG1vZGVsOiAnaW1hZ2VuLTMuMC1nZW5lcmF0ZS0wMDInLFxuICAgICAgICAgKiAgcHJvbXB0OiAnUm9ib3QgaG9sZGluZyBhIHJlZCBza2F0ZWJvYXJkJyxcbiAgICAgICAgICogIGNvbmZpZzoge1xuICAgICAgICAgKiAgICBudW1iZXJPZkltYWdlczogMSxcbiAgICAgICAgICogICAgaW5jbHVkZVJhaVJlYXNvbjogdHJ1ZSxcbiAgICAgICAgICogIH0sXG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKiBjb25zb2xlLmxvZyhyZXNwb25zZT8uZ2VuZXJhdGVkSW1hZ2VzPy5bMF0/LmltYWdlPy5pbWFnZUJ5dGVzKTtcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdlbmVyYXRlSW1hZ2VzID0gYXN5bmMgKHBhcmFtcykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2VuZXJhdGVJbWFnZXNJbnRlcm5hbChwYXJhbXMpLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIGxldCBwb3NpdGl2ZVByb21wdFNhZmV0eUF0dHJpYnV0ZXM7XG4gICAgICAgICAgICAgICAgY29uc3QgZ2VuZXJhdGVkSW1hZ2VzID0gW107XG4gICAgICAgICAgICAgICAgaWYgKGFwaVJlc3BvbnNlID09PSBudWxsIHx8IGFwaVJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhcGlSZXNwb25zZS5nZW5lcmF0ZWRJbWFnZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBnZW5lcmF0ZWRJbWFnZSBvZiBhcGlSZXNwb25zZS5nZW5lcmF0ZWRJbWFnZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChnZW5lcmF0ZWRJbWFnZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChnZW5lcmF0ZWRJbWFnZSA9PT0gbnVsbCB8fCBnZW5lcmF0ZWRJbWFnZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZ2VuZXJhdGVkSW1hZ2Uuc2FmZXR5QXR0cmlidXRlcykgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKF9hID0gZ2VuZXJhdGVkSW1hZ2UgPT09IG51bGwgfHwgZ2VuZXJhdGVkSW1hZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdlbmVyYXRlZEltYWdlLnNhZmV0eUF0dHJpYnV0ZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb250ZW50VHlwZSkgPT09ICdQb3NpdGl2ZSBQcm9tcHQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpdmVQcm9tcHRTYWZldHlBdHRyaWJ1dGVzID0gZ2VuZXJhdGVkSW1hZ2UgPT09IG51bGwgfHwgZ2VuZXJhdGVkSW1hZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdlbmVyYXRlZEltYWdlLnNhZmV0eUF0dHJpYnV0ZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZWRJbWFnZXMucHVzaChnZW5lcmF0ZWRJbWFnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIGlmIChwb3NpdGl2ZVByb21wdFNhZmV0eUF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZWRJbWFnZXM6IGdlbmVyYXRlZEltYWdlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aXZlUHJvbXB0U2FmZXR5QXR0cmlidXRlczogcG9zaXRpdmVQcm9tcHRTYWZldHlBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZWRJbWFnZXM6IGdlbmVyYXRlZEltYWdlcyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubGlzdCA9IGFzeW5jIChwYXJhbXMpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRDb25maWcgPSB7XG4gICAgICAgICAgICAgICAgcXVlcnlCYXNlOiB0cnVlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGFjdHVhbENvbmZpZyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdENvbmZpZyksIHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5jb25maWcpO1xuICAgICAgICAgICAgY29uc3QgYWN0dWFsUGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIGNvbmZpZzogYWN0dWFsQ29uZmlnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWFjdHVhbFBhcmFtcy5jb25maWcucXVlcnlCYXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoX2EgPSBhY3R1YWxQYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpbHRlcmluZyB0dW5lZCBtb2RlbHMgbGlzdCBmb3IgVmVydGV4IEFJIGlzIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3R1YWxQYXJhbXMuY29uZmlnLmZpbHRlciA9ICdsYWJlbHMudHVuZS10eXBlOionO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQYWdlcihQYWdlZEl0ZW0uUEFHRURfSVRFTV9NT0RFTFMsICh4KSA9PiB0aGlzLmxpc3RJbnRlcm5hbCh4KSwgYXdhaXQgdGhpcy5saXN0SW50ZXJuYWwoYWN0dWFsUGFyYW1zKSwgYWN0dWFsUGFyYW1zKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVkaXRzIGFuIGltYWdlIGJhc2VkIG9uIGEgcHJvbXB0LCBsaXN0IG9mIHJlZmVyZW5jZSBpbWFnZXMsIGFuZCBjb25maWd1cmF0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIGVkaXRpbmcgYW4gaW1hZ2UuXG4gICAgICAgICAqIEByZXR1cm4gVGhlIHJlc3BvbnNlIGZyb20gdGhlIEFQSS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogYGBgdHNcbiAgICAgICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjbGllbnQubW9kZWxzLmVkaXRJbWFnZSh7XG4gICAgICAgICAqICBtb2RlbDogJ2ltYWdlbi0zLjAtY2FwYWJpbGl0eS0wMDEnLFxuICAgICAgICAgKiAgcHJvbXB0OiAnR2VuZXJhdGUgYW4gaW1hZ2UgY29udGFpbmluZyBhIG11ZyB3aXRoIHRoZSBwcm9kdWN0IGxvZ28gWzFdIHZpc2libGUgb24gdGhlIHNpZGUgb2YgdGhlIG11Zy4nLFxuICAgICAgICAgKiAgcmVmZXJlbmNlSW1hZ2VzOiBbc3ViamVjdFJlZmVyZW5jZUltYWdlXVxuICAgICAgICAgKiAgY29uZmlnOiB7XG4gICAgICAgICAqICAgIG51bWJlck9mSW1hZ2VzOiAxLFxuICAgICAgICAgKiAgICBpbmNsdWRlUmFpUmVhc29uOiB0cnVlLFxuICAgICAgICAgKiAgfSxcbiAgICAgICAgICogfSk7XG4gICAgICAgICAqIGNvbnNvbGUubG9nKHJlc3BvbnNlPy5nZW5lcmF0ZWRJbWFnZXM/LlswXT8uaW1hZ2U/LmltYWdlQnl0ZXMpO1xuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZWRpdEltYWdlID0gYXN5bmMgKHBhcmFtcykgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGFyYW1zSW50ZXJuYWwgPSB7XG4gICAgICAgICAgICAgICAgbW9kZWw6IHBhcmFtcy5tb2RlbCxcbiAgICAgICAgICAgICAgICBwcm9tcHQ6IHBhcmFtcy5wcm9tcHQsXG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlSW1hZ2VzOiBbXSxcbiAgICAgICAgICAgICAgICBjb25maWc6IHBhcmFtcy5jb25maWcsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHBhcmFtcy5yZWZlcmVuY2VJbWFnZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyYW1zLnJlZmVyZW5jZUltYWdlcykge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXNJbnRlcm5hbC5yZWZlcmVuY2VJbWFnZXMgPSBwYXJhbXMucmVmZXJlbmNlSW1hZ2VzLm1hcCgoaW1nKSA9PiBpbWcudG9SZWZlcmVuY2VJbWFnZUFQSSgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5lZGl0SW1hZ2VJbnRlcm5hbChwYXJhbXNJbnRlcm5hbCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcHNjYWxlcyBhbiBpbWFnZSBiYXNlZCBvbiBhbiBpbWFnZSwgdXBzY2FsZSBmYWN0b3IsIGFuZCBjb25maWd1cmF0aW9uLlxuICAgICAgICAgKiBPbmx5IHN1cHBvcnRlZCBpbiBWZXJ0ZXggQUkgY3VycmVudGx5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHVwc2NhbGluZyBhbiBpbWFnZS5cbiAgICAgICAgICogQHJldHVybiBUaGUgcmVzcG9uc2UgZnJvbSB0aGUgQVBJLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBgYGB0c1xuICAgICAgICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNsaWVudC5tb2RlbHMudXBzY2FsZUltYWdlKHtcbiAgICAgICAgICogIG1vZGVsOiAnaW1hZ2VuLTMuMC1nZW5lcmF0ZS0wMDInLFxuICAgICAgICAgKiAgaW1hZ2U6IGltYWdlLFxuICAgICAgICAgKiAgdXBzY2FsZUZhY3RvcjogJ3gyJyxcbiAgICAgICAgICogIGNvbmZpZzoge1xuICAgICAgICAgKiAgICBpbmNsdWRlUmFpUmVhc29uOiB0cnVlLFxuICAgICAgICAgKiAgfSxcbiAgICAgICAgICogfSk7XG4gICAgICAgICAqIGNvbnNvbGUubG9nKHJlc3BvbnNlPy5nZW5lcmF0ZWRJbWFnZXM/LlswXT8uaW1hZ2U/LmltYWdlQnl0ZXMpO1xuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudXBzY2FsZUltYWdlID0gYXN5bmMgKHBhcmFtcykgPT4ge1xuICAgICAgICAgICAgbGV0IGFwaUNvbmZpZyA9IHtcbiAgICAgICAgICAgICAgICBudW1iZXJPZkltYWdlczogMSxcbiAgICAgICAgICAgICAgICBtb2RlOiAndXBzY2FsZScsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHBhcmFtcy5jb25maWcpIHtcbiAgICAgICAgICAgICAgICBhcGlDb25maWcgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGFwaUNvbmZpZyksIHBhcmFtcy5jb25maWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXBpUGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIG1vZGVsOiBwYXJhbXMubW9kZWwsXG4gICAgICAgICAgICAgICAgaW1hZ2U6IHBhcmFtcy5pbWFnZSxcbiAgICAgICAgICAgICAgICB1cHNjYWxlRmFjdG9yOiBwYXJhbXMudXBzY2FsZUZhY3RvcixcbiAgICAgICAgICAgICAgICBjb25maWc6IGFwaUNvbmZpZyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy51cHNjYWxlSW1hZ2VJbnRlcm5hbChhcGlQYXJhbXMpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIHRoZSBDYWxsYWJsZVRvb2xzIGluIHRoZSBwYXJhbWV0ZXJzIHRvIGJlIHNpbXBseSBUb29scywgaXRcbiAgICAgKiBjb3BpZXMgdGhlIHBhcmFtcyBpbnRvIGEgbmV3IG9iamVjdCBhbmQgcmVwbGFjZXMgdGhlIHRvb2xzLCBpdCBkb2VzIG5vdFxuICAgICAqIG1vZGlmeSB0aGUgb3JpZ2luYWwgcGFyYW1zLiBBbHNvIHNldHMgdGhlIE1DUCB1c2FnZSBoZWFkZXIgaWYgdGhlcmUgYXJlXG4gICAgICogTUNQIHRvb2xzIGluIHRoZSBwYXJhbWV0ZXJzLlxuICAgICAqL1xuICAgIGFzeW5jIHByb2Nlc3NQYXJhbXNGb3JNY3BVc2FnZShwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGNvbnN0IHRvb2xzID0gKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRvb2xzO1xuICAgICAgICBpZiAoIXRvb2xzKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybWVkVG9vbHMgPSBhd2FpdCBQcm9taXNlLmFsbCh0b29scy5tYXAoYXN5bmMgKHRvb2wpID0+IHtcbiAgICAgICAgICAgIGlmIChpc0NhbGxhYmxlVG9vbCh0b29sKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxhYmxlVG9vbCA9IHRvb2w7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGNhbGxhYmxlVG9vbC50b29sKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdG9vbDtcbiAgICAgICAgfSkpO1xuICAgICAgICBjb25zdCBuZXdQYXJhbXMgPSB7XG4gICAgICAgICAgICBtb2RlbDogcGFyYW1zLm1vZGVsLFxuICAgICAgICAgICAgY29udGVudHM6IHBhcmFtcy5jb250ZW50cyxcbiAgICAgICAgICAgIGNvbmZpZzogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwYXJhbXMuY29uZmlnKSwgeyB0b29sczogdHJhbnNmb3JtZWRUb29scyB9KSxcbiAgICAgICAgfTtcbiAgICAgICAgbmV3UGFyYW1zLmNvbmZpZy50b29scyA9IHRyYW5zZm9ybWVkVG9vbHM7XG4gICAgICAgIGlmIChwYXJhbXMuY29uZmlnICYmXG4gICAgICAgICAgICBwYXJhbXMuY29uZmlnLnRvb2xzICYmXG4gICAgICAgICAgICBoYXNNY3BUb29sVXNhZ2UocGFyYW1zLmNvbmZpZy50b29scykpIHtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSAoX2MgPSAoX2IgPSBwYXJhbXMuY29uZmlnLmh0dHBPcHRpb25zKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaGVhZGVycykgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDoge307XG4gICAgICAgICAgICBsZXQgbmV3SGVhZGVycyA9IE9iamVjdC5hc3NpZ24oe30sIGhlYWRlcnMpO1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKG5ld0hlYWRlcnMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIG5ld0hlYWRlcnMgPSB0aGlzLmFwaUNsaWVudC5nZXREZWZhdWx0SGVhZGVycygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0TWNwVXNhZ2VIZWFkZXIobmV3SGVhZGVycyk7XG4gICAgICAgICAgICBuZXdQYXJhbXMuY29uZmlnLmh0dHBPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwYXJhbXMuY29uZmlnLmh0dHBPcHRpb25zKSwgeyBoZWFkZXJzOiBuZXdIZWFkZXJzIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdQYXJhbXM7XG4gICAgfVxuICAgIGFzeW5jIGluaXRBZmNUb29sc01hcChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGNvbnN0IGFmY1Rvb2xzID0gbmV3IE1hcCgpO1xuICAgICAgICBmb3IgKGNvbnN0IHRvb2wgb2YgKF9iID0gKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRvb2xzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXSkge1xuICAgICAgICAgICAgaWYgKGlzQ2FsbGFibGVUb29sKHRvb2wpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FsbGFibGVUb29sID0gdG9vbDtcbiAgICAgICAgICAgICAgICBjb25zdCB0b29sRGVjbGFyYXRpb24gPSBhd2FpdCBjYWxsYWJsZVRvb2wudG9vbCgpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZGVjbGFyYXRpb24gb2YgKF9jID0gdG9vbERlY2xhcmF0aW9uLmZ1bmN0aW9uRGVjbGFyYXRpb25zKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBbXSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWRlY2xhcmF0aW9uLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRnVuY3Rpb24gZGVjbGFyYXRpb24gbmFtZSBpcyByZXF1aXJlZC4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYWZjVG9vbHMuaGFzKGRlY2xhcmF0aW9uLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYER1cGxpY2F0ZSB0b29sIGRlY2xhcmF0aW9uIG5hbWU6ICR7ZGVjbGFyYXRpb24ubmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhZmNUb29scy5zZXQoZGVjbGFyYXRpb24ubmFtZSwgY2FsbGFibGVUb29sKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFmY1Rvb2xzO1xuICAgIH1cbiAgICBhc3luYyBwcm9jZXNzQWZjU3RyZWFtKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgY29uc3QgbWF4UmVtb3RlQ2FsbHMgPSAoX2MgPSAoX2IgPSAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYXV0b21hdGljRnVuY3Rpb25DYWxsaW5nKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubWF4aW11bVJlbW90ZUNhbGxzKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBERUZBVUxUX01BWF9SRU1PVEVfQ0FMTFM7XG4gICAgICAgIGxldCB3ZXJlRnVuY3Rpb25zQ2FsbGVkID0gZmFsc2U7XG4gICAgICAgIGxldCByZW1vdGVDYWxsQ291bnQgPSAwO1xuICAgICAgICBjb25zdCBhZmNUb29sc01hcCA9IGF3YWl0IHRoaXMuaW5pdEFmY1Rvb2xzTWFwKHBhcmFtcyk7XG4gICAgICAgIHJldHVybiAoZnVuY3Rpb24gKG1vZGVscywgYWZjVG9vbHMsIHBhcmFtcykge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIHJldHVybiBfX2FzeW5jR2VuZXJhdG9yKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2MsIGVfMSwgX2QsIF9lO1xuICAgICAgICAgICAgICAgIHdoaWxlIChyZW1vdGVDYWxsQ291bnQgPCBtYXhSZW1vdGVDYWxscykge1xuICAgICAgICAgICAgICAgICAgICBpZiAod2VyZUZ1bmN0aW9uc0NhbGxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3RlQ2FsbENvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICB3ZXJlRnVuY3Rpb25zQ2FsbGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtZWRQYXJhbXMgPSB5aWVsZCBfX2F3YWl0KG1vZGVscy5wcm9jZXNzUGFyYW1zRm9yTWNwVXNhZ2UocGFyYW1zKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgX19hd2FpdChtb2RlbHMuZ2VuZXJhdGVDb250ZW50U3RyZWFtSW50ZXJuYWwodHJhbnNmb3JtZWRQYXJhbXMpKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZnVuY3Rpb25SZXNwb25zZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VDb250ZW50cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2YgPSB0cnVlLCByZXNwb25zZV8xID0gKGVfMSA9IHZvaWQgMCwgX19hc3luY1ZhbHVlcyhyZXNwb25zZSkpLCByZXNwb25zZV8xXzE7IHJlc3BvbnNlXzFfMSA9IHlpZWxkIF9fYXdhaXQocmVzcG9uc2VfMS5uZXh0KCkpLCBfYyA9IHJlc3BvbnNlXzFfMS5kb25lLCAhX2M7IF9mID0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9lID0gcmVzcG9uc2VfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9mID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2h1bmsgPSBfZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCB5aWVsZCBfX2F3YWl0KGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2h1bmsuY2FuZGlkYXRlcyAmJiAoKF9hID0gY2h1bmsuY2FuZGlkYXRlc1swXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbnRlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlQ29udGVudHMucHVzaChjaHVuay5jYW5kaWRhdGVzWzBdLmNvbnRlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgKF9iID0gY2h1bmsuY2FuZGlkYXRlc1swXS5jb250ZW50LnBhcnRzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlbW90ZUNhbGxDb3VudCA8IG1heFJlbW90ZUNhbGxzICYmIHBhcnQuZnVuY3Rpb25DYWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJ0LmZ1bmN0aW9uQ2FsbC5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRnVuY3Rpb24gY2FsbCBuYW1lIHdhcyBub3QgcmV0dXJuZWQgYnkgdGhlIG1vZGVsLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWFmY1Rvb2xzLmhhcyhwYXJ0LmZ1bmN0aW9uQ2FsbC5uYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEF1dG9tYXRpYyBmdW5jdGlvbiBjYWxsaW5nIHdhcyByZXF1ZXN0ZWQsIGJ1dCBub3QgYWxsIHRoZSB0b29scyB0aGUgbW9kZWwgdXNlZCBpbXBsZW1lbnQgdGhlIENhbGxhYmxlVG9vbCBpbnRlcmZhY2UuIEF2YWlsYWJsZSB0b29sczogJHthZmNUb29scy5rZXlzKCl9LCBtaXNpbmcgdG9vbDogJHtwYXJ0LmZ1bmN0aW9uQ2FsbC5uYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VQYXJ0cyA9IHlpZWxkIF9fYXdhaXQoYWZjVG9vbHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5nZXQocGFydC5mdW5jdGlvbkNhbGwubmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jYWxsVG9vbChbcGFydC5mdW5jdGlvbkNhbGxdKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uUmVzcG9uc2VzLnB1c2goLi4ucmVzcG9uc2VQYXJ0cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV9mICYmICFfYyAmJiAoX2QgPSByZXNwb25zZV8xLnJldHVybikpIHlpZWxkIF9fYXdhaXQoX2QuY2FsbChyZXNwb25zZV8xKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGZ1bmN0aW9uUmVzcG9uc2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdlcmVGdW5jdGlvbnNDYWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwb25zZUNodW5rID0gbmV3IEdlbmVyYXRlQ29udGVudFJlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlZFJlc3BvbnNlQ2h1bmsuY2FuZGlkYXRlcyA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvbGU6ICd1c2VyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRzOiBmdW5jdGlvblJlc3BvbnNlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIHlpZWxkIF9fYXdhaXQodHlwZWRSZXNwb25zZUNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0NvbnRlbnRzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdDb250ZW50cy5wdXNoKC4uLnJlc3BvbnNlQ29udGVudHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q29udGVudHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm9sZTogJ3VzZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRzOiBmdW5jdGlvblJlc3BvbnNlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdXBkYXRlZENvbnRlbnRzID0gdENvbnRlbnRzKHBhcmFtcy5jb250ZW50cykuY29uY2F0KG5ld0NvbnRlbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5jb250ZW50cyA9IHVwZGF0ZWRDb250ZW50cztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pKHRoaXMsIGFmY1Rvb2xzTWFwLCBwYXJhbXMpO1xuICAgIH1cbiAgICBhc3luYyBnZW5lcmF0ZUNvbnRlbnRJbnRlcm5hbChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZ2VuZXJhdGVDb250ZW50UGFyYW1ldGVyc1RvVmVydGV4KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne21vZGVsfTpnZW5lcmF0ZUNvbnRlbnQnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5Wydjb25maWcnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGdlbmVyYXRlQ29udGVudFJlc3BvbnNlRnJvbVZlcnRleChhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IEdlbmVyYXRlQ29udGVudFJlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBnZW5lcmF0ZUNvbnRlbnRQYXJhbWV0ZXJzVG9NbGRldih0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3ttb2RlbH06Z2VuZXJhdGVDb250ZW50JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnY29uZmlnJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYyA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBnZW5lcmF0ZUNvbnRlbnRSZXNwb25zZUZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IEdlbmVyYXRlQ29udGVudFJlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBnZW5lcmF0ZUNvbnRlbnRTdHJlYW1JbnRlcm5hbChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZ2VuZXJhdGVDb250ZW50UGFyYW1ldGVyc1RvVmVydGV4KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne21vZGVsfTpzdHJlYW1HZW5lcmF0ZUNvbnRlbnQ/YWx0PXNzZScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ2NvbmZpZyddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGNvbnN0IGFwaUNsaWVudCA9IHRoaXMuYXBpQ2xpZW50O1xuICAgICAgICAgICAgcmVzcG9uc2UgPSBhcGlDbGllbnQucmVxdWVzdFN0cmVhbSh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oZnVuY3Rpb24gKGFwaVJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fYXN5bmNHZW5lcmF0b3IodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2EsIGVfMiwgX2IsIF9jO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2QgPSB0cnVlLCBhcGlSZXNwb25zZV8xID0gX19hc3luY1ZhbHVlcyhhcGlSZXNwb25zZSksIGFwaVJlc3BvbnNlXzFfMTsgYXBpUmVzcG9uc2VfMV8xID0geWllbGQgX19hd2FpdChhcGlSZXNwb25zZV8xLm5leHQoKSksIF9hID0gYXBpUmVzcG9uc2VfMV8xLmRvbmUsICFfYTsgX2QgPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2MgPSBhcGlSZXNwb25zZV8xXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjaHVuayA9IF9jO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBnZW5lcmF0ZUNvbnRlbnRSZXNwb25zZUZyb21WZXJ0ZXgoKHlpZWxkIF9fYXdhaXQoY2h1bmsuanNvbigpKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBHZW5lcmF0ZUNvbnRlbnRSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCB5aWVsZCBfX2F3YWl0KHR5cGVkUmVzcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVfMl8xKSB7IGVfMiA9IHsgZXJyb3I6IGVfMl8xIH07IH1cbiAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX2QgJiYgIV9hICYmIChfYiA9IGFwaVJlc3BvbnNlXzEucmV0dXJuKSkgeWllbGQgX19hd2FpdChfYi5jYWxsKGFwaVJlc3BvbnNlXzEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7IH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZ2VuZXJhdGVDb250ZW50UGFyYW1ldGVyc1RvTWxkZXYodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bW9kZWx9OnN0cmVhbUdlbmVyYXRlQ29udGVudD9hbHQ9c3NlJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnY29uZmlnJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgY29uc3QgYXBpQ2xpZW50ID0gdGhpcy5hcGlDbGllbnQ7XG4gICAgICAgICAgICByZXNwb25zZSA9IGFwaUNsaWVudC5yZXF1ZXN0U3RyZWFtKHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYyA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbihmdW5jdGlvbiAoYXBpUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX19hc3luY0dlbmVyYXRvcih0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYSwgZV8zLCBfYiwgX2M7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfZCA9IHRydWUsIGFwaVJlc3BvbnNlXzIgPSBfX2FzeW5jVmFsdWVzKGFwaVJlc3BvbnNlKSwgYXBpUmVzcG9uc2VfMl8xOyBhcGlSZXNwb25zZV8yXzEgPSB5aWVsZCBfX2F3YWl0KGFwaVJlc3BvbnNlXzIubmV4dCgpKSwgX2EgPSBhcGlSZXNwb25zZV8yXzEuZG9uZSwgIV9hOyBfZCA9IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYyA9IGFwaVJlc3BvbnNlXzJfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rID0gX2M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGdlbmVyYXRlQ29udGVudFJlc3BvbnNlRnJvbU1sZGV2KCh5aWVsZCBfX2F3YWl0KGNodW5rLmpzb24oKSkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgR2VuZXJhdGVDb250ZW50UmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgeWllbGQgX19hd2FpdCh0eXBlZFJlc3ApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlXzNfMSkgeyBlXzMgPSB7IGVycm9yOiBlXzNfMSB9OyB9XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV9kICYmICFfYSAmJiAoX2IgPSBhcGlSZXNwb25zZV8yLnJldHVybikpIHlpZWxkIF9fYXdhaXQoX2IuY2FsbChhcGlSZXNwb25zZV8yKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMykgdGhyb3cgZV8zLmVycm9yOyB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgZW1iZWRkaW5ncyBmb3IgdGhlIGdpdmVuIGNvbnRlbnRzLiBPbmx5IHRleHQgaXMgc3VwcG9ydGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciBlbWJlZGRpbmcgY29udGVudHMuXG4gICAgICogQHJldHVybiBUaGUgcmVzcG9uc2UgZnJvbSB0aGUgQVBJLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYWkubW9kZWxzLmVtYmVkQ29udGVudCh7XG4gICAgICogIG1vZGVsOiAndGV4dC1lbWJlZGRpbmctMDA0JyxcbiAgICAgKiAgY29udGVudHM6IFtcbiAgICAgKiAgICAnV2hhdCBpcyB5b3VyIG5hbWU/JyxcbiAgICAgKiAgICAnV2hhdCBpcyB5b3VyIGZhdm9yaXRlIGNvbG9yPycsXG4gICAgICogIF0sXG4gICAgICogIGNvbmZpZzoge1xuICAgICAqICAgIG91dHB1dERpbWVuc2lvbmFsaXR5OiA2NCxcbiAgICAgKiAgfSxcbiAgICAgKiB9KTtcbiAgICAgKiBjb25zb2xlLmxvZyhyZXNwb25zZSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgZW1iZWRDb250ZW50KHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBlbWJlZENvbnRlbnRQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bW9kZWx9OnByZWRpY3QnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5Wydjb25maWcnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGVtYmVkQ29udGVudFJlc3BvbnNlRnJvbVZlcnRleChhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IEVtYmVkQ29udGVudFJlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBlbWJlZENvbnRlbnRQYXJhbWV0ZXJzVG9NbGRldih0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3ttb2RlbH06YmF0Y2hFbWJlZENvbnRlbnRzJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnY29uZmlnJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYyA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBlbWJlZENvbnRlbnRSZXNwb25zZUZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IEVtYmVkQ29udGVudFJlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYW4gaW1hZ2UgYmFzZWQgb24gYSB0ZXh0IGRlc2NyaXB0aW9uIGFuZCBjb25maWd1cmF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciBnZW5lcmF0aW5nIGltYWdlcy5cbiAgICAgKiBAcmV0dXJuIFRoZSByZXNwb25zZSBmcm9tIHRoZSBBUEkuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhaS5tb2RlbHMuZ2VuZXJhdGVJbWFnZXMoe1xuICAgICAqICBtb2RlbDogJ2ltYWdlbi0zLjAtZ2VuZXJhdGUtMDAyJyxcbiAgICAgKiAgcHJvbXB0OiAnUm9ib3QgaG9sZGluZyBhIHJlZCBza2F0ZWJvYXJkJyxcbiAgICAgKiAgY29uZmlnOiB7XG4gICAgICogICAgbnVtYmVyT2ZJbWFnZXM6IDEsXG4gICAgICogICAgaW5jbHVkZVJhaVJlYXNvbjogdHJ1ZSxcbiAgICAgKiAgfSxcbiAgICAgKiB9KTtcbiAgICAgKiBjb25zb2xlLmxvZyhyZXNwb25zZT8uZ2VuZXJhdGVkSW1hZ2VzPy5bMF0/LmltYWdlPy5pbWFnZUJ5dGVzKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBnZW5lcmF0ZUltYWdlc0ludGVybmFsKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBnZW5lcmF0ZUltYWdlc1BhcmFtZXRlcnNUb1ZlcnRleCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3ttb2RlbH06cHJlZGljdCcsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ2NvbmZpZyddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gZ2VuZXJhdGVJbWFnZXNSZXNwb25zZUZyb21WZXJ0ZXgoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBHZW5lcmF0ZUltYWdlc1Jlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBnZW5lcmF0ZUltYWdlc1BhcmFtZXRlcnNUb01sZGV2KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne21vZGVsfTpwcmVkaWN0JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnY29uZmlnJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYyA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBnZW5lcmF0ZUltYWdlc1Jlc3BvbnNlRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgR2VuZXJhdGVJbWFnZXNSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZWRpdEltYWdlSW50ZXJuYWwocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBlZGl0SW1hZ2VQYXJhbWV0ZXJzSW50ZXJuYWxUb1ZlcnRleCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3ttb2RlbH06cHJlZGljdCcsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ2NvbmZpZyddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gZWRpdEltYWdlUmVzcG9uc2VGcm9tVmVydGV4KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgRWRpdEltYWdlUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBpcyBvbmx5IHN1cHBvcnRlZCBieSB0aGUgVmVydGV4IEFJLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHVwc2NhbGVJbWFnZUludGVybmFsKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gdXBzY2FsZUltYWdlQVBJUGFyYW1ldGVyc0ludGVybmFsVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bW9kZWx9OnByZWRpY3QnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5Wydjb25maWcnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IHVwc2NhbGVJbWFnZVJlc3BvbnNlRnJvbVZlcnRleChhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IFVwc2NhbGVJbWFnZVJlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgaXMgb25seSBzdXBwb3J0ZWQgYnkgdGhlIFZlcnRleCBBSS4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZXRjaGVzIGluZm9ybWF0aW9uIGFib3V0IGEgbW9kZWwgYnkgbmFtZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCBtb2RlbEluZm8gPSBhd2FpdCBhaS5tb2RlbHMuZ2V0KHttb2RlbDogJ2dlbWluaS0yLjAtZmxhc2gnfSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgZ2V0KHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBnZXRNb2RlbFBhcmFtZXRlcnNUb1ZlcnRleCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3tuYW1lfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ2NvbmZpZyddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBtb2RlbEZyb21WZXJ0ZXgoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZ2V0TW9kZWxQYXJhbWV0ZXJzVG9NbGRldih0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3tuYW1lfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ2NvbmZpZyddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYyA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBtb2RlbEZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBsaXN0SW50ZXJuYWwocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGxpc3RNb2RlbHNQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bW9kZWxzX3VybH0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5Wydjb25maWcnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gbGlzdE1vZGVsc1Jlc3BvbnNlRnJvbVZlcnRleCh0aGlzLmFwaUNsaWVudCwgYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBMaXN0TW9kZWxzUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGxpc3RNb2RlbHNQYXJhbWV0ZXJzVG9NbGRldih0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3ttb2RlbHNfdXJsfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ2NvbmZpZyddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYyA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBsaXN0TW9kZWxzUmVzcG9uc2VGcm9tTWxkZXYodGhpcy5hcGlDbGllbnQsIGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgTGlzdE1vZGVsc1Jlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGEgdHVuZWQgbW9kZWwgYnkgaXRzIG5hbWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHVwZGF0aW5nIHRoZSBtb2RlbC5cbiAgICAgKiBAcmV0dXJuIFRoZSByZXNwb25zZSBmcm9tIHRoZSBBUEkuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhaS5tb2RlbHMudXBkYXRlKHtcbiAgICAgKiAgIG1vZGVsOiAndHVuZWQtbW9kZWwtbmFtZScsXG4gICAgICogICBjb25maWc6IHtcbiAgICAgKiAgICAgZGlzcGxheU5hbWU6ICdOZXcgZGlzcGxheSBuYW1lJyxcbiAgICAgKiAgICAgZGVzY3JpcHRpb246ICdOZXcgZGVzY3JpcHRpb24nLFxuICAgICAqICAgfSxcbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGUocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IHVwZGF0ZU1vZGVsUGFyYW1ldGVyc1RvVmVydGV4KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne21vZGVsfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ2NvbmZpZyddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BBVENIJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IG1vZGVsRnJvbVZlcnRleChhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSB1cGRhdGVNb2RlbFBhcmFtZXRlcnNUb01sZGV2KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne25hbWV9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnY29uZmlnJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUEFUQ0gnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gbW9kZWxGcm9tTWxkZXYoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBhIHR1bmVkIG1vZGVsIGJ5IGl0cyBuYW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciBkZWxldGluZyB0aGUgbW9kZWwuXG4gICAgICogQHJldHVybiBUaGUgcmVzcG9uc2UgZnJvbSB0aGUgQVBJLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYWkubW9kZWxzLmRlbGV0ZSh7bW9kZWw6ICd0dW5lZC1tb2RlbC1uYW1lJ30pO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIGRlbGV0ZShwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZGVsZXRlTW9kZWxQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bmFtZX0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5Wydjb25maWcnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdERUxFVEUnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGRlbGV0ZU1vZGVsUmVzcG9uc2VGcm9tVmVydGV4KCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IERlbGV0ZU1vZGVsUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGRlbGV0ZU1vZGVsUGFyYW1ldGVyc1RvTWxkZXYodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bmFtZX0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5Wydjb25maWcnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdERUxFVEUnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGRlbGV0ZU1vZGVsUmVzcG9uc2VGcm9tTWxkZXYoKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgRGVsZXRlTW9kZWxSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ291bnRzIHRoZSBudW1iZXIgb2YgdG9rZW5zIGluIHRoZSBnaXZlbiBjb250ZW50cy4gTXVsdGltb2RhbCBpbnB1dCBpc1xuICAgICAqIHN1cHBvcnRlZCBmb3IgR2VtaW5pIG1vZGVscy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgY291bnRpbmcgdG9rZW5zLlxuICAgICAqIEByZXR1cm4gVGhlIHJlc3BvbnNlIGZyb20gdGhlIEFQSS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFpLm1vZGVscy5jb3VudFRva2Vucyh7XG4gICAgICogIG1vZGVsOiAnZ2VtaW5pLTIuMC1mbGFzaCcsXG4gICAgICogIGNvbnRlbnRzOiAnVGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZy4nXG4gICAgICogfSk7XG4gICAgICogY29uc29sZS5sb2cocmVzcG9uc2UpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIGNvdW50VG9rZW5zKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBjb3VudFRva2Vuc1BhcmFtZXRlcnNUb1ZlcnRleCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3ttb2RlbH06Y291bnRUb2tlbnMnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5Wydjb25maWcnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGNvdW50VG9rZW5zUmVzcG9uc2VGcm9tVmVydGV4KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgQ291bnRUb2tlbnNSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gY291bnRUb2tlbnNQYXJhbWV0ZXJzVG9NbGRldih0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3ttb2RlbH06Y291bnRUb2tlbnMnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5Wydjb25maWcnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGNvdW50VG9rZW5zUmVzcG9uc2VGcm9tTWxkZXYoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBDb3VudFRva2Vuc1Jlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHaXZlbiBhIGxpc3Qgb2YgY29udGVudHMsIHJldHVybnMgYSBjb3JyZXNwb25kaW5nIFRva2Vuc0luZm8gY29udGFpbmluZ1xuICAgICAqIHRoZSBsaXN0IG9mIHRva2VucyBhbmQgbGlzdCBvZiB0b2tlbiBpZHMuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBHZW1pbmkgRGV2ZWxvcGVyIEFQSS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgY29tcHV0aW5nIHRva2Vucy5cbiAgICAgKiBAcmV0dXJuIFRoZSByZXNwb25zZSBmcm9tIHRoZSBBUEkuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhaS5tb2RlbHMuY29tcHV0ZVRva2Vucyh7XG4gICAgICogIG1vZGVsOiAnZ2VtaW5pLTIuMC1mbGFzaCcsXG4gICAgICogIGNvbnRlbnRzOiAnV2hhdCBpcyB5b3VyIG5hbWU/J1xuICAgICAqIH0pO1xuICAgICAqIGNvbnNvbGUubG9nKHJlc3BvbnNlKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBjb21wdXRlVG9rZW5zKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gY29tcHV0ZVRva2Vuc1BhcmFtZXRlcnNUb1ZlcnRleCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3ttb2RlbH06Y29tcHV0ZVRva2VucycsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ2NvbmZpZyddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gY29tcHV0ZVRva2Vuc1Jlc3BvbnNlRnJvbVZlcnRleChhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IENvbXB1dGVUb2tlbnNSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIG9ubHkgc3VwcG9ydGVkIGJ5IHRoZSBWZXJ0ZXggQUkuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogIEdlbmVyYXRlcyB2aWRlb3MgYmFzZWQgb24gYSB0ZXh0IGRlc2NyaXB0aW9uIGFuZCBjb25maWd1cmF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciBnZW5lcmF0aW5nIHZpZGVvcy5cbiAgICAgKiBAcmV0dXJuIEEgUHJvbWlzZTxHZW5lcmF0ZVZpZGVvc09wZXJhdGlvbj4gd2hpY2ggYWxsb3dzIHlvdSB0byB0cmFjayB0aGUgcHJvZ3Jlc3MgYW5kIGV2ZW50dWFsbHkgcmV0cmlldmUgdGhlIGdlbmVyYXRlZCB2aWRlb3MgdXNpbmcgdGhlIG9wZXJhdGlvbnMuZ2V0IG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCBvcGVyYXRpb24gPSBhd2FpdCBhaS5tb2RlbHMuZ2VuZXJhdGVWaWRlb3Moe1xuICAgICAqICBtb2RlbDogJ3Zlby0yLjAtZ2VuZXJhdGUtMDAxJyxcbiAgICAgKiAgcHJvbXB0OiAnQSBuZW9uIGhvbG9ncmFtIG9mIGEgY2F0IGRyaXZpbmcgYXQgdG9wIHNwZWVkJyxcbiAgICAgKiAgY29uZmlnOiB7XG4gICAgICogICAgbnVtYmVyT2ZWaWRlb3M6IDFcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIHdoaWxlICghb3BlcmF0aW9uLmRvbmUpIHtcbiAgICAgKiAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDAwMCkpO1xuICAgICAqICAgb3BlcmF0aW9uID0gYXdhaXQgYWkub3BlcmF0aW9ucy5nZXRWaWRlb3NPcGVyYXRpb24oe29wZXJhdGlvbjogb3BlcmF0aW9ufSk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2cob3BlcmF0aW9uLnJlc3BvbnNlPy5nZW5lcmF0ZWRWaWRlb3M/LlswXT8udmlkZW8/LnVyaSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgZ2VuZXJhdGVWaWRlb3MocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGdlbmVyYXRlVmlkZW9zUGFyYW1ldGVyc1RvVmVydGV4KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne21vZGVsfTpwcmVkaWN0TG9uZ1J1bm5pbmcnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5Wydjb25maWcnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGdlbmVyYXRlVmlkZW9zT3BlcmF0aW9uRnJvbVZlcnRleCQxKGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGdlbmVyYXRlVmlkZW9zUGFyYW1ldGVyc1RvTWxkZXYodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bW9kZWx9OnByZWRpY3RMb25nUnVubmluZycsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ2NvbmZpZyddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gZ2VuZXJhdGVWaWRlb3NPcGVyYXRpb25Gcm9tTWxkZXYkMShhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuLy8gQ29kZSBnZW5lcmF0ZWQgYnkgdGhlIEdvb2dsZSBHZW4gQUkgU0RLIGdlbmVyYXRvciBETyBOT1QgRURJVC5cbmZ1bmN0aW9uIGdldE9wZXJhdGlvblBhcmFtZXRlcnNUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21PcGVyYXRpb25OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnb3BlcmF0aW9uTmFtZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21PcGVyYXRpb25OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICdvcGVyYXRpb25OYW1lJ10sIGZyb21PcGVyYXRpb25OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29uZmlnJ10sIGZyb21Db25maWcpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZXRPcGVyYXRpb25QYXJhbWV0ZXJzVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU9wZXJhdGlvbk5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdvcGVyYXRpb25OYW1lJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU9wZXJhdGlvbk5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ29wZXJhdGlvbk5hbWUnXSwgZnJvbU9wZXJhdGlvbk5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb25maWcnXSwgZnJvbUNvbmZpZyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZldGNoUHJlZGljdE9wZXJhdGlvblBhcmFtZXRlcnNUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tT3BlcmF0aW9uTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ29wZXJhdGlvbk5hbWUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tT3BlcmF0aW9uTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ29wZXJhdGlvbk5hbWUnXSwgZnJvbU9wZXJhdGlvbk5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzb3VyY2VOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXNvdXJjZU5hbWUnXSk7XG4gICAgaWYgKGZyb21SZXNvdXJjZU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ3Jlc291cmNlTmFtZSddLCBmcm9tUmVzb3VyY2VOYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29uZmlnJ10sIGZyb21Db25maWcpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB2aWRlb0Zyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd2aWRlbycsICd1cmknXSk7XG4gICAgaWYgKGZyb21VcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1cmknXSwgZnJvbVVyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21WaWRlb0J5dGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndmlkZW8nLFxuICAgICAgICAnZW5jb2RlZFZpZGVvJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVZpZGVvQnl0ZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2aWRlb0J5dGVzJ10sIHRCeXRlcyhmcm9tVmlkZW9CeXRlcykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VuY29kaW5nJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZWRWaWRlb0Zyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVmlkZW8gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ19zZWxmJ10pO1xuICAgIGlmIChmcm9tVmlkZW8gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2aWRlbyddLCB2aWRlb0Zyb21NbGRldihmcm9tVmlkZW8pKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVWaWRlb3NSZXNwb25zZUZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tR2VuZXJhdGVkVmlkZW9zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ2VuZXJhdGVkU2FtcGxlcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21HZW5lcmF0ZWRWaWRlb3MgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUdlbmVyYXRlZFZpZGVvcztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZW5lcmF0ZWRWaWRlb0Zyb21NbGRldihpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dlbmVyYXRlZFZpZGVvcyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmFpTWVkaWFGaWx0ZXJlZENvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmFpTWVkaWFGaWx0ZXJlZENvdW50JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJhaU1lZGlhRmlsdGVyZWRDb3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JhaU1lZGlhRmlsdGVyZWRDb3VudCddLCBmcm9tUmFpTWVkaWFGaWx0ZXJlZENvdW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJhaU1lZGlhRmlsdGVyZWRSZWFzb25zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmFpTWVkaWFGaWx0ZXJlZFJlYXNvbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmFpTWVkaWFGaWx0ZXJlZFJlYXNvbnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyYWlNZWRpYUZpbHRlcmVkUmVhc29ucyddLCBmcm9tUmFpTWVkaWFGaWx0ZXJlZFJlYXNvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVZpZGVvc09wZXJhdGlvbkZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtZXRhZGF0YSddKTtcbiAgICBpZiAoZnJvbU1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWV0YWRhdGEnXSwgZnJvbU1ldGFkYXRhKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURvbmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2RvbmUnXSk7XG4gICAgaWYgKGZyb21Eb25lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZG9uZSddLCBmcm9tRG9uZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FcnJvciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXJyb3InXSk7XG4gICAgaWYgKGZyb21FcnJvciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Vycm9yJ10sIGZyb21FcnJvcik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlJyxcbiAgICAgICAgJ2dlbmVyYXRlVmlkZW9SZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlJ10sIGdlbmVyYXRlVmlkZW9zUmVzcG9uc2VGcm9tTWxkZXYoZnJvbVJlc3BvbnNlKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHZpZGVvRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnY3NVcmknXSk7XG4gICAgaWYgKGZyb21VcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1cmknXSwgZnJvbVVyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21WaWRlb0J5dGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnYnl0ZXNCYXNlNjRFbmNvZGVkJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVZpZGVvQnl0ZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2aWRlb0J5dGVzJ10sIHRCeXRlcyhmcm9tVmlkZW9CeXRlcykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZWRWaWRlb0Zyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVZpZGVvID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydfc2VsZiddKTtcbiAgICBpZiAoZnJvbVZpZGVvICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndmlkZW8nXSwgdmlkZW9Gcm9tVmVydGV4KGZyb21WaWRlbykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVZpZGVvc1Jlc3BvbnNlRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tR2VuZXJhdGVkVmlkZW9zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd2aWRlb3MnXSk7XG4gICAgaWYgKGZyb21HZW5lcmF0ZWRWaWRlb3MgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUdlbmVyYXRlZFZpZGVvcztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZW5lcmF0ZWRWaWRlb0Zyb21WZXJ0ZXgoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnZW5lcmF0ZWRWaWRlb3MnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJhaU1lZGlhRmlsdGVyZWRDb3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3JhaU1lZGlhRmlsdGVyZWRDb3VudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SYWlNZWRpYUZpbHRlcmVkQ291bnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyYWlNZWRpYUZpbHRlcmVkQ291bnQnXSwgZnJvbVJhaU1lZGlhRmlsdGVyZWRDb3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SYWlNZWRpYUZpbHRlcmVkUmVhc29ucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3JhaU1lZGlhRmlsdGVyZWRSZWFzb25zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJhaU1lZGlhRmlsdGVyZWRSZWFzb25zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmFpTWVkaWFGaWx0ZXJlZFJlYXNvbnMnXSwgZnJvbVJhaU1lZGlhRmlsdGVyZWRSZWFzb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVWaWRlb3NPcGVyYXRpb25Gcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21ldGFkYXRhJ10pO1xuICAgIGlmIChmcm9tTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtZXRhZGF0YSddLCBmcm9tTWV0YWRhdGEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRG9uZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZG9uZSddKTtcbiAgICBpZiAoZnJvbURvbmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkb25lJ10sIGZyb21Eb25lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVycm9yID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlcnJvciddKTtcbiAgICBpZiAoZnJvbUVycm9yICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXJyb3InXSwgZnJvbUVycm9yKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXNwb25zZSddKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2UnXSwgZ2VuZXJhdGVWaWRlb3NSZXNwb25zZUZyb21WZXJ0ZXgoZnJvbVJlc3BvbnNlKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuY2xhc3MgT3BlcmF0aW9ucyBleHRlbmRzIEJhc2VNb2R1bGUge1xuICAgIGNvbnN0cnVjdG9yKGFwaUNsaWVudCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmFwaUNsaWVudCA9IGFwaUNsaWVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgc3RhdHVzIG9mIGEgbG9uZy1ydW5uaW5nIG9wZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbWV0ZXJzIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgZ2V0IG9wZXJhdGlvbiByZXF1ZXN0LlxuICAgICAqIEByZXR1cm4gVGhlIHVwZGF0ZWQgT3BlcmF0aW9uIG9iamVjdCwgd2l0aCB0aGUgbGF0ZXN0IHN0YXR1cyBvciByZXN1bHQuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0VmlkZW9zT3BlcmF0aW9uKHBhcmFtZXRlcnMpIHtcbiAgICAgICAgY29uc3Qgb3BlcmF0aW9uID0gcGFyYW1ldGVycy5vcGVyYXRpb247XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IHBhcmFtZXRlcnMuY29uZmlnO1xuICAgICAgICBpZiAob3BlcmF0aW9uLm5hbWUgPT09IHVuZGVmaW5lZCB8fCBvcGVyYXRpb24ubmFtZSA9PT0gJycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT3BlcmF0aW9uIG5hbWUgaXMgcmVxdWlyZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgcmVzb3VyY2VOYW1lID0gb3BlcmF0aW9uLm5hbWUuc3BsaXQoJy9vcGVyYXRpb25zLycpWzBdO1xuICAgICAgICAgICAgbGV0IGh0dHBPcHRpb25zID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKGNvbmZpZyAmJiAnaHR0cE9wdGlvbnMnIGluIGNvbmZpZykge1xuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zID0gY29uZmlnLmh0dHBPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hQcmVkaWN0VmlkZW9zT3BlcmF0aW9uSW50ZXJuYWwoe1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbk5hbWU6IG9wZXJhdGlvbi5uYW1lLFxuICAgICAgICAgICAgICAgIHJlc291cmNlTmFtZTogcmVzb3VyY2VOYW1lLFxuICAgICAgICAgICAgICAgIGNvbmZpZzogeyBodHRwT3B0aW9uczogaHR0cE9wdGlvbnMgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VmlkZW9zT3BlcmF0aW9uSW50ZXJuYWwoe1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbk5hbWU6IG9wZXJhdGlvbi5uYW1lLFxuICAgICAgICAgICAgICAgIGNvbmZpZzogY29uZmlnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0VmlkZW9zT3BlcmF0aW9uSW50ZXJuYWwocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGdldE9wZXJhdGlvblBhcmFtZXRlcnNUb1ZlcnRleChwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne29wZXJhdGlvbk5hbWV9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnY29uZmlnJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGdlbmVyYXRlVmlkZW9zT3BlcmF0aW9uRnJvbVZlcnRleChhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBnZXRPcGVyYXRpb25QYXJhbWV0ZXJzVG9NbGRldihwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne29wZXJhdGlvbk5hbWV9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnY29uZmlnJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGdlbmVyYXRlVmlkZW9zT3BlcmF0aW9uRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGZldGNoUHJlZGljdFZpZGVvc09wZXJhdGlvbkludGVybmFsKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZmV0Y2hQcmVkaWN0T3BlcmF0aW9uUGFyYW1ldGVyc1RvVmVydGV4KHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7cmVzb3VyY2VOYW1lfTpmZXRjaFByZWRpY3RPcGVyYXRpb24nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5Wydjb25maWcnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGdlbmVyYXRlVmlkZW9zT3BlcmF0aW9uRnJvbVZlcnRleChhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgaXMgb25seSBzdXBwb3J0ZWQgYnkgdGhlIFZlcnRleCBBSS4nKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuZnVuY3Rpb24gcHJlYnVpbHRWb2ljZUNvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVZvaWNlTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndm9pY2VOYW1lJ10pO1xuICAgIGlmIChmcm9tVm9pY2VOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndm9pY2VOYW1lJ10sIGZyb21Wb2ljZU5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB2b2ljZUNvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVByZWJ1aWx0Vm9pY2VDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcmVidWlsdFZvaWNlQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVByZWJ1aWx0Vm9pY2VDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcmVidWlsdFZvaWNlQ29uZmlnJ10sIHByZWJ1aWx0Vm9pY2VDb25maWdUb01sZGV2KGZyb21QcmVidWlsdFZvaWNlQ29uZmlnKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHNwZWFrZXJWb2ljZUNvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNwZWFrZXIgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NwZWFrZXInXSk7XG4gICAgaWYgKGZyb21TcGVha2VyICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3BlYWtlciddLCBmcm9tU3BlYWtlcik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Wb2ljZUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndm9pY2VDb25maWcnXSk7XG4gICAgaWYgKGZyb21Wb2ljZUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZvaWNlQ29uZmlnJ10sIHZvaWNlQ29uZmlnVG9NbGRldihmcm9tVm9pY2VDb25maWcpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbXVsdGlTcGVha2VyVm9pY2VDb25maWdUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TcGVha2VyVm9pY2VDb25maWdzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc3BlYWtlclZvaWNlQ29uZmlncycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TcGVha2VyVm9pY2VDb25maWdzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21TcGVha2VyVm9pY2VDb25maWdzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNwZWFrZXJWb2ljZUNvbmZpZ1RvTWxkZXYoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzcGVha2VyVm9pY2VDb25maWdzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHNwZWVjaENvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVZvaWNlQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd2b2ljZUNvbmZpZyddKTtcbiAgICBpZiAoZnJvbVZvaWNlQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndm9pY2VDb25maWcnXSwgdm9pY2VDb25maWdUb01sZGV2KGZyb21Wb2ljZUNvbmZpZykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTXVsdGlTcGVha2VyVm9pY2VDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtdWx0aVNwZWFrZXJWb2ljZUNvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21NdWx0aVNwZWFrZXJWb2ljZUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ211bHRpU3BlYWtlclZvaWNlQ29uZmlnJ10sIG11bHRpU3BlYWtlclZvaWNlQ29uZmlnVG9NbGRldihmcm9tTXVsdGlTcGVha2VyVm9pY2VDb25maWcpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxhbmd1YWdlQ29kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGFuZ3VhZ2VDb2RlJ10pO1xuICAgIGlmIChmcm9tTGFuZ3VhZ2VDb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbGFuZ3VhZ2VDb2RlJ10sIGZyb21MYW5ndWFnZUNvZGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB2aWRlb01ldGFkYXRhVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRnBzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmcHMnXSk7XG4gICAgaWYgKGZyb21GcHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmcHMnXSwgZnJvbUZwcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmRPZmZzZXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VuZE9mZnNldCddKTtcbiAgICBpZiAoZnJvbUVuZE9mZnNldCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VuZE9mZnNldCddLCBmcm9tRW5kT2Zmc2V0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN0YXJ0T2Zmc2V0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzdGFydE9mZnNldCddKTtcbiAgICBpZiAoZnJvbVN0YXJ0T2Zmc2V0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3RhcnRPZmZzZXQnXSwgZnJvbVN0YXJ0T2Zmc2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gYmxvYlRvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Rpc3BsYXlOYW1lIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkYXRhJ10pO1xuICAgIGlmIChmcm9tRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2RhdGEnXSwgZnJvbURhdGEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBmaWxlRGF0YVRvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Rpc3BsYXlOYW1lIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWxlVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlVXJpJ10pO1xuICAgIGlmIChmcm9tRmlsZVVyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVVcmknXSwgZnJvbUZpbGVVcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBwYXJ0VG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVmlkZW9NZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ZpZGVvTWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVmlkZW9NZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZpZGVvTWV0YWRhdGEnXSwgdmlkZW9NZXRhZGF0YVRvTWxkZXYoZnJvbVZpZGVvTWV0YWRhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRob3VnaHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rob3VnaHQnXSk7XG4gICAgaWYgKGZyb21UaG91Z2h0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhvdWdodCddLCBmcm9tVGhvdWdodCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbmxpbmVEYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbmxpbmVEYXRhJ10pO1xuICAgIGlmIChmcm9tSW5saW5lRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2lubGluZURhdGEnXSwgYmxvYlRvTWxkZXYoZnJvbUlubGluZURhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbGVEYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlRGF0YSddKTtcbiAgICBpZiAoZnJvbUZpbGVEYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmlsZURhdGEnXSwgZmlsZURhdGFUb01sZGV2KGZyb21GaWxlRGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhvdWdodFNpZ25hdHVyZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Rob3VnaHRTaWduYXR1cmUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVGhvdWdodFNpZ25hdHVyZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rob3VnaHRTaWduYXR1cmUnXSwgZnJvbVRob3VnaHRTaWduYXR1cmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NvZGVFeGVjdXRpb25SZXN1bHQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvZGVFeGVjdXRpb25SZXN1bHQnXSwgZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXhlY3V0YWJsZUNvZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdleGVjdXRhYmxlQ29kZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FeGVjdXRhYmxlQ29kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2V4ZWN1dGFibGVDb2RlJ10sIGZyb21FeGVjdXRhYmxlQ29kZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GdW5jdGlvbkNhbGwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Z1bmN0aW9uQ2FsbCddKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uQ2FsbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uQ2FsbCddLCBmcm9tRnVuY3Rpb25DYWxsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvblJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvblJlc3BvbnNlJ10sIGZyb21GdW5jdGlvblJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRleHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RleHQnXSk7XG4gICAgaWYgKGZyb21UZXh0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGV4dCddLCBmcm9tVGV4dCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNvbnRlbnRUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21QYXJ0cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFydHMnXSk7XG4gICAgaWYgKGZyb21QYXJ0cyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tUGFydHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFydFRvTWxkZXYoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJ0cyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUm9sZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncm9sZSddKTtcbiAgICBpZiAoZnJvbVJvbGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyb2xlJ10sIGZyb21Sb2xlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZnVuY3Rpb25EZWNsYXJhdGlvblRvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUJlaGF2aW9yID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydiZWhhdmlvciddKTtcbiAgICBpZiAoZnJvbUJlaGF2aW9yICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYmVoYXZpb3InXSwgZnJvbUJlaGF2aW9yKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURlc2NyaXB0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkZXNjcmlwdGlvbiddKTtcbiAgICBpZiAoZnJvbURlc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGVzY3JpcHRpb24nXSwgZnJvbURlc2NyaXB0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QYXJhbWV0ZXJzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYXJhbWV0ZXJzJ10pO1xuICAgIGlmIChmcm9tUGFyYW1ldGVycyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BhcmFtZXRlcnMnXSwgZnJvbVBhcmFtZXRlcnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGFyYW1ldGVyc0pzb25TY2hlbWEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwYXJhbWV0ZXJzSnNvblNjaGVtYScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21QYXJhbWV0ZXJzSnNvblNjaGVtYSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BhcmFtZXRlcnNKc29uU2NoZW1hJ10sIGZyb21QYXJhbWV0ZXJzSnNvblNjaGVtYSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmVzcG9uc2UnXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlJ10sIGZyb21SZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZUpzb25TY2hlbWEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZUpzb25TY2hlbWEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VKc29uU2NoZW1hICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VKc29uU2NoZW1hJ10sIGZyb21SZXNwb25zZUpzb25TY2hlbWEpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBpbnRlcnZhbFRvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVN0YXJ0VGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3RhcnRUaW1lJ10pO1xuICAgIGlmIChmcm9tU3RhcnRUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3RhcnRUaW1lJ10sIGZyb21TdGFydFRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5kVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW5kVGltZSddKTtcbiAgICBpZiAoZnJvbUVuZFRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmRUaW1lJ10sIGZyb21FbmRUaW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ29vZ2xlU2VhcmNoVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVGltZVJhbmdlRmlsdGVyID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndGltZVJhbmdlRmlsdGVyJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRpbWVSYW5nZUZpbHRlciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RpbWVSYW5nZUZpbHRlciddLCBpbnRlcnZhbFRvTWxkZXYoZnJvbVRpbWVSYW5nZUZpbHRlcikpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBkeW5hbWljUmV0cmlldmFsQ29uZmlnVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZSddKTtcbiAgICBpZiAoZnJvbU1vZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RlJ10sIGZyb21Nb2RlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUR5bmFtaWNUaHJlc2hvbGQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdkeW5hbWljVGhyZXNob2xkJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUR5bmFtaWNUaHJlc2hvbGQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkeW5hbWljVGhyZXNob2xkJ10sIGZyb21EeW5hbWljVGhyZXNob2xkKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ29vZ2xlU2VhcmNoUmV0cmlldmFsVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRHluYW1pY1JldHJpZXZhbENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2R5bmFtaWNSZXRyaWV2YWxDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRHluYW1pY1JldHJpZXZhbENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2R5bmFtaWNSZXRyaWV2YWxDb25maWcnXSwgZHluYW1pY1JldHJpZXZhbENvbmZpZ1RvTWxkZXYoZnJvbUR5bmFtaWNSZXRyaWV2YWxDb25maWcpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdXJsQ29udGV4dFRvTWxkZXYoKSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB0b29sVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvbkRlY2xhcmF0aW9ucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb25EZWNsYXJhdGlvblRvTWxkZXYoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvbkRlY2xhcmF0aW9ucyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXRyaWV2YWwnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JldHJpZXZhbCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlU2VhcmNoID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnb29nbGVTZWFyY2gnXSk7XG4gICAgaWYgKGZyb21Hb29nbGVTZWFyY2ggIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVTZWFyY2gnXSwgZ29vZ2xlU2VhcmNoVG9NbGRldihmcm9tR29vZ2xlU2VhcmNoKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hb29nbGVTZWFyY2hSZXRyaWV2YWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdnb29nbGVTZWFyY2hSZXRyaWV2YWwnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ29vZ2xlU2VhcmNoUmV0cmlldmFsJ10sIGdvb2dsZVNlYXJjaFJldHJpZXZhbFRvTWxkZXYoZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCkpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbnRlcnByaXNlV2ViU2VhcmNoJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdlbnRlcnByaXNlV2ViU2VhcmNoIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2dvb2dsZU1hcHMnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dvb2dsZU1hcHMgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVybENvbnRleHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3VybENvbnRleHQnXSk7XG4gICAgaWYgKGZyb21VcmxDb250ZXh0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXJsQ29udGV4dCddLCB1cmxDb250ZXh0VG9NbGRldigpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvZGVFeGVjdXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjb2RlRXhlY3V0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNvZGVFeGVjdXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb2RlRXhlY3V0aW9uJ10sIGZyb21Db2RlRXhlY3V0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gc2Vzc2lvblJlc3VtcHRpb25Db25maWdUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21IYW5kbGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2hhbmRsZSddKTtcbiAgICBpZiAoZnJvbUhhbmRsZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2hhbmRsZSddLCBmcm9tSGFuZGxlKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndHJhbnNwYXJlbnQnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RyYW5zcGFyZW50IHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGF1ZGlvVHJhbnNjcmlwdGlvbkNvbmZpZ1RvTWxkZXYoKSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBhdXRvbWF0aWNBY3Rpdml0eURldGVjdGlvblRvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbURpc2FibGVkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNhYmxlZCddKTtcbiAgICBpZiAoZnJvbURpc2FibGVkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGlzYWJsZWQnXSwgZnJvbURpc2FibGVkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN0YXJ0T2ZTcGVlY2hTZW5zaXRpdml0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3N0YXJ0T2ZTcGVlY2hTZW5zaXRpdml0eScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TdGFydE9mU3BlZWNoU2Vuc2l0aXZpdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdGFydE9mU3BlZWNoU2Vuc2l0aXZpdHknXSwgZnJvbVN0YXJ0T2ZTcGVlY2hTZW5zaXRpdml0eSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmRPZlNwZWVjaFNlbnNpdGl2aXR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZW5kT2ZTcGVlY2hTZW5zaXRpdml0eScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FbmRPZlNwZWVjaFNlbnNpdGl2aXR5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW5kT2ZTcGVlY2hTZW5zaXRpdml0eSddLCBmcm9tRW5kT2ZTcGVlY2hTZW5zaXRpdml0eSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QcmVmaXhQYWRkaW5nTXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcmVmaXhQYWRkaW5nTXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUHJlZml4UGFkZGluZ01zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncHJlZml4UGFkZGluZ01zJ10sIGZyb21QcmVmaXhQYWRkaW5nTXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2lsZW5jZUR1cmF0aW9uTXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzaWxlbmNlRHVyYXRpb25NcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TaWxlbmNlRHVyYXRpb25NcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NpbGVuY2VEdXJhdGlvbk1zJ10sIGZyb21TaWxlbmNlRHVyYXRpb25Ncyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHJlYWx0aW1lSW5wdXRDb25maWdUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21BdXRvbWF0aWNBY3Rpdml0eURldGVjdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2F1dG9tYXRpY0FjdGl2aXR5RGV0ZWN0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUF1dG9tYXRpY0FjdGl2aXR5RGV0ZWN0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYXV0b21hdGljQWN0aXZpdHlEZXRlY3Rpb24nXSwgYXV0b21hdGljQWN0aXZpdHlEZXRlY3Rpb25Ub01sZGV2KGZyb21BdXRvbWF0aWNBY3Rpdml0eURldGVjdGlvbikpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQWN0aXZpdHlIYW5kbGluZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2FjdGl2aXR5SGFuZGxpbmcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQWN0aXZpdHlIYW5kbGluZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2FjdGl2aXR5SGFuZGxpbmcnXSwgZnJvbUFjdGl2aXR5SGFuZGxpbmcpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVHVybkNvdmVyYWdlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0dXJuQ292ZXJhZ2UnXSk7XG4gICAgaWYgKGZyb21UdXJuQ292ZXJhZ2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0dXJuQ292ZXJhZ2UnXSwgZnJvbVR1cm5Db3ZlcmFnZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHNsaWRpbmdXaW5kb3dUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21UYXJnZXRUb2tlbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RhcmdldFRva2VucyddKTtcbiAgICBpZiAoZnJvbVRhcmdldFRva2VucyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RhcmdldFRva2VucyddLCBmcm9tVGFyZ2V0VG9rZW5zKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY29udGV4dFdpbmRvd0NvbXByZXNzaW9uQ29uZmlnVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVHJpZ2dlclRva2VucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3RyaWdnZXJUb2tlbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVHJpZ2dlclRva2VucyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RyaWdnZXJUb2tlbnMnXSwgZnJvbVRyaWdnZXJUb2tlbnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2xpZGluZ1dpbmRvdyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NsaWRpbmdXaW5kb3cnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2xpZGluZ1dpbmRvdyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NsaWRpbmdXaW5kb3cnXSwgc2xpZGluZ1dpbmRvd1RvTWxkZXYoZnJvbVNsaWRpbmdXaW5kb3cpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gcHJvYWN0aXZpdHlDb25maWdUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Qcm9hY3RpdmVBdWRpbyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Byb2FjdGl2ZUF1ZGlvJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVByb2FjdGl2ZUF1ZGlvICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncHJvYWN0aXZlQXVkaW8nXSwgZnJvbVByb2FjdGl2ZUF1ZGlvKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGl2ZUNvbm5lY3RDb25maWdUb01sZGV2KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUdlbmVyYXRpb25Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdnZW5lcmF0aW9uQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUdlbmVyYXRpb25Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZyddLCBmcm9tR2VuZXJhdGlvbkNvbmZpZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZU1vZGFsaXRpZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZU1vZGFsaXRpZXMnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUmVzcG9uc2VNb2RhbGl0aWVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAncmVzcG9uc2VNb2RhbGl0aWVzJ10sIGZyb21SZXNwb25zZU1vZGFsaXRpZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGVtcGVyYXR1cmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RlbXBlcmF0dXJlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVGVtcGVyYXR1cmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICd0ZW1wZXJhdHVyZSddLCBmcm9tVGVtcGVyYXR1cmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9wUCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9wUCddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRvcFAgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICd0b3BQJ10sIGZyb21Ub3BQKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvcEsgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RvcEsnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Ub3BLICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAndG9wSyddLCBmcm9tVG9wSyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NYXhPdXRwdXRUb2tlbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtYXhPdXRwdXRUb2tlbnMnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTWF4T3V0cHV0VG9rZW5zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAnbWF4T3V0cHV0VG9rZW5zJ10sIGZyb21NYXhPdXRwdXRUb2tlbnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWVkaWFSZXNvbHV0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbWVkaWFSZXNvbHV0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU1lZGlhUmVzb2x1dGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ21lZGlhUmVzb2x1dGlvbiddLCBmcm9tTWVkaWFSZXNvbHV0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNlZWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NlZWQnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TZWVkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAnc2VlZCddLCBmcm9tU2VlZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TcGVlY2hDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NwZWVjaENvbmZpZyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVNwZWVjaENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ3NwZWVjaENvbmZpZyddLCBzcGVlY2hDb25maWdUb01sZGV2KHRMaXZlU3BlZWNoQ29uZmlnKGZyb21TcGVlY2hDb25maWcpKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmFibGVBZmZlY3RpdmVEaWFsb2cgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdlbmFibGVBZmZlY3RpdmVEaWFsb2cnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRW5hYmxlQWZmZWN0aXZlRGlhbG9nICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAnZW5hYmxlQWZmZWN0aXZlRGlhbG9nJ10sIGZyb21FbmFibGVBZmZlY3RpdmVEaWFsb2cpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzeXN0ZW1JbnN0cnVjdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TeXN0ZW1JbnN0cnVjdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdzeXN0ZW1JbnN0cnVjdGlvbiddLCBjb250ZW50VG9NbGRldih0Q29udGVudChmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24pKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub29scyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9vbHMnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Ub29scyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSB0VG9vbHMoZnJvbVRvb2xzKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b29sVG9NbGRldih0VG9vbChpdGVtKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAndG9vbHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNlc3Npb25SZXN1bXB0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2Vzc2lvblJlc3VtcHRpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU2Vzc2lvblJlc3VtcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnc2Vzc2lvblJlc3VtcHRpb24nXSwgc2Vzc2lvblJlc3VtcHRpb25Db25maWdUb01sZGV2KGZyb21TZXNzaW9uUmVzdW1wdGlvbikpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5wdXRBdWRpb1RyYW5zY3JpcHRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdpbnB1dEF1ZGlvVHJhbnNjcmlwdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21JbnB1dEF1ZGlvVHJhbnNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdpbnB1dEF1ZGlvVHJhbnNjcmlwdGlvbiddLCBhdWRpb1RyYW5zY3JpcHRpb25Db25maWdUb01sZGV2KCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0QXVkaW9UcmFuc2NyaXB0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnb3V0cHV0QXVkaW9UcmFuc2NyaXB0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU91dHB1dEF1ZGlvVHJhbnNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdvdXRwdXRBdWRpb1RyYW5zY3JpcHRpb24nXSwgYXVkaW9UcmFuc2NyaXB0aW9uQ29uZmlnVG9NbGRldigpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlYWx0aW1lSW5wdXRDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZWFsdGltZUlucHV0Q29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVJlYWx0aW1lSW5wdXRDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAncmVhbHRpbWVJbnB1dENvbmZpZyddLCByZWFsdGltZUlucHV0Q29uZmlnVG9NbGRldihmcm9tUmVhbHRpbWVJbnB1dENvbmZpZykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29udGV4dFdpbmRvd0NvbXByZXNzaW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY29udGV4dFdpbmRvd0NvbXByZXNzaW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUNvbnRleHRXaW5kb3dDb21wcmVzc2lvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdjb250ZXh0V2luZG93Q29tcHJlc3Npb24nXSwgY29udGV4dFdpbmRvd0NvbXByZXNzaW9uQ29uZmlnVG9NbGRldihmcm9tQ29udGV4dFdpbmRvd0NvbXByZXNzaW9uKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Qcm9hY3Rpdml0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncHJvYWN0aXZpdHknXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Qcm9hY3Rpdml0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdwcm9hY3Rpdml0eSddLCBwcm9hY3Rpdml0eUNvbmZpZ1RvTWxkZXYoZnJvbVByb2FjdGl2aXR5KSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpdmVDb25uZWN0Q29uc3RyYWludHNUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2V0dXAnLCAnbW9kZWwnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbmZpZyddLCBsaXZlQ29ubmVjdENvbmZpZ1RvTWxkZXYoZnJvbUNvbmZpZywgdG9PYmplY3QpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY3JlYXRlQXV0aFRva2VuQ29uZmlnVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUV4cGlyZVRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2V4cGlyZVRpbWUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21FeHBpcmVUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2V4cGlyZVRpbWUnXSwgZnJvbUV4cGlyZVRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmV3U2Vzc2lvbkV4cGlyZVRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICduZXdTZXNzaW9uRXhwaXJlVGltZScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21OZXdTZXNzaW9uRXhwaXJlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWyduZXdTZXNzaW9uRXhwaXJlVGltZSddLCBmcm9tTmV3U2Vzc2lvbkV4cGlyZVRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXNlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndXNlcyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVVzZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsndXNlcyddLCBmcm9tVXNlcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21MaXZlQ29ubmVjdENvbnN0cmFpbnRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbGl2ZUNvbm5lY3RDb25zdHJhaW50cycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21MaXZlQ29ubmVjdENvbnN0cmFpbnRzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2JpZGlHZW5lcmF0ZUNvbnRlbnRTZXR1cCddLCBsaXZlQ29ubmVjdENvbnN0cmFpbnRzVG9NbGRldihhcGlDbGllbnQsIGZyb21MaXZlQ29ubmVjdENvbnN0cmFpbnRzKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Mb2NrQWRkaXRpb25hbEZpZWxkcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2xvY2tBZGRpdGlvbmFsRmllbGRzJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUxvY2tBZGRpdGlvbmFsRmllbGRzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2ZpZWxkTWFzayddLCBmcm9tTG9ja0FkZGl0aW9uYWxGaWVsZHMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjcmVhdGVBdXRoVG9rZW5QYXJhbWV0ZXJzVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbmZpZyddLCBjcmVhdGVBdXRoVG9rZW5Db25maWdUb01sZGV2KGFwaUNsaWVudCwgZnJvbUNvbmZpZywgdG9PYmplY3QpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gYXV0aFRva2VuRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbi8qKlxuICogUmV0dXJucyBhIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIGZpZWxkIG1hc2tzIGZyb20gYSBnaXZlbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHNldHVwIFRoZSBvYmplY3QgdG8gZXh0cmFjdCBmaWVsZCBtYXNrcyBmcm9tLlxuICogQHJldHVybiBBIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIGZpZWxkIG1hc2tzLlxuICovXG5mdW5jdGlvbiBnZXRGaWVsZE1hc2tzKHNldHVwKSB7XG4gICAgY29uc3QgZmllbGRzID0gW107XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc2V0dXApIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzZXR1cCwga2V5KSkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBzZXR1cFtrZXldO1xuICAgICAgICAgICAgLy8gMm5kIGxheWVyLCByZWN1cnNpdmVseSBnZXQgZmllbGQgbWFza3Mgc2VlIFRPRE8oYi80MTgyOTAxMDApXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgIHZhbHVlICE9IG51bGwgJiZcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gT2JqZWN0LmtleXModmFsdWUpLm1hcCgoa2spID0+IGAke2tleX0uJHtra31gKTtcbiAgICAgICAgICAgICAgICBmaWVsZHMucHVzaCguLi5maWVsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmaWVsZHMucHVzaChrZXkpOyAvLyAxc3QgbGF5ZXJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmllbGRzLmpvaW4oJywnKTtcbn1cbi8qKlxuICogQ29udmVydHMgYmlkaUdlbmVyYXRlQ29udGVudFNldHVwLlxuICogQHBhcmFtIHJlcXVlc3REaWN0IC0gVGhlIHJlcXVlc3QgZGljdGlvbmFyeS5cbiAqIEBwYXJhbSBjb25maWcgLSBUaGUgY29uZmlndXJhdGlvbiBvYmplY3QuXG4gKiBAcmV0dXJuIC0gVGhlIG1vZGlmaWVkIHJlcXVlc3QgZGljdGlvbmFyeS5cbiAqL1xuZnVuY3Rpb24gY29udmVydEJpZGlTZXR1cFRvVG9rZW5TZXR1cChyZXF1ZXN0RGljdCwgY29uZmlnKSB7XG4gICAgLy8gQ29udmVydCBiaWRpR2VuZXJhdGVDb250ZW50U2V0dXAgZnJvbSBiaWRpR2VuZXJhdGVDb250ZW50U2V0dXAuc2V0dXAuXG4gICAgbGV0IHNldHVwRm9yTWFza0dlbmVyYXRpb24gPSBudWxsO1xuICAgIGNvbnN0IGJpZGlHZW5lcmF0ZUNvbnRlbnRTZXR1cFZhbHVlID0gcmVxdWVzdERpY3RbJ2JpZGlHZW5lcmF0ZUNvbnRlbnRTZXR1cCddO1xuICAgIGlmICh0eXBlb2YgYmlkaUdlbmVyYXRlQ29udGVudFNldHVwVmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgICAgIGJpZGlHZW5lcmF0ZUNvbnRlbnRTZXR1cFZhbHVlICE9PSBudWxsICYmXG4gICAgICAgICdzZXR1cCcgaW4gYmlkaUdlbmVyYXRlQ29udGVudFNldHVwVmFsdWUpIHtcbiAgICAgICAgLy8gTm93IHdlIGtub3cgYmlkaUdlbmVyYXRlQ29udGVudFNldHVwVmFsdWUgaXMgYW4gb2JqZWN0IGFuZCBoYXMgYSAnc2V0dXAnXG4gICAgICAgIC8vIHByb3BlcnR5LlxuICAgICAgICBjb25zdCBpbm5lclNldHVwID0gYmlkaUdlbmVyYXRlQ29udGVudFNldHVwVmFsdWVcbiAgICAgICAgICAgIC5zZXR1cDtcbiAgICAgICAgaWYgKHR5cGVvZiBpbm5lclNldHVwID09PSAnb2JqZWN0JyAmJiBpbm5lclNldHVwICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBWYWxpZCBpbm5lciBzZXR1cCBmb3VuZC5cbiAgICAgICAgICAgIHJlcXVlc3REaWN0WydiaWRpR2VuZXJhdGVDb250ZW50U2V0dXAnXSA9IGlubmVyU2V0dXA7XG4gICAgICAgICAgICBzZXR1cEZvck1hc2tHZW5lcmF0aW9uID0gaW5uZXJTZXR1cDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGBiaWRpR2VuZXJhdGVDb250ZW50U2V0dXBWYWx1ZS5zZXR1cGAgaXMgbm90IGEgdmFsaWQgb2JqZWN0OyB0cmVhdCBhc1xuICAgICAgICAgICAgLy8gaWYgYmlkaUdlbmVyYXRlQ29udGVudFNldHVwIGlzIGludmFsaWQuXG4gICAgICAgICAgICBkZWxldGUgcmVxdWVzdERpY3RbJ2JpZGlHZW5lcmF0ZUNvbnRlbnRTZXR1cCddO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGJpZGlHZW5lcmF0ZUNvbnRlbnRTZXR1cFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gYGJpZGlHZW5lcmF0ZUNvbnRlbnRTZXR1cGAgZXhpc3RzIGJ1dCBub3QgaW4gdGhlIGV4cGVjdGVkXG4gICAgICAgIC8vIHNoYXBlIHtzZXR1cDogey4uLn19OyB0cmVhdCBhcyBpbnZhbGlkLlxuICAgICAgICBkZWxldGUgcmVxdWVzdERpY3RbJ2JpZGlHZW5lcmF0ZUNvbnRlbnRTZXR1cCddO1xuICAgIH1cbiAgICBjb25zdCBwcmVFeGlzdGluZ0ZpZWxkTWFzayA9IHJlcXVlc3REaWN0WydmaWVsZE1hc2snXTtcbiAgICAvLyBIYW5kbGUgbWFzayBnZW5lcmF0aW9uIHNldHVwLlxuICAgIGlmIChzZXR1cEZvck1hc2tHZW5lcmF0aW9uKSB7XG4gICAgICAgIGNvbnN0IGdlbmVyYXRlZE1hc2tGcm9tQmlkaSA9IGdldEZpZWxkTWFza3Moc2V0dXBGb3JNYXNrR2VuZXJhdGlvbik7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbmZpZyA9PT0gbnVsbCB8fCBjb25maWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZy5sb2NrQWRkaXRpb25hbEZpZWxkcykgJiZcbiAgICAgICAgICAgIChjb25maWcgPT09IG51bGwgfHwgY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWcubG9ja0FkZGl0aW9uYWxGaWVsZHMubGVuZ3RoKSA9PT0gMCkge1xuICAgICAgICAgICAgLy8gQ2FzZSAxOiBsb2NrQWRkaXRpb25hbEZpZWxkcyBpcyBhbiBlbXB0eSBhcnJheS4gTG9jayBvbmx5IGZpZWxkcyBmcm9tXG4gICAgICAgICAgICAvLyBiaWRpIHNldHVwLlxuICAgICAgICAgICAgaWYgKGdlbmVyYXRlZE1hc2tGcm9tQmlkaSkge1xuICAgICAgICAgICAgICAgIC8vIE9ubHkgYXNzaWduIGlmIG1hc2sgaXMgbm90IGVtcHR5XG4gICAgICAgICAgICAgICAgcmVxdWVzdERpY3RbJ2ZpZWxkTWFzayddID0gZ2VuZXJhdGVkTWFza0Zyb21CaWRpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHJlcXVlc3REaWN0WydmaWVsZE1hc2snXTsgLy8gSWYgbWFzayBpcyBlbXB0eSwgZWZmZWN0aXZlbHkgbm9cbiAgICAgICAgICAgICAgICAvLyBzcGVjaWZpYyBmaWVsZHMgbG9ja2VkIGJ5IGJpZGlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoY29uZmlnID09PSBudWxsIHx8IGNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnLmxvY2tBZGRpdGlvbmFsRmllbGRzKSAmJlxuICAgICAgICAgICAgY29uZmlnLmxvY2tBZGRpdGlvbmFsRmllbGRzLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgIHByZUV4aXN0aW5nRmllbGRNYXNrICE9PSBudWxsICYmXG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KHByZUV4aXN0aW5nRmllbGRNYXNrKSAmJlxuICAgICAgICAgICAgcHJlRXhpc3RpbmdGaWVsZE1hc2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8gQ2FzZSAyOiBMb2NrIGZpZWxkcyBmcm9tIGJpZGkgc2V0dXAgKyBhZGRpdGlvbmFsIGZpZWxkc1xuICAgICAgICAgICAgLy8gKHByZUV4aXN0aW5nRmllbGRNYXNrKS5cbiAgICAgICAgICAgIGNvbnN0IGdlbmVyYXRpb25Db25maWdGaWVsZHMgPSBbXG4gICAgICAgICAgICAgICAgJ3RlbXBlcmF0dXJlJyxcbiAgICAgICAgICAgICAgICAndG9wSycsXG4gICAgICAgICAgICAgICAgJ3RvcFAnLFxuICAgICAgICAgICAgICAgICdtYXhPdXRwdXRUb2tlbnMnLFxuICAgICAgICAgICAgICAgICdyZXNwb25zZU1vZGFsaXRpZXMnLFxuICAgICAgICAgICAgICAgICdzZWVkJyxcbiAgICAgICAgICAgICAgICAnc3BlZWNoQ29uZmlnJyxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBsZXQgbWFwcGVkRmllbGRzRnJvbVByZUV4aXN0aW5nID0gW107XG4gICAgICAgICAgICBpZiAocHJlRXhpc3RpbmdGaWVsZE1hc2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIG1hcHBlZEZpZWxkc0Zyb21QcmVFeGlzdGluZyA9IHByZUV4aXN0aW5nRmllbGRNYXNrLm1hcCgoZmllbGQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdlbmVyYXRpb25Db25maWdGaWVsZHMuaW5jbHVkZXMoZmllbGQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYGdlbmVyYXRpb25Db25maWcuJHtmaWVsZH1gO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmaWVsZDsgLy8gS2VlcCBvcmlnaW5hbCBmaWVsZCBuYW1lIGlmIG5vdCBpblxuICAgICAgICAgICAgICAgICAgICAvLyBnZW5lcmF0aW9uQ29uZmlnRmllbGRzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBmaW5hbE1hc2tQYXJ0cyA9IFtdO1xuICAgICAgICAgICAgaWYgKGdlbmVyYXRlZE1hc2tGcm9tQmlkaSkge1xuICAgICAgICAgICAgICAgIGZpbmFsTWFza1BhcnRzLnB1c2goZ2VuZXJhdGVkTWFza0Zyb21CaWRpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXBwZWRGaWVsZHNGcm9tUHJlRXhpc3RpbmcubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGZpbmFsTWFza1BhcnRzLnB1c2goLi4ubWFwcGVkRmllbGRzRnJvbVByZUV4aXN0aW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaW5hbE1hc2tQYXJ0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdERpY3RbJ2ZpZWxkTWFzayddID0gZmluYWxNYXNrUGFydHMuam9pbignLCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgbm8gZmllbGRzIGZyb20gYmlkaSBhbmQgbm8gdmFsaWQgYWRkaXRpb25hbCBmaWVsZHMgZnJvbVxuICAgICAgICAgICAgICAgIC8vIHByZS1leGlzdGluZyBtYXNrLlxuICAgICAgICAgICAgICAgIGRlbGV0ZSByZXF1ZXN0RGljdFsnZmllbGRNYXNrJ107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBDYXNlIDM6IFwiTG9jayBhbGwgZmllbGRzXCIgKG1lYW5pbmcsIGRvbid0IHNlbmQgYSBmaWVsZF9tYXNrLCBsZXQgc2VydmVyXG4gICAgICAgICAgICAvLyBkZWZhdWx0cyBhcHBseSBvciBhbGwgYXJlIG11dGFibGUpLiBUaGlzIGlzIGhpdCBpZjpcbiAgICAgICAgICAgIC8vICAtIGBjb25maWcubG9ja0FkZGl0aW9uYWxGaWVsZHNgIGlzIHVuZGVmaW5lZC5cbiAgICAgICAgICAgIC8vICAtIGBjb25maWcubG9ja0FkZGl0aW9uYWxGaWVsZHNgIGlzIG5vbi1lbXB0eSwgQlVUXG4gICAgICAgICAgICAvLyAgYHByZUV4aXN0aW5nRmllbGRNYXNrYCBpcyBudWxsLCBub3QgYSBzdHJpbmcsIG9yIGFuIGVtcHR5IHN0cmluZy5cbiAgICAgICAgICAgIGRlbGV0ZSByZXF1ZXN0RGljdFsnZmllbGRNYXNrJ107XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIE5vIHZhbGlkIGBiaWRpR2VuZXJhdGVDb250ZW50U2V0dXBgIHdhcyBmb3VuZCBvciBleHRyYWN0ZWQuXG4gICAgICAgIC8vIFwiTG9jayBhZGRpdGlvbmFsIG51bGwgZmllbGRzIGlmIGFueVwiLlxuICAgICAgICBpZiAocHJlRXhpc3RpbmdGaWVsZE1hc2sgIT09IG51bGwgJiZcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkocHJlRXhpc3RpbmdGaWVsZE1hc2spICYmXG4gICAgICAgICAgICBwcmVFeGlzdGluZ0ZpZWxkTWFzay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSdzIGEgcHJlLWV4aXN0aW5nIGZpZWxkIG1hc2ssIGl0J3MgYSBzdHJpbmcsIGFuZCBpdCdzIG5vdFxuICAgICAgICAgICAgLy8gZW1wdHksIHRoZW4gd2Ugc2hvdWxkIGxvY2sgYWxsIGZpZWxkcy5cbiAgICAgICAgICAgIHJlcXVlc3REaWN0WydmaWVsZE1hc2snXSA9IHByZUV4aXN0aW5nRmllbGRNYXNrLmpvaW4oJywnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZSByZXF1ZXN0RGljdFsnZmllbGRNYXNrJ107XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcXVlc3REaWN0O1xufVxuY2xhc3MgVG9rZW5zIGV4dGVuZHMgQmFzZU1vZHVsZSB7XG4gICAgY29uc3RydWN0b3IoYXBpQ2xpZW50KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYXBpQ2xpZW50ID0gYXBpQ2xpZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGVwaGVtZXJhbCBhdXRoIHRva2VuIHJlc291cmNlLlxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBFcGhlcm1lcmFsIGF1dGggdG9rZW5zIGlzIG9ubHkgc3VwcG9ydGVkIGluIHRoZSBHZW1pbmkgRGV2ZWxvcGVyIEFQSS5cbiAgICAgKiBJdCBjYW4gYmUgdXNlZCBmb3IgdGhlIHNlc3Npb24gY29ubmVjdGlvbiB0byB0aGUgTGl2ZSBjb25zdHJhaW5lZCBBUEkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoZSBjcmVhdGUgcmVxdWVzdC5cbiAgICAgKiBAcmV0dXJuIFRoZSBjcmVhdGVkIGF1dGggdG9rZW4uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogLy8gQ2FzZSAxOiBJZiBMaXZlRXBoZW1lcmFsUGFyYW1ldGVycyBpcyB1bnNldCwgdW5sb2NrIExpdmVDb25uZWN0Q29uZmlnXG4gICAgICogLy8gd2hlbiB1c2luZyB0aGUgdG9rZW4gaW4gTGl2ZSBBUEkgc2Vzc2lvbnMuIEVhY2ggc2Vzc2lvbiBjb25uZWN0aW9uIGNhblxuICAgICAqIC8vIHVzZSBhIGRpZmZlcmVudCBjb25maWd1cmF0aW9uLlxuICAgICAqIGNvbnN0IGNvbmZpZzogQ3JlYXRlQXV0aFRva2VuQ29uZmlnID0ge1xuICAgICAqICAgICB1c2VzOiAzLFxuICAgICAqICAgICBleHBpcmVUaW1lOiAnMjAyNS0wNS0wMVQwMDowMDowMFonLFxuICAgICAqIH1cbiAgICAgKiBjb25zdCB0b2tlbiA9IGF3YWl0IGFpLnRva2Vucy5jcmVhdGUoY29uZmlnKTtcbiAgICAgKlxuICAgICAqIC8vIENhc2UgMjogSWYgTGl2ZUVwaGVtZXJhbFBhcmFtZXRlcnMgaXMgc2V0LCBsb2NrIGFsbCBmaWVsZHMgaW5cbiAgICAgKiAvLyBMaXZlQ29ubmVjdENvbmZpZyB3aGVuIHVzaW5nIHRoZSB0b2tlbiBpbiBMaXZlIEFQSSBzZXNzaW9ucy4gRm9yXG4gICAgICogLy8gZXhhbXBsZSwgY2hhbmdpbmcgYG91dHB1dEF1ZGlvVHJhbnNjcmlwdGlvbmAgaW4gdGhlIExpdmUgQVBJXG4gICAgICogLy8gY29ubmVjdGlvbiB3aWxsIGJlIGlnbm9yZWQgYnkgdGhlIEFQSS5cbiAgICAgKiBjb25zdCBjb25maWc6IENyZWF0ZUF1dGhUb2tlbkNvbmZpZyA9XG4gICAgICogICAgIHVzZXM6IDMsXG4gICAgICogICAgIGV4cGlyZVRpbWU6ICcyMDI1LTA1LTAxVDAwOjAwOjAwWicsXG4gICAgICogICAgIExpdmVFcGhlbWVyYWxQYXJhbWV0ZXJzOiB7XG4gICAgICogICAgICAgIG1vZGVsOiAnZ2VtaW5pLTIuMC1mbGFzaC0wMDEnLFxuICAgICAqICAgICAgICBjb25maWc6IHtcbiAgICAgKiAgICAgICAgICAgJ3Jlc3BvbnNlTW9kYWxpdGllcyc6IFsnQVVESU8nXSxcbiAgICAgKiAgICAgICAgICAgJ3N5c3RlbUluc3RydWN0aW9uJzogJ0Fsd2F5cyBhbnN3ZXIgaW4gRW5nbGlzaC4nLFxuICAgICAqICAgICAgICB9XG4gICAgICogICAgIH1cbiAgICAgKiB9XG4gICAgICogY29uc3QgdG9rZW4gPSBhd2FpdCBhaS50b2tlbnMuY3JlYXRlKGNvbmZpZyk7XG4gICAgICpcbiAgICAgKiAvLyBDYXNlIDM6IElmIExpdmVFcGhlbWVyYWxQYXJhbWV0ZXJzIGlzIHNldCBhbmQgbG9ja0FkZGl0aW9uYWxGaWVsZHMgaXNcbiAgICAgKiAvLyBzZXQsIGxvY2sgTGl2ZUNvbm5lY3RDb25maWcgd2l0aCBzZXQgYW5kIGFkZGl0aW9uYWwgZmllbGRzIChlLmcuXG4gICAgICogLy8gcmVzcG9uc2VNb2RhbGl0aWVzLCBzeXN0ZW1JbnN0cnVjdGlvbiwgdGVtcGVyYXR1cmUgaW4gdGhpcyBleGFtcGxlKSB3aGVuXG4gICAgICogLy8gdXNpbmcgdGhlIHRva2VuIGluIExpdmUgQVBJIHNlc3Npb25zLlxuICAgICAqIGNvbnN0IGNvbmZpZzogQ3JlYXRlQXV0aFRva2VuQ29uZmlnID1cbiAgICAgKiAgICAgdXNlczogMyxcbiAgICAgKiAgICAgZXhwaXJlVGltZTogJzIwMjUtMDUtMDFUMDA6MDA6MDBaJyxcbiAgICAgKiAgICAgTGl2ZUVwaGVtZXJhbFBhcmFtZXRlcnM6IHtcbiAgICAgKiAgICAgICAgbW9kZWw6ICdnZW1pbmktMi4wLWZsYXNoLTAwMScsXG4gICAgICogICAgICAgIGNvbmZpZzoge1xuICAgICAqICAgICAgICAgICAncmVzcG9uc2VNb2RhbGl0aWVzJzogWydBVURJTyddLFxuICAgICAqICAgICAgICAgICAnc3lzdGVtSW5zdHJ1Y3Rpb24nOiAnQWx3YXlzIGFuc3dlciBpbiBFbmdsaXNoLicsXG4gICAgICogICAgICAgIH1cbiAgICAgKiAgICAgfSxcbiAgICAgKiAgICAgbG9ja0FkZGl0aW9uYWxGaWVsZHM6IFsndGVtcGVyYXR1cmUnXSxcbiAgICAgKiB9XG4gICAgICogY29uc3QgdG9rZW4gPSBhd2FpdCBhaS50b2tlbnMuY3JlYXRlKGNvbmZpZyk7XG4gICAgICpcbiAgICAgKiAvLyBDYXNlIDQ6IElmIExpdmVFcGhlbWVyYWxQYXJhbWV0ZXJzIGlzIHNldCBhbmQgbG9ja0FkZGl0aW9uYWxGaWVsZHMgaXNcbiAgICAgKiAvLyBlbXB0eSBhcnJheSwgbG9jayBMaXZlQ29ubmVjdENvbmZpZyB3aXRoIHNldCBmaWVsZHMgKGUuZy5cbiAgICAgKiAvLyByZXNwb25zZU1vZGFsaXRpZXMsIHN5c3RlbUluc3RydWN0aW9uIGluIHRoaXMgZXhhbXBsZSkgd2hlbiB1c2luZyB0aGVcbiAgICAgKiAvLyB0b2tlbiBpbiBMaXZlIEFQSSBzZXNzaW9ucy5cbiAgICAgKiBjb25zdCBjb25maWc6IENyZWF0ZUF1dGhUb2tlbkNvbmZpZyA9XG4gICAgICogICAgIHVzZXM6IDMsXG4gICAgICogICAgIGV4cGlyZVRpbWU6ICcyMDI1LTA1LTAxVDAwOjAwOjAwWicsXG4gICAgICogICAgIExpdmVFcGhlbWVyYWxQYXJhbWV0ZXJzOiB7XG4gICAgICogICAgICAgIG1vZGVsOiAnZ2VtaW5pLTIuMC1mbGFzaC0wMDEnLFxuICAgICAqICAgICAgICBjb25maWc6IHtcbiAgICAgKiAgICAgICAgICAgJ3Jlc3BvbnNlTW9kYWxpdGllcyc6IFsnQVVESU8nXSxcbiAgICAgKiAgICAgICAgICAgJ3N5c3RlbUluc3RydWN0aW9uJzogJ0Fsd2F5cyBhbnN3ZXIgaW4gRW5nbGlzaC4nLFxuICAgICAqICAgICAgICB9XG4gICAgICogICAgIH0sXG4gICAgICogICAgIGxvY2tBZGRpdGlvbmFsRmllbGRzOiBbXSxcbiAgICAgKiB9XG4gICAgICogY29uc3QgdG9rZW4gPSBhd2FpdCBhaS50b2tlbnMuY3JlYXRlKGNvbmZpZyk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBjbGllbnQudG9rZW5zLmNyZWF0ZSBtZXRob2QgaXMgb25seSBzdXBwb3J0ZWQgYnkgdGhlIEdlbWluaSBEZXZlbG9wZXIgQVBJLicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGNyZWF0ZUF1dGhUb2tlblBhcmFtZXRlcnNUb01sZGV2KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgnYXV0aF90b2tlbnMnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5Wydjb25maWcnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZEJvZHkgPSBjb252ZXJ0QmlkaVNldHVwVG9Ub2tlblNldHVwKGJvZHksIHBhcmFtcy5jb25maWcpO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh0cmFuc2Zvcm1lZEJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGF1dGhUb2tlbkZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuY29uc3QgR09PR0xFX0FQSV9LRVlfSEVBREVSID0gJ3gtZ29vZy1hcGkta2V5JztcbmNvbnN0IFJFUVVJUkVEX1ZFUlRFWF9BSV9TQ09QRSA9ICdodHRwczovL3d3dy5nb29nbGVhcGlzLmNvbS9hdXRoL2Nsb3VkLXBsYXRmb3JtJztcbmNsYXNzIE5vZGVBdXRoIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIGlmIChvcHRzLmFwaUtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmFwaUtleSA9IG9wdHMuYXBpS2V5O1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZlcnRleEF1dGhPcHRpb25zID0gYnVpbGRHb29nbGVBdXRoT3B0aW9ucyhvcHRzLmdvb2dsZUF1dGhPcHRpb25zKTtcbiAgICAgICAgdGhpcy5nb29nbGVBdXRoID0gbmV3IEdvb2dsZUF1dGgodmVydGV4QXV0aE9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBhZGRBdXRoSGVhZGVycyhoZWFkZXJzKSB7XG4gICAgICAgIGlmICh0aGlzLmFwaUtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hcGlLZXkuc3RhcnRzV2l0aCgnYXV0aF90b2tlbnMvJykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VwaGVtZXJhbCB0b2tlbnMgYXJlIG9ubHkgc3VwcG9ydGVkIGJ5IHRoZSBsaXZlIEFQSS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYWRkS2V5SGVhZGVyKGhlYWRlcnMpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmFkZEdvb2dsZUF1dGhIZWFkZXJzKGhlYWRlcnMpO1xuICAgIH1cbiAgICBhZGRLZXlIZWFkZXIoaGVhZGVycykge1xuICAgICAgICBpZiAoaGVhZGVycy5nZXQoR09PR0xFX0FQSV9LRVlfSEVBREVSKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmFwaUtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBUaGlzIHNob3VsZCBuZXZlciBoYXBwZW4sIHRoaXMgbWV0aG9kIGlzIG9ubHkgY2FsbGVkXG4gICAgICAgICAgICAvLyB3aGVuIGFwaUtleSBpcyBzZXQuXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyeWluZyB0byBzZXQgQVBJIGtleSBoZWFkZXIgYnV0IGFwaUtleSBpcyBub3Qgc2V0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaGVhZGVycy5hcHBlbmQoR09PR0xFX0FQSV9LRVlfSEVBREVSLCB0aGlzLmFwaUtleSk7XG4gICAgfVxuICAgIGFzeW5jIGFkZEdvb2dsZUF1dGhIZWFkZXJzKGhlYWRlcnMpIHtcbiAgICAgICAgaWYgKHRoaXMuZ29vZ2xlQXV0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBUaGlzIHNob3VsZCBuZXZlciBoYXBwZW4sIGFkZEdvb2dsZUF1dGhIZWFkZXJzIHNob3VsZCBvbmx5IGJlXG4gICAgICAgICAgICAvLyBjYWxsZWQgd2hlbiB0aGVyZSBpcyBubyBhcGlLZXkgc2V0IGFuZCBpbiB0aGVzZSBjYXNlcyBnb29nbGVBdXRoXG4gICAgICAgICAgICAvLyBpcyBzZXQuXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyeWluZyB0byBzZXQgZ29vZ2xlLWF1dGggaGVhZGVycyBidXQgZ29vZ2xlQXV0aCBpcyB1bnNldCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGF1dGhIZWFkZXJzID0gYXdhaXQgdGhpcy5nb29nbGVBdXRoLmdldFJlcXVlc3RIZWFkZXJzKCk7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGF1dGhIZWFkZXJzKSB7XG4gICAgICAgICAgICBpZiAoaGVhZGVycy5nZXQoa2V5KSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGVhZGVycy5hcHBlbmQoa2V5LCBhdXRoSGVhZGVyc1trZXldKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGJ1aWxkR29vZ2xlQXV0aE9wdGlvbnMoZ29vZ2xlQXV0aE9wdGlvbnMpIHtcbiAgICBsZXQgYXV0aE9wdGlvbnM7XG4gICAgaWYgKCFnb29nbGVBdXRoT3B0aW9ucykge1xuICAgICAgICBhdXRoT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHNjb3BlczogW1JFUVVJUkVEX1ZFUlRFWF9BSV9TQ09QRV0sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhdXRoT3B0aW9ucztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGF1dGhPcHRpb25zID0gZ29vZ2xlQXV0aE9wdGlvbnM7XG4gICAgICAgIGlmICghYXV0aE9wdGlvbnMuc2NvcGVzKSB7XG4gICAgICAgICAgICBhdXRoT3B0aW9ucy5zY29wZXMgPSBbUkVRVUlSRURfVkVSVEVYX0FJX1NDT1BFXTtcbiAgICAgICAgICAgIHJldHVybiBhdXRoT3B0aW9ucztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgodHlwZW9mIGF1dGhPcHRpb25zLnNjb3BlcyA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgIGF1dGhPcHRpb25zLnNjb3BlcyAhPT0gUkVRVUlSRURfVkVSVEVYX0FJX1NDT1BFKSB8fFxuICAgICAgICAgICAgKEFycmF5LmlzQXJyYXkoYXV0aE9wdGlvbnMuc2NvcGVzKSAmJlxuICAgICAgICAgICAgICAgIGF1dGhPcHRpb25zLnNjb3Blcy5pbmRleE9mKFJFUVVJUkVEX1ZFUlRFWF9BSV9TQ09QRSkgPCAwKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGF1dGggc2NvcGVzLiBTY29wZXMgbXVzdCBpbmNsdWRlOiAke1JFUVVJUkVEX1ZFUlRFWF9BSV9TQ09QRX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXV0aE9wdGlvbnM7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5jbGFzcyBOb2RlRG93bmxvYWRlciB7XG4gICAgYXN5bmMgZG93bmxvYWQocGFyYW1zLCBhcGlDbGllbnQpIHtcbiAgICAgICAgaWYgKHBhcmFtcy5kb3dubG9hZFBhdGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZG93bmxvYWRGaWxlKHBhcmFtcywgYXBpQ2xpZW50KTtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZSBpbnN0YW5jZW9mIEh0dHBSZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHdyaXRlciA9IGNyZWF0ZVdyaXRlU3RyZWFtKHBhcmFtcy5kb3dubG9hZFBhdGgpO1xuICAgICAgICAgICAgICAgIFJlYWRhYmxlLmZyb21XZWIocmVzcG9uc2UucmVzcG9uc2VJbnRlcm5hbC5ib2R5KS5waXBlKHdyaXRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB3cml0ZUZpbGUocGFyYW1zLmRvd25sb2FkUGF0aCwgcmVzcG9uc2UsIHsgZW5jb2Rpbmc6ICdiYXNlNjQnIH0sIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHdyaXRlIGZpbGUgdG8gJHtwYXJhbXMuZG93bmxvYWRQYXRofTogJHtlcnJvcn1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gZG93bmxvYWRGaWxlKHBhcmFtcywgYXBpQ2xpZW50KSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgY29uc3QgbmFtZSA9IHRGaWxlTmFtZShwYXJhbXMuZmlsZSk7XG4gICAgaWYgKG5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gYXdhaXQgYXBpQ2xpZW50LnJlcXVlc3Qoe1xuICAgICAgICAgICAgcGF0aDogYGZpbGVzLyR7bmFtZX06ZG93bmxvYWRgLFxuICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICBxdWVyeVBhcmFtczoge1xuICAgICAgICAgICAgICAgICdhbHQnOiAnbWVkaWEnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNHZW5lcmF0ZWRWaWRlbyhwYXJhbXMuZmlsZSkpIHtcbiAgICAgICAgY29uc3QgdmlkZW9CeXRlcyA9IChfYyA9IHBhcmFtcy5maWxlLnZpZGVvKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudmlkZW9CeXRlcztcbiAgICAgICAgaWYgKHR5cGVvZiB2aWRlb0J5dGVzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHZpZGVvQnl0ZXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBkb3dubG9hZCBnZW5lcmF0ZWQgdmlkZW8sIFVyaSBvciB2aWRlb0J5dGVzIG5vdCBmb3VuZC4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpc1ZpZGVvKHBhcmFtcy5maWxlKSkge1xuICAgICAgICBjb25zdCB2aWRlb0J5dGVzID0gcGFyYW1zLmZpbGUudmlkZW9CeXRlcztcbiAgICAgICAgaWYgKHR5cGVvZiB2aWRlb0J5dGVzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHZpZGVvQnl0ZXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBkb3dubG9hZCB2aWRlbywgVXJpIG9yIHZpZGVvQnl0ZXMgbm90IGZvdW5kLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGZpbGUgdHlwZScpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuY2xhc3MgTm9kZVdlYlNvY2tldEZhY3Rvcnkge1xuICAgIGNyZWF0ZSh1cmwsIGhlYWRlcnMsIGNhbGxiYWNrcykge1xuICAgICAgICByZXR1cm4gbmV3IE5vZGVXZWJTb2NrZXQodXJsLCBoZWFkZXJzLCBjYWxsYmFja3MpO1xuICAgIH1cbn1cbmNsYXNzIE5vZGVXZWJTb2NrZXQge1xuICAgIGNvbnN0cnVjdG9yKHVybCwgaGVhZGVycywgY2FsbGJhY2tzKSB7XG4gICAgICAgIHRoaXMudXJsID0gdXJsO1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSBoZWFkZXJzO1xuICAgICAgICB0aGlzLmNhbGxiYWNrcyA9IGNhbGxiYWNrcztcbiAgICB9XG4gICAgY29ubmVjdCgpIHtcbiAgICAgICAgdGhpcy53cyA9IG5ldyBOb2RlV3MuV2ViU29ja2V0KHRoaXMudXJsLCB7IGhlYWRlcnM6IHRoaXMuaGVhZGVycyB9KTtcbiAgICAgICAgdGhpcy53cy5vbm9wZW4gPSB0aGlzLmNhbGxiYWNrcy5vbm9wZW47XG4gICAgICAgIHRoaXMud3Mub25lcnJvciA9IHRoaXMuY2FsbGJhY2tzLm9uZXJyb3I7XG4gICAgICAgIHRoaXMud3Mub25jbG9zZSA9IHRoaXMuY2FsbGJhY2tzLm9uY2xvc2U7XG4gICAgICAgIHRoaXMud3Mub25tZXNzYWdlID0gdGhpcy5jYWxsYmFja3Mub25tZXNzYWdlO1xuICAgIH1cbiAgICBzZW5kKG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKHRoaXMud3MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZWJTb2NrZXQgaXMgbm90IGNvbm5lY3RlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud3Muc2VuZChtZXNzYWdlKTtcbiAgICB9XG4gICAgY2xvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLndzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV2ViU29ja2V0IGlzIG5vdCBjb25uZWN0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndzLmNsb3NlKCk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG4vLyBDb2RlIGdlbmVyYXRlZCBieSB0aGUgR29vZ2xlIEdlbiBBSSBTREsgZ2VuZXJhdG9yIERPIE5PVCBFRElULlxuZnVuY3Rpb24gZ2V0VHVuaW5nSm9iUGFyYW1ldGVyc1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29uZmlnJ10sIGZyb21Db25maWcpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0VHVuaW5nSm9ic0NvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUGFnZVNpemUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhZ2VTaXplJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGFnZVNpemUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3F1ZXJ5JywgJ3BhZ2VTaXplJ10sIGZyb21QYWdlU2l6ZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QYWdlVG9rZW4gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhZ2VUb2tlbiddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBhZ2VUb2tlbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAncGFnZVRva2VuJ10sIGZyb21QYWdlVG9rZW4pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsdGVyID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWx0ZXInXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21GaWx0ZXIgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3F1ZXJ5JywgJ2ZpbHRlciddLCBmcm9tRmlsdGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdFR1bmluZ0pvYnNQYXJhbWV0ZXJzVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb25maWcnXSwgbGlzdFR1bmluZ0pvYnNDb25maWdUb01sZGV2KGZyb21Db25maWcsIHRvT2JqZWN0KSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHR1bmluZ0V4YW1wbGVUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21UZXh0SW5wdXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RleHRJbnB1dCddKTtcbiAgICBpZiAoZnJvbVRleHRJbnB1dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RleHRJbnB1dCddLCBmcm9tVGV4dElucHV0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU91dHB1dCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnb3V0cHV0J10pO1xuICAgIGlmIChmcm9tT3V0cHV0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnb3V0cHV0J10sIGZyb21PdXRwdXQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB0dW5pbmdEYXRhc2V0VG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnY3NVcmknXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2djc1VyaSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXhhbXBsZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2V4YW1wbGVzJ10pO1xuICAgIGlmIChmcm9tRXhhbXBsZXMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUV4YW1wbGVzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR1bmluZ0V4YW1wbGVUb01sZGV2KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXhhbXBsZXMnLCAnZXhhbXBsZXMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY3JlYXRlVHVuaW5nSm9iQ29uZmlnVG9NbGRldihmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZhbGlkYXRpb25EYXRhc2V0J10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd2YWxpZGF0aW9uRGF0YXNldCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVHVuZWRNb2RlbERpc3BsYXlOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndHVuZWRNb2RlbERpc3BsYXlOYW1lJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVR1bmVkTW9kZWxEaXNwbGF5TmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydkaXNwbGF5TmFtZSddLCBmcm9tVHVuZWRNb2RlbERpc3BsYXlOYW1lKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGVzY3JpcHRpb24nXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Rlc2NyaXB0aW9uIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FcG9jaENvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlcG9jaENvdW50J10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRXBvY2hDb3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWyd0dW5pbmdUYXNrJywgJ2h5cGVycGFyYW1ldGVycycsICdlcG9jaENvdW50J10sIGZyb21FcG9jaENvdW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxlYXJuaW5nUmF0ZU11bHRpcGxpZXIgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdsZWFybmluZ1JhdGVNdWx0aXBsaWVyJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUxlYXJuaW5nUmF0ZU11bHRpcGxpZXIgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0dW5pbmdUYXNrJywgJ2h5cGVycGFyYW1ldGVycycsICdsZWFybmluZ1JhdGVNdWx0aXBsaWVyJ10sIGZyb21MZWFybmluZ1JhdGVNdWx0aXBsaWVyKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXhwb3J0TGFzdENoZWNrcG9pbnRPbmx5J10pICE9PVxuICAgICAgICB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBvcnRMYXN0Q2hlY2twb2ludE9ubHkgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYWRhcHRlclNpemUnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FkYXB0ZXJTaXplIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21CYXRjaFNpemUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2JhdGNoU2l6ZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUJhdGNoU2l6ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWyd0dW5pbmdUYXNrJywgJ2h5cGVycGFyYW1ldGVycycsICdiYXRjaFNpemUnXSwgZnJvbUJhdGNoU2l6ZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21MZWFybmluZ1JhdGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xlYXJuaW5nUmF0ZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUxlYXJuaW5nUmF0ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWyd0dW5pbmdUYXNrJywgJ2h5cGVycGFyYW1ldGVycycsICdsZWFybmluZ1JhdGUnXSwgZnJvbUxlYXJuaW5nUmF0ZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVR1bmluZ0pvYlBhcmFtZXRlcnNUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21CYXNlTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Jhc2VNb2RlbCddKTtcbiAgICBpZiAoZnJvbUJhc2VNb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Jhc2VNb2RlbCddLCBmcm9tQmFzZU1vZGVsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRyYWluaW5nRGF0YXNldCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3RyYWluaW5nRGF0YXNldCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UcmFpbmluZ0RhdGFzZXQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0dW5pbmdUYXNrJywgJ3RyYWluaW5nRGF0YSddLCB0dW5pbmdEYXRhc2V0VG9NbGRldihmcm9tVHJhaW5pbmdEYXRhc2V0KSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbmZpZyddLCBjcmVhdGVUdW5pbmdKb2JDb25maWdUb01sZGV2KGZyb21Db25maWcsIHRvT2JqZWN0KSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdldFR1bmluZ0pvYlBhcmFtZXRlcnNUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb25maWcnXSwgZnJvbUNvbmZpZyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RUdW5pbmdKb2JzQ29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUGFnZVNpemUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhZ2VTaXplJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGFnZVNpemUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3F1ZXJ5JywgJ3BhZ2VTaXplJ10sIGZyb21QYWdlU2l6ZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QYWdlVG9rZW4gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhZ2VUb2tlbiddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBhZ2VUb2tlbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAncGFnZVRva2VuJ10sIGZyb21QYWdlVG9rZW4pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsdGVyID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWx0ZXInXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21GaWx0ZXIgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3F1ZXJ5JywgJ2ZpbHRlciddLCBmcm9tRmlsdGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdFR1bmluZ0pvYnNQYXJhbWV0ZXJzVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29uZmlnJ10sIGxpc3RUdW5pbmdKb2JzQ29uZmlnVG9WZXJ0ZXgoZnJvbUNvbmZpZywgdG9PYmplY3QpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdHVuaW5nRGF0YXNldFRvVmVydGV4KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUdjc1VyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ2NzVXJpJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tR2NzVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3N1cGVydmlzZWRUdW5pbmdTcGVjJywgJ3RyYWluaW5nRGF0YXNldFVyaSddLCBmcm9tR2NzVXJpKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXhhbXBsZXMnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4YW1wbGVzIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIFZlcnRleCBBSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdHVuaW5nVmFsaWRhdGlvbkRhdGFzZXRUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tR2NzVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnY3NVcmknXSk7XG4gICAgaWYgKGZyb21HY3NVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2YWxpZGF0aW9uRGF0YXNldFVyaSddLCBmcm9tR2NzVXJpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY3JlYXRlVHVuaW5nSm9iQ29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVmFsaWRhdGlvbkRhdGFzZXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd2YWxpZGF0aW9uRGF0YXNldCcsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21WYWxpZGF0aW9uRGF0YXNldCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzdXBlcnZpc2VkVHVuaW5nU3BlYyddLCB0dW5pbmdWYWxpZGF0aW9uRGF0YXNldFRvVmVydGV4KGZyb21WYWxpZGF0aW9uRGF0YXNldCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVHVuZWRNb2RlbERpc3BsYXlOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndHVuZWRNb2RlbERpc3BsYXlOYW1lJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVR1bmVkTW9kZWxEaXNwbGF5TmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWyd0dW5lZE1vZGVsRGlzcGxheU5hbWUnXSwgZnJvbVR1bmVkTW9kZWxEaXNwbGF5TmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EZXNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGVzY3JpcHRpb24nXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21EZXNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydkZXNjcmlwdGlvbiddLCBmcm9tRGVzY3JpcHRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXBvY2hDb3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXBvY2hDb3VudCddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUVwb2NoQ291bnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc3VwZXJ2aXNlZFR1bmluZ1NwZWMnLCAnaHlwZXJQYXJhbWV0ZXJzJywgJ2Vwb2NoQ291bnQnXSwgZnJvbUVwb2NoQ291bnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTGVhcm5pbmdSYXRlTXVsdGlwbGllciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2xlYXJuaW5nUmF0ZU11bHRpcGxpZXInLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTGVhcm5pbmdSYXRlTXVsdGlwbGllciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzdXBlcnZpc2VkVHVuaW5nU3BlYycsICdoeXBlclBhcmFtZXRlcnMnLCAnbGVhcm5pbmdSYXRlTXVsdGlwbGllciddLCBmcm9tTGVhcm5pbmdSYXRlTXVsdGlwbGllcik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FeHBvcnRMYXN0Q2hlY2twb2ludE9ubHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdleHBvcnRMYXN0Q2hlY2twb2ludE9ubHknLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRXhwb3J0TGFzdENoZWNrcG9pbnRPbmx5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3N1cGVydmlzZWRUdW5pbmdTcGVjJywgJ2V4cG9ydExhc3RDaGVja3BvaW50T25seSddLCBmcm9tRXhwb3J0TGFzdENoZWNrcG9pbnRPbmx5KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUFkYXB0ZXJTaXplID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhZGFwdGVyU2l6ZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUFkYXB0ZXJTaXplICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3N1cGVydmlzZWRUdW5pbmdTcGVjJywgJ2h5cGVyUGFyYW1ldGVycycsICdhZGFwdGVyU2l6ZSddLCBmcm9tQWRhcHRlclNpemUpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydiYXRjaFNpemUnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhdGNoU2l6ZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBWZXJ0ZXggQUkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xlYXJuaW5nUmF0ZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbGVhcm5pbmdSYXRlIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIFZlcnRleCBBSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY3JlYXRlVHVuaW5nSm9iUGFyYW1ldGVyc1RvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21CYXNlTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Jhc2VNb2RlbCddKTtcbiAgICBpZiAoZnJvbUJhc2VNb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Jhc2VNb2RlbCddLCBmcm9tQmFzZU1vZGVsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRyYWluaW5nRGF0YXNldCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3RyYWluaW5nRGF0YXNldCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UcmFpbmluZ0RhdGFzZXQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdXBlcnZpc2VkVHVuaW5nU3BlYycsICd0cmFpbmluZ0RhdGFzZXRVcmknXSwgdHVuaW5nRGF0YXNldFRvVmVydGV4KGZyb21UcmFpbmluZ0RhdGFzZXQsIHRvT2JqZWN0KSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbmZpZyddLCBjcmVhdGVUdW5pbmdKb2JDb25maWdUb1ZlcnRleChmcm9tQ29uZmlnLCB0b09iamVjdCkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB0dW5lZE1vZGVsRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZWwnXSwgZnJvbU1vZGVsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuZHBvaW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tRW5kcG9pbnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmRwb2ludCddLCBmcm9tRW5kcG9pbnQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB0dW5pbmdKb2JGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TdGF0ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3RhdGUnXSk7XG4gICAgaWYgKGZyb21TdGF0ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0YXRlJ10sIHRUdW5pbmdKb2JTdGF0dXMoZnJvbVN0YXRlKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DcmVhdGVUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjcmVhdGVUaW1lJ10pO1xuICAgIGlmIChmcm9tQ3JlYXRlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NyZWF0ZVRpbWUnXSwgZnJvbUNyZWF0ZVRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3RhcnRUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndHVuaW5nVGFzaycsXG4gICAgICAgICdzdGFydFRpbWUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU3RhcnRUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3RhcnRUaW1lJ10sIGZyb21TdGFydFRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5kVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3R1bmluZ1Rhc2snLFxuICAgICAgICAnY29tcGxldGVUaW1lJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUVuZFRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmRUaW1lJ10sIGZyb21FbmRUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVwZGF0ZVRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3VwZGF0ZVRpbWUnXSk7XG4gICAgaWYgKGZyb21VcGRhdGVUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXBkYXRlVGltZSddLCBmcm9tVXBkYXRlVGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EZXNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGVzY3JpcHRpb24nXSk7XG4gICAgaWYgKGZyb21EZXNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10sIGZyb21EZXNjcmlwdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21CYXNlTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Jhc2VNb2RlbCddKTtcbiAgICBpZiAoZnJvbUJhc2VNb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Jhc2VNb2RlbCddLCBmcm9tQmFzZU1vZGVsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVR1bmVkTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ19zZWxmJ10pO1xuICAgIGlmIChmcm9tVHVuZWRNb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3R1bmVkTW9kZWwnXSwgdHVuZWRNb2RlbEZyb21NbGRldihmcm9tVHVuZWRNb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGlzdGlsbGF0aW9uU3BlYyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2Rpc3RpbGxhdGlvblNwZWMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRGlzdGlsbGF0aW9uU3BlYyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Rpc3RpbGxhdGlvblNwZWMnXSwgZnJvbURpc3RpbGxhdGlvblNwZWMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXhwZXJpbWVudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXhwZXJpbWVudCddKTtcbiAgICBpZiAoZnJvbUV4cGVyaW1lbnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydleHBlcmltZW50J10sIGZyb21FeHBlcmltZW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxhYmVscyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGFiZWxzJ10pO1xuICAgIGlmIChmcm9tTGFiZWxzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbGFiZWxzJ10sIGZyb21MYWJlbHMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGlwZWxpbmVKb2IgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BpcGVsaW5lSm9iJ10pO1xuICAgIGlmIChmcm9tUGlwZWxpbmVKb2IgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwaXBlbGluZUpvYiddLCBmcm9tUGlwZWxpbmVKb2IpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2VydmljZUFjY291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZXJ2aWNlQWNjb3VudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZXJ2aWNlQWNjb3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NlcnZpY2VBY2NvdW50J10sIGZyb21TZXJ2aWNlQWNjb3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UdW5lZE1vZGVsRGlzcGxheU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0dW5lZE1vZGVsRGlzcGxheU5hbWUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVHVuZWRNb2RlbERpc3BsYXlOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndHVuZWRNb2RlbERpc3BsYXlOYW1lJ10sIGZyb21UdW5lZE1vZGVsRGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0VHVuaW5nSm9ic1Jlc3BvbnNlRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OZXh0UGFnZVRva2VuID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbmV4dFBhZ2VUb2tlbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21OZXh0UGFnZVRva2VuICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmV4dFBhZ2VUb2tlbiddLCBmcm9tTmV4dFBhZ2VUb2tlbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UdW5pbmdKb2JzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0dW5lZE1vZGVscyddKTtcbiAgICBpZiAoZnJvbVR1bmluZ0pvYnMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVR1bmluZ0pvYnM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHVuaW5nSm9iRnJvbU1sZGV2KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndHVuaW5nSm9icyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBvcGVyYXRpb25Gcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWV0YWRhdGEnXSk7XG4gICAgaWYgKGZyb21NZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21ldGFkYXRhJ10sIGZyb21NZXRhZGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Eb25lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkb25lJ10pO1xuICAgIGlmIChmcm9tRG9uZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2RvbmUnXSwgZnJvbURvbmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXJyb3IgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Vycm9yJ10pO1xuICAgIGlmIChmcm9tRXJyb3IgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlcnJvciddLCBmcm9tRXJyb3IpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB0dW5lZE1vZGVsQ2hlY2twb2ludEZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUNoZWNrcG9pbnRJZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY2hlY2twb2ludElkJ10pO1xuICAgIGlmIChmcm9tQ2hlY2twb2ludElkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2hlY2twb2ludElkJ10sIGZyb21DaGVja3BvaW50SWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXBvY2ggPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Vwb2NoJ10pO1xuICAgIGlmIChmcm9tRXBvY2ggIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlcG9jaCddLCBmcm9tRXBvY2gpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3RlcCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3RlcCddKTtcbiAgICBpZiAoZnJvbVN0ZXAgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdGVwJ10sIGZyb21TdGVwKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuZHBvaW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbmRwb2ludCddKTtcbiAgICBpZiAoZnJvbUVuZHBvaW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW5kcG9pbnQnXSwgZnJvbUVuZHBvaW50KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdHVuZWRNb2RlbEZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZWwnXSwgZnJvbU1vZGVsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuZHBvaW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbmRwb2ludCddKTtcbiAgICBpZiAoZnJvbUVuZHBvaW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW5kcG9pbnQnXSwgZnJvbUVuZHBvaW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNoZWNrcG9pbnRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjaGVja3BvaW50cyddKTtcbiAgICBpZiAoZnJvbUNoZWNrcG9pbnRzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21DaGVja3BvaW50cztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0dW5lZE1vZGVsQ2hlY2twb2ludEZyb21WZXJ0ZXgoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjaGVja3BvaW50cyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB0dW5pbmdKb2JGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3RhdGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3N0YXRlJ10pO1xuICAgIGlmIChmcm9tU3RhdGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdGF0ZSddLCB0VHVuaW5nSm9iU3RhdHVzKGZyb21TdGF0ZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ3JlYXRlVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY3JlYXRlVGltZSddKTtcbiAgICBpZiAoZnJvbUNyZWF0ZVRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjcmVhdGVUaW1lJ10sIGZyb21DcmVhdGVUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN0YXJ0VGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3RhcnRUaW1lJ10pO1xuICAgIGlmIChmcm9tU3RhcnRUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3RhcnRUaW1lJ10sIGZyb21TdGFydFRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5kVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW5kVGltZSddKTtcbiAgICBpZiAoZnJvbUVuZFRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmRUaW1lJ10sIGZyb21FbmRUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVwZGF0ZVRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3VwZGF0ZVRpbWUnXSk7XG4gICAgaWYgKGZyb21VcGRhdGVUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXBkYXRlVGltZSddLCBmcm9tVXBkYXRlVGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FcnJvciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXJyb3InXSk7XG4gICAgaWYgKGZyb21FcnJvciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Vycm9yJ10sIGZyb21FcnJvcik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EZXNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGVzY3JpcHRpb24nXSk7XG4gICAgaWYgKGZyb21EZXNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10sIGZyb21EZXNjcmlwdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21CYXNlTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Jhc2VNb2RlbCddKTtcbiAgICBpZiAoZnJvbUJhc2VNb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Jhc2VNb2RlbCddLCBmcm9tQmFzZU1vZGVsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVR1bmVkTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3R1bmVkTW9kZWwnXSk7XG4gICAgaWYgKGZyb21UdW5lZE1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndHVuZWRNb2RlbCddLCB0dW5lZE1vZGVsRnJvbVZlcnRleChmcm9tVHVuZWRNb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3VwZXJ2aXNlZFR1bmluZ1NwZWMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzdXBlcnZpc2VkVHVuaW5nU3BlYycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TdXBlcnZpc2VkVHVuaW5nU3BlYyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N1cGVydmlzZWRUdW5pbmdTcGVjJ10sIGZyb21TdXBlcnZpc2VkVHVuaW5nU3BlYyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UdW5pbmdEYXRhU3RhdHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0dW5pbmdEYXRhU3RhdHMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVHVuaW5nRGF0YVN0YXRzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndHVuaW5nRGF0YVN0YXRzJ10sIGZyb21UdW5pbmdEYXRhU3RhdHMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5jcnlwdGlvblNwZWMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdlbmNyeXB0aW9uU3BlYycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FbmNyeXB0aW9uU3BlYyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VuY3J5cHRpb25TcGVjJ10sIGZyb21FbmNyeXB0aW9uU3BlYyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QYXJ0bmVyTW9kZWxUdW5pbmdTcGVjID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncGFydG5lck1vZGVsVHVuaW5nU3BlYycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21QYXJ0bmVyTW9kZWxUdW5pbmdTcGVjICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncGFydG5lck1vZGVsVHVuaW5nU3BlYyddLCBmcm9tUGFydG5lck1vZGVsVHVuaW5nU3BlYyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EaXN0aWxsYXRpb25TcGVjID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZGlzdGlsbGF0aW9uU3BlYycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21EaXN0aWxsYXRpb25TcGVjICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGlzdGlsbGF0aW9uU3BlYyddLCBmcm9tRGlzdGlsbGF0aW9uU3BlYyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FeHBlcmltZW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydleHBlcmltZW50J10pO1xuICAgIGlmIChmcm9tRXhwZXJpbWVudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2V4cGVyaW1lbnQnXSwgZnJvbUV4cGVyaW1lbnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTGFiZWxzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsYWJlbHMnXSk7XG4gICAgaWYgKGZyb21MYWJlbHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsYWJlbHMnXSwgZnJvbUxhYmVscyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QaXBlbGluZUpvYiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGlwZWxpbmVKb2InXSk7XG4gICAgaWYgKGZyb21QaXBlbGluZUpvYiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BpcGVsaW5lSm9iJ10sIGZyb21QaXBlbGluZUpvYik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TZXJ2aWNlQWNjb3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NlcnZpY2VBY2NvdW50JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNlcnZpY2VBY2NvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2VydmljZUFjY291bnQnXSwgZnJvbVNlcnZpY2VBY2NvdW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVR1bmVkTW9kZWxEaXNwbGF5TmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3R1bmVkTW9kZWxEaXNwbGF5TmFtZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UdW5lZE1vZGVsRGlzcGxheU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0dW5lZE1vZGVsRGlzcGxheU5hbWUnXSwgZnJvbVR1bmVkTW9kZWxEaXNwbGF5TmFtZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RUdW5pbmdKb2JzUmVzcG9uc2VGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OZXh0UGFnZVRva2VuID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbmV4dFBhZ2VUb2tlbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21OZXh0UGFnZVRva2VuICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmV4dFBhZ2VUb2tlbiddLCBmcm9tTmV4dFBhZ2VUb2tlbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UdW5pbmdKb2JzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0dW5pbmdKb2JzJ10pO1xuICAgIGlmIChmcm9tVHVuaW5nSm9icyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tVHVuaW5nSm9icztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0dW5pbmdKb2JGcm9tVmVydGV4KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndHVuaW5nSm9icyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmNsYXNzIFR1bmluZ3MgZXh0ZW5kcyBCYXNlTW9kdWxlIHtcbiAgICBjb25zdHJ1Y3RvcihhcGlDbGllbnQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5hcGlDbGllbnQgPSBhcGlDbGllbnQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIGEgVHVuaW5nSm9iLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gbmFtZSAtIFRoZSByZXNvdXJjZSBuYW1lIG9mIHRoZSB0dW5pbmcgam9iLlxuICAgICAgICAgKiBAcmV0dXJuIC0gQSBUdW5pbmdKb2Igb2JqZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhwZXJpbWVudGFsIC0gVGhlIFNESydzIHR1bmluZyBpbXBsZW1lbnRhdGlvbiBpcyBleHBlcmltZW50YWwsIGFuZCBtYXlcbiAgICAgICAgICogY2hhbmdlIGluIGZ1dHVyZSB2ZXJzaW9ucy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2V0ID0gYXN5bmMgKHBhcmFtcykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0SW50ZXJuYWwocGFyYW1zKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3RzIHR1bmluZyBqb2JzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gY29uZmlnIC0gVGhlIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBsaXN0IHJlcXVlc3QuXG4gICAgICAgICAqIEByZXR1cm4gLSBBIGxpc3Qgb2YgdHVuaW5nIGpvYnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleHBlcmltZW50YWwgLSBUaGUgU0RLJ3MgdHVuaW5nIGltcGxlbWVudGF0aW9uIGlzIGV4cGVyaW1lbnRhbCwgYW5kIG1heVxuICAgICAgICAgKiBjaGFuZ2UgaW4gZnV0dXJlIHZlcnNpb25zLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5saXN0ID0gYXN5bmMgKHBhcmFtcyA9IHt9KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBhZ2VyKFBhZ2VkSXRlbS5QQUdFRF9JVEVNX1RVTklOR19KT0JTLCAoeCkgPT4gdGhpcy5saXN0SW50ZXJuYWwoeCksIGF3YWl0IHRoaXMubGlzdEludGVybmFsKHBhcmFtcyksIHBhcmFtcyk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgc3VwZXJ2aXNlZCBmaW5lLXR1bmluZyBqb2IuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhlIHR1bmluZyBqb2IuXG4gICAgICAgICAqIEByZXR1cm4gLSBBIFR1bmluZ0pvYiBvcGVyYXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleHBlcmltZW50YWwgLSBUaGUgU0RLJ3MgdHVuaW5nIGltcGxlbWVudGF0aW9uIGlzIGV4cGVyaW1lbnRhbCwgYW5kIG1heVxuICAgICAgICAgKiBjaGFuZ2UgaW4gZnV0dXJlIHZlcnNpb25zLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50dW5lID0gYXN5bmMgKHBhcmFtcykgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnR1bmVJbnRlcm5hbChwYXJhbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3BlcmF0aW9uID0gYXdhaXQgdGhpcy50dW5lTWxkZXZJbnRlcm5hbChwYXJhbXMpO1xuICAgICAgICAgICAgICAgIGxldCB0dW5lZE1vZGVsTmFtZSA9ICcnO1xuICAgICAgICAgICAgICAgIGlmIChvcGVyYXRpb25bJ21ldGFkYXRhJ10gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb25bJ21ldGFkYXRhJ11bJ3R1bmVkTW9kZWwnXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHR1bmVkTW9kZWxOYW1lID0gb3BlcmF0aW9uWydtZXRhZGF0YSddWyd0dW5lZE1vZGVsJ107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9wZXJhdGlvblsnbmFtZSddICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uWyduYW1lJ10uaW5jbHVkZXMoJy9vcGVyYXRpb25zLycpKSB7XG4gICAgICAgICAgICAgICAgICAgIHR1bmVkTW9kZWxOYW1lID0gb3BlcmF0aW9uWyduYW1lJ10uc3BsaXQoJy9vcGVyYXRpb25zLycpWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB0dW5pbmdKb2IgPSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHR1bmVkTW9kZWxOYW1lLFxuICAgICAgICAgICAgICAgICAgICBzdGF0ZTogSm9iU3RhdGUuSk9CX1NUQVRFX1FVRVVFRCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiB0dW5pbmdKb2I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIGdldEludGVybmFsKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBnZXRUdW5pbmdKb2JQYXJhbWV0ZXJzVG9WZXJ0ZXgocGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3tuYW1lfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ2NvbmZpZyddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSB0dW5pbmdKb2JGcm9tVmVydGV4KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGdldFR1bmluZ0pvYlBhcmFtZXRlcnNUb01sZGV2KHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bmFtZX0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5Wydjb25maWcnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gdHVuaW5nSm9iRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGxpc3RJbnRlcm5hbChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gbGlzdFR1bmluZ0pvYnNQYXJhbWV0ZXJzVG9WZXJ0ZXgocGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3R1bmluZ0pvYnMnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5Wydjb25maWcnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gbGlzdFR1bmluZ0pvYnNSZXNwb25zZUZyb21WZXJ0ZXgoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBMaXN0VHVuaW5nSm9ic1Jlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBsaXN0VHVuaW5nSm9ic1BhcmFtZXRlcnNUb01sZGV2KHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd0dW5lZE1vZGVscycsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ2NvbmZpZyddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYyA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBsaXN0VHVuaW5nSm9ic1Jlc3BvbnNlRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgTGlzdFR1bmluZ0pvYnNSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgdHVuZUludGVybmFsKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gY3JlYXRlVHVuaW5nSm9iUGFyYW1ldGVyc1RvVmVydGV4KHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd0dW5pbmdKb2JzJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnY29uZmlnJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSB0dW5pbmdKb2JGcm9tVmVydGV4KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBpcyBvbmx5IHN1cHBvcnRlZCBieSB0aGUgVmVydGV4IEFJLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHR1bmVNbGRldkludGVybmFsKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIG9ubHkgc3VwcG9ydGVkIGJ5IHRoZSBHZW1pbmkgRGV2ZWxvcGVyIEFQSS4nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBjcmVhdGVUdW5pbmdKb2JQYXJhbWV0ZXJzVG9NbGRldihwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgndHVuZWRNb2RlbHMnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5Wydjb25maWcnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IG9wZXJhdGlvbkZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY29uc3QgTUFYX0NIVU5LX1NJWkUgPSAxMDI0ICogMTAyNCAqIDg7IC8vIGJ5dGVzXG5jb25zdCBNQVhfUkVUUllfQ09VTlQgPSAzO1xuY29uc3QgSU5JVElBTF9SRVRSWV9ERUxBWV9NUyA9IDEwMDA7XG5jb25zdCBERUxBWV9NVUxUSVBMSUVSID0gMjtcbmNvbnN0IFhfR09PR19VUExPQURfU1RBVFVTX0hFQURFUl9GSUVMRCA9ICd4LWdvb2ctdXBsb2FkLXN0YXR1cyc7XG5hc3luYyBmdW5jdGlvbiB1cGxvYWRCbG9iKGZpbGUsIHVwbG9hZFVybCwgYXBpQ2xpZW50KSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgbGV0IGZpbGVTaXplID0gMDtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICBsZXQgcmVzcG9uc2UgPSBuZXcgSHR0cFJlc3BvbnNlKG5ldyBSZXNwb25zZSgpKTtcbiAgICBsZXQgdXBsb2FkQ29tbWFuZCA9ICd1cGxvYWQnO1xuICAgIGZpbGVTaXplID0gZmlsZS5zaXplO1xuICAgIHdoaWxlIChvZmZzZXQgPCBmaWxlU2l6ZSkge1xuICAgICAgICBjb25zdCBjaHVua1NpemUgPSBNYXRoLm1pbihNQVhfQ0hVTktfU0laRSwgZmlsZVNpemUgLSBvZmZzZXQpO1xuICAgICAgICBjb25zdCBjaHVuayA9IGZpbGUuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBjaHVua1NpemUpO1xuICAgICAgICBpZiAob2Zmc2V0ICsgY2h1bmtTaXplID49IGZpbGVTaXplKSB7XG4gICAgICAgICAgICB1cGxvYWRDb21tYW5kICs9ICcsIGZpbmFsaXplJztcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmV0cnlDb3VudCA9IDA7XG4gICAgICAgIGxldCBjdXJyZW50RGVsYXlNcyA9IElOSVRJQUxfUkVUUllfREVMQVlfTVM7XG4gICAgICAgIHdoaWxlIChyZXRyeUNvdW50IDwgTUFYX1JFVFJZX0NPVU5UKSB7XG4gICAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiAnJyxcbiAgICAgICAgICAgICAgICBib2R5OiBjaHVuayxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgYXBpVmVyc2lvbjogJycsXG4gICAgICAgICAgICAgICAgICAgIGJhc2VVcmw6IHVwbG9hZFVybCxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1gtR29vZy1VcGxvYWQtQ29tbWFuZCc6IHVwbG9hZENvbW1hbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAnWC1Hb29nLVVwbG9hZC1PZmZzZXQnOiBTdHJpbmcob2Zmc2V0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdDb250ZW50LUxlbmd0aCc6IFN0cmluZyhjaHVua1NpemUpLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICgoX2EgPSByZXNwb25zZSA9PT0gbnVsbCB8fCByZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzcG9uc2UuaGVhZGVycykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW1hfR09PR19VUExPQURfU1RBVFVTX0hFQURFUl9GSUVMRF0pIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHJ5Q291bnQrKztcbiAgICAgICAgICAgIGF3YWl0IHNsZWVwKGN1cnJlbnREZWxheU1zKTtcbiAgICAgICAgICAgIGN1cnJlbnREZWxheU1zID0gY3VycmVudERlbGF5TXMgKiBERUxBWV9NVUxUSVBMSUVSO1xuICAgICAgICB9XG4gICAgICAgIG9mZnNldCArPSBjaHVua1NpemU7XG4gICAgICAgIC8vIFRoZSBgeC1nb29nLXVwbG9hZC1zdGF0dXNgIGhlYWRlciBmaWVsZCBjYW4gYmUgYGFjdGl2ZWAsIGBmaW5hbGAgYW5kXG4gICAgICAgIC8vYGNhbmNlbGxlZGAgaW4gcmVzcG9zbmUuXG4gICAgICAgIGlmICgoKF9iID0gcmVzcG9uc2UgPT09IG51bGwgfHwgcmVzcG9uc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3BvbnNlLmhlYWRlcnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYltYX0dPT0dfVVBMT0FEX1NUQVRVU19IRUFERVJfRklFTERdKSAhPT0gJ2FjdGl2ZScpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE8oYi80MDEzOTE0MzApIEludmVzdGlnYXRlIHdoeSB0aGUgdXBsb2FkIHN0YXR1cyBpcyBub3QgZmluYWxpemVkXG4gICAgICAgIC8vIGV2ZW4gdGhvdWdoIGFsbCBjb250ZW50IGhhcyBiZWVuIHVwbG9hZGVkLlxuICAgICAgICBpZiAoZmlsZVNpemUgPD0gb2Zmc2V0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FsbCBjb250ZW50IGhhcyBiZWVuIHVwbG9hZGVkLCBidXQgdGhlIHVwbG9hZCBzdGF0dXMgaXMgbm90IGZpbmFsaXplZC4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByZXNwb25zZUpzb24gPSAoYXdhaXQgKHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS5qc29uKCkpKTtcbiAgICBpZiAoKChfYyA9IHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS5oZWFkZXJzKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2NbWF9HT09HX1VQTE9BRF9TVEFUVVNfSEVBREVSX0ZJRUxEXSkgIT09ICdmaW5hbCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gdXBsb2FkIGZpbGU6IFVwbG9hZCBzdGF0dXMgaXMgbm90IGZpbmFsaXplZC4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3BvbnNlSnNvblsnZmlsZSddO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0QmxvYlN0YXQoZmlsZSkge1xuICAgIGNvbnN0IGZpbGVTdGF0ID0geyBzaXplOiBmaWxlLnNpemUsIHR5cGU6IGZpbGUudHlwZSB9O1xuICAgIHJldHVybiBmaWxlU3RhdDtcbn1cbmZ1bmN0aW9uIHNsZWVwKG1zKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlUHJvbWlzZSkgPT4gc2V0VGltZW91dChyZXNvbHZlUHJvbWlzZSwgbXMpKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuY2xhc3MgTm9kZVVwbG9hZGVyIHtcbiAgICBhc3luYyBzdGF0KGZpbGUpIHtcbiAgICAgICAgY29uc3QgZmlsZVN0YXQgPSB7IHNpemU6IDAsIHR5cGU6IHVuZGVmaW5lZCB9O1xuICAgICAgICBpZiAodHlwZW9mIGZpbGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbFN0YXQgPSBhd2FpdCBmcy5zdGF0KGZpbGUpO1xuICAgICAgICAgICAgZmlsZVN0YXQuc2l6ZSA9IG9yaWdpbmFsU3RhdC5zaXplO1xuICAgICAgICAgICAgZmlsZVN0YXQudHlwZSA9IHRoaXMuaW5mZXJNaW1lVHlwZShmaWxlKTtcbiAgICAgICAgICAgIHJldHVybiBmaWxlU3RhdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBnZXRCbG9iU3RhdChmaWxlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyB1cGxvYWQoZmlsZSwgdXBsb2FkVXJsLCBhcGlDbGllbnQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBmaWxlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudXBsb2FkRmlsZUZyb21QYXRoKGZpbGUsIHVwbG9hZFVybCwgYXBpQ2xpZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB1cGxvYWRCbG9iKGZpbGUsIHVwbG9hZFVybCwgYXBpQ2xpZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbmZlcnMgdGhlIE1JTUUgdHlwZSBvZiBhIGZpbGUgYmFzZWQgb24gaXRzIGV4dGVuc2lvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmaWxlUGF0aCBUaGUgcGF0aCB0byB0aGUgZmlsZS5cbiAgICAgKiBAcmV0dXJucyBUaGUgTUlNRSB0eXBlIG9mIHRoZSBmaWxlLCBvciB1bmRlZmluZWQgaWYgaXQgY2Fubm90IGJlIGluZmVycmVkLlxuICAgICAqL1xuICAgIGluZmVyTWltZVR5cGUoZmlsZVBhdGgpIHtcbiAgICAgICAgLy8gR2V0IHRoZSBmaWxlIGV4dGVuc2lvbi5cbiAgICAgICAgY29uc3QgZmlsZUV4dGVuc2lvbiA9IGZpbGVQYXRoLnNsaWNlKGZpbGVQYXRoLmxhc3RJbmRleE9mKCcuJykgKyAxKTtcbiAgICAgICAgLy8gQ3JlYXRlIGEgbWFwIG9mIGZpbGUgZXh0ZW5zaW9ucyB0byBNSU1FIHR5cGVzLlxuICAgICAgICBjb25zdCBtaW1lVHlwZXMgPSB7XG4gICAgICAgICAgICAnYWFjJzogJ2F1ZGlvL2FhYycsXG4gICAgICAgICAgICAnYWJ3JzogJ2FwcGxpY2F0aW9uL3gtYWJpd29yZCcsXG4gICAgICAgICAgICAnYXJjJzogJ2FwcGxpY2F0aW9uL3gtZnJlZWFyYycsXG4gICAgICAgICAgICAnYXZpJzogJ3ZpZGVvL3gtbXN2aWRlbycsXG4gICAgICAgICAgICAnYXp3JzogJ2FwcGxpY2F0aW9uL3ZuZC5hbWF6b24uZWJvb2snLFxuICAgICAgICAgICAgJ2Jpbic6ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nLFxuICAgICAgICAgICAgJ2JtcCc6ICdpbWFnZS9ibXAnLFxuICAgICAgICAgICAgJ2J6JzogJ2FwcGxpY2F0aW9uL3gtYnppcCcsXG4gICAgICAgICAgICAnYnoyJzogJ2FwcGxpY2F0aW9uL3gtYnppcDInLFxuICAgICAgICAgICAgJ2NzaCc6ICdhcHBsaWNhdGlvbi94LWNzaCcsXG4gICAgICAgICAgICAnY3NzJzogJ3RleHQvY3NzJyxcbiAgICAgICAgICAgICdjc3YnOiAndGV4dC9jc3YnLFxuICAgICAgICAgICAgJ2RvYyc6ICdhcHBsaWNhdGlvbi9tc3dvcmQnLFxuICAgICAgICAgICAgJ2RvY3gnOiAnYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LndvcmRwcm9jZXNzaW5nbWwuZG9jdW1lbnQnLFxuICAgICAgICAgICAgJ2VvdCc6ICdhcHBsaWNhdGlvbi92bmQubXMtZm9udG9iamVjdCcsXG4gICAgICAgICAgICAnZXB1Yic6ICdhcHBsaWNhdGlvbi9lcHViK3ppcCcsXG4gICAgICAgICAgICAnZ3onOiAnYXBwbGljYXRpb24vZ3ppcCcsXG4gICAgICAgICAgICAnZ2lmJzogJ2ltYWdlL2dpZicsXG4gICAgICAgICAgICAnaHRtJzogJ3RleHQvaHRtbCcsXG4gICAgICAgICAgICAnaHRtbCc6ICd0ZXh0L2h0bWwnLFxuICAgICAgICAgICAgJ2ljbyc6ICdpbWFnZS92bmQubWljcm9zb2Z0Lmljb24nLFxuICAgICAgICAgICAgJ2ljcyc6ICd0ZXh0L2NhbGVuZGFyJyxcbiAgICAgICAgICAgICdqYXInOiAnYXBwbGljYXRpb24vamF2YS1hcmNoaXZlJyxcbiAgICAgICAgICAgICdqcGVnJzogJ2ltYWdlL2pwZWcnLFxuICAgICAgICAgICAgJ2pwZyc6ICdpbWFnZS9qcGVnJyxcbiAgICAgICAgICAgICdqcyc6ICd0ZXh0L2phdmFzY3JpcHQnLFxuICAgICAgICAgICAgJ2pzb24nOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAnanNvbmxkJzogJ2FwcGxpY2F0aW9uL2xkK2pzb24nLFxuICAgICAgICAgICAgJ2ttbCc6ICdhcHBsaWNhdGlvbi92bmQuZ29vZ2xlLWVhcnRoLmttbCt4bWwnLFxuICAgICAgICAgICAgJ2tteic6ICdhcHBsaWNhdGlvbi92bmQuZ29vZ2xlLWVhcnRoLmtteit4bWwnLFxuICAgICAgICAgICAgJ21qcyc6ICd0ZXh0L2phdmFzY3JpcHQnLFxuICAgICAgICAgICAgJ21wMyc6ICdhdWRpby9tcGVnJyxcbiAgICAgICAgICAgICdtcDQnOiAndmlkZW8vbXA0JyxcbiAgICAgICAgICAgICdtcGVnJzogJ3ZpZGVvL21wZWcnLFxuICAgICAgICAgICAgJ21wa2cnOiAnYXBwbGljYXRpb24vdm5kLmFwcGxlLmluc3RhbGxlcit4bWwnLFxuICAgICAgICAgICAgJ29kdCc6ICdhcHBsaWNhdGlvbi92bmQub2FzaXMub3BlbmRvY3VtZW50LnRleHQnLFxuICAgICAgICAgICAgJ29nYSc6ICdhdWRpby9vZ2cnLFxuICAgICAgICAgICAgJ29ndic6ICd2aWRlby9vZ2cnLFxuICAgICAgICAgICAgJ29neCc6ICdhcHBsaWNhdGlvbi9vZ2cnLFxuICAgICAgICAgICAgJ29wdXMnOiAnYXVkaW8vb3B1cycsXG4gICAgICAgICAgICAnb3RmJzogJ2ZvbnQvb3RmJyxcbiAgICAgICAgICAgICdwbmcnOiAnaW1hZ2UvcG5nJyxcbiAgICAgICAgICAgICdwZGYnOiAnYXBwbGljYXRpb24vcGRmJyxcbiAgICAgICAgICAgICdwaHAnOiAnYXBwbGljYXRpb24veC1odHRwZC1waHAnLFxuICAgICAgICAgICAgJ3BwdCc6ICdhcHBsaWNhdGlvbi92bmQubXMtcG93ZXJwb2ludCcsXG4gICAgICAgICAgICAncHB0eCc6ICdhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQucHJlc2VudGF0aW9ubWwucHJlc2VudGF0aW9uJyxcbiAgICAgICAgICAgICdyYXInOiAnYXBwbGljYXRpb24vdm5kLnJhcicsXG4gICAgICAgICAgICAncnRmJzogJ2FwcGxpY2F0aW9uL3J0ZicsXG4gICAgICAgICAgICAnc2gnOiAnYXBwbGljYXRpb24veC1zaCcsXG4gICAgICAgICAgICAnc3ZnJzogJ2ltYWdlL3N2Zyt4bWwnLFxuICAgICAgICAgICAgJ3N3Zic6ICdhcHBsaWNhdGlvbi94LXNob2Nrd2F2ZS1mbGFzaCcsXG4gICAgICAgICAgICAndGFyJzogJ2FwcGxpY2F0aW9uL3gtdGFyJyxcbiAgICAgICAgICAgICd0aWYnOiAnaW1hZ2UvdGlmZicsXG4gICAgICAgICAgICAndGlmZic6ICdpbWFnZS90aWZmJyxcbiAgICAgICAgICAgICd0cyc6ICd2aWRlby9tcDJ0JyxcbiAgICAgICAgICAgICd0dGYnOiAnZm9udC90dGYnLFxuICAgICAgICAgICAgJ3R4dCc6ICd0ZXh0L3BsYWluJyxcbiAgICAgICAgICAgICd2c2QnOiAnYXBwbGljYXRpb24vdm5kLnZpc2lvJyxcbiAgICAgICAgICAgICd3YXYnOiAnYXVkaW8vd2F2JyxcbiAgICAgICAgICAgICd3ZWJhJzogJ2F1ZGlvL3dlYm0nLFxuICAgICAgICAgICAgJ3dlYm0nOiAndmlkZW8vd2VibScsXG4gICAgICAgICAgICAnd2VicCc6ICdpbWFnZS93ZWJwJyxcbiAgICAgICAgICAgICd3b2ZmJzogJ2ZvbnQvd29mZicsXG4gICAgICAgICAgICAnd29mZjInOiAnZm9udC93b2ZmMicsXG4gICAgICAgICAgICAneGh0bWwnOiAnYXBwbGljYXRpb24veGh0bWwreG1sJyxcbiAgICAgICAgICAgICd4bHMnOiAnYXBwbGljYXRpb24vdm5kLm1zLWV4Y2VsJyxcbiAgICAgICAgICAgICd4bHN4JzogJ2FwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5zcHJlYWRzaGVldG1sLnNoZWV0JyxcbiAgICAgICAgICAgICd4bWwnOiAnYXBwbGljYXRpb24veG1sJyxcbiAgICAgICAgICAgICd4dWwnOiAnYXBwbGljYXRpb24vdm5kLm1vemlsbGEueHVsK3htbCcsXG4gICAgICAgICAgICAnemlwJzogJ2FwcGxpY2F0aW9uL3ppcCcsXG4gICAgICAgICAgICAnM2dwJzogJ3ZpZGVvLzNncHAnLFxuICAgICAgICAgICAgJzNnMic6ICd2aWRlby8zZ3BwMicsXG4gICAgICAgICAgICAnN3onOiAnYXBwbGljYXRpb24veC03ei1jb21wcmVzc2VkJyxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gTG9vayB1cCB0aGUgTUlNRSB0eXBlIGJhc2VkIG9uIHRoZSBmaWxlIGV4dGVuc2lvbi5cbiAgICAgICAgY29uc3QgbWltZVR5cGUgPSBtaW1lVHlwZXNbZmlsZUV4dGVuc2lvbi50b0xvd2VyQ2FzZSgpXTtcbiAgICAgICAgLy8gUmV0dXJuIHRoZSBNSU1FIHR5cGUuXG4gICAgICAgIHJldHVybiBtaW1lVHlwZTtcbiAgICB9XG4gICAgYXN5bmMgdXBsb2FkRmlsZUZyb21QYXRoKGZpbGUsIHVwbG9hZFVybCwgYXBpQ2xpZW50KSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBsZXQgZmlsZVNpemUgPSAwO1xuICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gbmV3IEh0dHBSZXNwb25zZShuZXcgUmVzcG9uc2UoKSk7XG4gICAgICAgIGxldCB1cGxvYWRDb21tYW5kID0gJ3VwbG9hZCc7XG4gICAgICAgIGxldCBmaWxlSGFuZGxlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZmlsZUhhbmRsZSA9IGF3YWl0IGZzLm9wZW4oZmlsZSwgJ3InKTtcbiAgICAgICAgICAgIGlmICghZmlsZUhhbmRsZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIG9wZW4gZmlsZWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmlsZVNpemUgPSAoYXdhaXQgZmlsZUhhbmRsZS5zdGF0KCkpLnNpemU7XG4gICAgICAgICAgICB3aGlsZSAob2Zmc2V0IDwgZmlsZVNpemUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaHVua1NpemUgPSBNYXRoLm1pbihNQVhfQ0hVTktfU0laRSwgZmlsZVNpemUgLSBvZmZzZXQpO1xuICAgICAgICAgICAgICAgIGlmIChvZmZzZXQgKyBjaHVua1NpemUgPj0gZmlsZVNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgdXBsb2FkQ29tbWFuZCArPSAnLCBmaW5hbGl6ZSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGNodW5rU2l6ZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBieXRlc1JlYWQ6IGJ5dGVzUmVhZCB9ID0gYXdhaXQgZmlsZUhhbmRsZS5yZWFkKGJ1ZmZlciwgMCwgY2h1bmtTaXplLCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgIGlmIChieXRlc1JlYWQgIT09IGNodW5rU2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byByZWFkICR7Y2h1bmtTaXplfSBieXRlcyBmcm9tIGZpbGUgYXQgb2Zmc2V0ICR7b2Zmc2V0fS4gYnl0ZXMgYWN0dWFsbHkgcmVhZDogJHtieXRlc1JlYWR9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rID0gbmV3IEJsb2IoW2J1ZmZlcl0pO1xuICAgICAgICAgICAgICAgIGxldCByZXRyeUNvdW50ID0gMDtcbiAgICAgICAgICAgICAgICBsZXQgY3VycmVudERlbGF5TXMgPSBJTklUSUFMX1JFVFJZX0RFTEFZX01TO1xuICAgICAgICAgICAgICAgIHdoaWxlIChyZXRyeUNvdW50IDwgTUFYX1JFVFJZX0NPVU5UKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogJycsXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBjaHVuayxcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBpVmVyc2lvbjogJycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFzZVVybDogdXBsb2FkVXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1gtR29vZy1VcGxvYWQtQ29tbWFuZCc6IHVwbG9hZENvbW1hbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdYLUdvb2ctVXBsb2FkLU9mZnNldCc6IFN0cmluZyhvZmZzZXQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnQ29udGVudC1MZW5ndGgnOiBTdHJpbmcoYnl0ZXNSZWFkKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoX2EgPSByZXNwb25zZSA9PT0gbnVsbCB8fCByZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzcG9uc2UuaGVhZGVycykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW1hfR09PR19VUExPQURfU1RBVFVTX0hFQURFUl9GSUVMRF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHJ5Q291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgc2xlZXAoY3VycmVudERlbGF5TXMpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50RGVsYXlNcyA9IGN1cnJlbnREZWxheU1zICogREVMQVlfTVVMVElQTElFUjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IGJ5dGVzUmVhZDtcbiAgICAgICAgICAgICAgICAvLyBUaGUgYHgtZ29vZy11cGxvYWQtc3RhdHVzYCBoZWFkZXIgZmllbGQgY2FuIGJlIGBhY3RpdmVgLCBgZmluYWxgIGFuZFxuICAgICAgICAgICAgICAgIC8vYGNhbmNlbGxlZGAgaW4gcmVzcG9zbmUuXG4gICAgICAgICAgICAgICAgaWYgKCgoX2IgPSByZXNwb25zZSA9PT0gbnVsbCB8fCByZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzcG9uc2UuaGVhZGVycykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW1hfR09PR19VUExPQURfU1RBVFVTX0hFQURFUl9GSUVMRF0pICE9PSAnYWN0aXZlJykge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGZpbGVTaXplIDw9IG9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FsbCBjb250ZW50IGhhcyBiZWVuIHVwbG9hZGVkLCBidXQgdGhlIHVwbG9hZCBzdGF0dXMgaXMgbm90IGZpbmFsaXplZC4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZUpzb24gPSAoYXdhaXQgKHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS5qc29uKCkpKTtcbiAgICAgICAgICAgIGlmICgoKF9jID0gcmVzcG9uc2UgPT09IG51bGwgfHwgcmVzcG9uc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3BvbnNlLmhlYWRlcnMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfY1tYX0dPT0dfVVBMT0FEX1NUQVRVU19IRUFERVJfRklFTERdKSAhPT0gJ2ZpbmFsJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHVwbG9hZCBmaWxlOiBVcGxvYWQgc3RhdHVzIGlzIG5vdCBmaW5hbGl6ZWQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2VKc29uWydmaWxlJ107XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAvLyBFbnN1cmUgdGhlIGZpbGUgaGFuZGxlIGlzIGFsd2F5cyBjbG9zZWRcbiAgICAgICAgICAgIGlmIChmaWxlSGFuZGxlKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgZmlsZUhhbmRsZS5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5jb25zdCBMQU5HVUFHRV9MQUJFTF9QUkVGSVggPSAnZ2wtbm9kZS8nO1xuLyoqXG4gKiBUaGUgR29vZ2xlIEdlbkFJIFNESy5cbiAqXG4gKiBAcmVtYXJrc1xuICogUHJvdmlkZXMgYWNjZXNzIHRvIHRoZSBHZW5BSSBmZWF0dXJlcyB0aHJvdWdoIGVpdGhlciB0aGUge0BsaW5rXG4gKiBodHRwczovL2Nsb3VkLmdvb2dsZS5jb20vdmVydGV4LWFpL2RvY3MvcmVmZXJlbmNlL3Jlc3QgfCBHZW1pbmkgQVBJfSBvclxuICogdGhlIHtAbGluayBodHRwczovL2Nsb3VkLmdvb2dsZS5jb20vdmVydGV4LWFpL2RvY3MvcmVmZXJlbmNlL3Jlc3QgfCBWZXJ0ZXggQUlcbiAqIEFQSX0uXG4gKlxuICogVGhlIHtAbGluayBHb29nbGVHZW5BSU9wdGlvbnMudmVydGV4YWl9IHZhbHVlIGRldGVybWluZXMgd2hpY2ggb2YgdGhlIEFQSVxuICogc2VydmljZXMgdG8gdXNlLlxuICpcbiAqIFdoZW4gdXNpbmcgdGhlIEdlbWluaSBBUEksIGEge0BsaW5rIEdvb2dsZUdlbkFJT3B0aW9ucy5hcGlLZXl9IG11c3QgYWxzbyBiZVxuICogc2V0LiBXaGVuIHVzaW5nIFZlcnRleCBBSSwgYm90aCB7QGxpbmsgR29vZ2xlR2VuQUlPcHRpb25zLnByb2plY3R9IGFuZCB7QGxpbmtcbiAqIEdvb2dsZUdlbkFJT3B0aW9ucy5sb2NhdGlvbn0gbXVzdCBiZSBzZXQsIG9yIGEge0BsaW5rXG4gKiBHb29nbGVHZW5BSU9wdGlvbnMuYXBpS2V5fSBtdXN0IGJlIHNldCB3aGVuIHVzaW5nIEV4cHJlc3MgTW9kZS5cbiAqXG4gKiBFeHBsaWNpdGx5IHBhc3NlZCBpbiB2YWx1ZXMgaW4ge0BsaW5rIEdvb2dsZUdlbkFJT3B0aW9uc30gd2lsbCBhbHdheXMgdGFrZVxuICogcHJlY2VkZW5jZSBvdmVyIGVudmlyb25tZW50IHZhcmlhYmxlcy4gSWYgYm90aCBwcm9qZWN0L2xvY2F0aW9uIGFuZCBhcGlfa2V5XG4gKiBleGlzdCBpbiB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGVzLCB0aGUgcHJvamVjdC9sb2NhdGlvbiB3aWxsIGJlIHVzZWQuXG4gKlxuICogQGV4YW1wbGVcbiAqIEluaXRpYWxpemluZyB0aGUgU0RLIGZvciB1c2luZyB0aGUgR2VtaW5pIEFQSTpcbiAqIGBgYHRzXG4gKiBpbXBvcnQge0dvb2dsZUdlbkFJfSBmcm9tICdAZ29vZ2xlL2dlbmFpJztcbiAqIGNvbnN0IGFpID0gbmV3IEdvb2dsZUdlbkFJKHthcGlLZXk6ICdHRU1JTklfQVBJX0tFWSd9KTtcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBJbml0aWFsaXppbmcgdGhlIFNESyBmb3IgdXNpbmcgdGhlIFZlcnRleCBBSSBBUEk6XG4gKiBgYGB0c1xuICogaW1wb3J0IHtHb29nbGVHZW5BSX0gZnJvbSAnQGdvb2dsZS9nZW5haSc7XG4gKiBjb25zdCBhaSA9IG5ldyBHb29nbGVHZW5BSSh7XG4gKiAgIHZlcnRleGFpOiB0cnVlLFxuICogICBwcm9qZWN0OiAnUFJPSkVDVF9JRCcsXG4gKiAgIGxvY2F0aW9uOiAnUFJPSkVDVF9MT0NBVElPTidcbiAqIH0pO1xuICogYGBgXG4gKlxuICovXG5jbGFzcyBHb29nbGVHZW5BSSB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgICAgICAgLy8gVmFsaWRhdGUgZXhwbGljaXRseSBzZXQgaW5pdGlhbGl6ZXIgdmFsdWVzLlxuICAgICAgICBpZiAoKG9wdGlvbnMucHJvamVjdCB8fCBvcHRpb25zLmxvY2F0aW9uKSAmJiBvcHRpb25zLmFwaUtleSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm9qZWN0L2xvY2F0aW9uIGFuZCBBUEkga2V5IGFyZSBtdXR1YWxseSBleGNsdXNpdmUgaW4gdGhlIGNsaWVudCBpbml0aWFsaXplci4nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZlcnRleGFpID1cbiAgICAgICAgICAgIChfYiA9IChfYSA9IG9wdGlvbnMudmVydGV4YWkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGdldEJvb2xlYW5FbnYoJ0dPT0dMRV9HRU5BSV9VU0VfVkVSVEVYQUknKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZmFsc2U7XG4gICAgICAgIGNvbnN0IGVudkFwaUtleSA9IGdldEFwaUtleUZyb21FbnYoKTtcbiAgICAgICAgY29uc3QgZW52UHJvamVjdCA9IGdldEVudignR09PR0xFX0NMT1VEX1BST0pFQ1QnKTtcbiAgICAgICAgY29uc3QgZW52TG9jYXRpb24gPSBnZXRFbnYoJ0dPT0dMRV9DTE9VRF9MT0NBVElPTicpO1xuICAgICAgICB0aGlzLmFwaUtleSA9IChfYyA9IG9wdGlvbnMuYXBpS2V5KSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBlbnZBcGlLZXk7XG4gICAgICAgIHRoaXMucHJvamVjdCA9IChfZCA9IG9wdGlvbnMucHJvamVjdCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogZW52UHJvamVjdDtcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IChfZSA9IG9wdGlvbnMubG9jYXRpb24pICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IGVudkxvY2F0aW9uO1xuICAgICAgICAvLyBIYW5kbGUgd2hlbiB0byB1c2UgVmVydGV4IEFJIGluIGV4cHJlc3MgbW9kZSAoYXBpIGtleSlcbiAgICAgICAgaWYgKG9wdGlvbnMudmVydGV4YWkpIHtcbiAgICAgICAgICAgIGlmICgoX2YgPSBvcHRpb25zLmdvb2dsZUF1dGhPcHRpb25zKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YuY3JlZGVudGlhbHMpIHtcbiAgICAgICAgICAgICAgICAvLyBFeHBsaWNpdCBjcmVkZW50aWFscyB0YWtlIHByZWNlZGVuY2Ugb3ZlciBpbXBsaWNpdCBhcGlfa2V5LlxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoJ1RoZSB1c2VyIHByb3ZpZGVkIEdvb2dsZSBDbG91ZCBjcmVkZW50aWFscyB3aWxsIHRha2UgcHJlY2VkZW5jZScgK1xuICAgICAgICAgICAgICAgICAgICAnIG92ZXIgdGhlIEFQSSBrZXkgZnJvbSB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGUuJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5hcGlLZXkgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBFeHBsaWNpdCBhcGlfa2V5IGFuZCBleHBsaWNpdCBwcm9qZWN0L2xvY2F0aW9uIGFscmVhZHkgaGFuZGxlZCBhYm92ZS5cbiAgICAgICAgICAgIGlmICgoZW52UHJvamVjdCB8fCBlbnZMb2NhdGlvbikgJiYgb3B0aW9ucy5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICAvLyBFeHBsaWNpdCBhcGlfa2V5IHRha2VzIHByZWNlZGVuY2Ugb3ZlciBpbXBsaWNpdCBwcm9qZWN0L2xvY2F0aW9uLlxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoJ1RoZSB1c2VyIHByb3ZpZGVkIFZlcnRleCBBSSBBUEkga2V5IHdpbGwgdGFrZSBwcmVjZWRlbmNlIG92ZXInICtcbiAgICAgICAgICAgICAgICAgICAgJyB0aGUgcHJvamVjdC9sb2NhdGlvbiBmcm9tIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZXMuJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9qZWN0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHRoaXMubG9jYXRpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgob3B0aW9ucy5wcm9qZWN0IHx8IG9wdGlvbnMubG9jYXRpb24pICYmIGVudkFwaUtleSkge1xuICAgICAgICAgICAgICAgIC8vIEV4cGxpY2l0IHByb2plY3QvbG9jYXRpb24gdGFrZXMgcHJlY2VkZW5jZSBvdmVyIGltcGxpY2l0IGFwaV9rZXkuXG4gICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1ZygnVGhlIHVzZXIgcHJvdmlkZWQgcHJvamVjdC9sb2NhdGlvbiB3aWxsIHRha2UgcHJlY2VkZW5jZSBvdmVyJyArXG4gICAgICAgICAgICAgICAgICAgICcgdGhlIEFQSSBrZXkgZnJvbSB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGVzLicpO1xuICAgICAgICAgICAgICAgIHRoaXMuYXBpS2V5ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoKGVudlByb2plY3QgfHwgZW52TG9jYXRpb24pICYmIGVudkFwaUtleSkge1xuICAgICAgICAgICAgICAgIC8vIEltcGxpY2l0IHByb2plY3QvbG9jYXRpb24gdGFrZXMgcHJlY2VkZW5jZSBvdmVyIGltcGxpY2l0IGFwaV9rZXkuXG4gICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1ZygnVGhlIHByb2plY3QvbG9jYXRpb24gZnJvbSB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGVzIHdpbGwgdGFrZScgK1xuICAgICAgICAgICAgICAgICAgICAnIHByZWNlZGVuY2Ugb3ZlciB0aGUgQVBJIGtleSBmcm9tIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZXMuJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5hcGlLZXkgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYmFzZVVybCA9IGdldEJhc2VVcmwob3B0aW9ucywgZ2V0RW52KCdHT09HTEVfVkVSVEVYX0JBU0VfVVJMJyksIGdldEVudignR09PR0xFX0dFTUlOSV9CQVNFX1VSTCcpKTtcbiAgICAgICAgaWYgKGJhc2VVcmwpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmh0dHBPcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5odHRwT3B0aW9ucy5iYXNlVXJsID0gYmFzZVVybDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuaHR0cE9wdGlvbnMgPSB7IGJhc2VVcmw6IGJhc2VVcmwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFwaVZlcnNpb24gPSBvcHRpb25zLmFwaVZlcnNpb247XG4gICAgICAgIGNvbnN0IGF1dGggPSBuZXcgTm9kZUF1dGgoe1xuICAgICAgICAgICAgYXBpS2V5OiB0aGlzLmFwaUtleSxcbiAgICAgICAgICAgIGdvb2dsZUF1dGhPcHRpb25zOiBvcHRpb25zLmdvb2dsZUF1dGhPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hcGlDbGllbnQgPSBuZXcgQXBpQ2xpZW50KHtcbiAgICAgICAgICAgIGF1dGg6IGF1dGgsXG4gICAgICAgICAgICBwcm9qZWN0OiB0aGlzLnByb2plY3QsXG4gICAgICAgICAgICBsb2NhdGlvbjogdGhpcy5sb2NhdGlvbixcbiAgICAgICAgICAgIGFwaVZlcnNpb246IHRoaXMuYXBpVmVyc2lvbixcbiAgICAgICAgICAgIGFwaUtleTogdGhpcy5hcGlLZXksXG4gICAgICAgICAgICB2ZXJ0ZXhhaTogdGhpcy52ZXJ0ZXhhaSxcbiAgICAgICAgICAgIGh0dHBPcHRpb25zOiBvcHRpb25zLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgdXNlckFnZW50RXh0cmE6IExBTkdVQUdFX0xBQkVMX1BSRUZJWCArIHByb2Nlc3MudmVyc2lvbixcbiAgICAgICAgICAgIHVwbG9hZGVyOiBuZXcgTm9kZVVwbG9hZGVyKCksXG4gICAgICAgICAgICBkb3dubG9hZGVyOiBuZXcgTm9kZURvd25sb2FkZXIoKSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubW9kZWxzID0gbmV3IE1vZGVscyh0aGlzLmFwaUNsaWVudCk7XG4gICAgICAgIHRoaXMubGl2ZSA9IG5ldyBMaXZlKHRoaXMuYXBpQ2xpZW50LCBhdXRoLCBuZXcgTm9kZVdlYlNvY2tldEZhY3RvcnkoKSk7XG4gICAgICAgIHRoaXMuYmF0Y2hlcyA9IG5ldyBCYXRjaGVzKHRoaXMuYXBpQ2xpZW50KTtcbiAgICAgICAgdGhpcy5jaGF0cyA9IG5ldyBDaGF0cyh0aGlzLm1vZGVscywgdGhpcy5hcGlDbGllbnQpO1xuICAgICAgICB0aGlzLmNhY2hlcyA9IG5ldyBDYWNoZXModGhpcy5hcGlDbGllbnQpO1xuICAgICAgICB0aGlzLmZpbGVzID0gbmV3IEZpbGVzKHRoaXMuYXBpQ2xpZW50KTtcbiAgICAgICAgdGhpcy5vcGVyYXRpb25zID0gbmV3IE9wZXJhdGlvbnModGhpcy5hcGlDbGllbnQpO1xuICAgICAgICB0aGlzLmF1dGhUb2tlbnMgPSBuZXcgVG9rZW5zKHRoaXMuYXBpQ2xpZW50KTtcbiAgICAgICAgdGhpcy50dW5pbmdzID0gbmV3IFR1bmluZ3ModGhpcy5hcGlDbGllbnQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEVudihlbnYpIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICByZXR1cm4gKF9jID0gKF9iID0gKF9hID0gcHJvY2VzcyA9PT0gbnVsbCB8fCBwcm9jZXNzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcm9jZXNzLmVudikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW2Vudl0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi50cmltKCkpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGdldEJvb2xlYW5FbnYoZW52KSB7XG4gICAgcmV0dXJuIHN0cmluZ1RvQm9vbGVhbihnZXRFbnYoZW52KSk7XG59XG5mdW5jdGlvbiBzdHJpbmdUb0Jvb2xlYW4oc3RyKSB7XG4gICAgaWYgKHN0ciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHN0ci50b0xvd2VyQ2FzZSgpID09PSAndHJ1ZSc7XG59XG5mdW5jdGlvbiBnZXRBcGlLZXlGcm9tRW52KCkge1xuICAgIGNvbnN0IGVudkdvb2dsZUFwaUtleSA9IGdldEVudignR09PR0xFX0FQSV9LRVknKTtcbiAgICBjb25zdCBlbnZHZW1pbmlBcGlLZXkgPSBnZXRFbnYoJ0dFTUlOSV9BUElfS0VZJyk7XG4gICAgaWYgKGVudkdvb2dsZUFwaUtleSAmJiBlbnZHZW1pbmlBcGlLZXkpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdCb3RoIEdPT0dMRV9BUElfS0VZIGFuZCBHRU1JTklfQVBJX0tFWSBhcmUgc2V0LiBVc2luZyBHT09HTEVfQVBJX0tFWS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIGVudkdvb2dsZUFwaUtleSB8fCBlbnZHZW1pbmlBcGlLZXk7XG59XG5cbmV4cG9ydCB7IEFjdGl2aXR5SGFuZGxpbmcsIEFkYXB0ZXJTaXplLCBBcGlFcnJvciwgQXV0aFR5cGUsIEJhdGNoZXMsIEJlaGF2aW9yLCBCbG9ja2VkUmVhc29uLCBDYWNoZXMsIENoYXQsIENoYXRzLCBDb21wdXRlVG9rZW5zUmVzcG9uc2UsIENvbnRyb2xSZWZlcmVuY2VJbWFnZSwgQ29udHJvbFJlZmVyZW5jZVR5cGUsIENvdW50VG9rZW5zUmVzcG9uc2UsIENyZWF0ZUZpbGVSZXNwb25zZSwgRGVsZXRlQ2FjaGVkQ29udGVudFJlc3BvbnNlLCBEZWxldGVGaWxlUmVzcG9uc2UsIERlbGV0ZU1vZGVsUmVzcG9uc2UsIER5bmFtaWNSZXRyaWV2YWxDb25maWdNb2RlLCBFZGl0SW1hZ2VSZXNwb25zZSwgRWRpdE1vZGUsIEVtYmVkQ29udGVudFJlc3BvbnNlLCBFbmRTZW5zaXRpdml0eSwgRmVhdHVyZVNlbGVjdGlvblByZWZlcmVuY2UsIEZpbGVTb3VyY2UsIEZpbGVTdGF0ZSwgRmlsZXMsIEZpbmlzaFJlYXNvbiwgRnVuY3Rpb25DYWxsaW5nQ29uZmlnTW9kZSwgRnVuY3Rpb25SZXNwb25zZSwgRnVuY3Rpb25SZXNwb25zZVNjaGVkdWxpbmcsIEdlbmVyYXRlQ29udGVudFJlc3BvbnNlLCBHZW5lcmF0ZUNvbnRlbnRSZXNwb25zZVByb21wdEZlZWRiYWNrLCBHZW5lcmF0ZUNvbnRlbnRSZXNwb25zZVVzYWdlTWV0YWRhdGEsIEdlbmVyYXRlSW1hZ2VzUmVzcG9uc2UsIEdlbmVyYXRlVmlkZW9zUmVzcG9uc2UsIEdvb2dsZUdlbkFJLCBIYXJtQmxvY2tNZXRob2QsIEhhcm1CbG9ja1RocmVzaG9sZCwgSGFybUNhdGVnb3J5LCBIYXJtUHJvYmFiaWxpdHksIEhhcm1TZXZlcml0eSwgSHR0cFJlc3BvbnNlLCBJbWFnZVByb21wdExhbmd1YWdlLCBJbmxpbmVkUmVzcG9uc2UsIEpvYlN0YXRlLCBMYW5ndWFnZSwgTGlzdEJhdGNoSm9ic1Jlc3BvbnNlLCBMaXN0Q2FjaGVkQ29udGVudHNSZXNwb25zZSwgTGlzdEZpbGVzUmVzcG9uc2UsIExpc3RNb2RlbHNSZXNwb25zZSwgTGlzdFR1bmluZ0pvYnNSZXNwb25zZSwgTGl2ZSwgTGl2ZUNsaWVudFRvb2xSZXNwb25zZSwgTGl2ZU11c2ljUGxheWJhY2tDb250cm9sLCBMaXZlTXVzaWNTZXJ2ZXJNZXNzYWdlLCBMaXZlU2VuZFRvb2xSZXNwb25zZVBhcmFtZXRlcnMsIExpdmVTZXJ2ZXJNZXNzYWdlLCBNYXNrUmVmZXJlbmNlSW1hZ2UsIE1hc2tSZWZlcmVuY2VNb2RlLCBNZWRpYU1vZGFsaXR5LCBNZWRpYVJlc29sdXRpb24sIE1vZGFsaXR5LCBNb2RlLCBNb2RlbHMsIE9wZXJhdGlvbnMsIE91dGNvbWUsIFBhZ2VkSXRlbSwgUGFnZXIsIFBlcnNvbkdlbmVyYXRpb24sIFJhd1JlZmVyZW5jZUltYWdlLCBSZXBsYXlSZXNwb25zZSwgU2FmZXR5RmlsdGVyTGV2ZWwsIFNjYWxlLCBTZXNzaW9uLCBTdGFydFNlbnNpdGl2aXR5LCBTdHlsZVJlZmVyZW5jZUltYWdlLCBTdWJqZWN0UmVmZXJlbmNlSW1hZ2UsIFN1YmplY3RSZWZlcmVuY2VUeXBlLCBUb2tlbnMsIFRyYWZmaWNUeXBlLCBUdXJuQ292ZXJhZ2UsIFR5cGUsIFVwc2NhbGVJbWFnZVJlc3BvbnNlLCBVcmxSZXRyaWV2YWxTdGF0dXMsIFZpZGVvQ29tcHJlc3Npb25RdWFsaXR5LCBjcmVhdGVNb2RlbENvbnRlbnQsIGNyZWF0ZVBhcnRGcm9tQmFzZTY0LCBjcmVhdGVQYXJ0RnJvbUNvZGVFeGVjdXRpb25SZXN1bHQsIGNyZWF0ZVBhcnRGcm9tRXhlY3V0YWJsZUNvZGUsIGNyZWF0ZVBhcnRGcm9tRnVuY3Rpb25DYWxsLCBjcmVhdGVQYXJ0RnJvbUZ1bmN0aW9uUmVzcG9uc2UsIGNyZWF0ZVBhcnRGcm9tVGV4dCwgY3JlYXRlUGFydEZyb21VcmksIGNyZWF0ZVVzZXJDb250ZW50LCBtY3BUb1Rvb2wsIHNldERlZmF1bHRCYXNlVXJscyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIl0sIm5hbWVzIjpbInoiLCJHb29nbGVBdXRoIiwiY3JlYXRlV3JpdGVTdHJlYW0iLCJ3cml0ZUZpbGUiLCJSZWFkYWJsZSIsIk5vZGVXcyIsImZzIiwiX2RlZmF1bHRCYXNlR2VtaW5pVXJsIiwidW5kZWZpbmVkIiwiX2RlZmF1bHRCYXNlVmVydGV4VXJsIiwic2V0RGVmYXVsdEJhc2VVcmxzIiwiYmFzZVVybFBhcmFtcyIsImdlbWluaVVybCIsInZlcnRleFVybCIsImdldERlZmF1bHRCYXNlVXJscyIsImdldEJhc2VVcmwiLCJvcHRpb25zIiwidmVydGV4QmFzZVVybEZyb21FbnYiLCJnZW1pbmlCYXNlVXJsRnJvbUVudiIsIl9hIiwiX2IiLCJfYyIsImh0dHBPcHRpb25zIiwiYmFzZVVybCIsImRlZmF1bHRCYXNlVXJscyIsInZlcnRleGFpIiwiQmFzZU1vZHVsZSIsImZvcm1hdE1hcCIsInRlbXBsYXRlU3RyaW5nIiwidmFsdWVNYXAiLCJyZWdleCIsInJlcGxhY2UiLCJtYXRjaCIsImtleSIsIk9iamVjdCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsInZhbHVlIiwiU3RyaW5nIiwiRXJyb3IiLCJzZXRWYWx1ZUJ5UGF0aCIsImRhdGEiLCJrZXlzIiwiaSIsImxlbmd0aCIsImVuZHNXaXRoIiwia2V5TmFtZSIsInNsaWNlIiwiQXJyYXkiLCJpc0FycmF5IiwiZnJvbSIsImFycmF5RGF0YSIsImoiLCJlbnRyeSIsImQiLCJrZXlUb1NldCIsImV4aXN0aW5nRGF0YSIsImFzc2lnbiIsImdldFZhbHVlQnlQYXRoIiwibWFwIiwiZXJyb3IiLCJUeXBlRXJyb3IiLCJPdXRjb21lIiwiTGFuZ3VhZ2UiLCJUeXBlIiwiSGFybUNhdGVnb3J5IiwiSGFybUJsb2NrTWV0aG9kIiwiSGFybUJsb2NrVGhyZXNob2xkIiwiTW9kZSIsIkF1dGhUeXBlIiwiRmluaXNoUmVhc29uIiwiSGFybVByb2JhYmlsaXR5IiwiSGFybVNldmVyaXR5IiwiQmxvY2tlZFJlYXNvbiIsIlRyYWZmaWNUeXBlIiwiTW9kYWxpdHkiLCJNZWRpYVJlc29sdXRpb24iLCJKb2JTdGF0ZSIsIkFkYXB0ZXJTaXplIiwiRmVhdHVyZVNlbGVjdGlvblByZWZlcmVuY2UiLCJCZWhhdmlvciIsIkR5bmFtaWNSZXRyaWV2YWxDb25maWdNb2RlIiwiRnVuY3Rpb25DYWxsaW5nQ29uZmlnTW9kZSIsIlVybFJldHJpZXZhbFN0YXR1cyIsIlNhZmV0eUZpbHRlckxldmVsIiwiUGVyc29uR2VuZXJhdGlvbiIsIkltYWdlUHJvbXB0TGFuZ3VhZ2UiLCJNYXNrUmVmZXJlbmNlTW9kZSIsIkNvbnRyb2xSZWZlcmVuY2VUeXBlIiwiU3ViamVjdFJlZmVyZW5jZVR5cGUiLCJFZGl0TW9kZSIsIlZpZGVvQ29tcHJlc3Npb25RdWFsaXR5IiwiRmlsZVN0YXRlIiwiRmlsZVNvdXJjZSIsIk1lZGlhTW9kYWxpdHkiLCJTdGFydFNlbnNpdGl2aXR5IiwiRW5kU2Vuc2l0aXZpdHkiLCJBY3Rpdml0eUhhbmRsaW5nIiwiVHVybkNvdmVyYWdlIiwiRnVuY3Rpb25SZXNwb25zZVNjaGVkdWxpbmciLCJTY2FsZSIsIkxpdmVNdXNpY1BsYXliYWNrQ29udHJvbCIsIkZ1bmN0aW9uUmVzcG9uc2UiLCJjcmVhdGVQYXJ0RnJvbVVyaSIsInVyaSIsIm1pbWVUeXBlIiwiZmlsZURhdGEiLCJmaWxlVXJpIiwiY3JlYXRlUGFydEZyb21UZXh0IiwidGV4dCIsImNyZWF0ZVBhcnRGcm9tRnVuY3Rpb25DYWxsIiwibmFtZSIsImFyZ3MiLCJmdW5jdGlvbkNhbGwiLCJjcmVhdGVQYXJ0RnJvbUZ1bmN0aW9uUmVzcG9uc2UiLCJpZCIsInJlc3BvbnNlIiwiZnVuY3Rpb25SZXNwb25zZSIsImNyZWF0ZVBhcnRGcm9tQmFzZTY0IiwiaW5saW5lRGF0YSIsImNyZWF0ZVBhcnRGcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCIsIm91dGNvbWUiLCJvdXRwdXQiLCJjb2RlRXhlY3V0aW9uUmVzdWx0IiwiY3JlYXRlUGFydEZyb21FeGVjdXRhYmxlQ29kZSIsImNvZGUiLCJsYW5ndWFnZSIsImV4ZWN1dGFibGVDb2RlIiwiX2lzUGFydCIsIm9iaiIsIl90b1BhcnRzIiwicGFydE9yU3RyaW5nIiwicGFydHMiLCJwdXNoIiwicGFydCIsImNyZWF0ZVVzZXJDb250ZW50Iiwicm9sZSIsImNyZWF0ZU1vZGVsQ29udGVudCIsIkh0dHBSZXNwb25zZSIsImNvbnN0cnVjdG9yIiwiaGVhZGVycyIsInBhaXIiLCJlbnRyaWVzIiwicmVzcG9uc2VJbnRlcm5hbCIsImpzb24iLCJHZW5lcmF0ZUNvbnRlbnRSZXNwb25zZVByb21wdEZlZWRiYWNrIiwiR2VuZXJhdGVDb250ZW50UmVzcG9uc2VVc2FnZU1ldGFkYXRhIiwiR2VuZXJhdGVDb250ZW50UmVzcG9uc2UiLCJfZCIsIl9lIiwiX2YiLCJfZyIsIl9oIiwiY2FuZGlkYXRlcyIsImNvbnRlbnQiLCJjb25zb2xlIiwid2FybiIsImFueVRleHRQYXJ0VGV4dCIsIm5vblRleHRQYXJ0cyIsImZpZWxkTmFtZSIsImZpZWxkVmFsdWUiLCJ0aG91Z2h0Iiwibm9uRGF0YVBhcnRzIiwiYXRvYiIsImJ0b2EiLCJmdW5jdGlvbkNhbGxzIiwiZmlsdGVyIiwiX2oiLCJFbWJlZENvbnRlbnRSZXNwb25zZSIsIkdlbmVyYXRlSW1hZ2VzUmVzcG9uc2UiLCJFZGl0SW1hZ2VSZXNwb25zZSIsIlVwc2NhbGVJbWFnZVJlc3BvbnNlIiwiTGlzdE1vZGVsc1Jlc3BvbnNlIiwiRGVsZXRlTW9kZWxSZXNwb25zZSIsIkNvdW50VG9rZW5zUmVzcG9uc2UiLCJDb21wdXRlVG9rZW5zUmVzcG9uc2UiLCJHZW5lcmF0ZVZpZGVvc1Jlc3BvbnNlIiwiTGlzdFR1bmluZ0pvYnNSZXNwb25zZSIsIkRlbGV0ZUNhY2hlZENvbnRlbnRSZXNwb25zZSIsIkxpc3RDYWNoZWRDb250ZW50c1Jlc3BvbnNlIiwiTGlzdEZpbGVzUmVzcG9uc2UiLCJDcmVhdGVGaWxlUmVzcG9uc2UiLCJEZWxldGVGaWxlUmVzcG9uc2UiLCJJbmxpbmVkUmVzcG9uc2UiLCJMaXN0QmF0Y2hKb2JzUmVzcG9uc2UiLCJSZXBsYXlSZXNwb25zZSIsIlJhd1JlZmVyZW5jZUltYWdlIiwidG9SZWZlcmVuY2VJbWFnZUFQSSIsInJlZmVyZW5jZUltYWdlQVBJIiwicmVmZXJlbmNlVHlwZSIsInJlZmVyZW5jZUltYWdlIiwicmVmZXJlbmNlSWQiLCJNYXNrUmVmZXJlbmNlSW1hZ2UiLCJtYXNrSW1hZ2VDb25maWciLCJjb25maWciLCJDb250cm9sUmVmZXJlbmNlSW1hZ2UiLCJjb250cm9sSW1hZ2VDb25maWciLCJTdHlsZVJlZmVyZW5jZUltYWdlIiwic3R5bGVJbWFnZUNvbmZpZyIsIlN1YmplY3RSZWZlcmVuY2VJbWFnZSIsInN1YmplY3RJbWFnZUNvbmZpZyIsIkxpdmVTZXJ2ZXJNZXNzYWdlIiwiYW55VGV4dFBhcnRGb3VuZCIsInNlcnZlckNvbnRlbnQiLCJtb2RlbFR1cm4iLCJMaXZlQ2xpZW50VG9vbFJlc3BvbnNlIiwiTGl2ZVNlbmRUb29sUmVzcG9uc2VQYXJhbWV0ZXJzIiwiZnVuY3Rpb25SZXNwb25zZXMiLCJMaXZlTXVzaWNTZXJ2ZXJNZXNzYWdlIiwiYXVkaW9DaHVuayIsImF1ZGlvQ2h1bmtzIiwidE1vZGVsIiwiYXBpQ2xpZW50IiwibW9kZWwiLCJpc1ZlcnRleEFJIiwic3RhcnRzV2l0aCIsImluZGV4T2YiLCJzcGxpdCIsInRDYWNoZXNNb2RlbCIsInRyYW5zZm9ybWVkTW9kZWwiLCJnZXRQcm9qZWN0IiwiZ2V0TG9jYXRpb24iLCJ0QmxvYnMiLCJibG9icyIsImJsb2IiLCJ0QmxvYiIsInRJbWFnZUJsb2IiLCJ0cmFuc2Zvcm1lZEJsb2IiLCJ0QXVkaW9CbG9iIiwidFBhcnQiLCJvcmlnaW4iLCJ0UGFydHMiLCJpdGVtIiwiX2lzQ29udGVudCIsIl9pc0Z1bmN0aW9uQ2FsbFBhcnQiLCJfaXNGdW5jdGlvblJlc3BvbnNlUGFydCIsInRDb250ZW50IiwidENvbnRlbnRzRm9yRW1iZWQiLCJmbGF0TWFwIiwidENvbnRlbnRzIiwicmVzdWx0IiwiYWNjdW11bGF0ZWRQYXJ0cyIsImlzQ29udGVudEFycmF5IiwiaXNDb250ZW50Iiwic3VwcG9ydGVkSnNvblNjaGVtYUZpZWxkcyIsIlNldCIsImpzb25TY2hlbWFUeXBlVmFsaWRhdG9yIiwiZW51bSIsInNjaGVtYVR5cGVVbmlvbiIsInVuaW9uIiwiYXJyYXkiLCJjcmVhdGVKc29uU2NoZW1hVmFsaWRhdG9yIiwic3RyaWN0TW9kZSIsImpzb25TY2hlbWFWYWxpZGF0b3IiLCJsYXp5IiwiYmFzZVNoYXBlIiwib2JqZWN0IiwidHlwZSIsIm9wdGlvbmFsIiwiZm9ybWF0Iiwic3RyaW5nIiwidGl0bGUiLCJkZXNjcmlwdGlvbiIsImRlZmF1bHQiLCJ1bmtub3duIiwiaXRlbXMiLCJtaW5JdGVtcyIsImNvZXJjZSIsIm1heEl0ZW1zIiwicHJvcGVydGllcyIsInJlY29yZCIsInJlcXVpcmVkIiwibWluUHJvcGVydGllcyIsIm1heFByb3BlcnRpZXMiLCJwcm9wZXJ0eU9yZGVyaW5nIiwibWluaW11bSIsIm51bWJlciIsIm1heGltdW0iLCJtaW5MZW5ndGgiLCJtYXhMZW5ndGgiLCJwYXR0ZXJuIiwiYW55T2YiLCJhZGRpdGlvbmFsUHJvcGVydGllcyIsImJvb2xlYW4iLCJzdHJpY3QiLCJmbGF0dGVuVHlwZUFycmF5VG9BbnlPZiIsInR5cGVMaXN0IiwicmVzdWx0aW5nU2NoZW1hIiwiaW5jbHVkZXMiLCJsaXN0V2l0aG91dE51bGwiLCJ2YWx1ZXMiLCJ0b1VwcGVyQ2FzZSIsIlRZUEVfVU5TUEVDSUZJRUQiLCJwcm9jZXNzSnNvblNjaGVtYSIsIl9qc29uU2NoZW1hIiwiZ2VuQUlTY2hlbWEiLCJzY2hlbWFGaWVsZE5hbWVzIiwibGlzdFNjaGVtYUZpZWxkTmFtZXMiLCJkaWN0U2NoZW1hRmllbGROYW1lcyIsImluY29taW5nQW55T2YiLCJsaXN0U2NoZW1hRmllbGRWYWx1ZSIsImRpY3RTY2hlbWFGaWVsZFZhbHVlIiwidFNjaGVtYSIsInNjaGVtYSIsInZhbGlkYXRlZEpzb25TY2hlbWEiLCJwYXJzZSIsInRTcGVlY2hDb25maWciLCJzcGVlY2hDb25maWciLCJ2b2ljZUNvbmZpZyIsInByZWJ1aWx0Vm9pY2VDb25maWciLCJ2b2ljZU5hbWUiLCJ0TGl2ZVNwZWVjaENvbmZpZyIsInRUb29sIiwidG9vbCIsImZ1bmN0aW9uRGVjbGFyYXRpb25zIiwiZnVuY3Rpb25EZWNsYXJhdGlvbiIsInBhcmFtZXRlcnMiLCJ0VG9vbHMiLCJ0b29scyIsInJlc291cmNlTmFtZSIsImNsaWVudCIsInJlc291cmNlUHJlZml4Iiwic3BsaXRzQWZ0ZXJQcmVmaXgiLCJzaG91bGRBcHBlbmRQcmVmaXgiLCJ0Q2FjaGVkQ29udGVudE5hbWUiLCJ0VHVuaW5nSm9iU3RhdHVzIiwic3RhdHVzIiwidEJ5dGVzIiwiZnJvbUltYWdlQnl0ZXMiLCJfaXNGaWxlIiwiaXNHZW5lcmF0ZWRWaWRlbyIsImlzVmlkZW8iLCJ0RmlsZU5hbWUiLCJmcm9tTmFtZSIsInZpZGVvIiwic3VmZml4IiwidE1vZGVsc1VybCIsImJhc2VNb2RlbHMiLCJyZXMiLCJ0RXh0cmFjdE1vZGVscyIsImhhc0ZpZWxkIiwibWNwVG9HZW1pbmlUb29sIiwibWNwVG9vbCIsIm1jcFRvb2xTY2hlbWEiLCJmaWx0ZXJUb0pzb25TY2hlbWEiLCJiZWhhdmlvciIsImdlbWluaVRvb2wiLCJtY3BUb29sc1RvR2VtaW5pVG9vbCIsIm1jcFRvb2xzIiwidG9vbE5hbWVzIiwibWNwVG9vbE5hbWUiLCJoYXMiLCJhZGQiLCJmaWx0ZXJMaXN0U2NoZW1hRmllbGQiLCJsaXN0RmllbGRWYWx1ZSIsImZpbHRlckRpY3RTY2hlbWFGaWVsZCIsInZhbHVlUmVjb3JkIiwiZmlsdGVyZWRTY2hlbWEiLCJ0eXBlVmFsdWUiLCJ0QmF0Y2hKb2JTb3VyY2UiLCJzcmMiLCJnY3NVcmkiLCJiaWdxdWVyeVVyaSIsImlubGluZWRSZXF1ZXN0cyIsImZpbGVOYW1lIiwidEJhdGNoSm9iRGVzdGluYXRpb24iLCJkZXN0IiwiZGVzdFN0cmluZyIsInRCYXRjaEpvYk5hbWUiLCJuYW1lU3RyaW5nIiwibWxkZXZQYXR0ZXJuIiwidGVzdCIsInBvcCIsInZlcnRleFBhdHRlcm4iLCJ0Sm9iU3RhdGUiLCJzdGF0ZSIsInN0YXRlU3RyaW5nIiwidmlkZW9NZXRhZGF0YVRvTWxkZXYkNCIsImZyb21PYmplY3QiLCJ0b09iamVjdCIsImZyb21GcHMiLCJmcm9tRW5kT2Zmc2V0IiwiZnJvbVN0YXJ0T2Zmc2V0IiwiYmxvYlRvTWxkZXYkNCIsImZyb21EYXRhIiwiZnJvbU1pbWVUeXBlIiwiZmlsZURhdGFUb01sZGV2JDQiLCJmcm9tRmlsZVVyaSIsInBhcnRUb01sZGV2JDQiLCJmcm9tVmlkZW9NZXRhZGF0YSIsImZyb21UaG91Z2h0IiwiZnJvbUlubGluZURhdGEiLCJmcm9tRmlsZURhdGEiLCJmcm9tVGhvdWdodFNpZ25hdHVyZSIsImZyb21Db2RlRXhlY3V0aW9uUmVzdWx0IiwiZnJvbUV4ZWN1dGFibGVDb2RlIiwiZnJvbUZ1bmN0aW9uQ2FsbCIsImZyb21GdW5jdGlvblJlc3BvbnNlIiwiZnJvbVRleHQiLCJjb250ZW50VG9NbGRldiQ0IiwiZnJvbVBhcnRzIiwidHJhbnNmb3JtZWRMaXN0IiwiZnJvbVJvbGUiLCJzY2hlbWFUb01sZGV2JDEiLCJmcm9tQW55T2YiLCJmcm9tRGVmYXVsdCIsImZyb21EZXNjcmlwdGlvbiIsImZyb21FbnVtIiwiZnJvbUV4YW1wbGUiLCJmcm9tRm9ybWF0IiwiZnJvbUl0ZW1zIiwiZnJvbU1heEl0ZW1zIiwiZnJvbU1heExlbmd0aCIsImZyb21NYXhQcm9wZXJ0aWVzIiwiZnJvbU1heGltdW0iLCJmcm9tTWluSXRlbXMiLCJmcm9tTWluTGVuZ3RoIiwiZnJvbU1pblByb3BlcnRpZXMiLCJmcm9tTWluaW11bSIsImZyb21OdWxsYWJsZSIsImZyb21QYXR0ZXJuIiwiZnJvbVByb3BlcnRpZXMiLCJmcm9tUHJvcGVydHlPcmRlcmluZyIsImZyb21SZXF1aXJlZCIsImZyb21UaXRsZSIsImZyb21UeXBlIiwic2FmZXR5U2V0dGluZ1RvTWxkZXYkMSIsImZyb21DYXRlZ29yeSIsImZyb21UaHJlc2hvbGQiLCJmdW5jdGlvbkRlY2xhcmF0aW9uVG9NbGRldiQ0IiwiZnJvbUJlaGF2aW9yIiwiZnJvbVBhcmFtZXRlcnMiLCJmcm9tUGFyYW1ldGVyc0pzb25TY2hlbWEiLCJmcm9tUmVzcG9uc2UiLCJmcm9tUmVzcG9uc2VKc29uU2NoZW1hIiwiaW50ZXJ2YWxUb01sZGV2JDQiLCJmcm9tU3RhcnRUaW1lIiwiZnJvbUVuZFRpbWUiLCJnb29nbGVTZWFyY2hUb01sZGV2JDQiLCJmcm9tVGltZVJhbmdlRmlsdGVyIiwiZHluYW1pY1JldHJpZXZhbENvbmZpZ1RvTWxkZXYkNCIsImZyb21Nb2RlIiwiZnJvbUR5bmFtaWNUaHJlc2hvbGQiLCJnb29nbGVTZWFyY2hSZXRyaWV2YWxUb01sZGV2JDQiLCJmcm9tRHluYW1pY1JldHJpZXZhbENvbmZpZyIsInVybENvbnRleHRUb01sZGV2JDQiLCJ0b29sVG9NbGRldiQ0IiwiZnJvbUZ1bmN0aW9uRGVjbGFyYXRpb25zIiwiZnJvbUdvb2dsZVNlYXJjaCIsImZyb21Hb29nbGVTZWFyY2hSZXRyaWV2YWwiLCJmcm9tVXJsQ29udGV4dCIsImZyb21Db2RlRXhlY3V0aW9uIiwiZnVuY3Rpb25DYWxsaW5nQ29uZmlnVG9NbGRldiQyIiwiZnJvbUFsbG93ZWRGdW5jdGlvbk5hbWVzIiwibGF0TG5nVG9NbGRldiQyIiwiZnJvbUxhdGl0dWRlIiwiZnJvbUxvbmdpdHVkZSIsInJldHJpZXZhbENvbmZpZ1RvTWxkZXYkMiIsImZyb21MYXRMbmciLCJmcm9tTGFuZ3VhZ2VDb2RlIiwidG9vbENvbmZpZ1RvTWxkZXYkMiIsImZyb21GdW5jdGlvbkNhbGxpbmdDb25maWciLCJmcm9tUmV0cmlldmFsQ29uZmlnIiwicHJlYnVpbHRWb2ljZUNvbmZpZ1RvTWxkZXYkMyIsImZyb21Wb2ljZU5hbWUiLCJ2b2ljZUNvbmZpZ1RvTWxkZXYkMyIsImZyb21QcmVidWlsdFZvaWNlQ29uZmlnIiwic3BlYWtlclZvaWNlQ29uZmlnVG9NbGRldiQzIiwiZnJvbVNwZWFrZXIiLCJmcm9tVm9pY2VDb25maWciLCJtdWx0aVNwZWFrZXJWb2ljZUNvbmZpZ1RvTWxkZXYkMyIsImZyb21TcGVha2VyVm9pY2VDb25maWdzIiwic3BlZWNoQ29uZmlnVG9NbGRldiQzIiwiZnJvbU11bHRpU3BlYWtlclZvaWNlQ29uZmlnIiwidGhpbmtpbmdDb25maWdUb01sZGV2JDEiLCJmcm9tSW5jbHVkZVRob3VnaHRzIiwiZnJvbVRoaW5raW5nQnVkZ2V0IiwiZ2VuZXJhdGVDb250ZW50Q29uZmlnVG9NbGRldiQxIiwicGFyZW50T2JqZWN0IiwiZnJvbVN5c3RlbUluc3RydWN0aW9uIiwiZnJvbVRlbXBlcmF0dXJlIiwiZnJvbVRvcFAiLCJmcm9tVG9wSyIsImZyb21DYW5kaWRhdGVDb3VudCIsImZyb21NYXhPdXRwdXRUb2tlbnMiLCJmcm9tU3RvcFNlcXVlbmNlcyIsImZyb21SZXNwb25zZUxvZ3Byb2JzIiwiZnJvbUxvZ3Byb2JzIiwiZnJvbVByZXNlbmNlUGVuYWx0eSIsImZyb21GcmVxdWVuY3lQZW5hbHR5IiwiZnJvbVNlZWQiLCJmcm9tUmVzcG9uc2VNaW1lVHlwZSIsImZyb21SZXNwb25zZVNjaGVtYSIsImZyb21TYWZldHlTZXR0aW5ncyIsImZyb21Ub29scyIsImZyb21Ub29sQ29uZmlnIiwiZnJvbUNhY2hlZENvbnRlbnQiLCJmcm9tUmVzcG9uc2VNb2RhbGl0aWVzIiwiZnJvbU1lZGlhUmVzb2x1dGlvbiIsImZyb21TcGVlY2hDb25maWciLCJmcm9tVGhpbmtpbmdDb25maWciLCJpbmxpbmVkUmVxdWVzdFRvTWxkZXYiLCJmcm9tTW9kZWwiLCJmcm9tQ29udGVudHMiLCJmcm9tQ29uZmlnIiwiYmF0Y2hKb2JTb3VyY2VUb01sZGV2IiwiZnJvbUZpbGVOYW1lIiwiZnJvbUlubGluZWRSZXF1ZXN0cyIsImNyZWF0ZUJhdGNoSm9iQ29uZmlnVG9NbGRldiIsImZyb21EaXNwbGF5TmFtZSIsImNyZWF0ZUJhdGNoSm9iUGFyYW1ldGVyc1RvTWxkZXYiLCJmcm9tU3JjIiwiZ2V0QmF0Y2hKb2JQYXJhbWV0ZXJzVG9NbGRldiIsImNhbmNlbEJhdGNoSm9iUGFyYW1ldGVyc1RvTWxkZXYiLCJsaXN0QmF0Y2hKb2JzQ29uZmlnVG9NbGRldiIsImZyb21QYWdlU2l6ZSIsImZyb21QYWdlVG9rZW4iLCJsaXN0QmF0Y2hKb2JzUGFyYW1ldGVyc1RvTWxkZXYiLCJiYXRjaEpvYlNvdXJjZVRvVmVydGV4IiwiZnJvbUdjc1VyaSIsImZyb21CaWdxdWVyeVVyaSIsImJhdGNoSm9iRGVzdGluYXRpb25Ub1ZlcnRleCIsImNyZWF0ZUJhdGNoSm9iQ29uZmlnVG9WZXJ0ZXgiLCJmcm9tRGVzdCIsImNyZWF0ZUJhdGNoSm9iUGFyYW1ldGVyc1RvVmVydGV4IiwiZ2V0QmF0Y2hKb2JQYXJhbWV0ZXJzVG9WZXJ0ZXgiLCJjYW5jZWxCYXRjaEpvYlBhcmFtZXRlcnNUb1ZlcnRleCIsImxpc3RCYXRjaEpvYnNDb25maWdUb1ZlcnRleCIsImZyb21GaWx0ZXIiLCJsaXN0QmF0Y2hKb2JzUGFyYW1ldGVyc1RvVmVydGV4Iiwiam9iRXJyb3JGcm9tTWxkZXYiLCJ2aWRlb01ldGFkYXRhRnJvbU1sZGV2JDIiLCJibG9iRnJvbU1sZGV2JDIiLCJmaWxlRGF0YUZyb21NbGRldiQyIiwicGFydEZyb21NbGRldiQyIiwiY29udGVudEZyb21NbGRldiQyIiwiY2l0YXRpb25NZXRhZGF0YUZyb21NbGRldiQxIiwiZnJvbUNpdGF0aW9ucyIsInVybE1ldGFkYXRhRnJvbU1sZGV2JDIiLCJmcm9tUmV0cmlldmVkVXJsIiwiZnJvbVVybFJldHJpZXZhbFN0YXR1cyIsInVybENvbnRleHRNZXRhZGF0YUZyb21NbGRldiQyIiwiZnJvbVVybE1ldGFkYXRhIiwiY2FuZGlkYXRlRnJvbU1sZGV2JDEiLCJmcm9tQ29udGVudCIsImZyb21DaXRhdGlvbk1ldGFkYXRhIiwiZnJvbVRva2VuQ291bnQiLCJmcm9tRmluaXNoUmVhc29uIiwiZnJvbVVybENvbnRleHRNZXRhZGF0YSIsImZyb21BdmdMb2dwcm9icyIsImZyb21Hcm91bmRpbmdNZXRhZGF0YSIsImZyb21JbmRleCIsImZyb21Mb2dwcm9ic1Jlc3VsdCIsImZyb21TYWZldHlSYXRpbmdzIiwiZ2VuZXJhdGVDb250ZW50UmVzcG9uc2VGcm9tTWxkZXYkMSIsImZyb21DYW5kaWRhdGVzIiwiZnJvbU1vZGVsVmVyc2lvbiIsImZyb21Qcm9tcHRGZWVkYmFjayIsImZyb21Vc2FnZU1ldGFkYXRhIiwiaW5saW5lZFJlc3BvbnNlRnJvbU1sZGV2IiwiZnJvbUVycm9yIiwiYmF0Y2hKb2JEZXN0aW5hdGlvbkZyb21NbGRldiIsImZyb21JbmxpbmVkUmVzcG9uc2VzIiwiYmF0Y2hKb2JGcm9tTWxkZXYiLCJmcm9tU3RhdGUiLCJmcm9tQ3JlYXRlVGltZSIsImZyb21VcGRhdGVUaW1lIiwibGlzdEJhdGNoSm9ic1Jlc3BvbnNlRnJvbU1sZGV2IiwiZnJvbU5leHRQYWdlVG9rZW4iLCJmcm9tQmF0Y2hKb2JzIiwiam9iRXJyb3JGcm9tVmVydGV4IiwiZnJvbURldGFpbHMiLCJmcm9tQ29kZSIsImZyb21NZXNzYWdlIiwiYmF0Y2hKb2JTb3VyY2VGcm9tVmVydGV4IiwiYmF0Y2hKb2JEZXN0aW5hdGlvbkZyb21WZXJ0ZXgiLCJiYXRjaEpvYkZyb21WZXJ0ZXgiLCJsaXN0QmF0Y2hKb2JzUmVzcG9uc2VGcm9tVmVydGV4IiwiUGFnZWRJdGVtIiwiUGFnZXIiLCJyZXF1ZXN0IiwicGFyYW1zIiwicGFnZUludGVybmFsIiwicGFyYW1zSW50ZXJuYWwiLCJyZXF1ZXN0SW50ZXJuYWwiLCJpbml0IiwibmFtZUludGVybmFsIiwiaWR4SW50ZXJuYWwiLCJyZXF1ZXN0UGFyYW1zIiwicGFnZUludGVybmFsU2l6ZSIsImluaXROZXh0UGFnZSIsInBhZ2UiLCJwYWdlU2l6ZSIsInBhZ2VMZW5ndGgiLCJnZXRJdGVtIiwiaW5kZXgiLCJTeW1ib2wiLCJhc3luY0l0ZXJhdG9yIiwibmV4dCIsImhhc05leHRQYWdlIiwibmV4dFBhZ2UiLCJkb25lIiwicmV0dXJuIiwiQmF0Y2hlcyIsImNyZWF0ZSIsImRpc3BsYXlOYW1lIiwiY3JlYXRlSW50ZXJuYWwiLCJsaXN0IiwiUEFHRURfSVRFTV9CQVRDSF9KT0JTIiwieCIsImxpc3RJbnRlcm5hbCIsInBhdGgiLCJxdWVyeVBhcmFtcyIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5IiwiaHR0cE1ldGhvZCIsImFib3J0U2lnbmFsIiwidGhlbiIsImh0dHBSZXNwb25zZSIsImFwaVJlc3BvbnNlIiwicmVzcCIsImdldCIsImNhbmNlbCIsInR5cGVkUmVzcCIsInZpZGVvTWV0YWRhdGFUb01sZGV2JDMiLCJibG9iVG9NbGRldiQzIiwiZmlsZURhdGFUb01sZGV2JDMiLCJwYXJ0VG9NbGRldiQzIiwiY29udGVudFRvTWxkZXYkMyIsImZ1bmN0aW9uRGVjbGFyYXRpb25Ub01sZGV2JDMiLCJpbnRlcnZhbFRvTWxkZXYkMyIsImdvb2dsZVNlYXJjaFRvTWxkZXYkMyIsImR5bmFtaWNSZXRyaWV2YWxDb25maWdUb01sZGV2JDMiLCJnb29nbGVTZWFyY2hSZXRyaWV2YWxUb01sZGV2JDMiLCJ1cmxDb250ZXh0VG9NbGRldiQzIiwidG9vbFRvTWxkZXYkMyIsImZ1bmN0aW9uQ2FsbGluZ0NvbmZpZ1RvTWxkZXYkMSIsImxhdExuZ1RvTWxkZXYkMSIsInJldHJpZXZhbENvbmZpZ1RvTWxkZXYkMSIsInRvb2xDb25maWdUb01sZGV2JDEiLCJjcmVhdGVDYWNoZWRDb250ZW50Q29uZmlnVG9NbGRldiIsImZyb21UdGwiLCJmcm9tRXhwaXJlVGltZSIsImNyZWF0ZUNhY2hlZENvbnRlbnRQYXJhbWV0ZXJzVG9NbGRldiIsImdldENhY2hlZENvbnRlbnRQYXJhbWV0ZXJzVG9NbGRldiIsImRlbGV0ZUNhY2hlZENvbnRlbnRQYXJhbWV0ZXJzVG9NbGRldiIsInVwZGF0ZUNhY2hlZENvbnRlbnRDb25maWdUb01sZGV2IiwidXBkYXRlQ2FjaGVkQ29udGVudFBhcmFtZXRlcnNUb01sZGV2IiwibGlzdENhY2hlZENvbnRlbnRzQ29uZmlnVG9NbGRldiIsImxpc3RDYWNoZWRDb250ZW50c1BhcmFtZXRlcnNUb01sZGV2IiwidmlkZW9NZXRhZGF0YVRvVmVydGV4JDIiLCJibG9iVG9WZXJ0ZXgkMiIsImZpbGVEYXRhVG9WZXJ0ZXgkMiIsInBhcnRUb1ZlcnRleCQyIiwiY29udGVudFRvVmVydGV4JDIiLCJmdW5jdGlvbkRlY2xhcmF0aW9uVG9WZXJ0ZXgkMiIsImludGVydmFsVG9WZXJ0ZXgkMiIsImdvb2dsZVNlYXJjaFRvVmVydGV4JDIiLCJkeW5hbWljUmV0cmlldmFsQ29uZmlnVG9WZXJ0ZXgkMiIsImdvb2dsZVNlYXJjaFJldHJpZXZhbFRvVmVydGV4JDIiLCJlbnRlcnByaXNlV2ViU2VhcmNoVG9WZXJ0ZXgkMiIsImFwaUtleUNvbmZpZ1RvVmVydGV4JDIiLCJmcm9tQXBpS2V5U3RyaW5nIiwiYXV0aENvbmZpZ1RvVmVydGV4JDIiLCJmcm9tQXBpS2V5Q29uZmlnIiwiZnJvbUF1dGhUeXBlIiwiZnJvbUdvb2dsZVNlcnZpY2VBY2NvdW50Q29uZmlnIiwiZnJvbUh0dHBCYXNpY0F1dGhDb25maWciLCJmcm9tT2F1dGhDb25maWciLCJmcm9tT2lkY0NvbmZpZyIsImdvb2dsZU1hcHNUb1ZlcnRleCQyIiwiZnJvbUF1dGhDb25maWciLCJ1cmxDb250ZXh0VG9WZXJ0ZXgkMiIsInRvb2xUb1ZlcnRleCQyIiwiZnJvbVJldHJpZXZhbCIsImZyb21FbnRlcnByaXNlV2ViU2VhcmNoIiwiZnJvbUdvb2dsZU1hcHMiLCJmdW5jdGlvbkNhbGxpbmdDb25maWdUb1ZlcnRleCQxIiwibGF0TG5nVG9WZXJ0ZXgkMSIsInJldHJpZXZhbENvbmZpZ1RvVmVydGV4JDEiLCJ0b29sQ29uZmlnVG9WZXJ0ZXgkMSIsImNyZWF0ZUNhY2hlZENvbnRlbnRDb25maWdUb1ZlcnRleCIsImZyb21LbXNLZXlOYW1lIiwiY3JlYXRlQ2FjaGVkQ29udGVudFBhcmFtZXRlcnNUb1ZlcnRleCIsImdldENhY2hlZENvbnRlbnRQYXJhbWV0ZXJzVG9WZXJ0ZXgiLCJkZWxldGVDYWNoZWRDb250ZW50UGFyYW1ldGVyc1RvVmVydGV4IiwidXBkYXRlQ2FjaGVkQ29udGVudENvbmZpZ1RvVmVydGV4IiwidXBkYXRlQ2FjaGVkQ29udGVudFBhcmFtZXRlcnNUb1ZlcnRleCIsImxpc3RDYWNoZWRDb250ZW50c0NvbmZpZ1RvVmVydGV4IiwibGlzdENhY2hlZENvbnRlbnRzUGFyYW1ldGVyc1RvVmVydGV4IiwiY2FjaGVkQ29udGVudEZyb21NbGRldiIsImRlbGV0ZUNhY2hlZENvbnRlbnRSZXNwb25zZUZyb21NbGRldiIsImxpc3RDYWNoZWRDb250ZW50c1Jlc3BvbnNlRnJvbU1sZGV2IiwiZnJvbUNhY2hlZENvbnRlbnRzIiwiY2FjaGVkQ29udGVudEZyb21WZXJ0ZXgiLCJkZWxldGVDYWNoZWRDb250ZW50UmVzcG9uc2VGcm9tVmVydGV4IiwibGlzdENhY2hlZENvbnRlbnRzUmVzcG9uc2VGcm9tVmVydGV4IiwiQ2FjaGVzIiwiUEFHRURfSVRFTV9DQUNIRURfQ09OVEVOVFMiLCJkZWxldGUiLCJ1cGRhdGUiLCJfX3ZhbHVlcyIsIm8iLCJzIiwiaXRlcmF0b3IiLCJtIiwiX19hd2FpdCIsInYiLCJfX2FzeW5jR2VuZXJhdG9yIiwidGhpc0FyZyIsIl9hcmd1bWVudHMiLCJnZW5lcmF0b3IiLCJnIiwiYXBwbHkiLCJxIiwiQXN5bmNJdGVyYXRvciIsInZlcmIiLCJhd2FpdFJldHVybiIsImYiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsIm4iLCJhIiwiYiIsInJlc3VtZSIsInN0ZXAiLCJlIiwic2V0dGxlIiwiciIsImZ1bGZpbGwiLCJzaGlmdCIsIl9fYXN5bmNWYWx1ZXMiLCJTdXBwcmVzc2VkRXJyb3IiLCJzdXBwcmVzc2VkIiwibWVzc2FnZSIsImlzVmFsaWRSZXNwb25zZSIsImlzVmFsaWRDb250ZW50IiwidmFsaWRhdGVIaXN0b3J5IiwiaGlzdG9yeSIsImV4dHJhY3RDdXJhdGVkSGlzdG9yeSIsImNvbXByZWhlbnNpdmVIaXN0b3J5IiwiY3VyYXRlZEhpc3RvcnkiLCJtb2RlbE91dHB1dCIsImlzVmFsaWQiLCJDaGF0cyIsIm1vZGVsc01vZHVsZSIsIkNoYXQiLCJzdHJ1Y3R1cmVkQ2xvbmUiLCJzZW5kUHJvbWlzZSIsInNlbmRNZXNzYWdlIiwiaW5wdXRDb250ZW50IiwicmVzcG9uc2VQcm9taXNlIiwiZ2VuZXJhdGVDb250ZW50IiwiY29udGVudHMiLCJnZXRIaXN0b3J5IiwiY29uY2F0Iiwib3V0cHV0Q29udGVudCIsImZ1bGxBdXRvbWF0aWNGdW5jdGlvbkNhbGxpbmdIaXN0b3J5IiwiYXV0b21hdGljRnVuY3Rpb25DYWxsaW5nSGlzdG9yeSIsInJlY29yZEhpc3RvcnkiLCJjYXRjaCIsInNlbmRNZXNzYWdlU3RyZWFtIiwic3RyZWFtUmVzcG9uc2UiLCJnZW5lcmF0ZUNvbnRlbnRTdHJlYW0iLCJwcm9jZXNzU3RyZWFtUmVzcG9uc2UiLCJjdXJhdGVkIiwiYXJndW1lbnRzIiwicHJvY2Vzc1N0cmVhbVJlc3BvbnNlXzEiLCJlXzEiLCJzdHJlYW1SZXNwb25zZV8xIiwic3RyZWFtUmVzcG9uc2VfMV8xIiwiY2h1bmsiLCJlXzFfMSIsInVzZXJJbnB1dCIsIm91dHB1dENvbnRlbnRzIiwiZXZlcnkiLCJBcGlFcnJvciIsInNldFByb3RvdHlwZU9mIiwibGlzdEZpbGVzQ29uZmlnVG9NbGRldiIsImxpc3RGaWxlc1BhcmFtZXRlcnNUb01sZGV2IiwiZmlsZVN0YXR1c1RvTWxkZXYiLCJmaWxlVG9NbGRldiIsImZyb21TaXplQnl0ZXMiLCJmcm9tRXhwaXJhdGlvblRpbWUiLCJmcm9tU2hhMjU2SGFzaCIsImZyb21VcmkiLCJmcm9tRG93bmxvYWRVcmkiLCJmcm9tU291cmNlIiwiY3JlYXRlRmlsZVBhcmFtZXRlcnNUb01sZGV2IiwiZnJvbUZpbGUiLCJnZXRGaWxlUGFyYW1ldGVyc1RvTWxkZXYiLCJkZWxldGVGaWxlUGFyYW1ldGVyc1RvTWxkZXYiLCJmaWxlU3RhdHVzRnJvbU1sZGV2IiwiZmlsZUZyb21NbGRldiIsImxpc3RGaWxlc1Jlc3BvbnNlRnJvbU1sZGV2IiwiZnJvbUZpbGVzIiwiY3JlYXRlRmlsZVJlc3BvbnNlRnJvbU1sZGV2IiwiZGVsZXRlRmlsZVJlc3BvbnNlRnJvbU1sZGV2IiwiRmlsZXMiLCJQQUdFRF9JVEVNX0ZJTEVTIiwidXBsb2FkIiwidXBsb2FkRmlsZSIsImZpbGUiLCJkb3dubG9hZCIsImRvd25sb2FkRmlsZSIsInByZWJ1aWx0Vm9pY2VDb25maWdUb01sZGV2JDIiLCJwcmVidWlsdFZvaWNlQ29uZmlnVG9WZXJ0ZXgkMSIsInZvaWNlQ29uZmlnVG9NbGRldiQyIiwidm9pY2VDb25maWdUb1ZlcnRleCQxIiwic3BlYWtlclZvaWNlQ29uZmlnVG9NbGRldiQyIiwibXVsdGlTcGVha2VyVm9pY2VDb25maWdUb01sZGV2JDIiLCJzcGVlY2hDb25maWdUb01sZGV2JDIiLCJzcGVlY2hDb25maWdUb1ZlcnRleCQxIiwidmlkZW9NZXRhZGF0YVRvTWxkZXYkMiIsInZpZGVvTWV0YWRhdGFUb1ZlcnRleCQxIiwiYmxvYlRvTWxkZXYkMiIsImJsb2JUb1ZlcnRleCQxIiwiZmlsZURhdGFUb01sZGV2JDIiLCJmaWxlRGF0YVRvVmVydGV4JDEiLCJwYXJ0VG9NbGRldiQyIiwicGFydFRvVmVydGV4JDEiLCJjb250ZW50VG9NbGRldiQyIiwiY29udGVudFRvVmVydGV4JDEiLCJmdW5jdGlvbkRlY2xhcmF0aW9uVG9NbGRldiQyIiwiZnVuY3Rpb25EZWNsYXJhdGlvblRvVmVydGV4JDEiLCJpbnRlcnZhbFRvTWxkZXYkMiIsImludGVydmFsVG9WZXJ0ZXgkMSIsImdvb2dsZVNlYXJjaFRvTWxkZXYkMiIsImdvb2dsZVNlYXJjaFRvVmVydGV4JDEiLCJkeW5hbWljUmV0cmlldmFsQ29uZmlnVG9NbGRldiQyIiwiZHluYW1pY1JldHJpZXZhbENvbmZpZ1RvVmVydGV4JDEiLCJnb29nbGVTZWFyY2hSZXRyaWV2YWxUb01sZGV2JDIiLCJnb29nbGVTZWFyY2hSZXRyaWV2YWxUb1ZlcnRleCQxIiwiZW50ZXJwcmlzZVdlYlNlYXJjaFRvVmVydGV4JDEiLCJhcGlLZXlDb25maWdUb1ZlcnRleCQxIiwiYXV0aENvbmZpZ1RvVmVydGV4JDEiLCJnb29nbGVNYXBzVG9WZXJ0ZXgkMSIsInVybENvbnRleHRUb01sZGV2JDIiLCJ1cmxDb250ZXh0VG9WZXJ0ZXgkMSIsInRvb2xUb01sZGV2JDIiLCJ0b29sVG9WZXJ0ZXgkMSIsInNlc3Npb25SZXN1bXB0aW9uQ29uZmlnVG9NbGRldiQxIiwiZnJvbUhhbmRsZSIsInNlc3Npb25SZXN1bXB0aW9uQ29uZmlnVG9WZXJ0ZXgiLCJmcm9tVHJhbnNwYXJlbnQiLCJhdWRpb1RyYW5zY3JpcHRpb25Db25maWdUb01sZGV2JDEiLCJhdWRpb1RyYW5zY3JpcHRpb25Db25maWdUb1ZlcnRleCIsImF1dG9tYXRpY0FjdGl2aXR5RGV0ZWN0aW9uVG9NbGRldiQxIiwiZnJvbURpc2FibGVkIiwiZnJvbVN0YXJ0T2ZTcGVlY2hTZW5zaXRpdml0eSIsImZyb21FbmRPZlNwZWVjaFNlbnNpdGl2aXR5IiwiZnJvbVByZWZpeFBhZGRpbmdNcyIsImZyb21TaWxlbmNlRHVyYXRpb25NcyIsImF1dG9tYXRpY0FjdGl2aXR5RGV0ZWN0aW9uVG9WZXJ0ZXgiLCJyZWFsdGltZUlucHV0Q29uZmlnVG9NbGRldiQxIiwiZnJvbUF1dG9tYXRpY0FjdGl2aXR5RGV0ZWN0aW9uIiwiZnJvbUFjdGl2aXR5SGFuZGxpbmciLCJmcm9tVHVybkNvdmVyYWdlIiwicmVhbHRpbWVJbnB1dENvbmZpZ1RvVmVydGV4Iiwic2xpZGluZ1dpbmRvd1RvTWxkZXYkMSIsImZyb21UYXJnZXRUb2tlbnMiLCJzbGlkaW5nV2luZG93VG9WZXJ0ZXgiLCJjb250ZXh0V2luZG93Q29tcHJlc3Npb25Db25maWdUb01sZGV2JDEiLCJmcm9tVHJpZ2dlclRva2VucyIsImZyb21TbGlkaW5nV2luZG93IiwiY29udGV4dFdpbmRvd0NvbXByZXNzaW9uQ29uZmlnVG9WZXJ0ZXgiLCJwcm9hY3Rpdml0eUNvbmZpZ1RvTWxkZXYkMSIsImZyb21Qcm9hY3RpdmVBdWRpbyIsInByb2FjdGl2aXR5Q29uZmlnVG9WZXJ0ZXgiLCJsaXZlQ29ubmVjdENvbmZpZ1RvTWxkZXYkMSIsImZyb21HZW5lcmF0aW9uQ29uZmlnIiwiZnJvbUVuYWJsZUFmZmVjdGl2ZURpYWxvZyIsImZyb21TZXNzaW9uUmVzdW1wdGlvbiIsImZyb21JbnB1dEF1ZGlvVHJhbnNjcmlwdGlvbiIsImZyb21PdXRwdXRBdWRpb1RyYW5zY3JpcHRpb24iLCJmcm9tUmVhbHRpbWVJbnB1dENvbmZpZyIsImZyb21Db250ZXh0V2luZG93Q29tcHJlc3Npb24iLCJmcm9tUHJvYWN0aXZpdHkiLCJsaXZlQ29ubmVjdENvbmZpZ1RvVmVydGV4IiwibGl2ZUNvbm5lY3RQYXJhbWV0ZXJzVG9NbGRldiIsImxpdmVDb25uZWN0UGFyYW1ldGVyc1RvVmVydGV4IiwiYWN0aXZpdHlTdGFydFRvTWxkZXYiLCJhY3Rpdml0eVN0YXJ0VG9WZXJ0ZXgiLCJhY3Rpdml0eUVuZFRvTWxkZXYiLCJhY3Rpdml0eUVuZFRvVmVydGV4IiwibGl2ZVNlbmRSZWFsdGltZUlucHV0UGFyYW1ldGVyc1RvTWxkZXYiLCJmcm9tTWVkaWEiLCJmcm9tQXVkaW8iLCJmcm9tQXVkaW9TdHJlYW1FbmQiLCJmcm9tVmlkZW8iLCJmcm9tQWN0aXZpdHlTdGFydCIsImZyb21BY3Rpdml0eUVuZCIsImxpdmVTZW5kUmVhbHRpbWVJbnB1dFBhcmFtZXRlcnNUb1ZlcnRleCIsIndlaWdodGVkUHJvbXB0VG9NbGRldiIsImZyb21XZWlnaHQiLCJsaXZlTXVzaWNTZXRXZWlnaHRlZFByb21wdHNQYXJhbWV0ZXJzVG9NbGRldiIsImZyb21XZWlnaHRlZFByb21wdHMiLCJsaXZlTXVzaWNHZW5lcmF0aW9uQ29uZmlnVG9NbGRldiIsImZyb21HdWlkYW5jZSIsImZyb21CcG0iLCJmcm9tRGVuc2l0eSIsImZyb21CcmlnaHRuZXNzIiwiZnJvbVNjYWxlIiwiZnJvbU11dGVCYXNzIiwiZnJvbU11dGVEcnVtcyIsImZyb21Pbmx5QmFzc0FuZERydW1zIiwibGl2ZU11c2ljU2V0Q29uZmlnUGFyYW1ldGVyc1RvTWxkZXYiLCJmcm9tTXVzaWNHZW5lcmF0aW9uQ29uZmlnIiwibGl2ZU11c2ljQ2xpZW50U2V0dXBUb01sZGV2IiwibGl2ZU11c2ljQ2xpZW50Q29udGVudFRvTWxkZXYiLCJsaXZlTXVzaWNDbGllbnRNZXNzYWdlVG9NbGRldiIsImZyb21TZXR1cCIsImZyb21DbGllbnRDb250ZW50IiwiZnJvbVBsYXliYWNrQ29udHJvbCIsImxpdmVTZXJ2ZXJTZXR1cENvbXBsZXRlRnJvbU1sZGV2IiwibGl2ZVNlcnZlclNldHVwQ29tcGxldGVGcm9tVmVydGV4IiwidmlkZW9NZXRhZGF0YUZyb21NbGRldiQxIiwidmlkZW9NZXRhZGF0YUZyb21WZXJ0ZXgkMSIsImJsb2JGcm9tTWxkZXYkMSIsImJsb2JGcm9tVmVydGV4JDEiLCJmaWxlRGF0YUZyb21NbGRldiQxIiwiZmlsZURhdGFGcm9tVmVydGV4JDEiLCJwYXJ0RnJvbU1sZGV2JDEiLCJwYXJ0RnJvbVZlcnRleCQxIiwiY29udGVudEZyb21NbGRldiQxIiwiY29udGVudEZyb21WZXJ0ZXgkMSIsInRyYW5zY3JpcHRpb25Gcm9tTWxkZXYiLCJmcm9tRmluaXNoZWQiLCJ0cmFuc2NyaXB0aW9uRnJvbVZlcnRleCIsInVybE1ldGFkYXRhRnJvbU1sZGV2JDEiLCJ1cmxDb250ZXh0TWV0YWRhdGFGcm9tTWxkZXYkMSIsImxpdmVTZXJ2ZXJDb250ZW50RnJvbU1sZGV2IiwiZnJvbU1vZGVsVHVybiIsImZyb21UdXJuQ29tcGxldGUiLCJmcm9tSW50ZXJydXB0ZWQiLCJmcm9tR2VuZXJhdGlvbkNvbXBsZXRlIiwiZnJvbUlucHV0VHJhbnNjcmlwdGlvbiIsImZyb21PdXRwdXRUcmFuc2NyaXB0aW9uIiwibGl2ZVNlcnZlckNvbnRlbnRGcm9tVmVydGV4IiwiZnVuY3Rpb25DYWxsRnJvbU1sZGV2IiwiZnJvbUlkIiwiZnJvbUFyZ3MiLCJmdW5jdGlvbkNhbGxGcm9tVmVydGV4IiwibGl2ZVNlcnZlclRvb2xDYWxsRnJvbU1sZGV2IiwiZnJvbUZ1bmN0aW9uQ2FsbHMiLCJsaXZlU2VydmVyVG9vbENhbGxGcm9tVmVydGV4IiwibGl2ZVNlcnZlclRvb2xDYWxsQ2FuY2VsbGF0aW9uRnJvbU1sZGV2IiwiZnJvbUlkcyIsImxpdmVTZXJ2ZXJUb29sQ2FsbENhbmNlbGxhdGlvbkZyb21WZXJ0ZXgiLCJtb2RhbGl0eVRva2VuQ291bnRGcm9tTWxkZXYiLCJmcm9tTW9kYWxpdHkiLCJtb2RhbGl0eVRva2VuQ291bnRGcm9tVmVydGV4IiwidXNhZ2VNZXRhZGF0YUZyb21NbGRldiIsImZyb21Qcm9tcHRUb2tlbkNvdW50IiwiZnJvbUNhY2hlZENvbnRlbnRUb2tlbkNvdW50IiwiZnJvbVJlc3BvbnNlVG9rZW5Db3VudCIsImZyb21Ub29sVXNlUHJvbXB0VG9rZW5Db3VudCIsImZyb21UaG91Z2h0c1Rva2VuQ291bnQiLCJmcm9tVG90YWxUb2tlbkNvdW50IiwiZnJvbVByb21wdFRva2Vuc0RldGFpbHMiLCJmcm9tQ2FjaGVUb2tlbnNEZXRhaWxzIiwiZnJvbVJlc3BvbnNlVG9rZW5zRGV0YWlscyIsImZyb21Ub29sVXNlUHJvbXB0VG9rZW5zRGV0YWlscyIsInVzYWdlTWV0YWRhdGFGcm9tVmVydGV4IiwiZnJvbVRyYWZmaWNUeXBlIiwibGl2ZVNlcnZlckdvQXdheUZyb21NbGRldiIsImZyb21UaW1lTGVmdCIsImxpdmVTZXJ2ZXJHb0F3YXlGcm9tVmVydGV4IiwibGl2ZVNlcnZlclNlc3Npb25SZXN1bXB0aW9uVXBkYXRlRnJvbU1sZGV2IiwiZnJvbU5ld0hhbmRsZSIsImZyb21SZXN1bWFibGUiLCJmcm9tTGFzdENvbnN1bWVkQ2xpZW50TWVzc2FnZUluZGV4IiwibGl2ZVNlcnZlclNlc3Npb25SZXN1bXB0aW9uVXBkYXRlRnJvbVZlcnRleCIsImxpdmVTZXJ2ZXJNZXNzYWdlRnJvbU1sZGV2IiwiZnJvbVNldHVwQ29tcGxldGUiLCJmcm9tU2VydmVyQ29udGVudCIsImZyb21Ub29sQ2FsbCIsImZyb21Ub29sQ2FsbENhbmNlbGxhdGlvbiIsImZyb21Hb0F3YXkiLCJmcm9tU2Vzc2lvblJlc3VtcHRpb25VcGRhdGUiLCJsaXZlU2VydmVyTWVzc2FnZUZyb21WZXJ0ZXgiLCJsaXZlTXVzaWNTZXJ2ZXJTZXR1cENvbXBsZXRlRnJvbU1sZGV2Iiwid2VpZ2h0ZWRQcm9tcHRGcm9tTWxkZXYiLCJsaXZlTXVzaWNDbGllbnRDb250ZW50RnJvbU1sZGV2IiwibGl2ZU11c2ljR2VuZXJhdGlvbkNvbmZpZ0Zyb21NbGRldiIsImxpdmVNdXNpY1NvdXJjZU1ldGFkYXRhRnJvbU1sZGV2IiwiYXVkaW9DaHVua0Zyb21NbGRldiIsImZyb21Tb3VyY2VNZXRhZGF0YSIsImxpdmVNdXNpY1NlcnZlckNvbnRlbnRGcm9tTWxkZXYiLCJmcm9tQXVkaW9DaHVua3MiLCJsaXZlTXVzaWNGaWx0ZXJlZFByb21wdEZyb21NbGRldiIsImZyb21GaWx0ZXJlZFJlYXNvbiIsImxpdmVNdXNpY1NlcnZlck1lc3NhZ2VGcm9tTWxkZXYiLCJmcm9tRmlsdGVyZWRQcm9tcHQiLCJ2aWRlb01ldGFkYXRhVG9NbGRldiQxIiwiYmxvYlRvTWxkZXYkMSIsImZpbGVEYXRhVG9NbGRldiQxIiwicGFydFRvTWxkZXYkMSIsImNvbnRlbnRUb01sZGV2JDEiLCJzY2hlbWFUb01sZGV2Iiwic2FmZXR5U2V0dGluZ1RvTWxkZXYiLCJmdW5jdGlvbkRlY2xhcmF0aW9uVG9NbGRldiQxIiwiaW50ZXJ2YWxUb01sZGV2JDEiLCJnb29nbGVTZWFyY2hUb01sZGV2JDEiLCJkeW5hbWljUmV0cmlldmFsQ29uZmlnVG9NbGRldiQxIiwiZ29vZ2xlU2VhcmNoUmV0cmlldmFsVG9NbGRldiQxIiwidXJsQ29udGV4dFRvTWxkZXYkMSIsInRvb2xUb01sZGV2JDEiLCJmdW5jdGlvbkNhbGxpbmdDb25maWdUb01sZGV2IiwibGF0TG5nVG9NbGRldiIsInJldHJpZXZhbENvbmZpZ1RvTWxkZXYiLCJ0b29sQ29uZmlnVG9NbGRldiIsInByZWJ1aWx0Vm9pY2VDb25maWdUb01sZGV2JDEiLCJ2b2ljZUNvbmZpZ1RvTWxkZXYkMSIsInNwZWFrZXJWb2ljZUNvbmZpZ1RvTWxkZXYkMSIsIm11bHRpU3BlYWtlclZvaWNlQ29uZmlnVG9NbGRldiQxIiwic3BlZWNoQ29uZmlnVG9NbGRldiQxIiwidGhpbmtpbmdDb25maWdUb01sZGV2IiwiZ2VuZXJhdGVDb250ZW50Q29uZmlnVG9NbGRldiIsImdlbmVyYXRlQ29udGVudFBhcmFtZXRlcnNUb01sZGV2IiwiZW1iZWRDb250ZW50Q29uZmlnVG9NbGRldiIsImZyb21UYXNrVHlwZSIsImZyb21PdXRwdXREaW1lbnNpb25hbGl0eSIsImVtYmVkQ29udGVudFBhcmFtZXRlcnNUb01sZGV2IiwiZnJvbU1vZGVsRm9yRW1iZWRDb250ZW50IiwiZ2VuZXJhdGVJbWFnZXNDb25maWdUb01sZGV2IiwiZnJvbU51bWJlck9mSW1hZ2VzIiwiZnJvbUFzcGVjdFJhdGlvIiwiZnJvbUd1aWRhbmNlU2NhbGUiLCJmcm9tU2FmZXR5RmlsdGVyTGV2ZWwiLCJmcm9tUGVyc29uR2VuZXJhdGlvbiIsImZyb21JbmNsdWRlU2FmZXR5QXR0cmlidXRlcyIsImZyb21JbmNsdWRlUmFpUmVhc29uIiwiZnJvbUxhbmd1YWdlIiwiZnJvbU91dHB1dE1pbWVUeXBlIiwiZnJvbU91dHB1dENvbXByZXNzaW9uUXVhbGl0eSIsImdlbmVyYXRlSW1hZ2VzUGFyYW1ldGVyc1RvTWxkZXYiLCJmcm9tUHJvbXB0IiwiZ2V0TW9kZWxQYXJhbWV0ZXJzVG9NbGRldiIsImxpc3RNb2RlbHNDb25maWdUb01sZGV2IiwiZnJvbVF1ZXJ5QmFzZSIsImxpc3RNb2RlbHNQYXJhbWV0ZXJzVG9NbGRldiIsInVwZGF0ZU1vZGVsQ29uZmlnVG9NbGRldiIsImZyb21EZWZhdWx0Q2hlY2twb2ludElkIiwidXBkYXRlTW9kZWxQYXJhbWV0ZXJzVG9NbGRldiIsImRlbGV0ZU1vZGVsUGFyYW1ldGVyc1RvTWxkZXYiLCJjb3VudFRva2Vuc0NvbmZpZ1RvTWxkZXYiLCJjb3VudFRva2Vuc1BhcmFtZXRlcnNUb01sZGV2IiwiaW1hZ2VUb01sZGV2IiwiZ2VuZXJhdGVWaWRlb3NDb25maWdUb01sZGV2IiwiZnJvbU51bWJlck9mVmlkZW9zIiwiZnJvbUR1cmF0aW9uU2Vjb25kcyIsImZyb21OZWdhdGl2ZVByb21wdCIsImZyb21FbmhhbmNlUHJvbXB0IiwiZ2VuZXJhdGVWaWRlb3NQYXJhbWV0ZXJzVG9NbGRldiIsImZyb21JbWFnZSIsInZpZGVvTWV0YWRhdGFUb1ZlcnRleCIsImJsb2JUb1ZlcnRleCIsImZpbGVEYXRhVG9WZXJ0ZXgiLCJwYXJ0VG9WZXJ0ZXgiLCJjb250ZW50VG9WZXJ0ZXgiLCJzY2hlbWFUb1ZlcnRleCIsIm1vZGVsU2VsZWN0aW9uQ29uZmlnVG9WZXJ0ZXgiLCJmcm9tRmVhdHVyZVNlbGVjdGlvblByZWZlcmVuY2UiLCJzYWZldHlTZXR0aW5nVG9WZXJ0ZXgiLCJmcm9tTWV0aG9kIiwiZnVuY3Rpb25EZWNsYXJhdGlvblRvVmVydGV4IiwiaW50ZXJ2YWxUb1ZlcnRleCIsImdvb2dsZVNlYXJjaFRvVmVydGV4IiwiZHluYW1pY1JldHJpZXZhbENvbmZpZ1RvVmVydGV4IiwiZ29vZ2xlU2VhcmNoUmV0cmlldmFsVG9WZXJ0ZXgiLCJlbnRlcnByaXNlV2ViU2VhcmNoVG9WZXJ0ZXgiLCJhcGlLZXlDb25maWdUb1ZlcnRleCIsImF1dGhDb25maWdUb1ZlcnRleCIsImdvb2dsZU1hcHNUb1ZlcnRleCIsInVybENvbnRleHRUb1ZlcnRleCIsInRvb2xUb1ZlcnRleCIsImZ1bmN0aW9uQ2FsbGluZ0NvbmZpZ1RvVmVydGV4IiwibGF0TG5nVG9WZXJ0ZXgiLCJyZXRyaWV2YWxDb25maWdUb1ZlcnRleCIsInRvb2xDb25maWdUb1ZlcnRleCIsInByZWJ1aWx0Vm9pY2VDb25maWdUb1ZlcnRleCIsInZvaWNlQ29uZmlnVG9WZXJ0ZXgiLCJzcGVlY2hDb25maWdUb1ZlcnRleCIsInRoaW5raW5nQ29uZmlnVG9WZXJ0ZXgiLCJnZW5lcmF0ZUNvbnRlbnRDb25maWdUb1ZlcnRleCIsImZyb21Sb3V0aW5nQ29uZmlnIiwiZnJvbU1vZGVsU2VsZWN0aW9uQ29uZmlnIiwiZnJvbUxhYmVscyIsImZyb21BdWRpb1RpbWVzdGFtcCIsImdlbmVyYXRlQ29udGVudFBhcmFtZXRlcnNUb1ZlcnRleCIsImVtYmVkQ29udGVudENvbmZpZ1RvVmVydGV4IiwiZnJvbUF1dG9UcnVuY2F0ZSIsImVtYmVkQ29udGVudFBhcmFtZXRlcnNUb1ZlcnRleCIsImdlbmVyYXRlSW1hZ2VzQ29uZmlnVG9WZXJ0ZXgiLCJmcm9tT3V0cHV0R2NzVXJpIiwiZnJvbUFkZFdhdGVybWFyayIsImdlbmVyYXRlSW1hZ2VzUGFyYW1ldGVyc1RvVmVydGV4IiwiaW1hZ2VUb1ZlcnRleCIsIm1hc2tSZWZlcmVuY2VDb25maWdUb1ZlcnRleCIsImZyb21NYXNrTW9kZSIsImZyb21TZWdtZW50YXRpb25DbGFzc2VzIiwiZnJvbU1hc2tEaWxhdGlvbiIsImNvbnRyb2xSZWZlcmVuY2VDb25maWdUb1ZlcnRleCIsImZyb21Db250cm9sVHlwZSIsImZyb21FbmFibGVDb250cm9sSW1hZ2VDb21wdXRhdGlvbiIsInN0eWxlUmVmZXJlbmNlQ29uZmlnVG9WZXJ0ZXgiLCJmcm9tU3R5bGVEZXNjcmlwdGlvbiIsInN1YmplY3RSZWZlcmVuY2VDb25maWdUb1ZlcnRleCIsImZyb21TdWJqZWN0VHlwZSIsImZyb21TdWJqZWN0RGVzY3JpcHRpb24iLCJyZWZlcmVuY2VJbWFnZUFQSUludGVybmFsVG9WZXJ0ZXgiLCJmcm9tUmVmZXJlbmNlSW1hZ2UiLCJmcm9tUmVmZXJlbmNlSWQiLCJmcm9tUmVmZXJlbmNlVHlwZSIsImZyb21NYXNrSW1hZ2VDb25maWciLCJmcm9tQ29udHJvbEltYWdlQ29uZmlnIiwiZnJvbVN0eWxlSW1hZ2VDb25maWciLCJmcm9tU3ViamVjdEltYWdlQ29uZmlnIiwiZWRpdEltYWdlQ29uZmlnVG9WZXJ0ZXgiLCJmcm9tRWRpdE1vZGUiLCJmcm9tQmFzZVN0ZXBzIiwiZWRpdEltYWdlUGFyYW1ldGVyc0ludGVybmFsVG9WZXJ0ZXgiLCJmcm9tUmVmZXJlbmNlSW1hZ2VzIiwidXBzY2FsZUltYWdlQVBJQ29uZmlnSW50ZXJuYWxUb1ZlcnRleCIsImZyb21FbmhhbmNlSW5wdXRJbWFnZSIsImZyb21JbWFnZVByZXNlcnZhdGlvbkZhY3RvciIsInVwc2NhbGVJbWFnZUFQSVBhcmFtZXRlcnNJbnRlcm5hbFRvVmVydGV4IiwiZnJvbVVwc2NhbGVGYWN0b3IiLCJnZXRNb2RlbFBhcmFtZXRlcnNUb1ZlcnRleCIsImxpc3RNb2RlbHNDb25maWdUb1ZlcnRleCIsImxpc3RNb2RlbHNQYXJhbWV0ZXJzVG9WZXJ0ZXgiLCJ1cGRhdGVNb2RlbENvbmZpZ1RvVmVydGV4IiwidXBkYXRlTW9kZWxQYXJhbWV0ZXJzVG9WZXJ0ZXgiLCJkZWxldGVNb2RlbFBhcmFtZXRlcnNUb1ZlcnRleCIsImNvdW50VG9rZW5zQ29uZmlnVG9WZXJ0ZXgiLCJjb3VudFRva2Vuc1BhcmFtZXRlcnNUb1ZlcnRleCIsImNvbXB1dGVUb2tlbnNQYXJhbWV0ZXJzVG9WZXJ0ZXgiLCJ2aWRlb1RvVmVydGV4IiwiZnJvbVZpZGVvQnl0ZXMiLCJnZW5lcmF0ZVZpZGVvc0NvbmZpZ1RvVmVydGV4IiwiZnJvbVJlc29sdXRpb24iLCJmcm9tUHVic3ViVG9waWMiLCJmcm9tR2VuZXJhdGVBdWRpbyIsImZyb21MYXN0RnJhbWUiLCJmcm9tQ29tcHJlc3Npb25RdWFsaXR5IiwiZ2VuZXJhdGVWaWRlb3NQYXJhbWV0ZXJzVG9WZXJ0ZXgiLCJ2aWRlb01ldGFkYXRhRnJvbU1sZGV2IiwiYmxvYkZyb21NbGRldiIsImZpbGVEYXRhRnJvbU1sZGV2IiwicGFydEZyb21NbGRldiIsImNvbnRlbnRGcm9tTWxkZXYiLCJjaXRhdGlvbk1ldGFkYXRhRnJvbU1sZGV2IiwidXJsTWV0YWRhdGFGcm9tTWxkZXYiLCJ1cmxDb250ZXh0TWV0YWRhdGFGcm9tTWxkZXYiLCJjYW5kaWRhdGVGcm9tTWxkZXYiLCJnZW5lcmF0ZUNvbnRlbnRSZXNwb25zZUZyb21NbGRldiIsImNvbnRlbnRFbWJlZGRpbmdGcm9tTWxkZXYiLCJmcm9tVmFsdWVzIiwiZW1iZWRDb250ZW50TWV0YWRhdGFGcm9tTWxkZXYiLCJlbWJlZENvbnRlbnRSZXNwb25zZUZyb21NbGRldiIsImZyb21FbWJlZGRpbmdzIiwiZnJvbU1ldGFkYXRhIiwiaW1hZ2VGcm9tTWxkZXYiLCJzYWZldHlBdHRyaWJ1dGVzRnJvbU1sZGV2IiwiZnJvbUNhdGVnb3JpZXMiLCJmcm9tU2NvcmVzIiwiZnJvbUNvbnRlbnRUeXBlIiwiZ2VuZXJhdGVkSW1hZ2VGcm9tTWxkZXYiLCJmcm9tUmFpRmlsdGVyZWRSZWFzb24iLCJmcm9tU2FmZXR5QXR0cmlidXRlcyIsImdlbmVyYXRlSW1hZ2VzUmVzcG9uc2VGcm9tTWxkZXYiLCJmcm9tR2VuZXJhdGVkSW1hZ2VzIiwiZnJvbVBvc2l0aXZlUHJvbXB0U2FmZXR5QXR0cmlidXRlcyIsInR1bmVkTW9kZWxJbmZvRnJvbU1sZGV2IiwiZnJvbUJhc2VNb2RlbCIsIm1vZGVsRnJvbU1sZGV2IiwiZnJvbVZlcnNpb24iLCJmcm9tVHVuZWRNb2RlbEluZm8iLCJmcm9tSW5wdXRUb2tlbkxpbWl0IiwiZnJvbU91dHB1dFRva2VuTGltaXQiLCJmcm9tU3VwcG9ydGVkQWN0aW9ucyIsImxpc3RNb2RlbHNSZXNwb25zZUZyb21NbGRldiIsImZyb21Nb2RlbHMiLCJkZWxldGVNb2RlbFJlc3BvbnNlRnJvbU1sZGV2IiwiY291bnRUb2tlbnNSZXNwb25zZUZyb21NbGRldiIsImZyb21Ub3RhbFRva2VucyIsInZpZGVvRnJvbU1sZGV2JDEiLCJnZW5lcmF0ZWRWaWRlb0Zyb21NbGRldiQxIiwiZ2VuZXJhdGVWaWRlb3NSZXNwb25zZUZyb21NbGRldiQxIiwiZnJvbUdlbmVyYXRlZFZpZGVvcyIsImZyb21SYWlNZWRpYUZpbHRlcmVkQ291bnQiLCJmcm9tUmFpTWVkaWFGaWx0ZXJlZFJlYXNvbnMiLCJnZW5lcmF0ZVZpZGVvc09wZXJhdGlvbkZyb21NbGRldiQxIiwiZnJvbURvbmUiLCJ2aWRlb01ldGFkYXRhRnJvbVZlcnRleCIsImJsb2JGcm9tVmVydGV4IiwiZmlsZURhdGFGcm9tVmVydGV4IiwicGFydEZyb21WZXJ0ZXgiLCJjb250ZW50RnJvbVZlcnRleCIsImNpdGF0aW9uTWV0YWRhdGFGcm9tVmVydGV4IiwidXJsTWV0YWRhdGFGcm9tVmVydGV4IiwidXJsQ29udGV4dE1ldGFkYXRhRnJvbVZlcnRleCIsImNhbmRpZGF0ZUZyb21WZXJ0ZXgiLCJmcm9tRmluaXNoTWVzc2FnZSIsImdlbmVyYXRlQ29udGVudFJlc3BvbnNlRnJvbVZlcnRleCIsImZyb21SZXNwb25zZUlkIiwiY29udGVudEVtYmVkZGluZ1N0YXRpc3RpY3NGcm9tVmVydGV4IiwiZnJvbVRydW5jYXRlZCIsImNvbnRlbnRFbWJlZGRpbmdGcm9tVmVydGV4IiwiZnJvbVN0YXRpc3RpY3MiLCJlbWJlZENvbnRlbnRNZXRhZGF0YUZyb21WZXJ0ZXgiLCJmcm9tQmlsbGFibGVDaGFyYWN0ZXJDb3VudCIsImVtYmVkQ29udGVudFJlc3BvbnNlRnJvbVZlcnRleCIsImltYWdlRnJvbVZlcnRleCIsInNhZmV0eUF0dHJpYnV0ZXNGcm9tVmVydGV4IiwiZ2VuZXJhdGVkSW1hZ2VGcm9tVmVydGV4IiwiZnJvbUVuaGFuY2VkUHJvbXB0IiwiZ2VuZXJhdGVJbWFnZXNSZXNwb25zZUZyb21WZXJ0ZXgiLCJlZGl0SW1hZ2VSZXNwb25zZUZyb21WZXJ0ZXgiLCJ1cHNjYWxlSW1hZ2VSZXNwb25zZUZyb21WZXJ0ZXgiLCJlbmRwb2ludEZyb21WZXJ0ZXgiLCJmcm9tRGVwbG95ZWRNb2RlbElkIiwidHVuZWRNb2RlbEluZm9Gcm9tVmVydGV4IiwiY2hlY2twb2ludEZyb21WZXJ0ZXgiLCJmcm9tQ2hlY2twb2ludElkIiwiZnJvbUVwb2NoIiwiZnJvbVN0ZXAiLCJtb2RlbEZyb21WZXJ0ZXgiLCJmcm9tRW5kcG9pbnRzIiwiZnJvbUNoZWNrcG9pbnRzIiwibGlzdE1vZGVsc1Jlc3BvbnNlRnJvbVZlcnRleCIsImRlbGV0ZU1vZGVsUmVzcG9uc2VGcm9tVmVydGV4IiwiY291bnRUb2tlbnNSZXNwb25zZUZyb21WZXJ0ZXgiLCJjb21wdXRlVG9rZW5zUmVzcG9uc2VGcm9tVmVydGV4IiwiZnJvbVRva2Vuc0luZm8iLCJ2aWRlb0Zyb21WZXJ0ZXgkMSIsImdlbmVyYXRlZFZpZGVvRnJvbVZlcnRleCQxIiwiZ2VuZXJhdGVWaWRlb3NSZXNwb25zZUZyb21WZXJ0ZXgkMSIsImdlbmVyYXRlVmlkZW9zT3BlcmF0aW9uRnJvbVZlcnRleCQxIiwiQ09OVEVOVF9UWVBFX0hFQURFUiIsIlNFUlZFUl9USU1FT1VUX0hFQURFUiIsIlVTRVJfQUdFTlRfSEVBREVSIiwiR09PR0xFX0FQSV9DTElFTlRfSEVBREVSIiwiU0RLX1ZFUlNJT04iLCJMSUJSQVJZX0xBQkVMIiwiVkVSVEVYX0FJX0FQSV9ERUZBVUxUX1ZFUlNJT04iLCJHT09HTEVfQUlfQVBJX0RFRkFVTFRfVkVSU0lPTiIsInJlc3BvbnNlTGluZVJFIiwiQXBpQ2xpZW50Iiwib3B0cyIsImNsaWVudE9wdGlvbnMiLCJwcm9qZWN0IiwibG9jYXRpb24iLCJhcGlLZXkiLCJpbml0SHR0cE9wdGlvbnMiLCJhcGlWZXJzaW9uIiwiYmFzZVVybEZyb21Qcm9qZWN0TG9jYXRpb24iLCJub3JtYWxpemVBdXRoUGFyYW1ldGVycyIsImdldERlZmF1bHRIZWFkZXJzIiwicGF0Y2hIdHRwT3B0aW9ucyIsImdldEFwaVZlcnNpb24iLCJnZXRSZXF1ZXN0VXJsIiwiZ2V0UmVxdWVzdFVybEludGVybmFsIiwiZ2V0SGVhZGVycyIsInVybEVsZW1lbnQiLCJqb2luIiwiZ2V0QmFzZVJlc291cmNlUGF0aCIsImdldEFwaUtleSIsImdldFdlYnNvY2tldEJhc2VVcmwiLCJ1cmxQYXJ0cyIsIlVSTCIsInByb3RvY29sIiwidG9TdHJpbmciLCJzZXRCYXNlVXJsIiwidXJsIiwiY29uc3RydWN0VXJsIiwicHJlcGVuZFByb2plY3RMb2NhdGlvbiIsInNob3VsZFByZXBlbmRWZXJ0ZXhQcm9qZWN0UGF0aCIsInBhdGNoZWRIdHRwT3B0aW9ucyIsInNlYXJjaFBhcmFtcyIsImFwcGVuZCIsInJlcXVlc3RJbml0IiwiaW5jbHVkZUV4dHJhSHR0cE9wdGlvbnNUb1JlcXVlc3RJbml0IiwidW5hcnlBcGlDYWxsIiwiYmFzZUh0dHBPcHRpb25zIiwicmVxdWVzdEh0dHBPcHRpb25zIiwicmVxdWVzdFN0cmVhbSIsInNldCIsInN0cmVhbUFwaUNhbGwiLCJ0aW1lb3V0IiwiYWJvcnRDb250cm9sbGVyIiwiQWJvcnRDb250cm9sbGVyIiwic2lnbmFsIiwic2V0VGltZW91dCIsImFib3J0IiwiYWRkRXZlbnRMaXN0ZW5lciIsImV4dHJhQm9keSIsImluY2x1ZGVFeHRyYUJvZHlUb1JlcXVlc3RJbml0IiwiZ2V0SGVhZGVyc0ludGVybmFsIiwiYXBpQ2FsbCIsIm1ldGhvZCIsInRocm93RXJyb3JJZk5vdE9LIiwicmVhZGVyIiwiZ2V0UmVhZGVyIiwiZGVjb2RlciIsIlRleHREZWNvZGVyIiwiYnVmZmVyIiwicmVhZCIsInRyaW0iLCJjaHVua1N0cmluZyIsImRlY29kZSIsImNodW5rSnNvbiIsImVycm9ySnNvbiIsImVycm9yTWVzc2FnZSIsImFwaUVycm9yIiwicHJvY2Vzc2VkQ2h1bmtTdHJpbmciLCJwYXJ0aWFsUmVzcG9uc2UiLCJSZXNwb25zZSIsInN0YXR1c1RleHQiLCJyZWxlYXNlTG9jayIsImZldGNoIiwidmVyc2lvbkhlYWRlclZhbHVlIiwidXNlckFnZW50RXh0cmEiLCJIZWFkZXJzIiwiTWF0aCIsImNlaWwiLCJhdXRoIiwiYWRkQXV0aEhlYWRlcnMiLCJmaWxlVG9VcGxvYWQiLCJ1cGxvYWRlciIsImZpbGVTdGF0Iiwic3RhdCIsInNpemVCeXRlcyIsInNpemUiLCJ1cGxvYWRVcmwiLCJmZXRjaFVwbG9hZFVybCIsImRvd25sb2FkZXIiLCJvayIsImVycm9yQm9keSIsIkJsb2IiLCJjdXJyZW50Qm9keU9iamVjdCIsInBhcnNlZEJvZHkiLCJkZWVwTWVyZ2UiLCJ0YXJnZXQiLCJzb3VyY2UiLCJzb3VyY2VWYWx1ZSIsInRhcmdldFZhbHVlIiwibWVyZ2VkQm9keSIsIk1DUF9MQUJFTCIsImhhc01jcFRvb2xVc2FnZSIsImlzTWNwQ2FsbGFibGVUb29sIiwic2V0TWNwVXNhZ2VIZWFkZXIiLCJleGlzdGluZ0hlYWRlciIsInRyaW1TdGFydCIsImhhc01jcENsaWVudFRvb2xzIiwic29tZSIsImhhc05vbk1jcFRvb2xzIiwiTWNwQ2FsbGFibGVUb29sIiwibGlzdEFsbFRvb2xzIiwibWNwQ2xpZW50IiwibWF4VG9vbHMiLCJsaXN0QWxsVG9vbHNfMSIsImN1cnNvciIsIm51bVRvb2xzIiwidCIsImxpc3RUb29scyIsIm5leHRDdXJzb3IiLCJtY3BDbGllbnRzIiwiZnVuY3Rpb25OYW1lVG9NY3BDbGllbnQiLCJpbml0aWFsaXplIiwiZnVuY3Rpb25NYXAiLCJjYWxsVG9vbCIsImZ1bmN0aW9uQ2FsbFJlc3BvbnNlUGFydHMiLCJyZXF1ZXN0T3B0aW9ucyIsImNhbGxUb29sUmVzcG9uc2UiLCJpc0Vycm9yIiwiaXNNY3BDbGllbnQiLCJtY3BUb1Rvb2wiLCJtYXliZUNvbmZpZyIsImhhbmRsZVdlYlNvY2tldE1lc3NhZ2UkMSIsIm9ubWVzc2FnZSIsImV2ZW50Iiwic2VydmVyTWVzc2FnZSIsIkxpdmVNdXNpYyIsIndlYlNvY2tldEZhY3RvcnkiLCJjb25uZWN0Iiwid2Vic29ja2V0QmFzZVVybCIsIm1hcFRvSGVhZGVycyQxIiwib25vcGVuUmVzb2x2ZSIsIm9ub3BlblByb21pc2UiLCJjYWxsYmFja3MiLCJvbm9wZW5Bd2FpdGVkQ2FsbGJhY2siLCJ3ZWJzb2NrZXRDYWxsYmFja3MiLCJvbm9wZW4iLCJvbmVycm9yIiwib25jbG9zZSIsImNvbm4iLCJoZWFkZXJzVG9NYXAkMSIsInNldHVwIiwiY2xpZW50TWVzc2FnZSIsInNlbmQiLCJMaXZlTXVzaWNTZXNzaW9uIiwic2V0V2VpZ2h0ZWRQcm9tcHRzIiwid2VpZ2h0ZWRQcm9tcHRzIiwic2V0V2VpZ2h0ZWRQcm9tcHRzUGFyYW1ldGVycyIsImNsaWVudENvbnRlbnQiLCJzZXRNdXNpY0dlbmVyYXRpb25Db25maWciLCJtdXNpY0dlbmVyYXRpb25Db25maWciLCJzZXRDb25maWdQYXJhbWV0ZXJzIiwic2VuZFBsYXliYWNrQ29udHJvbCIsInBsYXliYWNrQ29udHJvbCIsInBsYXkiLCJQTEFZIiwicGF1c2UiLCJQQVVTRSIsInN0b3AiLCJTVE9QIiwicmVzZXRDb250ZXh0IiwiUkVTRVRfQ09OVEVYVCIsImNsb3NlIiwiaGVhZGVyTWFwIiwiZm9yRWFjaCIsIkZVTkNUSU9OX1JFU1BPTlNFX1JFUVVJUkVTX0lEIiwiaGFuZGxlV2ViU29ja2V0TWVzc2FnZSIsImpzb25EYXRhIiwiQXJyYXlCdWZmZXIiLCJMaXZlIiwibXVzaWMiLCJkZWZhdWx0SGVhZGVycyIsIm1hcFRvSGVhZGVycyIsImhlYWRlcnNUb01hcCIsInJlc3BvbnNlTW9kYWxpdGllcyIsIkFVRElPIiwiZ2VuZXJhdGlvbkNvbmZpZyIsImlucHV0VG9vbHMiLCJjb252ZXJ0ZWRUb29scyIsImlzQ2FsbGFibGVUb29sIiwiY2FsbGFibGVUb29sIiwibGl2ZUNvbm5lY3RQYXJhbWV0ZXJzIiwiU2Vzc2lvbiIsImRlZmF1bHRMaXZlU2VuZENsaWVudENvbnRlbnRQYXJhbWVydGVycyIsInR1cm5Db21wbGV0ZSIsInRMaXZlQ2xpZW50Q29udGVudCIsInR1cm5zIiwidExpdmVDbGllbnR0VG9vbFJlc3BvbnNlIiwidG9vbFJlc3BvbnNlIiwic2VuZENsaWVudENvbnRlbnQiLCJzZW5kUmVhbHRpbWVJbnB1dCIsInNlbmRUb29sUmVzcG9uc2UiLCJERUZBVUxUX01BWF9SRU1PVEVfQ0FMTFMiLCJzaG91bGREaXNhYmxlQWZjIiwiYXV0b21hdGljRnVuY3Rpb25DYWxsaW5nIiwiZGlzYWJsZSIsImNhbGxhYmxlVG9vbHNQcmVzZW50IiwibWF4Q2FsbHMiLCJtYXhpbXVtUmVtb3RlQ2FsbHMiLCJOdW1iZXIiLCJpc0ludGVnZXIiLCJzaG91bGRBcHBlbmRBZmNIaXN0b3J5IiwiaWdub3JlQ2FsbEhpc3RvcnkiLCJNb2RlbHMiLCJ0cmFuc2Zvcm1lZFBhcmFtcyIsInByb2Nlc3NQYXJhbXNGb3JNY3BVc2FnZSIsImdlbmVyYXRlQ29udGVudEludGVybmFsIiwiZnVuY3Rpb25SZXNwb25zZUNvbnRlbnQiLCJtYXhSZW1vdGVDYWxscyIsInJlbW90ZUNhbGxzIiwicmVzcG9uc2VDb250ZW50IiwiZnVuY3Rpb25SZXNwb25zZVBhcnRzIiwiZ2VuZXJhdGVDb250ZW50U3RyZWFtSW50ZXJuYWwiLCJwcm9jZXNzQWZjU3RyZWFtIiwiZ2VuZXJhdGVJbWFnZXMiLCJnZW5lcmF0ZUltYWdlc0ludGVybmFsIiwicG9zaXRpdmVQcm9tcHRTYWZldHlBdHRyaWJ1dGVzIiwiZ2VuZXJhdGVkSW1hZ2VzIiwiZ2VuZXJhdGVkSW1hZ2UiLCJzYWZldHlBdHRyaWJ1dGVzIiwiY29udGVudFR5cGUiLCJkZWZhdWx0Q29uZmlnIiwicXVlcnlCYXNlIiwiYWN0dWFsQ29uZmlnIiwiYWN0dWFsUGFyYW1zIiwiUEFHRURfSVRFTV9NT0RFTFMiLCJlZGl0SW1hZ2UiLCJwcm9tcHQiLCJyZWZlcmVuY2VJbWFnZXMiLCJpbWciLCJlZGl0SW1hZ2VJbnRlcm5hbCIsInVwc2NhbGVJbWFnZSIsImFwaUNvbmZpZyIsIm51bWJlck9mSW1hZ2VzIiwibW9kZSIsImFwaVBhcmFtcyIsImltYWdlIiwidXBzY2FsZUZhY3RvciIsInVwc2NhbGVJbWFnZUludGVybmFsIiwidHJhbnNmb3JtZWRUb29scyIsImFsbCIsIm5ld1BhcmFtcyIsIm5ld0hlYWRlcnMiLCJpbml0QWZjVG9vbHNNYXAiLCJhZmNUb29scyIsIk1hcCIsInRvb2xEZWNsYXJhdGlvbiIsImRlY2xhcmF0aW9uIiwid2VyZUZ1bmN0aW9uc0NhbGxlZCIsInJlbW90ZUNhbGxDb3VudCIsImFmY1Rvb2xzTWFwIiwibW9kZWxzIiwicmVzcG9uc2VDb250ZW50cyIsInJlc3BvbnNlXzEiLCJyZXNwb25zZV8xXzEiLCJyZXNwb25zZVBhcnRzIiwidHlwZWRSZXNwb25zZUNodW5rIiwibmV3Q29udGVudHMiLCJ1cGRhdGVkQ29udGVudHMiLCJlXzIiLCJhcGlSZXNwb25zZV8xIiwiYXBpUmVzcG9uc2VfMV8xIiwiZV8yXzEiLCJlXzMiLCJhcGlSZXNwb25zZV8yIiwiYXBpUmVzcG9uc2VfMl8xIiwiZV8zXzEiLCJlbWJlZENvbnRlbnQiLCJjb3VudFRva2VucyIsImNvbXB1dGVUb2tlbnMiLCJnZW5lcmF0ZVZpZGVvcyIsImdldE9wZXJhdGlvblBhcmFtZXRlcnNUb01sZGV2IiwiZnJvbU9wZXJhdGlvbk5hbWUiLCJnZXRPcGVyYXRpb25QYXJhbWV0ZXJzVG9WZXJ0ZXgiLCJmZXRjaFByZWRpY3RPcGVyYXRpb25QYXJhbWV0ZXJzVG9WZXJ0ZXgiLCJmcm9tUmVzb3VyY2VOYW1lIiwidmlkZW9Gcm9tTWxkZXYiLCJnZW5lcmF0ZWRWaWRlb0Zyb21NbGRldiIsImdlbmVyYXRlVmlkZW9zUmVzcG9uc2VGcm9tTWxkZXYiLCJnZW5lcmF0ZVZpZGVvc09wZXJhdGlvbkZyb21NbGRldiIsInZpZGVvRnJvbVZlcnRleCIsImdlbmVyYXRlZFZpZGVvRnJvbVZlcnRleCIsImdlbmVyYXRlVmlkZW9zUmVzcG9uc2VGcm9tVmVydGV4IiwiZ2VuZXJhdGVWaWRlb3NPcGVyYXRpb25Gcm9tVmVydGV4IiwiT3BlcmF0aW9ucyIsImdldFZpZGVvc09wZXJhdGlvbiIsIm9wZXJhdGlvbiIsImZldGNoUHJlZGljdFZpZGVvc09wZXJhdGlvbkludGVybmFsIiwib3BlcmF0aW9uTmFtZSIsImdldFZpZGVvc09wZXJhdGlvbkludGVybmFsIiwicHJlYnVpbHRWb2ljZUNvbmZpZ1RvTWxkZXYiLCJ2b2ljZUNvbmZpZ1RvTWxkZXYiLCJzcGVha2VyVm9pY2VDb25maWdUb01sZGV2IiwibXVsdGlTcGVha2VyVm9pY2VDb25maWdUb01sZGV2Iiwic3BlZWNoQ29uZmlnVG9NbGRldiIsInZpZGVvTWV0YWRhdGFUb01sZGV2IiwiYmxvYlRvTWxkZXYiLCJmaWxlRGF0YVRvTWxkZXYiLCJwYXJ0VG9NbGRldiIsImNvbnRlbnRUb01sZGV2IiwiZnVuY3Rpb25EZWNsYXJhdGlvblRvTWxkZXYiLCJpbnRlcnZhbFRvTWxkZXYiLCJnb29nbGVTZWFyY2hUb01sZGV2IiwiZHluYW1pY1JldHJpZXZhbENvbmZpZ1RvTWxkZXYiLCJnb29nbGVTZWFyY2hSZXRyaWV2YWxUb01sZGV2IiwidXJsQ29udGV4dFRvTWxkZXYiLCJ0b29sVG9NbGRldiIsInNlc3Npb25SZXN1bXB0aW9uQ29uZmlnVG9NbGRldiIsImF1ZGlvVHJhbnNjcmlwdGlvbkNvbmZpZ1RvTWxkZXYiLCJhdXRvbWF0aWNBY3Rpdml0eURldGVjdGlvblRvTWxkZXYiLCJyZWFsdGltZUlucHV0Q29uZmlnVG9NbGRldiIsInNsaWRpbmdXaW5kb3dUb01sZGV2IiwiY29udGV4dFdpbmRvd0NvbXByZXNzaW9uQ29uZmlnVG9NbGRldiIsInByb2FjdGl2aXR5Q29uZmlnVG9NbGRldiIsImxpdmVDb25uZWN0Q29uZmlnVG9NbGRldiIsImxpdmVDb25uZWN0Q29uc3RyYWludHNUb01sZGV2IiwiY3JlYXRlQXV0aFRva2VuQ29uZmlnVG9NbGRldiIsImZyb21OZXdTZXNzaW9uRXhwaXJlVGltZSIsImZyb21Vc2VzIiwiZnJvbUxpdmVDb25uZWN0Q29uc3RyYWludHMiLCJmcm9tTG9ja0FkZGl0aW9uYWxGaWVsZHMiLCJjcmVhdGVBdXRoVG9rZW5QYXJhbWV0ZXJzVG9NbGRldiIsImF1dGhUb2tlbkZyb21NbGRldiIsImdldEZpZWxkTWFza3MiLCJmaWVsZHMiLCJmaWVsZCIsImtrIiwiY29udmVydEJpZGlTZXR1cFRvVG9rZW5TZXR1cCIsInJlcXVlc3REaWN0Iiwic2V0dXBGb3JNYXNrR2VuZXJhdGlvbiIsImJpZGlHZW5lcmF0ZUNvbnRlbnRTZXR1cFZhbHVlIiwiaW5uZXJTZXR1cCIsInByZUV4aXN0aW5nRmllbGRNYXNrIiwiZ2VuZXJhdGVkTWFza0Zyb21CaWRpIiwibG9ja0FkZGl0aW9uYWxGaWVsZHMiLCJnZW5lcmF0aW9uQ29uZmlnRmllbGRzIiwibWFwcGVkRmllbGRzRnJvbVByZUV4aXN0aW5nIiwiZmluYWxNYXNrUGFydHMiLCJUb2tlbnMiLCJ0cmFuc2Zvcm1lZEJvZHkiLCJHT09HTEVfQVBJX0tFWV9IRUFERVIiLCJSRVFVSVJFRF9WRVJURVhfQUlfU0NPUEUiLCJOb2RlQXV0aCIsInZlcnRleEF1dGhPcHRpb25zIiwiYnVpbGRHb29nbGVBdXRoT3B0aW9ucyIsImdvb2dsZUF1dGhPcHRpb25zIiwiZ29vZ2xlQXV0aCIsImFkZEtleUhlYWRlciIsImFkZEdvb2dsZUF1dGhIZWFkZXJzIiwiYXV0aEhlYWRlcnMiLCJnZXRSZXF1ZXN0SGVhZGVycyIsImF1dGhPcHRpb25zIiwic2NvcGVzIiwiTm9kZURvd25sb2FkZXIiLCJkb3dubG9hZFBhdGgiLCJ3cml0ZXIiLCJmcm9tV2ViIiwicGlwZSIsImVuY29kaW5nIiwidmlkZW9CeXRlcyIsIk5vZGVXZWJTb2NrZXRGYWN0b3J5IiwiTm9kZVdlYlNvY2tldCIsIndzIiwiV2ViU29ja2V0IiwiZ2V0VHVuaW5nSm9iUGFyYW1ldGVyc1RvTWxkZXYiLCJsaXN0VHVuaW5nSm9ic0NvbmZpZ1RvTWxkZXYiLCJsaXN0VHVuaW5nSm9ic1BhcmFtZXRlcnNUb01sZGV2IiwidHVuaW5nRXhhbXBsZVRvTWxkZXYiLCJmcm9tVGV4dElucHV0IiwiZnJvbU91dHB1dCIsInR1bmluZ0RhdGFzZXRUb01sZGV2IiwiZnJvbUV4YW1wbGVzIiwiY3JlYXRlVHVuaW5nSm9iQ29uZmlnVG9NbGRldiIsImZyb21UdW5lZE1vZGVsRGlzcGxheU5hbWUiLCJmcm9tRXBvY2hDb3VudCIsImZyb21MZWFybmluZ1JhdGVNdWx0aXBsaWVyIiwiZnJvbUJhdGNoU2l6ZSIsImZyb21MZWFybmluZ1JhdGUiLCJjcmVhdGVUdW5pbmdKb2JQYXJhbWV0ZXJzVG9NbGRldiIsImZyb21UcmFpbmluZ0RhdGFzZXQiLCJnZXRUdW5pbmdKb2JQYXJhbWV0ZXJzVG9WZXJ0ZXgiLCJsaXN0VHVuaW5nSm9ic0NvbmZpZ1RvVmVydGV4IiwibGlzdFR1bmluZ0pvYnNQYXJhbWV0ZXJzVG9WZXJ0ZXgiLCJ0dW5pbmdEYXRhc2V0VG9WZXJ0ZXgiLCJ0dW5pbmdWYWxpZGF0aW9uRGF0YXNldFRvVmVydGV4IiwiY3JlYXRlVHVuaW5nSm9iQ29uZmlnVG9WZXJ0ZXgiLCJmcm9tVmFsaWRhdGlvbkRhdGFzZXQiLCJmcm9tRXhwb3J0TGFzdENoZWNrcG9pbnRPbmx5IiwiZnJvbUFkYXB0ZXJTaXplIiwiY3JlYXRlVHVuaW5nSm9iUGFyYW1ldGVyc1RvVmVydGV4IiwidHVuZWRNb2RlbEZyb21NbGRldiIsImZyb21FbmRwb2ludCIsInR1bmluZ0pvYkZyb21NbGRldiIsImZyb21UdW5lZE1vZGVsIiwiZnJvbURpc3RpbGxhdGlvblNwZWMiLCJmcm9tRXhwZXJpbWVudCIsImZyb21QaXBlbGluZUpvYiIsImZyb21TZXJ2aWNlQWNjb3VudCIsImxpc3RUdW5pbmdKb2JzUmVzcG9uc2VGcm9tTWxkZXYiLCJmcm9tVHVuaW5nSm9icyIsIm9wZXJhdGlvbkZyb21NbGRldiIsInR1bmVkTW9kZWxDaGVja3BvaW50RnJvbVZlcnRleCIsInR1bmVkTW9kZWxGcm9tVmVydGV4IiwidHVuaW5nSm9iRnJvbVZlcnRleCIsImZyb21TdXBlcnZpc2VkVHVuaW5nU3BlYyIsImZyb21UdW5pbmdEYXRhU3RhdHMiLCJmcm9tRW5jcnlwdGlvblNwZWMiLCJmcm9tUGFydG5lck1vZGVsVHVuaW5nU3BlYyIsImxpc3RUdW5pbmdKb2JzUmVzcG9uc2VGcm9tVmVydGV4IiwiVHVuaW5ncyIsImdldEludGVybmFsIiwiUEFHRURfSVRFTV9UVU5JTkdfSk9CUyIsInR1bmUiLCJ0dW5lSW50ZXJuYWwiLCJ0dW5lTWxkZXZJbnRlcm5hbCIsInR1bmVkTW9kZWxOYW1lIiwidHVuaW5nSm9iIiwiSk9CX1NUQVRFX1FVRVVFRCIsIk1BWF9DSFVOS19TSVpFIiwiTUFYX1JFVFJZX0NPVU5UIiwiSU5JVElBTF9SRVRSWV9ERUxBWV9NUyIsIkRFTEFZX01VTFRJUExJRVIiLCJYX0dPT0dfVVBMT0FEX1NUQVRVU19IRUFERVJfRklFTEQiLCJ1cGxvYWRCbG9iIiwiZmlsZVNpemUiLCJvZmZzZXQiLCJ1cGxvYWRDb21tYW5kIiwiY2h1bmtTaXplIiwibWluIiwicmV0cnlDb3VudCIsImN1cnJlbnREZWxheU1zIiwic2xlZXAiLCJyZXNwb25zZUpzb24iLCJnZXRCbG9iU3RhdCIsIm1zIiwicmVzb2x2ZVByb21pc2UiLCJOb2RlVXBsb2FkZXIiLCJvcmlnaW5hbFN0YXQiLCJpbmZlck1pbWVUeXBlIiwidXBsb2FkRmlsZUZyb21QYXRoIiwiZmlsZVBhdGgiLCJmaWxlRXh0ZW5zaW9uIiwibGFzdEluZGV4T2YiLCJtaW1lVHlwZXMiLCJ0b0xvd2VyQ2FzZSIsImZpbGVIYW5kbGUiLCJvcGVuIiwiVWludDhBcnJheSIsImJ5dGVzUmVhZCIsIkxBTkdVQUdFX0xBQkVMX1BSRUZJWCIsIkdvb2dsZUdlbkFJIiwiZ2V0Qm9vbGVhbkVudiIsImVudkFwaUtleSIsImdldEFwaUtleUZyb21FbnYiLCJlbnZQcm9qZWN0IiwiZ2V0RW52IiwiZW52TG9jYXRpb24iLCJjcmVkZW50aWFscyIsImRlYnVnIiwicHJvY2VzcyIsInZlcnNpb24iLCJsaXZlIiwiYmF0Y2hlcyIsImNoYXRzIiwiY2FjaGVzIiwiZmlsZXMiLCJvcGVyYXRpb25zIiwiYXV0aFRva2VucyIsInR1bmluZ3MiLCJlbnYiLCJzdHJpbmdUb0Jvb2xlYW4iLCJzdHIiLCJlbnZHb29nbGVBcGlLZXkiLCJlbnZHZW1pbmlBcGlLZXkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@google/genai/dist/node/index.mjs\n");

/***/ })

};
;